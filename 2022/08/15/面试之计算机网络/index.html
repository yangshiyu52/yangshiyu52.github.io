<!DOCTYPE html>


<html lang="en">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title>面试之计算机网络 |  Healer</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    <link rel="alternate" href="/atom.xml" title="Healer" type="application/atom+xml">
</head>
  </html>
</html>


<body>
  <div id="app">
    
      
      <canvas width="1777" height="841"
        style="position: fixed; left: 0px; top: 0px; z-index: 99999; pointer-events: none;"></canvas>
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-面试之计算机网络"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
	
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  面试之计算机网络
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/08/15/%E9%9D%A2%E8%AF%95%E4%B9%8B%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" class="article-date">
  <time datetime="2022-08-15T11:37:01.000Z" itemprop="datePublished">2022-08-15</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a>
  </div>
  
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> Word count:</span>
            <span class="post-count">6.1k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> Reading time≈</span>
            <span class="post-count">21 min</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="什么是754层网络模型？"><a href="#什么是754层网络模型？" class="headerlink" title="什么是754层网络模型？"></a>什么是754层网络模型？</h1><p>全局上理解 <code>7层协议，4层，5层</code>的对应关系。</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/290e6090b29a4c529508f834785175cf.png" alt="img"></p>
<p>OSI 依层次结构来划分：应用层（Application）、表示层（Presentation）、会话层（Session）、传输层（Transport）、网络层（Network）、数据链路层（Data Link）、物理层（Physical）</p>
<h1 id="TCP建立连接过程的三次握手"><a href="#TCP建立连接过程的三次握手" class="headerlink" title="TCP建立连接过程的三次握手"></a>TCP建立连接过程的三次握手</h1><p>TCP 有 6 种标识：<code>SYN(建立联机) ACK(确认) PSH(传送) FIN(结束) RST(重置) URG(紧急)</code></p>
<ul>
<li><strong>什么是三次握手</strong>？</li>
</ul>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220907194538705.png" alt="image-20220907194538705"></p>
<p>为了保证数据能到达目标，TCP采用三次握手策略：</p>
<ol>
<li>发送端首先发送一个带<strong>SYN</strong>（synchronize）标志的数据包给接收方【第一次的 seq 序列号是随机产生的，这样是为了网络安全，如果不是随机产生初始序列号，黑客将会以很容易的方式获取到你与其他主机之间的初始化序列号，并且伪造序列号进行攻击】</li>
<li>接收端收到后，回传一个带有 <strong>SYN&#x2F;ACK</strong>（acknowledgement）标志的数据包以示传达确认信息【SYN 是为了告诉发送端，发送方到接收方的通道没问题；ACK 用来验证接收方到发送方的通道没问题】</li>
<li>最后，发送端再回传一个带 ACK 标志的数据包，代表握手结束，若在握手某个过程中某个阶段莫名中断，TCP 协议会再次以相同的顺序发送相同的数据包</li>
</ol>
<ul>
<li><strong>为什么要三次握手</strong>？</li>
</ul>
<p>三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的</p>
<ol>
<li>第一次握手，发送端：什么都确认不了；接收端：对方发送正常，自己接受正常</li>
<li>第二次握手，发送端：对方发送，接受正常，自己发送，接受正常 ；接收端：对方发送正常，自己接受正常</li>
<li>第三次握手，发送端：对方发送，接受正常，自己发送，接受正常；接收端：对方发送，接受正常，自己发送，接受正常</li>
</ol>
<ul>
<li><strong>两次握手不行吗？为什么TCP客户端最后还要发送一次确认呢</strong>？</li>
</ul>
<p>主要防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误。经典场景：客户端发送了第一个请求连接并且没有丢失，只是因为在网络结点中滞留的时间太长了。</p>
<ol>
<li>由于 TCP 的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。</li>
<li>此时此前滞留的那一次请求连接，网络通畅了到达服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的浪费。</li>
<li>如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接。</li>
</ol>
<ul>
<li><strong>为什么三次握手，返回时，ack 值是 seq 加 1（ack &#x3D; x+1）</strong></li>
</ul>
<ol>
<li>假设对方接收到数据，比如sequence number &#x3D; 1000，TCP Payload &#x3D; 1000，数据第一个字节编号为1000，最后一个为1999，回应一个确认报文，确认号为2000，意味着编号2000前的字节接收完成，准备接收编号为2000及更多的数据</li>
<li>确认收到的序列，并且告诉发送端下一次发送的序列号从哪里开始（便于接收方对数据排序，便于选择重传）</li>
</ol>
<ul>
<li><strong>TCP三次握手中，最后一次回复丢失，会发生什么</strong>？</li>
</ul>
<ol>
<li>如果最后一次 ACK 在网络中丢失，那么 Server 端（服务端）该 TCP 连接的状态仍为 SYN_RECV，并且根据  TCP 的超时重传机制依次等待3秒、6秒、12秒后重新发送 SYN+ACK 包，以便 Client（客户端）重新发送ACK包</li>
<li>如果重发指定次数后，仍然未收到 ACK 应答，那么一段时间后，Server（服务端）自动关闭这个连接</li>
<li>但是 Client（客户端）认为这个连接已经建立，如果 Client（客户端）端向 Server（服务端）发送数据，Server 端（服务端）将以RST 包（Reset，标示复位，用于异常的关闭连接）响应，此时，客户端知道第三次握手失败</li>
</ol>
<h1 id="SYN-洪泛攻击-SYN-Flood，半开放攻击-，怎么解决？"><a href="#SYN-洪泛攻击-SYN-Flood，半开放攻击-，怎么解决？" class="headerlink" title="SYN 洪泛攻击(SYN Flood，半开放攻击)，怎么解决？"></a>SYN 洪泛攻击(SYN Flood，半开放攻击)，怎么解决？</h1><ul>
<li><strong>什么是SYN洪范泛攻击</strong>？</li>
</ul>
<p>SYN Flood 利用 TCP 协议缺陷，发送大量伪造的 TCP 连接请求，常用假冒的 IP 或 IP 号段发来海量的请求连接的第一个握手包（SYN包），被攻击服务器回应第二个握手包（SYN+ACK包），因为对方是假冒IP，对方永远收不到包且不会回应第三个握手包。导致被攻击服务器保持大量 SYN_RECV 状态的“半连接”，并且会重试默认 5 次回应第二个握手包，大量随机的恶意 syn 占满了未完成连接队列，导致正常合法的 syn 排不上队列，让正常的业务请求连接不进来。【服务器端的资源分配是在二次握手时分配的，而客户端的资源是在完成三次握手时分配的，所以服务器容易受到 SYN 洪泛攻击】</p>
<ul>
<li><strong>如何检测 SYN 攻击？</strong></li>
</ul>
<p>当你在服务器上看到大量的半连接状态时，特别是源 IP 地址是随机的，基本上可以断定这是一次 SYN 攻击【在 Linux&#x2F;Unix 上可以使用系统自带的 netstats 命令来检测 SYN 攻击】</p>
<ul>
<li><strong>怎么解决</strong>？ SYN 攻击不能完全被阻止，除非将 TCP 协议重新设计。我们所做的是尽可能的减轻 SYN 攻击的危害，</li>
</ul>
<ol>
<li>缩短超时（SYN Timeout）时间</li>
<li>增加最大半连接数</li>
<li>过滤网关防护</li>
<li>SYN cookies技术：<ol>
<li>当服务器接受到 SYN 报文段时，不直接为该 TCP 分配资源，而只是打开一个半开的套接字。接着会使用 SYN 报文段的源 Id，目的 Id，端口号以及只有服务器自己知道的一个秘密函数生成一个 cookie，并把 cookie 作为序列号响应给客户端。</li>
<li>如果客户端是正常建立连接，将会返回一个确认字段为 cookie + 1 的报文段。接下来服务器会根据确认报文的源 Id，目的 Id，端口号以及秘密函数计算出一个结果，如果结果的值 + 1 等于确认字段的值，则证明是刚刚请求连接的客户端，这时候才为该 TCP 分配资源</li>
</ol>
</li>
</ol>
<h1 id="TCP断开连接过程的四次挥手？"><a href="#TCP断开连接过程的四次挥手？" class="headerlink" title="TCP断开连接过程的四次挥手？"></a>TCP断开连接过程的四次挥手？</h1><ul>
<li><strong>什么是四次挥手</strong>？</li>
</ul>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220907200133430.png" alt="image-20220907200133430"></p>
<ol>
<li>主动断开方（客户端&#x2F;服务端）-发送一个 FIN，用来关闭主动断开方（客户端&#x2F;服务端）到被动断开方（客户端&#x2F;服务端）的数据传送</li>
<li>被动断开方（客户端&#x2F;服务端）-收到这个 FIN，它发回一 个 ACK，确认序号为收到的序号加1 。和 SYN 一样，一个 FIN 将占用一个序号</li>
<li>被动断开方（客户端&#x2F;服务端）-关闭与主动断开方（客户端&#x2F;服务端）的连接，发送一个 FIN 给主动断开方（客户端&#x2F;服务端）</li>
<li>主动断开方（客户端&#x2F;服务端）-发回 ACK 报文确认，并将确认序号设置为收到序号加1</li>
</ol>
<ul>
<li><strong>为什么连接的时候是三次握手，关闭的时候却是四次握手</strong>？</li>
</ul>
<ol>
<li>建立连接的时候， 服务器在 LISTEN 状态下，收到建立连接请求的 SYN 报文后，把 ACK 和 SYN 放在一个报文里发送给客户端。</li>
<li>关闭连接时，服务器收到对方的 FIN 报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以服务器可以立即关闭，也可以发送一些数据给对方后，再发送 FIN 报文给对方来表示同意现在关闭连接。因此，服务器 ACK和 FIN 一般都会分开发送，从而导致多了一次。</li>
</ol>
<ul>
<li><strong>为什么 TCP 挥手每两次中间有一个 FIN-WAIT2 等待时间</strong>？</li>
</ul>
<p>主动关闭的一端调用完 close 以后（即发 FIN 给被动关闭的一端， 并且收到其对 FIN 的确认ACK）则进入 FIN_WAIT_2 状态。如果这个时候因为网络突然断掉、被动关闭的一段宕机等原因，导致主动关闭的一端不能收到被动关闭的一端发来的 FIN（防止对端不发送关闭连接的 FIN 包给本端），这个时候就需要 FIN_WAIT_2 定时器， 如果在该定时器超时的时候，还是没收到被动关闭一端发来的 FIN，那么直接释放这个链接，进入 CLOSE 状态</p>
<ul>
<li><strong>为什么客户端最后还要等待 2MSL？为什么还有个TIME-WAIT的时间等待</strong>？</li>
</ul>
<ol>
<li>保证客户端发送的最后一个 ACK 报文能够到达服务器，因为这个 ACK 报文可能丢失，服务器已经发送了 FIN+ACK 报文，请求断开，客户端却没有回应，于是服务器又会重新发送一次，而客户端就能在这个 2MSL 时间段内收到这个重传的报文，接着给出回应报文，并且会重启 2MSL 计时器。</li>
<li>防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个 2MSL 时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失，这样新的连接中不会出现旧连接的请求报文。</li>
<li>2MSL，最大报文生存时间，一个MSL 30 秒，2MSL &#x3D; 60s</li>
</ol>
<ul>
<li><strong>客户端 TIME-WAIT 状态过多会产生什么后果？怎样处理</strong>？</li>
</ul>
<ol>
<li>作为服务器，短时间内关闭了大量的 Client 连接，就会造成服务器上出现大量的TIME_WAIT连接，占据大量的 tuple &#x2F;tApl&#x2F; ，严重消耗着服务器的资源，此时部分客户端就会显示连接不上</li>
<li>作为客户端，短时间内大量的短连接，会大量消耗的 Client 机器的端口，毕竟端口只有65535个，端口被耗尽了，后续就无法在发起新的连接了</li>
<li>在高并发短连接的 TCP 服务器上，当服务器处理完请求后立刻主动正常关闭连接。这个场景下会出现大量 socket 处于TIME_WAIT状态。如果客户端的并发量持续很高，此时部分客户端就会显示连接不上<ol>
<li>高并发可以让服务器在短时间范围内同时占用大量端口，而端口有个0~65535的范围，并不是很多，刨除系统和其他服务要用的，剩下的就更少了</li>
<li>短连接表示“业务处理+传输数据的时间 远远小于 TIMEWAIT超时的时间”的连接</li>
</ol>
</li>
<li>解决方法：<ol>
<li>用负载均衡来抗这些高并发的短请求；</li>
<li>服务器可以设置 SO_REUSEADDR 套接字选项来避免 TIME_WAIT状态，TIME_WAIT 状态可以通过优化服务器参数得到解决，因为发生TIME_WAIT的情况是服务器自己可控的，要么就是对方连接的异常，要么就是自己没有迅速回收资源，总之不是由于自己程序错误导致的</li>
<li>强制关闭，发送 RST 包越过TIMEWAIT状态，直接进入CLOSED状态</li>
</ol>
</li>
</ol>
<ul>
<li><strong>服务器出现了大量 CLOSE_WAIT 状态如何解决</strong>？</li>
</ul>
<p>大量 CLOSE_WAIT 表示程序出现了问题，对方的 socket 已经关闭连接，而我方忙于读或写没有及时关闭连接，需要检查代码，特别是释放资源的代码，或者是处理请求的线程配置。</p>
<ul>
<li><strong>服务端会有一个TIME_WAIT状态吗？如果是服务端主动断开连接呢</strong>？</li>
</ul>
<ol>
<li>发起链接的主动方基本都是客户端，但是断开连接的主动方服务器和客户端都可以充当，也就是说，只要是主动断开连接的，就会有 TIME_WAIT状态</li>
<li>四次挥手是指断开一个TCP连接时，需要客户端和服务端总共发送4个包以确认连接的断开。在socket编程中，这一过程由客户端或服务端任一方执行close来触发</li>
<li>由于TCP连接时全双工的，因此，每个方向的数据传输通道都必须要单独进行关闭。</li>
</ol>
<h1 id="DNS-解析流程？"><a href="#DNS-解析流程？" class="headerlink" title="DNS 解析流程？"></a>DNS 解析流程？</h1><p>.com.fi 国际金融域名 DNS 解析的步骤一共分为9步，如果每次解析都要走完9个步骤，大家浏览网站的速度也不会那么快，现在之所以能保持这么快的访问速度，其实一般的解析都是跑完第4步就可以了。除非一个地区完全是第一次访问（在都没有缓存的情况下）才会走完9个步骤，这个情况很少。</p>
<ul>
<li>本地客户机提出域名解析请求，查找本地 HOST 文件后将该请求发送给本地的域名服务器。</li>
<li>将请求发送给本地的域名服务器。</li>
<li>当本地的域名服务器收到请求后，就先查询本地的缓存。</li>
<li>如果有该纪录项，则本地的域名服务器就直接把查询的结果返回浏览器。</li>
<li>如果本地 DNS 缓存中没有该纪录，则本地域名服务器就直接把请求发给根域名服务器。</li>
<li>然后根域名服务器再返回给本地域名服务器一个所查询域（根的子域）的主域名服务器的地址。</li>
<li>本地服务器再向上一步返回的域名服务器发送请求，然后接受请求的服务器查询自己的缓存，如果没有该纪录，则返回相关的下级的域名服务器的地址。</li>
<li>重复第7步，直到找到正确的纪录。</li>
<li>本地域名服务器把返回的结果保存到缓存，以备下一次使用，同时还将结果返回给客户机。</li>
</ul>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220907202110899.png" alt="image-20220907202110899"></p>
<p>注意事项：</p>
<p><strong>递归查询</strong>：在该模式下DNS服务器接收到客户机请求，必须使用一个准确的查询结果回复客户机。如果DNS服务器本地没有存储查询DNS信息，那么该服务器会询问其他服务器，并将返回的查询结果提交给客户机。</p>
<p><strong>迭代查询</strong>：DNS所在服务器若没有可以响应的结果，会向客户机提供其他能够解析查询请求的DNS服务器地址，当客户机发送查询请求时，DNS服务器并不直接回复查询结果，而是告诉客户机另一台DNS服务器地址，客户机再向这台DNS服务器提交请求，依次循环直到返回查询的结果为止。</p>
<h1 id="为什么DNS通常基于UDP？"><a href="#为什么DNS通常基于UDP？" class="headerlink" title="为什么DNS通常基于UDP？"></a>为什么DNS通常基于UDP？</h1><p>DNS通常是基于UDP的，但当数据长度大于512字节的时候，为了保证传输质量，就会使用基于TCP的实现方式</p>
<ul>
<li><strong>从数据包的数量以及占有网络资源的层面</strong></li>
</ul>
<p>使用基于UDP的DNS协议只要一个请求、一个应答就好了; 而使用基于TCP的DNS协议要三次握手、发送数据以及应答、四次挥手; 明显基于TCP协议的DNS更浪费网络资源！</p>
<ul>
<li><strong>从数据一致性层面</strong></li>
</ul>
<p>DNS数据包不是那种大数据包，所以使用UDP不需要考虑分包，如果丢包那么就是全部丢包，如果收到了数据，那就是收到了全部数据！所以只需要考虑丢包的情况，那就算是丢包了，重新请求一次就好了。而且DNS的报文允许填入序号字段，对于请求报文和其对应的应答报文，这个字段是相同的，通过它可以区分DNS应答是对应的哪个请求</p>
<h4 id="什么是DNS劫持？"><a href="#什么是DNS劫持？" class="headerlink" title="什么是DNS劫持？"></a>什么是DNS劫持？</h4><p>DNS劫持就是通过劫持了DNS服务器，通过某些手段取得某域名的解析记录控制权，进而修改此域名的解析结果，导致对该域名的访问由原IP地址转入到修改后的指定IP，其结果就是对特定的网址不能访问或访问的是假网址，从而实现窃取资料或者破坏原有正常服务的目的。DNS劫持通过篡改DNS服务器上的数据返回给用户一个错误的查询结果来实现的。</p>
<ul>
<li><strong>DNS劫持症状</strong></li>
</ul>
<p>在某些地区的用户在成功连接宽带后，首次打开任何页面都指向ISP提供的“电信互联星空”、“网通黄页广告”等内容页面。还有就是曾经出现过用户访问Google域名的时候出现了百度的网站。这些都属于DNS劫持。</p>
<h1 id="什么是DNS污染？"><a href="#什么是DNS污染？" class="headerlink" title="什么是DNS污染？"></a>什么是DNS污染？</h1><p>DNS污染是一种让一般用户由于得到虚假目标主机IP而不能与其通信的方法，是一种DNS缓存投毒攻击（DNS cache poisoning）。其工作方式是：由于通常的DNS查询没有任何认证机制，而且DNS查询通常基于的UDP是无连接不可靠的协议，因此DNS的查询非常容易被篡改，通过对UDP端口53上的DNS查询进行入侵检测，一经发现与关键词相匹配的请求则立即伪装成目标域名的解析服务器（NS，Name Server）给查询者返回虚假结果。</p>
<p>而DNS污染则是发生在用户请求的第一步上，直接从协议上对用户的DNS请求进行干扰。</p>
<p><strong>DNS污染症状</strong>：</p>
<p>目前一些被禁止访问的网站很多就是通过DNS污染来实现的，例如YouTube、Facebook等网站。</p>
<p><strong>解决方法</strong>:</p>
<ol>
<li>对于DNS劫持，可以采用使用国外免费公用的DNS服务器解决。例如OpenDNS（208.67.222.222）或GoogleDNS（8.8.8.8）。</li>
<li>对于DNS污染，可以说，个人用户很难单单靠设置解决，通常可以使用VPN或者域名远程解析的方法解决，但这大多需要购买付费的VPN或SSH等，也可以通过修改Hosts的方法，手动设置域名正确的IP地址。</li>
</ol>
<h4 id="¶-为什么要DNS流量监控？"><a href="#¶-为什么要DNS流量监控？" class="headerlink" title="¶ 为什么要DNS流量监控？"></a><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81dns%E6%B5%81%E9%87%8F%E7%9B%91%E6%8E%A7">¶</a> 为什么要DNS流量监控？</h4><p>预示网络中正出现可疑或恶意代码的 DNS 组合查询或流量特征。例如：</p>
<ul>
<li>1.来自伪造源地址的 DNS 查询、或未授权使用且无出口过滤地址的 DNS 查询，若同时观察到异常大的 DNS 查询量或使用 TCP 而非 UDP 进行 DNS 查询，这可能表明网络内存在被感染的主机，受到了 DDoS 攻击。</li>
<li>2.异常 DNS 查询可能是针对域名服务器或解析器（根据目标 IP 地址确定）的漏洞攻击的标志。与此同时，这些查询也可能表明网络中有不正常运行的设备。原因可能是恶意软件或未能成功清除恶意软件。</li>
<li>3.在很多情况下，DNS 查询要求解析的域名如果是已知的恶意域名，或具有域名生成算法( DGA )（与非法僵尸网络有关）常见特征的域名，或者向未授权使用的解析器发送的查询，都是证明网络中存在被感染主机的有力证据。</li>
<li>4.DNS 响应也能显露可疑或恶意数据在网络主机间传播的迹象。例如，DNS 响应的长度或组合特征可以暴露恶意或非法行为。例如，响应消息异常巨大（放大攻击），或响应消息的 Answer Section 或 Additional Section 非常可疑（缓存污染，隐蔽通道）。</li>
<li>5.针对自身域名组合的 DNS 响应，如果解析至不同于你发布在授权区域中的 IP 地址，或来自未授权区域主机的域名服务器的响应，或解析为名称错误( NXDOMAIN )的对区域主机名的肯定响应，均表明域名或注册账号可能被劫持或 DNS 响应被篡改。</li>
<li>6.来自可疑 IP 地址的 DNS 响应，例如来自分配给宽带接入网络 IP 段的地址、非标准端口上出现的 DNS 流量，异常大量的解析至短生存时间( TTL )域名的响应消息，或异常大量的包含“ name error ”( NXDOMAIN )的响应消息，往往是主机被僵尸网络控制、运行恶意软件或被感染的表现。</li>
</ul>
<h1 id="输入URL-到页面加载过程？"><a href="#输入URL-到页面加载过程？" class="headerlink" title="输入URL 到页面加载过程？"></a>输入URL 到页面加载过程？</h1><ol>
<li>地址栏输入URL</li>
<li>DNS 域名解析IP</li>
<li>请求和响应数据<ol>
<li>建立TCP连接（3次握手）</li>
<li>发送HTTP请求</li>
<li>服务器处理请求</li>
<li>返回HTTP响应结果</li>
<li>关闭TCP连接（4次挥手）</li>
</ol>
</li>
<li>浏览器加载，解析和渲染</li>
</ol>
<p>下图是在数据传输过程中的工作方式，在发送端是应用层–&gt;链路层这个方向的封包过程，每经过一层都会增加该层的头部。而接收端则是从链路层–&gt;应用层解包的过程，每经过一层则会去掉相应的首部。</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220907202308092.png" alt="image-20220907202308092"></p>
<h1 id="如何使用netstat查看服务及监听端口？"><a href="#如何使用netstat查看服务及监听端口？" class="headerlink" title="如何使用netstat查看服务及监听端口？"></a>如何使用netstat查看服务及监听端口？</h1><p><code>netstat -t/-u/-l/-r/-n</code>【显示网络相关信息,-t:TCP协议,-u:UDP协议,-l:监听,-r:路由,-n:显示IP地址和端口号】</p>
<ul>
<li>查看本机监听的端口</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@pdai-centos ~]<span class="comment"># netstat -tlun</span></span><br><span class="line">Active Internet connections (only servers)</span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State      </span><br><span class="line">tcp        0      0 0.0.0.0:80              0.0.0.0:*               LISTEN      </span><br><span class="line">tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN     </span><br><span class="line">tcp        0      0 0.0.0.0:443             0.0.0.0:*               LISTEN                          </span><br><span class="line">udp        0      0 172.21.0.14:123         0.0.0.0:*                          </span><br><span class="line">udp        0      0 127.0.0.1:123           0.0.0.0:*                          </span><br><span class="line">udp6       0      0 fe80::5054:ff:fe2b::123 :::*                               </span><br><span class="line">udp6       0      0 ::1:123                 :::* </span><br><span class="line">  </span><br><span class="line">        @pdai: 代码已经复制到剪贴板</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10</p>
<h4 id="¶-如何使用TCPDump抓包？"><a href="#¶-如何使用TCPDump抓包？" class="headerlink" title="¶ 如何使用TCPDump抓包？"></a><a href="#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8tcpdump%E6%8A%93%E5%8C%85">¶</a> 如何使用TCPDump抓包？</h4><p>tcpdump 是一款强大的网络抓包工具，它使用 libpcap 库来抓取网络数据包，这个库在几乎在所有的 Linux&#x2F;Unix 中都有。</p>
<p><strong>tcpdump 的常用参数</strong>如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ tcpdump -i eth0 -nn -s0 -v port 80</span><br><span class="line">  </span><br><span class="line">        @pdai: 代码已经复制到剪贴板</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>1</p>
<ul>
<li>-i : 选择要捕获的接口，通常是以太网卡或无线网卡，也可以是 vlan 或其他特殊接口。如果该系统上只有一个网络接口，则无需指定。</li>
<li>-nn : 单个 n 表示不解析域名，直接显示 IP；两个 n 表示不解析域名和端口。这样不仅方便查看 IP 和端口号，而且在抓取大量数据时非常高效，因为域名解析会降低抓取速度。</li>
<li>-s0 : tcpdump 默认只会截取前 96 字节的内容，要想截取所有的报文内容，可以使用 <code>-s number</code>， number 就是你要截取的报文字节数，如果是 0 的话，表示截取报文全部内容。</li>
<li>-v : 使用 <code>-v</code>，<code>-vv</code> 和 <code>-vvv</code> 来显示更多的详细信息，通常会显示更多与特定协议相关的信息。</li>
<li><code>port 80</code> : 这是一个常见的端口过滤器，表示仅抓取 80 端口上的流量，通常是 HTTP。</li>
</ul>
<h4 id="¶-如何使用Wireshark抓包分析？"><a href="#¶-如何使用Wireshark抓包分析？" class="headerlink" title="¶ 如何使用Wireshark抓包分析？"></a><a href="#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8wireshark%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90">¶</a> 如何使用Wireshark抓包分析？</h4><p>Wireshark（前称Ethereal）是一个网络封包分析软件。网络封包分析软件的功能是撷取网络封包，并尽可能显示出最为详细的网络封包资料。Wireshark使用WinPCAP作为接口，直接与网卡进行数据报文交换。</p>
<p>首先看下TCP报文首部，和wireshark捕获到的TCP包中的每个字段如下图所示：</p>
<p><img src="https://pdai-1257820000.cos.ap-beijing.myqcloud.com/pdai.tech/public/_images/develop/network/dev-network-wireshark-1.jpeg" alt="img"></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=http://example.com/2022/08/15/%E9%9D%A2%E8%AF%95%E4%B9%8B%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/2022/08/16/JUC%EF%BC%9A%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B%E4%B9%8B%E5%86%85%E5%AD%98/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            共享模型之内存
          
        </div>
      </a>
    
    
      <a href="/2022/08/14/JUC%EF%BC%9A%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B%E4%B9%8B%E7%AE%A1%E7%A8%8B/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">共享模型之管程</div>
      </a>
    
  </nav>

  
   
    
    <script src="https://cdn.staticfile.org/twikoo/1.4.18/twikoo.all.min.js"></script>
    <div id="twikoo" class="twikoo"></div>
    <script>
        twikoo.init({
            envId: ""
        })
    </script>
 
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2021-2022
        <i class="ri-heart-fill heart_icon"></i> Yang Shiyu
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="Healer"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: ".tocbot",
    contentSelector: ".article-entry",
    headingSelector: "h1, h2, h3, h4, h5, h6",
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: "main",
    positionFixedSelector: ".tocbot",
    positionFixedClass: "is-position-fixed",
    fixedSidebarOffset: "auto",
  });
</script>

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->
 
<script src="/js/clickBoom2.js"></script>
 
<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->
 
<script src="/js/dz.js"></script>
 
<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>