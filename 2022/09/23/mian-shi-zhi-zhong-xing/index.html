<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="面试之中兴, Healer">
    <meta name="description" content="">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>面试之中兴 | Healer</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 6.2.0"><link rel="alternate" href="/atom.xml" title="Healer" type="application/atom+xml">
</head>



   <style>
    body{
       background-image: url(https://ysy-java.oss-cn-hangzhou.aliyuncs.com/girl.jpg);
       background-repeat:no-repeat;
       background-size:cover;
       background-attachment:fixed;
    }
</style>



<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">Healer</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">Healer</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        
    </ul>
</div>


        </div>

        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/9.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">面试之中兴</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        padding: 35px 0 15px 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        padding-bottom: 30px;
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/%E4%B8%AD%E5%85%B4/">
                                <span class="chip bg-color">中兴</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/%E9%9D%A2%E8%AF%95/" class="post-category">
                                面试
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2022-09-23
                </div>
                

                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    10.6k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    37 分
                </div>
                

                
            </div>
        </div>
        <hr class="clearfix">

        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="redis-的雪崩、穿透和击穿"><a href="#redis-的雪崩、穿透和击穿" class="headerlink" title="redis 的雪崩、穿透和击穿"></a>redis 的雪崩、穿透和击穿</h1><h2 id="redis-缓存雪崩"><a href="#redis-缓存雪崩" class="headerlink" title="redis 缓存雪崩"></a>redis 缓存雪崩</h2><p>所谓的 redis 缓存雪崩指的是：大量的应用请求无法在 Redis 缓存中进行处理，紧接着，应用将大量请求发送到数据库层，导致数据库层的压力激增。<strong>redis 中大量 key 集中过期或者 redis 服务器宕机，从而导致大量请求从数据库获取数据，导致数据库服务器访问压力过大。</strong></p>
<p><strong>解决方式：</strong></p>
<ol>
<li>若是由于大量 key 过期所造成的，可以给 key 的 ttl 生存时间值 设置一个过期时间</li>
<li>若是因为 redis 服务器宕机所导致的，可以搭建 redis 集群，保证高可用</li>
<li>可以从请求量层面进行解决，对缓存业务添加限流和服务降级策略</li>
<li>可以添加多级缓存，比如说 nginx 缓存</li>
</ol>
<h2 id="redis-缓存击穿"><a href="#redis-缓存击穿" class="headerlink" title="redis 缓存击穿"></a>redis 缓存击穿</h2><p>所谓的 redis 缓存击穿指的是：<strong>热点 key 的过期，从而导致大量访问热点 key 的请求访问数据库，从而导致数据库压力过大。key 中对应数据存在，当 key 中对应的数据在缓存中过期，而此时又有大量请求访问该数据，缓存中过期了，请求会直接访问数据库并回设到缓存中，高并发访问数据库会导致数据库崩溃。</strong></p>
<p><strong>解决方式</strong>：热点 key 通常是我们通过后台进行批量添加的，比如秒杀活动，解决热点 key 失效，可以重建缓存</p>
<ol>
<li>互斥锁实现：只允许一个线程对 redis 缓存进行重建，其他线程处于等待状态，可以通过 redis 当中的 setnx 实现。缺点是串行化执行，效率低。优点是一致性高。</li>
<li>逻辑过期：给需要缓存的数据添加一个逻辑过期字段，通过对逻辑过期字段的判断，判断数据有无过期，如果过期则开启一个线程进行缓存重建，并且返回之前的数据。缺点是数据的一致性低，优点是相应速度快。</li>
<li>在缓存访问非常频繁的热点数据时，不要设置过期时间</li>
</ol>
<h2 id="redis-缓存穿透"><a href="#redis-缓存穿透" class="headerlink" title="redis 缓存穿透"></a>redis 缓存穿透</h2><p>所谓的 redis 缓存穿透指的是：redis 当中没有数据，数据库当中也没有数据，请求每次都是访问数据库，而数据库又没有数据返回。这样一来，缓存也就成了“摆设”，如果应用持续有大量请求访问数据，就会同时给缓存和数据库带来巨大压力</p>
<p><strong>解决方式：</strong></p>
<ol>
<li>缓存空值。缺点是有点浪费内存空间，如果这样的请求过多，会导致redis当中有大量这种无用缓存，可以给其设置一个ttl。</li>
<li>使用布隆过滤器。布隆过滤器原理是一个二进制的数组，存储的是0或1，在添加元素时进行多次 hash 运算，得到多个0或1，存储到相应位置。</li>
<li>热点参数的限流降级</li>
<li>进行权限校验</li>
<li>做好数据格式的校验</li>
</ol>
<h1 id="数据库三大范式"><a href="#数据库三大范式" class="headerlink" title="数据库三大范式"></a>数据库三大范式</h1><ul>
<li><p><strong>第一设计范式 ：表中的每一列都不能再分(不要出现二维表)</strong></p>
</li>
<li><p>第二设计范式：满足第一设计范式，除主键外每一列都必须依靠主键</p>
</li>
<li><p>第三设计范式：满足第二设计范式，除主键列外，每一列都不能相互依靠</p>
</li>
</ul>
<h1 id="mysql-与-redis-的区别"><a href="#mysql-与-redis-的区别" class="headerlink" title="mysql 与 redis 的区别"></a>mysql 与 redis 的区别</h1><p><strong>类型上</strong></p>
<p>从类型上来说，mysql 是关系型数据库，redis 是缓存数据库</p>
<p><strong>作用上</strong></p>
<p>mysql 用于持久化的存储数据到硬盘，功能强大，速度较慢，基于磁盘，读写速度没有 Redis 快，但是不受空间容量限制，性价比高</p>
<p>redis 用于存储使用较为频繁的数据到缓存中，读取速度快，基于内存，读写速度快，也可做持久化，但是内存空间有限，当数据量超过内存空间时，需扩充内存，但内存价格贵</p>
<p><strong>需求上</strong></p>
<p>mysql 和 redis 因为需求的不同，一般都是配合使用。需要高性能的地方使用 Redis，不需要高性能的地方使用 MySQL。存储数据在MySQL 和 Redis 之间做同步。</p>
<h1 id="什么是Redis，为什么用Redis"><a href="#什么是Redis，为什么用Redis" class="headerlink" title="什么是Redis，为什么用Redis"></a>什么是Redis，为什么用Redis</h1><p>Redis 是一种支持 key-value 等多种数据结构的存储系统。可用于缓存，事件发布或订阅，高速队列等场景。支持网络，提供字符串，哈希，列表，队列，集合结构直接存取，<strong>基于内存，可持久化</strong>。</p>
<ul>
<li><strong>读写性能优异</strong><ul>
<li>Redis能读的速度是110000次&#x2F;s，写的速度是81000次&#x2F;s （测试条件见下一节）。</li>
</ul>
</li>
<li><strong>数据类型丰富</strong><ul>
<li>Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。</li>
</ul>
</li>
<li><strong>原子性</strong><ul>
<li>Redis的所有操作都是原子性的，同时Redis还支持对几个操作全并后的原子性执行。</li>
</ul>
</li>
<li><strong>丰富的特性</strong><ul>
<li>Redis支持 publish&#x2F;subscribe, 通知, key 过期等特性。</li>
</ul>
</li>
<li><strong>持久化</strong><ul>
<li>Redis支持RDB, AOF等持久化方式</li>
</ul>
</li>
<li><strong>发布订阅</strong><ul>
<li>Redis支持发布&#x2F;订阅模式</li>
</ul>
</li>
<li><strong>分布式</strong><ul>
<li>Redis Cluster</li>
</ul>
</li>
</ul>
<h1 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h1><ul>
<li><p>不使用对象来进行真实操作，使用我们自己创建的代理对象来操作</p>
</li>
<li><p>为其他对象提供一种<strong>代理</strong>以控制对这个对象的访问。在某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用。</p>
</li>
<li><p>动态代理的优势在于<strong>能够很方便的对代理类中方法进行集中处理，而不用修改每个被代理的方法</strong>。</p>
</li>
<li><p>不修改源目标的前提下，额外扩展源目标的功能。即通过访问源目标的代理类，再由代理类去访问源目标。</p>
</li>
<li><p>原生的 jdk 的动态代理存在缺陷，代理类和委托类必须实现同一个接口</p>
</li>
<li><p>jdk 的动态代理底层实现是基于<strong>接口实现</strong>的</p>
</li>
<li><p>cglib 的动态代理底层是基于<strong>继承</strong>的</p>
</li>
</ul>
<h1 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h1><p><strong>前后端不分离</strong></p>
<p>SpringMVC 底层有一个核心对象：<strong>DispatcherServlet 前端控制器</strong>（分发器），使用了 SpringMVC  框架之后，所有的请求都会执行 DispatcherServlet 这个对象，不再去直接执行对应的 Controller，而是先通过 DispatcherServlet 前端控制器找到该请求路径（URL） 对应的控制器，前端控制器再去调用该控制器执行具体业务。</p>
<img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20210309195355880.png" alt="image-20210309195355880" style="zoom:200%;" />

<ol>
<li>一个请求匹配<strong>前端控制器 DispatcherServlet</strong> 的请求映射路径(在 web.xml 中指定)，WEB 容器将该<strong>请求转交给 DispatcherServlet 处理</strong></li>
<li>DispatcherServlet 接收到请求后，解析URL，将根据请求信息交给<strong>处理器映射器 （HandlerMapping）</strong></li>
<li>HandlerMapping 根据用户的url请求 <strong>查找匹配该 url 的 Handler</strong>，并<strong>返回一个执行链</strong> </li>
<li><strong>DispatcherServlet 再请求处理器适配器(HandlerAdapter)</strong> 调用相应的 <strong>Handler</strong> 进行处理并返回 <strong>ModelAndView 给 DispatcherServlet</strong></li>
<li>DispatcherServlet 将 ModelAndView <strong>请求 ViewReslover（视图解析器）解析，返回具体 View</strong></li>
<li>DispatcherServlet <strong>对 View 进行渲染视图</strong>（即将模型数据填充至视图中）</li>
<li><strong>DispatcherServlet 将页面响应给用户</strong></li>
</ol>
<p>注意：</p>
<ul>
<li>在前端浏览器上第一次请求我们的 DispatchServlet 前端控制器（核心组件），会创建该 DispatchServlet 对象的实例，再执行 DispatchServlet 中的 init() 方法 ， 从 spring 容器中按照类型注入来获取 DispatchServlet 中的属性对应的组件来进行依赖注入 ！！！</li>
<li>如果不是第一次请求的话，各大组件依赖注入完毕，直接执行 doService() 方法来完成后续操作！！！</li>
<li>SpringMVC 底层也有自己的一个容器：WebXmlApplicationContext ，和 spring 的 ApplicationContext 容器是父子关系，SpringMVC 的容器是继承了 Spring 容器的，spring 容器是父容器，springmvc 容器是子容器！！！</li>
<li>springmvc 在需要使用到某个功能组件的时候，先去自己的 WebXmlApplicationContext 容器中去找，如果没有则去 spring 容器中去找</li>
<li>springmvc 可以获取 spring 容器中的 bean，而 spring 则无法获取 springmvc 容器中的 bean ！！！！</li>
<li>一般的话像 Controller 层对象一般都是存放在 springmvc 的容器中来共 springmvc 中的处理器适配器去调用！！！</li>
<li>Service 层 和 Dao 层对象，一般则是放在 spring 容器中，因为像一些事务的处理和 mybatis 核心对象的生成不是加上注解之后就会立即生效，而是先生成代理对象，一般这些代理对象一般都在 spring 容器中注册！！！</li>
</ul>
<p><strong>前后端分离</strong></p>
<p>使用 <strong>@ResponseBody</strong> 来把数据写入到响应体中。所以不需要进行页面的跳转。</p>
<ol>
<li><p>用户发起请求被 <strong>DispatchServlet</strong> 所处理</p>
</li>
<li><p>DispatchServlet 通过 HandlerMapping 根据具体的请求查找能处理这个请求的 Handler。（HandlerMapping 主要是处理请求和Handler方法的映射关系的）</p>
</li>
<li><p>HandlerMapping 返回一个能够处理请求的执行链给 DispatchServlet，这个链中除了包含 Handler 方法也包含拦截器。</p>
</li>
<li><p>DispatchServlet 拿着执行链去找 HandlerAdapter 执行链中的方法。</p>
</li>
<li><p>HandlerAdater 会去执行对应的 Handler 方法，把数据处理转换成合适的类型，然后作为方法参数传入</p>
</li>
<li><p>Handler 方法执行完后的返回值会被 HandlerAdapter 转换成 ModelAndView 类型。<strong>由于使用了 @ResponseBody 注解，返回的ModelAndView 会为 null，并且 HandlerAdapter 会把方法返回值放到响应体中。</strong>（HandlerAdater 主要进行 Handler 方法参数和返回值的处理。）</p>
</li>
<li><p>返回 ModelAndView 给 DispatchServlet。</p>
</li>
<li><p>因为返回的 ModelAndView 为null，所以不用去解析视图解析和其后面的操作</p>
</li>
</ol>
<h1 id="SpringBoot-自动配置"><a href="#SpringBoot-自动配置" class="headerlink" title="SpringBoot 自动配置"></a>SpringBoot 自动配置</h1><p>使用 SpringBoot 之后，一个整合了 SpringMVC 的 WEB 工程开发，变的无比简单，那些繁杂的配置都消失不见了，这是如何做到的？</p>
<p>一切魔力的开始，都是从我们的 main 函数来的，所以我们再次来看下<strong>启动类</strong>：</p>
<p>我们发现特别的地方有两个：</p>
<ul>
<li>注解：**@SpringBootApplication**</li>
<li>run方法：SpringApplication.run()</li>
</ul>
<p>我们分别来研究这两个部分。</p>
<p>在 Spring 程序 main 方法中，添加**@SpringBootApplication或者@EnableAutoConfiguration**会自动去 maven 中读取每个 starter 中的 <code>spring.factories</code> 文件，该文件里配置了所有需要被创建的 Spring 容器中的 bean</p>
<h2 id="SpringBootApplication"><a href="#SpringBootApplication" class="headerlink" title="@SpringBootApplication"></a>@SpringBootApplication</h2><p>标注在某个类上，说明这个类是 SpringBoot 的主配置类，SpringBoot 项目就应该运行这个类的 main 方法来启动 SpringBoot 应用。</p>
<p>这里重点的注解有3个：</p>
<ul>
<li><strong>@SpringBootConfiguration</strong></li>
<li><strong>@EnableAutoConfiguration</strong></li>
<li><strong>@ComponentScan</strong></li>
</ul>
<h3 id="SpringBootConfiguration"><a href="#SpringBootConfiguration" class="headerlink" title="@SpringBootConfiguration"></a>@SpringBootConfiguration</h3><p>通过源码我们可以看出，<strong>在这个注解上面，又有一个<code>@Configuration</code>注解</strong>。通过上面的注释阅读我们知道：这个<strong>注解的作用就是声明当前类是一个配置类，然后 Spring 会自动扫描到添加了<code>@Configuration</code>的类，并且读取其中的配置信息。而<code>@SpringBootConfiguration</code> 是来声明当前类是 SpringBoot 应用的配置类，</strong>项目中只能有一个。所以一般我们无需自己添加。</p>
<h3 id="EnableAutoConfiguration"><a href="#EnableAutoConfiguration" class="headerlink" title="@EnableAutoConfiguration"></a>@EnableAutoConfiguration</h3><p><strong>开启自动配置功能</strong></p>
<p>总结，SpringBoot 内部对大量的第三方库或 Spring 内部库进行了默认配置，这些配置是否生效，取决于我们是否引入了对应库所需的依赖，如果有那么默认配置就会生效。</p>
<p>所以，我们使用 SpringBoot 构建一个项目，只需要引入所需框架的依赖，配置就可以交给SpringBoot处理了。除非你不希望使用SpringBoot 的默认配置，它也提供了自定义配置的入口。</p>
<h3 id="ComponentScan"><a href="#ComponentScan" class="headerlink" title="@ComponentScan"></a>@ComponentScan</h3><p>而我们的 @SpringBootApplication 注解声明的类就是 main 函数所在的启动类，因此扫描的包是该类所在包及其子包。因此，<strong>一般启动类会放在一个比较前的包目录中。</strong></p>
<p>自动扫描包（扫描当前主启动类同级的包）并加载符合条件的组件或者 bean，将这个 bean 定义加载到 IOC 容器中。</p>
<h1 id="接口与抽象类"><a href="#接口与抽象类" class="headerlink" title="接口与抽象类"></a>接口与抽象类</h1><ul>
<li>一个子类只能继承一个抽象类，但能实现多个接口</li>
<li>抽象类可以有构造方法，接口没有构造方法</li>
<li>抽象类可以有普通成员变量，接口没有普通成员变量</li>
<li>抽象类和接口都可有静态成员变量，抽象类中静态成员变量访问类型任意，接口只能 <strong>public static final</strong> (默认)</li>
<li>抽象类可以没有抽象方法，抽象类可以有普通方法；接口在 JDK8 之前都是抽象方法，在JDK8可以有default方法，在JDK9中允许有私有普通方法</li>
<li>抽象类可以有静态方法；接口在JDK8之前不能有静态方法，在JDK8中可以有静态方法，且只能被接口类直接调用（不能被实现类的对象调用）</li>
<li>抽象类中的方法可以是public、protected; 接口方法在JDK8之前只有public abstract，在JDK8可以有default方法，在JDK9中允许有private方法</li>
</ul>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">抽象类</th>
<th align="center">接口</th>
</tr>
</thead>
<tbody><tr>
<td align="center">构造方法</td>
<td align="center">可以有</td>
<td align="center">不可以有</td>
</tr>
<tr>
<td align="center">普通成员变量</td>
<td align="center">可以有</td>
<td align="center">不可以有</td>
</tr>
<tr>
<td align="center">静态成员变量</td>
<td align="center">访问类型任意</td>
<td align="center">只能 <strong>public static final</strong></td>
</tr>
<tr>
<td align="center">方法</td>
<td align="center">可以没有抽象方法，可以有普通方法</td>
<td align="center">JDK8 之前：抽象方法，JDK8可以有default方法，JDK9中允许有私有普通方法</td>
</tr>
<tr>
<td align="center">静态方法</td>
<td align="center">可以有</td>
<td align="center">JDK8之前不能有静态方法，JDK8中可以有静态方法，只能被接口类直接调用</td>
</tr>
</tbody></table>
<h1 id="为什么需要泛型"><a href="#为什么需要泛型" class="headerlink" title="为什么需要泛型"></a>为什么需要泛型</h1><ol>
<li><p><strong>适用于多种数据类型执行相同的代码</strong></p>
<p>如果没有泛型，要实现不同类型的加法，每种类型都需要重载一个add方法；通过泛型，我们可以复用为一个方法：</p>
</li>
<li><p><strong>泛型中的类型在使用时指定，不需要强制类型转换</strong>（<strong>类型安全</strong>，编译器会<strong>检查类型</strong>）</p>
</li>
</ol>
<h1 id="String、StringBuffer-与-StringBuilder"><a href="#String、StringBuffer-与-StringBuilder" class="headerlink" title="String、StringBuffer 与 StringBuilder"></a>String、StringBuffer 与 StringBuilder</h1><ul>
<li>可变和适用范围。String 对象是不可变的，而 StringBuffer 和 StringBuilder 是可变字符序列。每次对 String 的操作相当于生成一个新的 String 对象，而对 StringBuffer 和 StringBuilder 的操作是对对象本身的操作，而不会生成新的对象，所以对于频繁改变内容的字符串避免使用 String，因为频繁的生成对象将会对系统性能产生影响。</li>
<li>线程安全。String 由于有 final 修饰，是不可变的，也就可以理解为常量，<strong>线程安全</strong>。StringBuilder 和 StringBuffer 的区别在于 StringBuilder 不保证同步，StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，<strong>线程安全</strong>。StringBuilder 并没有对方法进行加同步锁，<strong>非线程安全</strong>。</li>
</ul>
<h1 id="List，Set，Map-三者的区别"><a href="#List，Set，Map-三者的区别" class="headerlink" title="List，Set，Map 三者的区别"></a>List，Set，Map 三者的区别</h1><ul>
<li>List (对付顺序的好帮⼿)：存储的元素是有序的、可重复的。</li>
<li>Set (注重独⼀⽆⼆的性质)：存储的元素是⽆序的、不可重复的。</li>
<li>Map (⽤ Key 来搜索的专家)：使⽤键值对（kye-value）存储，类似于数学上的函数 y&#x3D;f(x)，“x”代表 key，”y”代表 value，Key 是⽆序的、不可重复的，value 是⽆序的、可重复的，每个键最多映射到⼀个值。</li>
</ul>
<h1 id="Arraylist-与-LinkedList-区别"><a href="#Arraylist-与-LinkedList-区别" class="headerlink" title="Arraylist 与 LinkedList 区别"></a>Arraylist 与 LinkedList 区别</h1><ul>
<li><strong>是否保证线程安全：</strong> ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全；</li>
<li><strong>底层数据结构：</strong> Arraylist 底层使⽤的是 <strong>Object</strong> <strong>数组</strong>； LinkedList 底层使⽤的是 <strong>双向链表</strong> 数据结构（JDK1.6 之前为循环链表，JDK1.7 取消了循环。注意双向链表和双向循环链表的区别，下⾯有介绍到！）</li>
<li><strong>插⼊和删除是否受元素位置的影响：</strong><ul>
<li><strong>ArrayList</strong> <strong>采⽤数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。</strong> ⽐如：执⾏ add(E e) ⽅法的时候， ArrayList 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是 O(1)。但是如果要在指定位置 i 插⼊和删除元素的话（ add(int index, E element) ）时间复杂度就为 O(n-i)。因为在进⾏上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执⾏向后位&#x2F;向前移⼀位的操作。</li>
<li>LinkedList <strong>采⽤链表存储，所以对于</strong> <strong>add(E e)</strong> <strong>⽅法的插⼊，删除元素时间复杂度不受元素位置的影响，近似</strong> **O(1)**，如果是要在指定位置 <strong>i</strong> <strong>插⼊和删除元素的话（</strong> <strong>(add(int index, Eelement)</strong> <strong>） 时间复杂度近似为</strong> <strong>o(n))</strong> <strong>因为需要先移动到指定位置再插⼊。</strong></li>
</ul>
</li>
<li><strong>是否⽀持快速随机访问：</strong> LinkedList 不⽀持⾼效的随机元素访问，⽽ ArrayList ⽀持。快速随机访问就是通过元素的序号快速获取元素对象(对应于 get(int index) ⽅法)。 </li>
<li><strong>内存空间占⽤：</strong> ArrayList 的空间浪费主要体现在在 list 列表的结尾会预留⼀定的容量空间，⽽ LinkedList 的空间花费则体现在它的每⼀个元素都需要消耗⽐ ArrayList 更多的空间（因为要存放直接后继和直接前驱以及数据）。</li>
</ul>
<h1 id="ArrayList-与-Vector-的区别"><a href="#ArrayList-与-Vector-的区别" class="headerlink" title="ArrayList 与 Vector 的区别"></a>ArrayList 与 Vector 的区别</h1><ul>
<li>ArrayList 是 List 的主要实现类，底层使⽤ Object[ ] 存储，适⽤于频繁的查找⼯作，线程不安全 ；</li>
<li>Vector 是 List 的古⽼实现类，底层使⽤ Object[ ] 存储，线程安全的。</li>
</ul>
<h1 id="HashMap-和-Hashtable-的区别"><a href="#HashMap-和-Hashtable-的区别" class="headerlink" title="HashMap 和 Hashtable 的区别"></a>HashMap 和 Hashtable 的区别</h1><ul>
<li><p><strong>线程是否安全：</strong> HashMap 是⾮线程安全的，HashTable 是线程安全的，因为 HashTable 内部的⽅法基本都经过 synchronized 修饰。（如果你要保证线程安全的话就使⽤ ConcurrentHashMap 吧！）；</p>
</li>
<li><p><strong>效率：</strong> 因为线程安全的问题， HashMap 要⽐ HashTable 效率⾼⼀点。另外， HashTable基本被淘汰，不要在代码中使⽤它；</p>
</li>
<li><p><strong>对</strong> <strong>Null key</strong> <strong>和</strong> <strong>Null value</strong> <strong>的⽀持：</strong> HashMap 可以存储 null 的 key 和 value，但 null 作为键只能有⼀个，null 作为值可以有多个；HashTable 不允许有 null 键和 null 值，否则会抛出 NullPointerException 。</p>
</li>
<li><p><strong>初始容量大小和每次扩充容量大小的不同 ：</strong></p>
<ul>
<li>创建时如果不指定容量初始值， Hashtable默认的初始大小为 11，之后每次扩充，容量变为原来的 2n+1。 HashMap 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。</li>
<li>创建时如果给定了容量初始值，那么 Hashtable 会直接使⽤你给定的⼤⼩，⽽ HashMap 会将其扩充为 2 的幂次方大小（ HashMap 中的 tableSizeFor() ⽅法保证，下⾯给出了源代码）。也就是说 HashMap 总是使⽤ 2 的幂作为哈希表的⼤⼩，后⾯会介绍到为什么是 2 的幂次⽅。</li>
</ul>
</li>
<li><p><strong>底层数据结构：</strong> JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红⿊树前会判断，如果当前数组的⻓度⼩于 64，那么会选择先进⾏数组扩容，⽽不是转换为红⿊树）时，将<strong>链表转化为红⿊树</strong>，以减少搜索时间。Hashtable 没有这样的机制。</p>
</li>
</ul>
<h1 id="HashMap-和-HashSet区别"><a href="#HashMap-和-HashSet区别" class="headerlink" title="HashMap 和 HashSet区别"></a>HashMap 和 HashSet区别</h1><p>HashSet 底层就是基于 HashMap 实现的。（ HashSet 的源码⾮常⾮常少，因为除了 clone() 、 writeObject() 、 readObject() 是 HashSet ⾃⼰不得不实现之外，其他⽅法都是直接调⽤ HashMap 中的⽅法。</p>
<table>
<thead>
<tr>
<th align="center">HashMap</th>
<th align="center">HashSet</th>
</tr>
</thead>
<tbody><tr>
<td align="center">实现了 Map 接⼝</td>
<td align="center">实现 Set 接⼝</td>
</tr>
<tr>
<td align="center">存储键值对</td>
<td align="center">仅存储对象</td>
</tr>
<tr>
<td align="center">调⽤ put() 向 map 中添加元素</td>
<td align="center">调⽤ add() ⽅法向 Set 中添加元素</td>
</tr>
<tr>
<td align="center">HashMap 使⽤键（Key）计算 hashcode</td>
<td align="center">HashSet 使⽤成员对象来计算 hashcode 值，对于两个对象来说 hashcode 可能相同，所以 equals() ⽅法⽤来判断对象的相等性</td>
</tr>
</tbody></table>
<h1 id="ConcurrentHashMap-和-Hashtable-的区别"><a href="#ConcurrentHashMap-和-Hashtable-的区别" class="headerlink" title="ConcurrentHashMap 和 Hashtable 的区别"></a>ConcurrentHashMap 和 Hashtable 的区别</h1><p>ConcurrentHashMap 和 Hashtable 的区别主要体现在<strong>实现线程安全的⽅式上不同</strong></p>
<ul>
<li><strong>底层数据结构：</strong> JDK1.7 的 ConcurrentHashMap 底层采⽤ <strong>分段的数组+链表</strong> 实现，JDK1.8采⽤的数据结构跟 HashMap1.8 的结构⼀样，<strong>数组+链表&#x2F;红黑二叉树</strong>。 Hashtable 和 JDK1.8 之前的 HashMap 的底层数据结构类似都是采⽤ <strong>数组+链表</strong> 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突⽽存在的；</li>
<li><strong>实现线程安全的⽅式（重要）：</strong><ul>
<li><strong>在</strong> <strong>JDK1.7</strong> <strong>的时候，</strong> <strong>ConcurrentHashMap</strong> <strong>（分段锁）</strong>对整个桶数组进⾏了分割分段( Segment )，每⼀把锁只锁容器其中⼀部分数据，多线程访问容器⾥不同数据段的数据，就不会存在锁竞争，提⾼并发访问率。 <strong>到了</strong> <strong>JDK1.8</strong> <strong>的时候已经摒弃了 Segment</strong> 的概念，⽽是直接⽤ <strong>Node 数组+链表+红黑树</strong> 的数据结构来实现，<strong>并发控制使⽤ synchronized 和 CAS</strong> 来操作。（JDK1.6 <strong>以后 对</strong> <strong>synchronized</strong> <strong>锁做了很多优化）</strong> 整个看起来就像是优化过且线程安全的 HashMap ，虽然在 JDK1.8 中还能看到 Segment 的数据结构，但是已经简化了属性，只是为了兼容旧版本；</li>
<li><strong>Hashtable(同⼀把锁)</strong> :使⽤ synchronized 来保证线程安全，效率⾮常低下。当⼀个线程访问同步⽅法时，其他线程也访问同步⽅法，可能会进⼊阻塞或轮询状态，如使⽤ put 添加元素，另⼀个线程不能使⽤ put 添加元素，也不能使⽤ get，竞争会越来越激烈效率越低。</li>
<li>JDK1.8 的 ConcurrentHashMap 不在是 <strong>Segment</strong> <strong>数组</strong> <strong>+ HashEntry</strong> <strong>数组</strong> <strong>+</strong> <strong>链表</strong>，而是 <strong>Node</strong> <strong>数组</strong> <strong>+</strong> <strong>链表</strong> <strong>&#x2F;</strong> <strong>红⿊树</strong>。不过，Node 只能⽤于链表的情况，红⿊树的情况需要使⽤ <strong>TreeNode</strong> 。当冲突链表达到⼀定长度时，链表会转换成红⿊树。</li>
</ul>
</li>
</ul>
<h1 id="TCP建立连接过程的三次握手"><a href="#TCP建立连接过程的三次握手" class="headerlink" title="TCP建立连接过程的三次握手"></a>TCP建立连接过程的三次握手</h1><p>TCP 有 6 种标识：<code>SYN(建立联机) ACK(确认) PSH(传送) FIN(结束) RST(重置) URG(紧急)</code></p>
<ul>
<li><strong>什么是三次握手</strong>？</li>
</ul>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220907194538705.png" alt="image-20220907194538705"></p>
<p>为了保证数据能到达目标，TCP采用三次握手策略：</p>
<ol>
<li><strong>发送端首先发送一个带SYN（synchronize）标志的数据包给接收方</strong>【第一次的 seq 序列号是随机产生的，这样是为了网络安全，如果不是随机产生初始序列号，黑客将会以很容易的方式获取到你与其他主机之间的初始化序列号，并且伪造序列号进行攻击】</li>
<li><strong>接收端收到后，回传一个带有 SYN&#x2F;ACK（acknowledgement）标志的数据包以示传达确认信息</strong>【SYN 是为了告诉发送端，发送方到接收方的通道没问题；ACK 用来验证接收方到发送方的通道没问题】</li>
<li><strong>最后，发送端再回传一个带 ACK 标志的数据包，代表握手结束，若在握手某个过程中某个阶段莫名中断，TCP 协议会再次以相同的顺序发送相同的数据包</strong></li>
</ol>
<h1 id="TCP断开连接过程的四次挥手？"><a href="#TCP断开连接过程的四次挥手？" class="headerlink" title="TCP断开连接过程的四次挥手？"></a>TCP断开连接过程的四次挥手？</h1><ul>
<li><strong>什么是四次挥手</strong>？</li>
</ul>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220907200133430.png" alt="image-20220907200133430"></p>
<ol>
<li><strong>主动断开方</strong>（客户端&#x2F;服务端）-<strong>发送一个 FIN，用来关闭主动断开方（客户端&#x2F;服务端）到被动断开方（客户端&#x2F;服务端）的数据传送</strong></li>
<li><strong>被动断开方</strong>（客户端&#x2F;服务端）-<strong>收到这个 FIN，它发回一 个 ACK，确认序号为收到的序号加1</strong> 。和 SYN 一样，一个 FIN 将占用一个序号</li>
<li><strong>被动断开方</strong>（客户端&#x2F;服务端）-<strong>关闭与主动断开方（客户端&#x2F;服务端）的连接，发送一个 FIN 给主动断开方</strong>（客户端&#x2F;服务端）</li>
<li><strong>主动断开方</strong>（客户端&#x2F;服务端）-<strong>发回 ACK 报文确认，并将确认序号设置为收到序号加1</strong></li>
</ol>
<h1 id="什么是-Http-协议"><a href="#什么是-Http-协议" class="headerlink" title="什么是 Http 协议"></a>什么是 Http 协议</h1><p><strong>HTTP是一个基于TCP&#x2F;IP通信协议来传递数据的协议。HTTP协议工作于客户端-服务端架构之上，实现可靠性的传输文字、图片、音频、视频等超文本数据的规范，格式简称为“超文本传输协议”。Http协议属于应用层，用户访问的第一层就是http。</strong></p>
<p>特点：</p>
<ol>
<li><strong>简单快速</strong>：客户端向服务器发送请求时，只需传送请求方法和路径即可。</li>
<li><strong>灵活</strong>：HTTP允许传输任意类型的数据对象。</li>
<li><strong>无连接</strong>：限制每次连接只处理一个请求。服务器处理完客户请求，并收到客户应答后，即断开连接。</li>
<li><strong>无状态</strong>：协议对于事务处理没有记忆能力。</li>
<li><strong>支持B&#x2F;S及C&#x2F;S模式</strong>。</li>
</ol>
<h1 id="Http-和-Https-的区别？"><a href="#Http-和-Https-的区别？" class="headerlink" title="Http 和 Https 的区别？"></a>Http 和 Https 的区别？</h1><ul>
<li><strong>端口不同</strong>：Http是80，Https443</li>
<li><strong>安全性</strong>：http是超文本传输协议，信息是明文传输，https则是通过SSL加密处理的传输协议，更加安全。</li>
<li><strong>是否付费</strong>：https需要拿到CA证书，需要付费</li>
<li><strong>连接方式</strong>：http和https使用的是完全不同的连接方式（HTTP的连接很简单，是无状态的；HTTPS 协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。）</li>
</ul>
<h1 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h1><p><strong>HTTP状态码表示客户端HTTP请求的返回结果、标识服务器处理是否正常、表明请求出现的错误等。</strong>状态码的类别：</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/1f40e0f9a6944e54b8c062c35c0e3177.png" alt="img"></p>
<blockquote>
<p><strong>常用状态码：</strong><br>200： 请求被正常处理<br>204： 请求被受理但没有资源可以返回<br>301： 永久性重定向<br>302： 临时重定向<br>304： 已缓存<br>400： 请求报文语法有误，服务器无法识别<br>403： 请求的对应资源禁止被访问<br>404： 服务器无法找到对应资源<br>500： 服务器内部错误<br>503： 服务器正忙</p>
</blockquote>
<h1 id="GET方法与POST方法的区别"><a href="#GET方法与POST方法的区别" class="headerlink" title="GET方法与POST方法的区别"></a>GET方法与POST方法的区别</h1><ul>
<li><strong>功能上</strong>： GET一般用来从服务器上获取资源，POST一般用来更新服务器上的资源；</li>
<li><strong>安全性</strong>： GET是不安全的，因为GET请求提交的数据将明文出现在URL上（请求头上），可能会泄露私密信息；POST请求参数则被包装到请求体中，相对更安全。</li>
<li><strong>数据量</strong>： Get 传输的数据量小，因为受URL长度限制，但效率较高； Post可以传输大量数据，所以上传文件时只能用Post方式；</li>
<li><strong>效率</strong>：Get 效率高</li>
</ul>
<h1 id="TCP-与-UDP"><a href="#TCP-与-UDP" class="headerlink" title="TCP 与 UDP"></a>TCP 与 UDP</h1><ul>
<li>TCP&#x2F;IP即传输控制协议，是面向连接的协议，发送数据前要先建立连接，TCP提供可靠的服务，也就是说，通过TCP连接传输的数据不会丢失，没有重复，并且按顺序到达。（类似于打电话）</li>
<li>UDP 是属于TCP&#x2F;IP协议族中的一种。是无连接的协议，发送数据前不需要建立连接，是没有可靠性的协议。因为不需要建立连接所以可以在在网络上以任何可能的路径传输，因此能否到达目的地，到达目的地的时间以及内容的正确性都是不能被保证的。（类似于发微信）</li>
<li><strong>传输控制协议-TCP</strong>：提供面向连接的，可靠的数据传输服务。</li>
<li><strong>用户数据协议-UDP</strong>：提供无连接的，尽大努力的数据传输服务（不保证数据传输的可靠性）。</li>
</ul>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">TCP</th>
<th align="center">UDP</th>
</tr>
</thead>
<tbody><tr>
<td align="center">是否连接</td>
<td align="center">面向连接</td>
<td align="center">无连接</td>
</tr>
<tr>
<td align="center">是否可靠</td>
<td align="center">可靠传输，使用 流量控制和拥塞控 制</td>
<td align="center">不可靠传输，不使用流量控制和拥塞控制</td>
</tr>
<tr>
<td align="center">连接对象个数</td>
<td align="center">只能是一对一通信</td>
<td align="center">支持一对一，一对多，多对一和多对多交互通信</td>
</tr>
<tr>
<td align="center">传输方式</td>
<td align="center">面向字节流</td>
<td align="center">面向报文</td>
</tr>
<tr>
<td align="center">首部开销</td>
<td align="center">首部小20字节， 大60字 节</td>
<td align="center">首部开销小，仅8字节</td>
</tr>
<tr>
<td align="center">场景</td>
<td align="center">适用于要求可靠传输的应用，例如 文件传输</td>
<td align="center">适用于实时应用（IP电话、视频会议、直播等）</td>
</tr>
</tbody></table>
<h1 id="Session、Cookie-和-Token-的对比"><a href="#Session、Cookie-和-Token-的对比" class="headerlink" title="Session、Cookie 和 Token 的对比"></a>Session、Cookie 和 Token 的对比</h1><ul>
<li><strong>cookie</strong>：cookie 是由 Web 服务器保存在用户浏览器上的文件（key-value格式），可以包含用户相关的信息。客户端向服务器发起请求时，会携带服务器端之前创建的 cookie，服务器端通过 cookie 中携带的数据区分不同的用户。</li>
<li><strong>session</strong>：session 是浏览器和服务器会话过程中，服务器会分配的一块储存空间给 session。服务器默认会为客户浏览器的 cookie 中设置 sessionid，这个sessionid 就和 cookie 对应，浏览器在向服务器请求过程中传输的 cookie 包含 sessionid ，服务器根据传输 cookie 中的 sessionid 获取出会话中存储的信息，然后确定会话的身份信息。</li>
<li><strong>token</strong>：Token 是在客户端频繁向服务端请求数据，服务端频繁的去数据库查询用户名和密码并进行对比，判断用户名和密码正确与否，并作出相应提示，在这样的背景下，Token 便应运而生。Token 是服务端生成的一串字符串，以作客户端进行请求的一个令牌，当第一次登录后，服务器生成一个 Token 便将此Token返回给客户端，以后客户端只需带上这个 Token 前来请求数据即可，无需再次带上用户名和密码。使用 Token 的目的：Token的目的是为了减轻服务器的压力，减少频繁的查询数据库，使服务器更加健壮。</li>
<li><strong>cookie与session区别</strong><ul>
<li><strong>安全性</strong>：cookie 数据存放在客户端上，安全性较差，session 数据放在服务器上，安全性相对更高</li>
<li><strong>大小限制</strong>：cookie 有大小限制，单个cookie保存的数据不能超过4K，session无此限制，理论上只与服务器的内存大小有关；</li>
<li><strong>服务器资源消耗</strong>：Session是保存在服务器端上会存在一段时间才会消失，当访问增多，对服务器性能有影响</li>
<li><strong>实现机制</strong>：Session的实现常常依赖于Cookie机制，通过Cookie机制回传SessionID；</li>
</ul>
</li>
<li>Token 是在服务端产生的。如果前端使用用户名&#x2F;密码向服务端请求认证，服务端认证成功，那么在服务端会返回 Token 给前端。前端可以在每次请求的时候带上 Token 证明自己的合法地位 </li>
<li><strong>session与token区别</strong><ul>
<li>session机制存在服务器压力增大，CSRF跨站伪造请求攻击，扩展性不强等问题；</li>
<li>session存储在服务器端，token存储在客户端</li>
<li>token提供认证和授权功能，作为身份认证，token安全性比session好；</li>
<li>session这种会话存储方式方式只适用于客户端代码和服务端代码运行在同一台服务器上，token适用于项目级的前后端分离（前后端代码运行在不同的服务器下）</li>
</ul>
</li>
</ul>
<h1 id="redis-缓存"><a href="#redis-缓存" class="headerlink" title="redis 缓存"></a>redis 缓存</h1><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>将博客浏览量添加到缓存中，开启服务时，首先从数据库中将数据读取并添加到缓存中，以后读取的话就从缓存中读</p>
<p>①在应用启动时把博客的浏览量存储到 redis 中</p>
<p>②更新浏览量时去更新redis中的数据</p>
<p>③每隔10分钟把Redis中的浏览量更新到数据库中</p>
<p>④读取文章浏览量时从redis读取</p>
<h2 id="如何保证缓存与数据库的双写一致性"><a href="#如何保证缓存与数据库的双写一致性" class="headerlink" title="如何保证缓存与数据库的双写一致性"></a>如何保证缓存与数据库的双写一致性</h2><ul>
<li>读的时候，先读缓存，缓存没有的话，就读数据库，然后取出数据后放入缓存，同时返回响应。</li>
<li>更新的时候，先更新数据库，然后再删除缓存。</li>
</ul>
<h1 id="SpringSecurity"><a href="#SpringSecurity" class="headerlink" title="SpringSecurity"></a>SpringSecurity</h1><p>用户认证指的是：验证某个用户是否为系统中的合法主体，也就是说<strong>用户能否访问该系统</strong>。<strong>用户认证一般要求用户提供用户名和密码</strong>。系统通过校验用户名和密码来完成认证过程。<strong>通俗点说就是系统认为用户是否能登录</strong></p>
<p>用户授权指的是<strong>验证某个用户是否有权限执行某个操作</strong>。在一个系统中，不同用户所具有的权限是不同的。比如对一个文件来说，有的用户只能进行读取，而有的用户可以进行修改。一般来说，系统会为不同的用户分配不同的角色，而每个角色则对应一系列的权限。<strong>通俗点讲就是系统判断用户是否有权限去做某些事情。</strong></p>
<p>springsecurity 底层实现为一条过滤器链，就是用户请求进来，判断有没有请求的权限，抛出异常，重定向跳转。</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20211215094003288.png" alt="image-20211215094003288"></p>
<h2 id="SpringSecurity-完整流程"><a href="#SpringSecurity-完整流程" class="headerlink" title="SpringSecurity 完整流程"></a>SpringSecurity 完整流程</h2><p>SpringSecurity 的原理其实就是一个过滤器链，内部包含了提供各种功能的过滤器。这里我们可以看看入门案例中的过滤器。</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20211214144425527.png" alt="image-20211214144425527"></p>
<p>图中只展示了核心过滤器，其它的非核心过滤器并没有在图中展示。</p>
<p><strong>UsernamePasswordAuthenticationFilter</strong>：负责处理我们在登陆页面填写了用户名密码后的登陆请求。入门案例的认证工作主要有它负责。</p>
<p><strong>ExceptionTranslationFilter：</strong>处理过滤器链中抛出的任何 AccessDeniedException 和 AuthenticationException 。</p>
<p><strong>FilterSecurityInterceptor：</strong>负责权限校验的过滤器。</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20211214151515385.png" alt="image-20211214151515385"></p>
<p><strong>登录</strong></p>
<p>​	①自定义登录接口</p>
<p>​				调用 ProviderManager 的方法进行认证 如果认证通过生成 jwt</p>
<p>​				把用户信息存入redis 中</p>
<p>​	②自定义 UserDetailsService </p>
<p>​				在这个实现类中去查询数据库</p>
<p>​    ③因为 UserDetailsService 方法的返回值是 UserDetails 类型，所以需要定义一个类，实现该接口，把用户信息封装在其中。</p>
<p>​	④使用 SpringSecurity 为我们提供的 BCryptPasswordEncode 来进行密码校验</p>
<p><strong>校验</strong></p>
<p>​	①定义 Jwt 认证过滤器</p>
<p>​				获取 token</p>
<p>​				解析 token 获取其中的 userid</p>
<p>​				从 redis 中获取用户信息</p>
<p>​				存入 SecurityContextHolder</p>
<h2 id="自定义失败处理"><a href="#自定义失败处理" class="headerlink" title="自定义失败处理"></a>自定义失败处理</h2><p>如果是认证过程中出现的异常会被封装成 AuthenticationException 然后调用 <strong>AuthenticationEntryPoint</strong> 对象的方法去进行异常处理。</p>
<p>如果是授权过程中出现的异常会被封装成 AccessDeniedException 然后调用<strong>AccessDeniedHandler</strong>对象的方法去进行异常处理。</p>
<p>所以如果我们需要自定义异常处理，我们只需要自定义AuthenticationEntryPoint和AccessDeniedHandler然后配置给SpringSecurity即可。</p>
<h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><p><strong>ThreadPoolExecutor</strong></p>
<p><strong>可重用线程</strong>(消费者：不断获取任务来执行)+<strong>阻塞队列</strong>(生产者消费者模式下平衡速度差异的组件)+<strong>main</strong>(生产者：源源不断生成任务)</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/1649578294816-7de57308-6d74-48e7-9d16-c33c5aabecbb.png" alt="img"></p>
<ul>
<li>corePoolSize 核心线程数目 (最多保留的线程数) </li>
<li>maximumPoolSize 最大线程数目 </li>
<li>keepAliveTime 生存时间 - 针对救急线程 </li>
<li>unit 时间单位 - 针对救急线程 </li>
<li>workQueue 阻塞队列 </li>
<li>threadFactory 线程工厂 - 可以为线程创建时起个好名字 </li>
<li>handler 拒绝策略</li>
</ul>
<p><strong>拒绝策略</strong></p>
<pre><code>// 1) 死等
// 2) 带超时等待
// 3) 让调用者放弃任务执行 DiscardPolicy 放弃本次任务
// 4) 让调用者抛出异常 AbortPolicy 让调用者抛出 RejectedExecutionException 异常，这是默认策略
// 5) 让调用者自己执行任务 CallerRunsPolicy 让调用者运行任务 
DiscardOldestPolicy 放弃队列中最早的任务，本任务取而代之 
</code></pre>
<h1 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h1><p><strong>进程</strong></p>
<ul>
<li>程序由指令和数据组成，但这些指令要运行，数据要读写，就必须将指令加载至 CPU，数据加载至内存。在指令运行过程中还需要用到磁盘、网络等设备。进程就是用来加载指令、管理内存、管理 IO 的</li>
<li>当一个程序被运行，从磁盘加载这个程序的代码至内存，这时就开启了一个进程。</li>
<li>进程就可以视为程序的一个实例。</li>
</ul>
<p><strong>线程</strong></p>
<ul>
<li>一个进程之内可以分为一到多个线程。</li>
<li>一个线程就是一个指令流，将指令流中的一条条指令以一定的顺序交给 CPU 执行</li>
<li>Java 中，线程作为最小调度单位，进程作为资源分配的最小单位。</li>
</ul>
<h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><p>在并发环境下，各进程因竞争资源而造成的一种互相等待对方手里的资源，导致各进程都阻塞，都无法向前推进的现象，就是“死锁”发生后若无外力干涉，这些进程都将无法向前推进。</p>
<h2 id="死锁产生的必要条件"><a href="#死锁产生的必要条件" class="headerlink" title="死锁产生的必要条件"></a>死锁产生的必要条件</h2><p>产生死锁必须同时满足以下四个条件，若有一个不满足，死锁就不会发生</p>
<ol>
<li><strong>互斥条件</strong>：对互斥使用的资源的争夺才会导致死锁</li>
<li><strong>不剥夺条件</strong>：进程获得的资源在未使用完之前，<strong>不能由其他进程强行夺走，只能主动释放</strong></li>
<li><strong>请求和保持条件</strong>：进程<strong>已经保持了至少一个资源</strong>，但又提出了新的资源<strong>请求</strong>，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源<strong>保持</strong>不放</li>
<li><strong>循环等待条件</strong>：存在一种进程<strong>资源的循环等待链</strong>，链中的每一个进程已获得的资源同时被下一个进程所请求</li>
</ol>
<h2 id="死锁的处理策略"><a href="#死锁的处理策略" class="headerlink" title="死锁的处理策略"></a>死锁的处理策略</h2><ol>
<li><strong>预防死锁</strong>：破坏死锁产生的四个必要条件中的一个或几个</li>
<li><strong>避免死锁</strong>：用某种方法防止系统进入不安全状态，从而避免死锁</li>
<li><strong>死锁的检测和解除</strong>：允许死锁的发生，操作系统检测出死锁后，会采取措施解除死锁</li>
</ol>
<h1 id="Monitor"><a href="#Monitor" class="headerlink" title="Monitor"></a>Monitor</h1><h2 id="Java-对象头"><a href="#Java-对象头" class="headerlink" title="Java 对象头"></a>Java 对象头</h2><p>以 32 位虚拟机为例</p>
<p>普通对象的对象头结构如下，其中，<strong>Mark Word</strong> 主要用来存储对象自身的运行时数据；<strong>Klass Word</strong> 为指针，指向对应的 Class 对象。</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/1649081202993-bd236bb4-a971-4f15-87a1-f2a058958f3c.png" alt="image.png"></p>
<p>数组对象：相对于普通对象多了记录数组长度</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/1649081220496-eb45aee3-9713-43ce-a77e-9967987344cd.png" alt="image.png"></p>
<h3 id="Mark-Word-结构"><a href="#Mark-Word-结构" class="headerlink" title="Mark Word 结构"></a>Mark Word 结构</h3><p>不同对象状态下结构和含义也不同</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/1649081240952-98e4241a-9de3-4379-8e72-6267a688f801.png" alt="image.png"></p>
<p>64 位虚拟机 Mark Word</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/1649081263135-b6219f01-fda8-4ba0-9444-000700649870.png" alt="image.png"></p>
<p>所以一个对象的结构如下：</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/202206261904168.png" alt="1583678624634"></p>
<h2 id="原理之-Monitor-锁"><a href="#原理之-Monitor-锁" class="headerlink" title="原理之 Monitor (锁)"></a>原理之 Monitor (锁)</h2><p>Monitor 被翻译为<strong>监视器</strong>或者说<strong>管程</strong></p>
<p>每个 java 对象都可以关联一个 Monitor 对象，如果使用 <code>synchronized</code> 给对象上锁（重量级）之后，该对象头的 Mark Word 中就被设置为指向 Monitor 对象的指针。</p>
<h3 id="Monitor-结构"><a href="#Monitor-结构" class="headerlink" title="Monitor 结构"></a>Monitor 结构</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/202206261904369.png" alt="1583652360228"></p>
<ul>
<li>刚开始时 Monitor 中的 Owner为 null</li>
<li>当 Thread-2 执行 synchronized(obj){} 代码时就会将 Monitor 的所有者 Owner 设置为 Thread-2，上锁成功，Monitor 中同一时刻只能有一个Owner</li>
<li>当 Thread-2 占据锁时，如果线程 Thread-3，Thread-4 也来执行 synchronized(obj){} 代码，就会进入EntryList中变成 BLOCKED 状态</li>
<li>Thread-2 执行完同步代码块的内容，然后唤醒 EntryList 中等待的线程来竞争锁，竞争时是<strong>非公平</strong>的</li>
<li>图中 WaitSet 中的 Thread-0，Thread-1 是之前获得过锁，但条件不满足进入 WAITING 状态的线程，后面讲 wait-notify 时会分析</li>
</ul>
<blockquote>
<p>注意：</p>
<ul>
<li>synchronized 必须是进入同一个对象的 monitor 才有上述的效果</li>
<li>不加 synchronized 的对象不会关联监视器，不遵从以上规则</li>
</ul>
</blockquote>
<h2 id="原理之-synchronized-进阶-锁升级"><a href="#原理之-synchronized-进阶-锁升级" class="headerlink" title="原理之 synchronized 进阶 (锁升级)"></a>原理之 synchronized 进阶 (锁升级)</h2><h3 id="不涉及-Monitor-的-轻量级锁"><a href="#不涉及-Monitor-的-轻量级锁" class="headerlink" title="(不涉及 Monitor 的)轻量级锁"></a>(不涉及 Monitor 的)轻量级锁</h3><ul>
<li><p>轻量级锁的使用场景是：如果一个对象虽然有多个线程要对它进行加锁，但是加锁的时间是错开的（也就是没有人可以竞争的），那么可以使用轻量级锁来进行优化。</p>
</li>
<li><p>轻量级锁对使用者是透明的，即语法仍然是<code>synchronized</code></p>
</li>
<li><p>每次指向到 synchronized 代码块时，都会创建<strong>锁记录（Lock Record）对象</strong>，每个线程都会包括一个锁记录的结构，锁记录内部可以储存对象的 <strong>Mark Word 和对象引用 reference</strong></p>
</li>
</ul>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/202206261904048.png" alt="1583755737580"></p>
<ul>
<li>让锁记录中的 Object reference 指向对象，并且尝试用 cas(compare and sweep) 替换 Object 对象的 Mark Word ，将 Mark Word 的值存入锁记录中</li>
</ul>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/202206261904627.png" alt="1583755888236"></p>
<ul>
<li>如果 cas 替换成功，那么对象的对象头储存的就是<strong>锁记录的地址和状态00</strong>，表示由该线程给对象加锁，如下所示</li>
</ul>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/202206261904394.png" alt="1583755964276"></p>
<ul>
<li>如果 cas 失败，有两种情况<ul>
<li>如果是其它线程已经持有了该 Object 的轻量级锁，那么表示有竞争，将进入锁膨胀阶段</li>
<li>如果是自己的线程已经执行了 synchronized 进行加锁，那么再添加一条 Lock Record 作为<strong>重入的计数</strong></li>
</ul>
</li>
</ul>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/202206261904108.png" alt="1583756190177"></p>
<ul>
<li>当线程退出 synchronized 代码块的时候，如果获取的是取值为 null 的锁记录 ，表示有重入，这时重置锁记录，表示重入计数<strong>减一</strong></li>
</ul>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/202206261904255.png" alt="1583756357835"></p>
<ul>
<li>当线程退出 synchronized 代码块的时候，如果获取的锁记录取值不为 null，那么使用 cas 将 Mark Word 的值恢复给对象<ul>
<li>成功，则解锁成功</li>
<li>失败，则说明轻量级锁进行了锁膨胀或已经升级为重量级锁，进入重量级锁解锁流程</li>
</ul>
</li>
</ul>
<h3 id="轻量级-锁膨胀-为重量级锁"><a href="#轻量级-锁膨胀-为重量级锁" class="headerlink" title="(轻量级)锁膨胀(为重量级锁)"></a>(轻量级)锁膨胀(为重量级锁)</h3><p>如果在尝试加轻量级锁的过程中，cas 操作无法成功，这是有一种情况就是其它线程已经为这个对象加上了轻量级锁，这是就要进行锁膨胀，将轻量级锁变成重量级锁。</p>
<ul>
<li>当 Thread-1 进行轻量级加锁时，Thread-0 已经对该对象加了轻量级锁</li>
</ul>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/202206261904499.png" alt="1583757433691"></p>
<ul>
<li>这时 Thread-1 加轻量级锁失败，进入锁膨胀流程<ul>
<li>即为对象申请 Monitor 锁，让 Object 指向重量级锁地址</li>
<li>然后自己进入Monitor 的 EntryList 变成 BLOCKED 状态</li>
</ul>
</li>
</ul>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/202206261904936.png" alt="1583757586447"></p>
<ul>
<li>当Thread-0 退出 synchronized 同步块时，使用 cas 将 Mark Word 的值恢复给对象头，失败，那么会进入重量级锁的解锁过程，即按照 Monitor 的地址找到 Monitor 对象，将 Owner 设置为 null，唤醒 EntryList 中的 Thread-1 线程</li>
</ul>
<h3 id="比轻量级锁更轻的-偏向锁"><a href="#比轻量级锁更轻的-偏向锁" class="headerlink" title="(比轻量级锁更轻的)偏向锁"></a>(比轻量级锁更轻的)偏向锁</h3><ul>
<li>轻量级锁在没有竞争时（就自己这个线程），每次重入仍然需要执行 CAS 操作。 </li>
<li>Java 6 中引入了偏向锁来做进一步优化：只有第一次使用 CAS 将<strong>线程 ID 设置到对象的 Mark Word 头</strong>，之后发现这个线程 ID 是自己的就表示没有竞争，不用重新 CAS。以后只要不发生竞争，这个对象就归该线程所有</li>
</ul>
<blockquote>
<p>这里的线程 id 是操作系统赋予的 id 和 Thread 的 id 是不同的</p>
</blockquote>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220815123841079.png" alt="image-20220815123841079"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/1649161246692-d1f2d011-3f7c-443f-802c-608c025e9699.png" alt="image.png"></p>
<h4 id="偏向状态"><a href="#偏向状态" class="headerlink" title="偏向状态"></a>偏向状态</h4><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/202206261905389.png" alt="1583762169169"></p>
<p>一个对象的创建过程</p>
<ul>
<li>如果开启了偏向锁（默认是开启的），那么对象刚创建之后，Mark Word 值为 0x05，即最后三位的值<strong>101</strong>，并且这时它的 Thread，epoch，age都是0</li>
<li>偏向锁默认是延迟的，不会在程序启动的时候立刻生效，如果想避免延迟，可以添加虚拟机参数来禁用延迟：-<code>XX:BiasedLockingStartupDelay=0</code>来<strong>禁用延迟</strong></li>
<li>如果没有开启偏向锁，那么对象创建后，markword 值为 0x01 即最后 3 位为 <strong>001</strong>，这时它的 hashcode、age 都为 0，第一次用到 hashcode 时才会赋值</li>
<li>注意：处于偏向锁的对象解锁后，线程 id 仍存储于对象头中</li>
</ul>
<h1 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h1><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220730212626643.png" alt="image-20220730212626643"></p>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">Yang Shiyu</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://yangshiyu52.github.io/2022/09/23/mian-shi-zhi-zhong-xing/">https://yangshiyu52.github.io/2022/09/23/mian-shi-zhi-zhong-xing/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">Yang Shiyu</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/%E4%B8%AD%E5%85%B4/">
                                    <span class="chip bg-color">中兴</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2022/09/23/xiang-mu-bo-ke-guan-li-xi-tong/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/23.jpg" class="responsive-img" alt="博客管理系统">
                        
                        <span class="card-title">博客管理系统</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2022-09-23
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E9%A1%B9%E7%9B%AE/" class="post-category">
                                    项目
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/java/">
                        <span class="chip bg-color">java</span>
                    </a>
                    
                    <a href="/tags/%E9%A1%B9%E7%9B%AE/">
                        <span class="chip bg-color">项目</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2022/09/04/shu-ju-jie-gou-yu-suan-fa-shu/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/1.jpg" class="responsive-img" alt="树">
                        
                        <span class="card-title">树</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2022-09-04
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" class="post-category">
                                    数据结构与算法
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
    <div class="container row center-align" style="margin-bottom: 15px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2021-2022</span>
            
            <span id="year">2021</span>
            <a href="/about" target="_blank">Yang Shiyu</a>
            
            <br>
            
            &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                class="white-color">521.7k</span>&nbsp;字
            
            
            
            
            
            
            <span id="busuanzi_container_site_pv">
                |&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv"
                    class="white-color"></span>&nbsp;次
            </span>
            
            
            <span id="busuanzi_container_site_uv">
                |&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv"
                    class="white-color"></span>&nbsp;人
            </span>
            
            <br>
            
            <span id="sitetime">载入运行时间...</span>
            <script>
                function siteTime() {
                    var seconds = 1000;
                    var minutes = seconds * 60;
                    var hours = minutes * 60;
                    var days = hours * 24;
                    var years = days * 365;
                    var today = new Date();
                    var startYear = "2021";
                    var startMonth = "1";
                    var startDate = "20";
                    var startHour = "0";
                    var startMinute = "0";
                    var startSecond = "0";
                    var todayYear = today.getFullYear();
                    var todayMonth = today.getMonth() + 1;
                    var todayDate = today.getDate();
                    var todayHour = today.getHours();
                    var todayMinute = today.getMinutes();
                    var todaySecond = today.getSeconds();
                    var t1 = Date.UTC(startYear, startMonth, startDate, startHour, startMinute, startSecond);
                    var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
                    var diff = t2 - t1;
                    var diffYears = Math.floor(diff / years);
                    var diffDays = Math.floor((diff / days) - diffYears * 365);
                    var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);
                    var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) /
                        minutes);
                    var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours -
                        diffMinutes * minutes) / seconds);
                    if (startYear == todayYear) {
                        document.getElementById("year").innerHTML = todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffDays + " 天 " + diffHours +
                            " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    } else {
                        document.getElementById("year").innerHTML = startYear + " - " + todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffYears + " 年 " + diffDays +
                            " 天 " + diffHours + " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    }
                }
                setInterval(siteTime, 1000);
            </script>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/yangshiyu52" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:706425658@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=706425658" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 706425658" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

	
    
    <script type="text/javascript" color="0,0,255"
        pointColor="0,0,255" opacity='0.7'
        zIndex="-1" count="99"
        src="/libs/background/canvas-nest.js"></script>
    

    
    
    <script type="text/javascript" size="150" alpha='0.6'
        zIndex="-1" src="/libs/background/ribbon-refresh.min.js" async="async"></script>
    

    
    <script type="text/javascript" src="/libs/background/ribbon-dynamic.js" async="async"></script>
    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
