<!DOCTYPE html>


<html lang="en">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title>面试之数据库 |  Healer</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    <link rel="alternate" href="/atom.xml" title="Healer" type="application/atom+xml">
</head>
  </html>
</html>


<body>
  <div id="app">
    
      
      <canvas width="1777" height="841"
        style="position: fixed; left: 0px; top: 0px; z-index: 99999; pointer-events: none;"></canvas>
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-面试之数据库"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
	
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  面试之数据库
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/09/02/%E9%9D%A2%E8%AF%95%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%BA%93/" class="article-date">
  <time datetime="2022-09-02T07:13:58.481Z" itemprop="datePublished">2022-09-02</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a>
  </div>
  
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> Word count:</span>
            <span class="post-count">9.7k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> Reading time≈</span>
            <span class="post-count">35 min</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="原理和SQL"><a href="#原理和SQL" class="headerlink" title="原理和SQL"></a>原理和SQL</h1><h2 id="事务及其基本特性"><a href="#事务及其基本特性" class="headerlink" title="事务及其基本特性"></a>事务及其基本特性</h2><p>事务就是用户定义的一系列数据库操作，这些操作可以视为一个完整的逻辑处理工作单元，要么全部执行，要么全部不执行，是不可分割的工作单元。事务指的是满足 ACID 特性的一组操作，可以通过 Commit 提交一个事务，也可以使用 Rollback 进行回滚。</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/185b9c49-4c13-4241-a848-fbff85c03a64.png" alt="image"></p>
<ul>
<li>事务基本特性 <strong>ACID</strong><ul>
<li><strong>A原子性(atomicity)</strong> 指的是一个事务中的操作要么全部成功，要么全部失败。</li>
<li><strong>C一致性(consistency)</strong> 指的是数据库总是从一个一致性的状态转换到另外一个一致性的状态。比如 A 转账给 B 100 块钱，假设中间 sql 执行过程中系统崩溃 A 也不会损失 100 块，因为事务没有提交，修改也就不会保存到数据库。事务执行前后的状态(数据)保持一致</li>
<li><strong>I隔离性(isolation)</strong> 指的是一个事务的修改在最终提交前，对其他事务是不可见的。一个事务的执行不可以被其他事务干扰。</li>
<li><strong>D持久性(durability)</strong> 指的是一旦事务提交，所做的修改就会永久保存到数据库中。</li>
</ul>
</li>
</ul>
<h2 id="数据库中并发一致性问题"><a href="#数据库中并发一致性问题" class="headerlink" title="数据库中并发一致性问题"></a>数据库中并发一致性问题</h2><p>在并发环境下，事务的隔离性很难保证，因此会出现很多并发一致性问题。</p>
<ul>
<li><strong>丢失修改</strong></li>
</ul>
<p>T1 和 T2 两个事务都对一个数据进行修改，T1 先修改，T2 随后修改，T2 的修改覆盖了 T1 的修改。</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/88ff46b3-028a-4dbb-a572-1f062b8b96d3.png" alt="image"></p>
<ul>
<li><strong>读脏数据</strong></li>
</ul>
<p>T1 修改一个数据，T2 随后读取这个数据。如果 T1 撤销了这次修改，那么 T2 读取的数据是脏数据。</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/dd782132-d830-4c55-9884-cfac0a541b8e.png" alt="image"></p>
<ul>
<li><strong>不可重复读</strong></li>
</ul>
<p>T2 读取一个数据，T1 对该数据做了修改。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同。</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/c8d18ca9-0b09-441a-9a0c-fb063630d708.png" alt="image"></p>
<ul>
<li><strong>幻读</strong></li>
</ul>
<p>T1 读取某个范围的数据，T2 在这个范围内插入新的数据，T1 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/72fe492e-f1cb-4cfc-92f8-412fb3ae6fec.png" alt="image"></p>
<h2 id="事务的隔离等级"><a href="#事务的隔离等级" class="headerlink" title="事务的隔离等级"></a>事务的隔离等级</h2><ul>
<li><strong>读未提交(READ UNCOMMITTED)</strong> 事务中的修改，即使没有提交，对其它事务也是可见的。</li>
<li><strong>读已提交(READ COMMITTED)</strong> 一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。</li>
<li><strong>可重复读(REPEATABLE READ)</strong> 保证在同一个事务中多次读取同样数据的结果是一样的。</li>
<li><strong>可串行化(SERIALIZABLE)</strong> 提供严格的事务隔离，它要求事务序列化执行，事务只能一个接着一个地执行，但不能并发执行，如果仅仅通过“行级锁”是无法实现序列化的，必须通过其他机制保证新插入的数据不会被执行查询操作的事务访问到。</li>
</ul>
<table>
<thead>
<tr>
<th align="center">隔离级别</th>
<th align="center">脏读</th>
<th align="center">不可重复读</th>
<th align="center">幻读</th>
</tr>
</thead>
<tbody><tr>
<td align="center">读未提交</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">读已提交</td>
<td align="center">×</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">可重复读</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">可串行化</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">×</td>
</tr>
</tbody></table>
<h2 id="ACID-靠什么保证"><a href="#ACID-靠什么保证" class="headerlink" title="ACID 靠什么保证"></a>ACID 靠什么保证</h2><ul>
<li><strong>A原子性(atomicity)</strong> 由 <strong>undo log</strong> 日志保证，它记录了需要回滚的日志信息，事务回滚时撤销已经执行成功的 sql</li>
<li><strong>C一致性(consistency)</strong> 一般由<strong>代码层面</strong>来保证</li>
<li><strong>I隔离性(isolation)</strong> 由 <strong>MVCC</strong> 来保证</li>
<li><strong>D持久性(durability)</strong> 由<strong>内存+ redo log</strong> 来保证，mysql 修改数据同时在内存和 redo log 记录这次操作，事务提交的时候通过redo log 刷盘，宕机的时候可以从 redo log 恢复</li>
</ul>
<h2 id="SQL-优化的实践经验"><a href="#SQL-优化的实践经验" class="headerlink" title="SQL 优化的实践经验"></a>SQL 优化的实践经验</h2><ol>
<li><p>对查询进行优化，要尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。</p>
</li>
<li><p>应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id from t where num is null</span><br></pre></td></tr></table></figure>

<p>最好不要给数据库留 NULL，尽可能的使用 NOT NULL填充数据库.</p>
<p>备注、描述、评论之类的可以设置为 NULL，其他的，最好不要使用NULL。</p>
<p>不要以为 NULL 不需要空间，比如：char(100) 型，在字段建立时，空间就固定了， 不管是否插入值（NULL也包含在内），都是占用 100个字符的空间的，如果是varchar这样的变长字段， null 不占用空间。</p>
<p>可以在num上设置默认值0，确保表中num列没有null值，然后这样查询：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id from t where num = 0</span><br></pre></td></tr></table></figure>
</li>
<li><p>应尽量避免在 where 子句中使用 !&#x3D; 或 &lt; &gt; 操作符，否则将引擎放弃使用索引而进行全表扫描。</p>
</li>
<li><p>应尽量避免在 where 子句中使用 or 来连接条件，如果一个字段有索引，一个字段没有索引，将导致引擎放弃使用索引而进行全表扫描，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id from t where num=10 or Name = &#x27;admin&#x27;</span><br></pre></td></tr></table></figure>

<p>可以这样查询：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select id from t where num = 10</span><br><span class="line">union all</span><br><span class="line">select id from t where Name = &#x27;admin&#x27;</span><br></pre></td></tr></table></figure>
</li>
<li><p>in 和 not in 也要慎用，否则会导致全表扫描，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id from t where num in(1,2,3)</span><br></pre></td></tr></table></figure>

<p>对于连续的数值，能用 between 就不要用 in 了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id from t where num between 1 and 3</span><br></pre></td></tr></table></figure>

<p>很多时候用 exists 代替 in 是一个好的选择：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select num from a where num in(select num from b)  </span><br></pre></td></tr></table></figure>

<p>用下面的语句替换：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select num from a where exists(select 1 from b where num=a.num)</span><br></pre></td></tr></table></figure>
</li>
<li><p>下面的查询也将导致全表扫描：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id from t where name like ‘%abc%’</span><br></pre></td></tr></table></figure>

<p>若要提高效率，可以考虑全文检索。</p>
</li>
<li><p>如果在 where 子句中使用参数，也会导致全表扫描。因为 SQL 只有在运行时才会解析局部变量，但优化程序不能将访问计划的选择推迟到运行时；它必须在编译时进行选择。然 而，如果在编译时建立访问计划，变量的值还是未知的，因而无法作为索引选择的输入项。如下面语句将进行全表扫描：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id from t where num = @num</span><br></pre></td></tr></table></figure>

<p>可以改为强制查询使用索引：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id from t with(index(索引名)) where num = @num</span><br></pre></td></tr></table></figure>

<p>应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id from t where num/2 = 100</span><br></pre></td></tr></table></figure>

<p>应改为:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id from t where num = 100*2</span><br></pre></td></tr></table></figure>
</li>
<li><p>应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select id from t where substring(name,1,3) = ’abc’       -–name以abc开头的id</span><br><span class="line">select id from t where datediff(day,createdate,’2005-11-30′) = 0    -–‘2005-11-30’    --生成的id</span><br></pre></td></tr></table></figure>

<p>应改为:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select id from t where name like &#x27;abc%&#x27;</span><br><span class="line">select id from t where createdate &gt;= &#x27;2005-11-30&#x27; and createdate &lt; &#x27;2005-12-1&#x27;</span><br></pre></td></tr></table></figure>
</li>
<li><p>不要在 where 子句中的“&#x3D;”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。</p>
</li>
<li><p>在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使用，并且应尽可能的让字段顺序与索引顺序相一致。</p>
</li>
<li><p>不要写一些没有意义的查询，如需要生成一个空表结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select col1,col2 into #t from t where 1=0</span><br></pre></td></tr></table></figure>

<p>这类代码不会返回任何结果集，但是会消耗系统资源的，应改成这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create table #t(…)</span><br></pre></td></tr></table></figure>
</li>
<li><p>Update 语句，如果只更改1、2个字段，不要 Update 全部字段，否则频繁调用会引起明显的性能消耗，同时带来大量日志。</p>
</li>
<li><p>对于多张大数据量（这里几百条就算大了）的表 JOIN，要先分页再 JOIN，否则逻辑读会很高，性能很差。</p>
</li>
<li><p>select count(*) from table；这样不带任何条件的 count 会引起全表扫描，并且没有任何业务意义，是一定要杜绝的。</p>
</li>
<li><p>索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数最好不要超过 6 个，若太多则应考虑一些不常使用到的列上建的索引是否有 必要。</p>
</li>
<li><p>应尽可能的避免更新 clustered 索引数据列，因为 clustered 索引数据列的顺序就是表记录的物理存储顺序，一旦该列值改变将导致整个表记录的顺序的调整，会耗费相当大的资源。若应用系统需要频繁更新 clustered 索引数据列，那么需要考虑是否应将该索引建为 clustered 索引。</p>
</li>
<li><p>尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。这是因为引擎在处理查询和连 接时会逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。</p>
</li>
<li><p>尽可能的使用 varchar&#x2F;nvarchar 代替 char&#x2F;nchar ，因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。</p>
</li>
<li><p>任何地方都不要使用 select * from t ，用具体的字段列表代替“*”，不要返回用不到的任何字段。</p>
</li>
<li><p>尽量使用表变量来代替临时表。如果表变量包含大量数据，请注意索引非常有限（只有主键索引）。</p>
</li>
<li><p>避免频繁创建和删除临时表，以减少系统表资源的消耗。临时表并不是不可使用，适当地使用它们可以使某些例程更有效，例如，当需要重复引用大型表或常用表中的某个数据集时。但是，对于一次性事件， 最好使用导出表。</p>
</li>
<li><p>在新建临时表时，如果一次性插入数据量很大，那么可以使用 select into 代替 create table，避免造成大量 log ，以提高速度；如果数据量不大，为了缓和系统表的资源，应先 create table，然后 insert。</p>
</li>
<li><p>如果使用到了临时表，在存储过程的最后务必将所有的临时表显式删除，先 truncate table ，然后 drop table ，这样可以避免系统表的较长时间锁定。</p>
</li>
<li><p>尽量避免使用游标，因为游标的效率较差，如果游标操作的数据超过1万行，那么就应该考虑改写。</p>
</li>
<li><p>使用基于游标的方法或临时表方法之前，应先寻找基于集的解决方案来解决问题，基于集的方法通常更有效。</p>
</li>
<li><p>与临时表一样，游标并不是不可使用。对小型数据集使用 FAST_FORWARD 游标通常要优于其他逐行处理方法，尤其是在必须引用几个表才能获得所需的数据时。在结果集中包括“合计”的例程通常要比使用游标执行的速度快。如果开发时 间允许，基于游标的方法和基于集的方法都可以尝试一下，看哪一种方法的效果更好。</p>
</li>
<li><p>在所有的存储过程和触发器的开始处设置 SET NOCOUNT ON ，在结束时设置 SET NOCOUNT OFF 。无需在执行存储过程和触发器的每个语句后向客户端发送 DONE_IN_PROC 消息。</p>
</li>
<li><p>尽量避免大事务操作，提高系统并发能力。</p>
</li>
<li><p>尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理。</p>
</li>
</ol>
<h2 id="Buffer-Pool、undo-log、redo-log、bin-log"><a href="#Buffer-Pool、undo-log、redo-log、bin-log" class="headerlink" title="Buffer Pool、undo log、redo log、bin log"></a>Buffer Pool、undo log、redo log、bin log</h2><p>由于磁盘随机读写的效率很低，MySQL 为了提供性能，读写不是直接操作的磁盘文件，而是在内存中开辟了一个叫做 <strong>buffer pool</strong> 的缓存区域，更新数据的时候会优先更新到 buffer pool，之后再由 I&#x2F;O 线程写入磁盘。同时为了 InnoDB 为了保证宕机不丢失 buffer pool 中的数据，实现 crash safe，还引入了一个叫做<strong>redo log</strong> 的日志模块。另外还有处于 MySQL Server 层的用于备份磁盘数据的 <strong>bin log</strong>，用于事务回滚和 MVCC 的 <strong>undo log</strong> 等。</p>
<ul>
<li>Buffer Pool 是 MySQL 的一个非常重要的组件，因为针对数据库的增删改操作都是在 Buffer Pool 中完成的</li>
<li>Undo log 记录的是数据操作前的样子</li>
<li>redo log 记录的是数据被操作后的样子（redo log 是 Innodb 存储引擎特有）</li>
<li>bin log 记录的是整个操作记录（这个对于主从复制具有非常重要的意义）</li>
</ul>
<h2 id="从准备更新一条数据到事务的提交的流程描述？"><a href="#从准备更新一条数据到事务的提交的流程描述？" class="headerlink" title="从准备更新一条数据到事务的提交的流程描述？"></a>从准备更新一条数据到事务的提交的流程描述？</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/db-mysql-sql-14.png" alt="img"></p>
<ul>
<li>首先执行器根据 MySQL 的执行计划来查询数据，先是从缓存池中查询数据，如果没有就会去数据库中查询，如果查询到了就将其放到缓存池中</li>
<li>在数据从缓存到缓存池的同时，会写入 undo log 日志文件</li>
<li>更新的动作是在 Buffer Pool 中完成的，同时会将更新后的数据添加到 redo log buffer 中</li>
<li>完成以后就可以提交事务，在提交的同时会做以下三件事<ul>
<li>将 redo log buffer中的数据刷入到 redo log 文件中</li>
<li>将本次操作记录写入到 bin log 文件中</li>
<li>将 bin log 文件名字和更新内容在 bin log 中的位置记录到 redo log 中，同时在 redo log 最后添加 commit 标记</li>
</ul>
</li>
</ul>
<h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><h2 id="myisam-和-innodb"><a href="#myisam-和-innodb" class="headerlink" title="myisam 和 innodb"></a>myisam 和 innodb</h2><p><strong>myisam</strong> 引擎是5.1版本之前的默认引擎，支持全文检索、压缩、空间函数等，但是<strong>不支持事务和行级锁</strong>，所以一般用于有大量查询少量插入的场景来使用，而且myisam <strong>不支持外键</strong>，并且索引和数据是分开存储的。</p>
<p><strong>innodb</strong> 是基于 B+Tree 索引建立的，和 myisam 相反它<strong>支持事务、外键</strong>，并且通过 MVCC 来支持高并发，索引和数据存储在一起。</p>
<h2 id="MySQL-的索引"><a href="#MySQL-的索引" class="headerlink" title="MySQL 的索引"></a>MySQL 的索引</h2><p><strong>索引在什么层面？</strong></p>
<p>首先，索引是在<strong>存储引擎层实现</strong>的，而不是在服务器层实现的，所以不同存储引擎具有不同的索引类型和实现。</p>
<p><strong>有哪些？</strong></p>
<ul>
<li><strong>B+Tree 索引</strong><ul>
<li>是大多数 MySQL 存储引擎的默认索引类型。</li>
</ul>
</li>
<li><strong>哈希索引</strong><ul>
<li>哈希索引能以 O(1) 时间进行查找，但是失去了有序性；</li>
<li>InnoDB 存储引擎有一个特殊的功能叫“自适应哈希索引”，当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找。</li>
</ul>
</li>
<li><strong>全文索引</strong><ul>
<li>MyISAM 存储引擎支持全文索引，用于查找文本中的关键词，而不是直接比较是否相等。查找条件使用 MATCH AGAINST，而不是普通的 WHERE。</li>
<li>全文索引一般使用倒排索引实现，它记录着关键词到其所在文档的映射。</li>
<li>InnoDB 存储引擎在 MySQL 5.6.4 版本中也开始支持全文索引。</li>
</ul>
</li>
<li><strong>空间数据索引</strong><ul>
<li>MyISAM 存储引擎支持空间数据索引(R-Tree)，可以用于地理数据存储。空间数据索引会从所有维度来索引数据，可以有效地使用任意维度来进行组合查询。</li>
</ul>
</li>
</ul>
<h2 id="索引实现-B-树"><a href="#索引实现-B-树" class="headerlink" title="索引实现 B+树"></a>索引实现 B+树</h2><ul>
<li><strong>什么是 B+Tree?</strong></li>
</ul>
<p>B+Tree 是基于 B Tree 和叶子节点顺序访问指针进行实现，它具有 B Tree 的平衡性，并且通过顺序访问指针来提高区间查询的性能。在 B+Tree 中，一个节点中的 key 从左到右非递减排列，如果某个指针的左右相邻 key 分别是 keyi 和 keyi+1，且不为 null，则该指针指向节点的所有 key 大于等于 keyi 且小于等于 keyi+1。</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/061c88c1-572f-424f-b580-9cbce903a3fe.png" alt="img"></p>
<ul>
<li><strong>为什么是 B+Tree</strong>?<ul>
<li>为了减少磁盘读取次数，决定了树的高度不能高，所以必须是先 B-Tree；</li>
<li>以页为单位读取使得三次 I&#x2F;O 就能完全载入一个节点，且相邻的节点也能够被预先载入；所以数据放在叶子节点，本质上是一个 Page 页；</li>
<li>为了支持范围查询以及关联关系， 页中数据需要有序，且页的尾部节点指向下个页的头部；</li>
</ul>
</li>
<li><strong>B+树 索引可分为聚簇索引和非聚簇索引</strong>?</li>
</ul>
<ol>
<li>主索引就是聚簇索引（也称聚集索引，clustered index）</li>
<li>辅助索引（有时也称非聚簇索引或二级索引，secondary index，non-clustered index）。</li>
</ol>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/db-mysql-index-1.png" alt="img"></p>
<p>如上图，<strong>主键索引的叶子节点保存的是真正的数据。而辅助索引叶子节点的数据区保存的是主键索引关键字的值</strong>。</p>
<p>假如要查询 name &#x3D; C 的数据，其搜索过程如下：a) 先在辅助索引中通过 C 查询最后找到主键 id &#x3D; 9； b) 在主键索引中搜索 id 为 9 的数据，最终在主键索引的叶子节点中获取到真正的数据。所以通过辅助索引进行检索，需要检索两次索引。</p>
<p>之所以这样设计，一个原因就是：如果和 MyISAM 一样在主键索引和辅助索引的叶子节点中都存放数据行指针，一旦数据发生迁移，则需要去重新组织维护所有的索引。</p>
<h2 id="覆盖索引和回表"><a href="#覆盖索引和回表" class="headerlink" title="覆盖索引和回表"></a>覆盖索引和回表</h2><p>覆盖索引指的是在一次查询中，如果一个索引包含或者说覆盖所有需要查询的字段的值，我们就称之为覆盖索引，而不再需要回表查询。</p>
<p>而要确定一个查询是否是覆盖索引，我们只需要 explain sql 语句看 Extra 的结果是否是“Using index”即可。</p>
<p>比如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> age<span class="operator">=</span><span class="number">1</span>; <span class="operator">/</span><span class="operator">/</span> 查询的name无法从索引数据获取</span><br><span class="line">explain <span class="keyword">select</span> id, age <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> age<span class="operator">=</span><span class="number">1</span>; <span class="operator">/</span><span class="operator">/</span>可以直接从索引获取</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> s1 <span class="keyword">where</span> id<span class="operator">=</span><span class="number">123</span>;</span><br><span class="line">该 <span class="keyword">sql</span>命中了索引，但未覆盖索引。</span><br><span class="line">利用 id<span class="operator">=</span><span class="number">123</span> 到索引的数据结构中定位到该 id 在硬盘中的位置，或者说再数据表中的位置。</span><br><span class="line">但是我们 <span class="keyword">select</span> 的字段为<span class="operator">*</span>，除了 id 以外还需要其他字段，这就意味着，我们通过索引结构取到 id 还不够，</span><br><span class="line">还需要利用该 id 再去找到该 id 所在行的其他字段值，这是需要时间的，很明显，如果我们只 <span class="keyword">select</span> id，</span><br><span class="line">就减去了这份苦恼，如下</span><br><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> s1 <span class="keyword">where</span> id<span class="operator">=</span><span class="number">123</span>;</span><br><span class="line">这条就是覆盖索引了，命中索引，且从索引的数据结构直接就取到了id在硬盘的地址，速度很快</span><br></pre></td></tr></table></figure>

<p>回表：在 InnoDB 存储引擎下，二级索引查询到的索引列，如果需要查找所有列的数据，则需要到主键索引里面去取出数据。这个过程就称为回表。因为行的数据都是存在主键B+tree的叶子节点里面，二级索引的B+树叶子节点都是存放的(索引列,主键)。</p>
<h2 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h2><ul>
<li><strong>什么是MVCC？</strong></li>
</ul>
<p>MVCC，全称 Multi-Version Concurrency Control，即多版本并发控制。MVCC是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问，在编程语言中实现事务内存。</p>
<p>在 Mysql 的 InnoDB 引擎中就是指在已提交读(READ COMMITTD)和可重复读(REPEATABLE READ)这两种隔离级别下的事务对于 SELECT 操作会访问版本链中的记录的过程。</p>
<p>这就使得别的事务可以修改这条记录，反正每次修改都会在版本链中记录。SELECT 可以去版本链中拿记录，这就实现了<strong>读-写，写-读</strong>的并发执行，提升了系统的性能。 </p>
<ul>
<li><strong>MySQL 的 InnoDB 引擎实现 MVCC 的 3 个基础点</strong></li>
</ul>
<ol>
<li><strong>隐式字段</strong></li>
</ol>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/db-mysql-mvcc-1.png" alt="img"></p>
<p>如上图，DB_ROW_ID 是数据库默认为该行记录生成的唯一隐式主键；DB_TRX_ID 是当前操作该记录的事务 ID； 而 DB_ROLL_PTR 是一个回滚指针，用于配合undo日志，指向上一个旧版本；delete flag 没有展示出来。</p>
<ol start="2">
<li><strong>undo log</strong></li>
</ol>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/db-mysql-mvcc-4.png" alt="img"></p>
<p>从上面，我们就可以看出，不同事务或者相同事务的对同一记录的修改，会导致该记录的 undo log 成为一条记录版本线性表，即链表，undo log 的链首就是最新的旧记录，链尾就是最早的旧记录</p>
<ol start="3">
<li><strong>ReadView</strong></li>
</ol>
<p>已提交读和可重复读的区别就在于它们生成 ReadView 的策略不同。</p>
<p>ReadView 中主要就是有个列表来存储我们系统中当前活跃着的读写事务，也就是begin了还未提交的事务。通过这个列表来判断记录的某个版本是否对当前事务可见。假设当前列表里的事务 id 为[80,100]。</p>
<p>a) 如果你要访问的记录版本的事务 id 为 50，比当前列表最小的 id 80 小，那说明这个事务在之前就提交了，所以对当前活动的事务来说是可访问的。</p>
<p>b) 如果你要访问的记录版本的事务 id 为 90，发现此事务在列表id最大值和最小值之间，那就再判断一下是否在列表内，如果在那就说明此事务还未提交，所以版本不能被访问。如果不在那说明事务已经提交，所以版本可以被访问。</p>
<p>c) 如果你要访问的记录版本的事务 id 为 110，那比事务列表最大 id 100 都大，那说明这个版本是在 ReadView 生成之后才发生的，所以不能被访问。</p>
<p>这些记录都是去 undo log 链里面找的，先找最近记录，如果最近这一条记录事务 id 不符合条件，不可见的话，再去找上一个版本再比较当前事务的 id 和这个版本事务 id 看能不能访问，以此类推直到返回可见的版本或者结束。</p>
<ul>
<li><strong>举个例子</strong> ，在已提交读隔离级别下：</li>
</ul>
<p>比如此时有一个事务 id 为 100 的事务，修改了 name，使得的 name 等于小明 2，但是事务还没提交。则此时的版本链是</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/db-mysql-mvcc-11.jpeg" alt="img"></p>
<p>那此时另一个事务发起了select 语句要查询 id 为1的记录，那此时生成的 ReadView 列表只有[100]。那就去版本链去找了，首先肯定找最近的一条，发现 trx_id 是 100,也就是 name 为小明 2 的那条记录，发现在列表内，所以不能访问。</p>
<p>这时候就通过指针继续找下一条，name 为小明 1 的记录，发现 trx_id 是 60，小于列表中的最小 id,所以可以访问，直接访问结果为小明 1。</p>
<p>那这时候我们把事务 id 为 100 的事务提交了，并且新建了一个事务 id 为 110 也修改 id 为 1 的记录，并且不提交事务</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/db-mysql-mvcc-12.jpeg" alt="img"></p>
<p>这时候版本链就是</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/db-mysql-mvcc-13.jpeg" alt="img"></p>
<p>这时候之前那个 select 事务又执行了一次查询,要查询 id 为 1 的记录。</p>
<p><strong>已提交读隔离级别下的事务在每次查询的开始都会生成一个独立的 ReadView,而可重复读隔离级别则在第一次读的时候生成一个 ReadView，之后的读都复用之前的 ReadView</strong>。</p>
<ol>
<li>如果你是已提交读隔离级别，这时候你会重新一个 ReadView，那你的活动事务列表中的值就变了，变成了[110]。按照上的说法，你去版本链通过 trx_id 对比查找到合适的结果就是小明 2。</li>
<li>如果你是可重复读隔离级别，这时候你的 ReadView 还是第一次 select 时候生成的 ReadView，也就是列表的值还是[100]。所以 select 的结果是小明1。所以第二次 select 结果和第一次一样，所以叫可重复读！</li>
</ol>
<p>这就是 Mysql 的 MVCC，通过版本链，实现多版本，可并发读-写，写-读。通过 ReadView 生成策略的不同实现不同的隔离级别。</p>
<h2 id="MySQL-锁的类型"><a href="#MySQL-锁的类型" class="headerlink" title="MySQL 锁的类型"></a>MySQL 锁的类型</h2><p><strong>说两个维度</strong>：</p>
<ul>
<li><p>共享锁(简称S锁)和排他锁(简称X锁)</p>
<ul>
<li><strong>读锁</strong>是共享的，可以通过lock in share mode实现，这时候只能读不能写。</li>
<li><strong>写锁</strong>是排他的，它会阻塞其他的写锁和读锁。从颗粒度来区分，可以分为表锁和行锁两种。</li>
</ul>
</li>
<li><p>表锁和行锁</p>
<ul>
<li><p><strong>表锁</strong>会锁定整张表并且阻塞其他用户对该表的所有读写操作，比如alter修改表结构的时候会锁表。</p>
</li>
<li><p>行锁</p>
<p>又可以分为乐观锁和悲观锁</p>
<ul>
<li>悲观锁可以通过for update实现</li>
<li>乐观锁则通过版本号实现。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>两个维度结合来看</strong>：</p>
<ul>
<li>共享锁(行锁):Shared Locks<ul>
<li>读锁(s锁),多个事务对于同一数据可以共享访问,不能操作修改</li>
<li>使用方法:<ul>
<li>加锁:SELECT * FROM table WHERE id&#x3D;1 LOCK IN SHARE MODE</li>
<li>释锁:COMMIT&#x2F;ROLLBACK</li>
</ul>
</li>
</ul>
</li>
<li>排他锁（行锁）：Exclusive Locks<ul>
<li>写锁(X锁)，互斥锁&#x2F;独占锁,事务获取了一个数据的X锁，其他事务就不能再获取该行的读锁和写锁（S锁、X锁），只有获取了该排他锁的事务是可以对数据行进行读取和修改</li>
<li>使用方法:<ul>
<li>DELETE&#x2F; UPDATE&#x2F; INSERT – 加锁</li>
<li>SELECT * FROM table WHERE … FOR UPDATE – 加锁</li>
<li>COMMIT&#x2F;ROLLBACK – 释锁</li>
</ul>
</li>
</ul>
</li>
<li>意向共享锁(IS)<ul>
<li>一个数据行加共享锁前必须先取得该表的IS锁，意向共享锁之间是可以相互兼容的 意向排它锁(IX) 一个数据行加排他锁前必须先取得该表的IX锁，意向排它锁之间是可以相互兼容的 意向锁(IS、IX)是InnoDB引擎操作数据之前自动加的，不需要用户干预; 意义： 当事务操作需要锁表时，只需判断意向锁是否存在，存在时则可快速返回该表不能启用表锁</li>
<li>意向共享锁(IS锁)（表锁）：Intention Shared Locks<ul>
<li>表示事务准备给数据行加入共享锁，也就是说一个数据行加共享锁 前必须先取得该表的IS锁。</li>
</ul>
</li>
<li>意向排它锁(IX锁)（表锁）：Intention Exclusive Locks<ul>
<li>表示事务准备给数据行加入排他锁，说明事务在一个数据行加排他 锁前必须先取得该表的IX锁。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h2><p>首先分库分表分为垂直和水平两个方式，一般来说我们拆分的顺序是先垂直后水平。</p>
<ul>
<li><strong>垂直分库</strong></li>
</ul>
<p>基于现在微服务拆分来说，都是已经做到了垂直分库了</p>
<ul>
<li><strong>垂直分表</strong></li>
</ul>
<p>垂直切分是将一张表按列切分成多个表，通常是按照列的关系密集程度进行切分，也可以利用垂直切分将经常被使用的列和不经常被使用的列切分到不同的表中。</p>
<p>在数据库的层面使用垂直切分将按数据库中表的密集程度部署到不同的库中，例如将原来的电商数据库垂直切分成商品数据库、用户数据库等。</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/e130e5b8-b19a-4f1e-b860-223040525cf6.jpg" alt="img"></p>
<ul>
<li><strong>水平分表</strong></li>
</ul>
<p>首先根据业务场景来决定使用什么字段作为分表字段(sharding_key)，比如我们现在日订单1000万，我们大部分的场景来源于C端，我们可以用user_id作为sharding_key，数据查询支持到最近3个月的订单，超过3个月的做归档处理，那么3个月的数据量就是9亿，可以分1024张表，那么每张表的数据大概就在100万左右。</p>
<p>比如用户id为100，那我们都经过hash(100)，然后对1024取模，就可以落到对应的表上了。</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/63c2909f-0c5f-496f-9fe5-ee9176b31aba.jpg" alt="img"></p>
<h2 id="分表后的ID怎么保证唯一性"><a href="#分表后的ID怎么保证唯一性" class="headerlink" title="分表后的ID怎么保证唯一性"></a>分表后的ID怎么保证唯一性</h2><p>因为我们主键默认都是自增的，那么分表之后的主键在不同表就肯定会有冲突了。有几个办法考虑：</p>
<ul>
<li>设定步长，比如1-1024张表我们分别设定1-1024的基础步长，这样主键落到不同的表就不会冲突了。</li>
<li>分布式ID，自己实现一套分布式ID生成算法或者使用开源的比如雪花算法这种</li>
<li>分表后不使用主键作为查询依据，而是每张表单独新增一个字段作为唯一主键使用，比如订单表订单号是唯一的，不管最终落在哪张表都基于订单号作为查询依据，更新也一样。</li>
</ul>
<h2 id="分表后非sharding-key的查询怎么处理"><a href="#分表后非sharding-key的查询怎么处理" class="headerlink" title="分表后非sharding_key的查询怎么处理"></a>分表后非sharding_key的查询怎么处理</h2><ul>
<li>可以做一个mapping表，比如这时候商家要查询订单列表怎么办呢？不带user_id查询的话你总不能扫全表吧？所以我们可以做一个映射关系表，保存商家和用户的关系，查询的时候先通过商家查询到用户列表，再通过user_id去查询。</li>
<li>大宽表，一般而言，商户端对数据实时性要求并不是很高，比如查询订单列表，可以把订单表同步到离线（实时）数仓，再基于数仓去做成一张宽表，再基于其他如es提供查询服务。</li>
<li>数据量不是很大的话，比如后台的一些查询之类的，也可以通过多线程扫表，然后再聚合结果的方式来做。或者异步的形式也是可以的。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Callable&lt;List&lt;User&gt;&gt;&gt; taskList = Lists.newArrayList();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">shardingIndex</span> <span class="operator">=</span> <span class="number">0</span>; shardingIndex &lt; <span class="number">1024</span>; shardingIndex++) &#123;</span><br><span class="line">    taskList.add(() -&gt; (userMapper.getProcessingAccountList(shardingIndex)));</span><br><span class="line">&#125;</span><br><span class="line">List&lt;ThirdAccountInfo&gt; list = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    list = taskExecutor.executeTask(taskList);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TaskExecutor</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; List&lt;T&gt; <span class="title function_">executeTask</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        List&lt;T&gt; result = Lists.newArrayList();</span><br><span class="line">        List&lt;Future&lt;T&gt;&gt; futures = ExecutorUtil.invokeAll(tasks);</span><br><span class="line">        <span class="keyword">for</span> (Future&lt;T&gt; future : futures) &#123;</span><br><span class="line">            result.add(future.get());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="MySQL-主从复制"><a href="#MySQL-主从复制" class="headerlink" title="MySQL 主从复制"></a>MySQL 主从复制</h2><p>主要涉及三个线程: binlog 线程、I&#x2F;O 线程和 SQL 线程。</p>
<ul>
<li><strong>binlog 线程</strong> : 负责将主服务器上的数据更改写入二进制日志中。</li>
<li><strong>I&#x2F;O 线程</strong> : 负责从主服务器上读取二进制日志，并写入从服务器的中继日志中。</li>
<li><strong>SQL 线程</strong> : 负责读取中继日志并重放其中的 SQL 语句。</li>
</ul>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/master-slave.png" alt="img"></p>
<p><strong>全同步复制</strong></p>
<p>主库写入binlog后强制同步日志到从库，所有的从库都执行完成后才返回给客户端，但是很显然这个方式的话性能会受到严重影响。</p>
<p><strong>半同步复制</strong></p>
<p>和全同步不同的是，半同步复制的逻辑是这样，从库写入日志成功后返回ACK确认给主库，主库收到至少一个从库的确认就认为写操作完成。</p>
<h2 id="MySQL主从的延迟怎么解决"><a href="#MySQL主从的延迟怎么解决" class="headerlink" title="MySQL主从的延迟怎么解决"></a>MySQL主从的延迟怎么解决</h2><p>这个问题貌似真的是个无解的问题，只能是说自己来判断了，需要走主库的强制走主库查询。</p>
<h2 id="MySQL读写分离方案"><a href="#MySQL读写分离方案" class="headerlink" title="MySQL读写分离方案"></a>MySQL读写分离方案</h2><p>主服务器处理写操作以及实时性要求比较高的读操作，而从服务器处理读操作。</p>
<p>读写分离能提高性能的原因在于:</p>
<ul>
<li>主从服务器负责各自的读和写，极大程度缓解了锁的争用；</li>
<li>从服务器可以使用 MyISAM，提升查询性能以及节约系统开销；</li>
<li>增加冗余，提高可用性。</li>
</ul>
<p>读写分离常用代理方式来实现，代理服务器接收应用层传来的读写请求，然后决定转发到哪个服务器。</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/master-slave-proxy.png" alt="img"></p>
<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="什么是Redis，为什么用Redis？"><a href="#什么是Redis，为什么用Redis？" class="headerlink" title="什么是Redis，为什么用Redis？"></a>什么是Redis，为什么用Redis？</h2><p>Redis 是一种支持 key-value 等多种数据结构的存储系统。可用于缓存，事件发布或订阅，高速队列等场景。支持网络，提供字符串，哈希，列表，队列，集合结构直接存取，<strong>基于内存，可持久化</strong>。</p>
<ul>
<li><strong>读写性能优异</strong><ul>
<li>Redis能读的速度是110000次&#x2F;s,写的速度是81000次&#x2F;s （测试条件见下一节）。</li>
</ul>
</li>
<li><strong>数据类型丰富</strong><ul>
<li>Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。</li>
</ul>
</li>
<li><strong>原子性</strong><ul>
<li>Redis的所有操作都是原子性的，同时Redis还支持对几个操作全并后的原子性执行。</li>
</ul>
</li>
<li><strong>丰富的特性</strong><ul>
<li>Redis支持 publish&#x2F;subscribe, 通知, key 过期等特性。</li>
</ul>
</li>
<li><strong>持久化</strong><ul>
<li>Redis支持RDB, AOF等持久化方式</li>
</ul>
</li>
<li><strong>发布订阅</strong><ul>
<li>Redis支持发布&#x2F;订阅模式</li>
</ul>
</li>
<li><strong>分布式</strong><ul>
<li>Redis Cluster</li>
</ul>
</li>
</ul>
<h2 id="为什么-Redis-是单线程的以及为什么这么快？"><a href="#为什么-Redis-是单线程的以及为什么这么快？" class="headerlink" title="为什么 Redis 是单线程的以及为什么这么快？"></a>为什么 Redis 是单线程的以及为什么这么快？</h2><ul>
<li><strong>redis 完全基于内存</strong>，绝大部分请求是纯粹的内存操作，非常快速.</li>
<li>数据结构简单，对数据操作也简单，redis 中的数据结构是专门进行设计的</li>
<li>采用单线程模型，避免了不必要的上下文切换和竞争条件，也不存在多线程或者多线程切换而消耗CPU，不用考虑各种锁的问题，不存在加锁，释放锁的操作，没有因为可能出现死锁而导致性能消耗</li>
<li>使用了多路 IO 复用模型，非阻塞IO</li>
<li>使用底层模型不同，它们之间底层实现方式及与客户端之间的通信的应用协议不一样，Redis直接构建了自己的VM机制，因为一般的系统调用系统函数，会浪费一定的时间去移动和请求</li>
</ul>
<h2 id="Redis-一般有哪些使用场景？"><a href="#Redis-一般有哪些使用场景？" class="headerlink" title="Redis 一般有哪些使用场景？"></a>Redis 一般有哪些使用场景？</h2><p>可以结合自己的项目讲讲，比如</p>
<ul>
<li><strong>热点数据的缓存</strong></li>
</ul>
<p>缓存是 Redis 最常见的应用场景，之所有这么使用，主要是因为 Redis 读写性能优异。而且逐渐有取代 memcached，成为首选服务端缓存的组件。而且，Redis内部是支持事务的，在使用时候能有效保证数据的一致性。</p>
<ul>
<li><strong>限时业务的运用</strong></li>
</ul>
<p>redis 中可以使用 expire 命令设置一个键的生存时间，到时间后 redis 会删除它。利用这一特性可以运用在限时的优惠活动信息、手机验证码等业务场景。</p>
<ul>
<li><strong>计数器相关问题</strong></li>
</ul>
<p>redis 由于 incrby 命令可以实现原子性的递增，所以可以运用于高并发的秒杀活动、分布式序列号的生成、具体业务还体现在比如限制一个手机号发多少条短信、一个接口一分钟限制多少请求、一个接口一天限制调用多少次等等。</p>
<ul>
<li><strong>分布式锁</strong></li>
</ul>
<p>这个主要利用 redis 的 setnx 命令进行，setnx：”set if not exists”就是如果不存在则成功设置缓存同时返回1，否则返回0 ，这个特性在俞你奔远方的后台中有所运用，因为我们服务器是集群的，定时任务可能在两台机器上都会运行，所以在定时任务中，首先通过 setnx 设置一个 lock，如果成功设置则执行，如果没有成功设置，则表明该定时任务已执行。 当然结合具体业务，我们可以给这个 lock 加一个过期时间，比如说 30 分钟执行一次的定时任务，那么这个过期时间设置为小于 30 分钟的一个时间就可以，这个与定时任务的周期以及定时任务执行消耗时间相关。</p>
<p>在分布式锁的场景中，主要用在比如秒杀系统等。</p>
<h2 id="Redis-有哪些数据类型？"><a href="#Redis-有哪些数据类型？" class="headerlink" title="Redis 有哪些数据类型？"></a>Redis 有哪些数据类型？</h2><ul>
<li><strong>5种基础数据类型</strong>，分别是：String、List、Set、Zset、Hash。</li>
</ul>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/db-redis-ds-1.jpeg" alt="img"></p>
<table>
<thead>
<tr>
<th align="center">结构类型</th>
<th align="center">结构存储的值</th>
<th align="center">结构的读写能力</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>String字符串</strong></td>
<td align="center">可以是字符串、整数或浮点数</td>
<td align="center">对整个字符串或字符串的一部分进行操作；对整数或浮点数进行自增或自减操作；</td>
</tr>
<tr>
<td align="center"><strong>List列表</strong></td>
<td align="center">一个链表，链表上的每个节点都包含一个字符串</td>
<td align="center">对链表的两端进行push和pop操作，读取单个或多个元素；根据值查找或删除元素；</td>
</tr>
<tr>
<td align="center"><strong>Set集合</strong></td>
<td align="center">包含字符串的无序集合</td>
<td align="center">字符串的集合，包含基础的方法有看是否存在添加、获取、删除；还包含计算交集、并集、差集等</td>
</tr>
<tr>
<td align="center"><strong>Hash散列</strong></td>
<td align="center">包含键值对的无序散列表</td>
<td align="center">包含方法有添加、获取、删除单个元素</td>
</tr>
<tr>
<td align="center"><strong>Zset有序集合</strong></td>
<td align="center">和散列一样，用于存储键值对</td>
<td align="center">字符串成员与浮点数分数之间的有序映射；元素的排列顺序由分数的大小决定；包含方法有添加、获取、删除单个元素以及根据分值范围或成员来获取元素</td>
</tr>
</tbody></table>
<ul>
<li><strong>三种特殊的数据类型</strong> 分别是 HyperLogLogs（基数统计）， Bitmaps (位图) 和 geospatial （地理位置)</li>
</ul>
<h2 id="Redis-的对象机制（redisObject"><a href="#Redis-的对象机制（redisObject" class="headerlink" title="Redis 的对象机制（redisObject)"></a>Redis 的对象机制（redisObject)</h2><p>比如说，集合类型就可以由字典和整数集合两种不同的数据结构实现，但是，当用户执行 ZADD 命令时，他&#x2F;她应该不必关心集合使用的是什么编码，只要 Redis 能按照 ZADD 命令的指示，将新元素添加到集合就可以了。</p>
<p>这说明， <strong>操作数据类型的命令除了要对键的类型进行检查之外， 还需要根据数据类型的不同编码进行多态处理</strong>。</p>
<p>为了解决以上问题，<strong>Redis 构建了自己的类型系统</strong>，这个系统的主要功能包括:</p>
<ul>
<li>redisObject 对象</li>
<li>基于 redisObject 对象的类型检查</li>
<li>基于 redisObject 对象的显式多态函数</li>
<li>对 redisObject 进行分配、共享和销毁的机制</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Redis 对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类型</span></span><br><span class="line">    <span class="type">unsigned</span> type:<span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编码方式</span></span><br><span class="line">    <span class="type">unsigned</span> encoding:<span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// LRU - 24位, 记录最末一次访问时间（相对于lru_clock）; 或者 LFU（最少使用的数据：8位频率，16位访问时间）</span></span><br><span class="line">    <span class="type">unsigned</span> lru:LRU_BITS; <span class="comment">// LRU_BITS: 24</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 引用计数</span></span><br><span class="line">    <span class="type">int</span> refcount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指向底层数据结构实例</span></span><br><span class="line">    <span class="type">void</span> *ptr;</span><br><span class="line"></span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure>

<p>下图对应上面的结构</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/db-redis-object-1.png" alt="img"></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=http://example.com/2022/09/02/%E9%9D%A2%E8%AF%95%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%BA%93/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/2022/09/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%9A%E6%A0%91/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            树
          
        </div>
      </a>
    
    
      <a href="/2022/09/02/%E9%9D%A2%E8%AF%95%E4%B9%8BJava%E5%B9%B6%E5%8F%91/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">面试之Java并发</div>
      </a>
    
  </nav>

  
   
    
    <script src="https://cdn.staticfile.org/twikoo/1.4.18/twikoo.all.min.js"></script>
    <div id="twikoo" class="twikoo"></div>
    <script>
        twikoo.init({
            envId: ""
        })
    </script>
 
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2021-2022
        <i class="ri-heart-fill heart_icon"></i> Yang Shiyu
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="Healer"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: ".tocbot",
    contentSelector: ".article-entry",
    headingSelector: "h1, h2, h3, h4, h5, h6",
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: "main",
    positionFixedSelector: ".tocbot",
    positionFixedClass: "is-position-fixed",
    fixedSidebarOffset: "auto",
  });
</script>

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->
 
<script src="/js/clickBoom2.js"></script>
 
<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->
 
<script src="/js/dz.js"></script>
 
<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>