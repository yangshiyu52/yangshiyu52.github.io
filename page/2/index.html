<!DOCTYPE html>


<html lang="en">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title> Healer</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      
<section class="cover">
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover1.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">Healer</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.staticfile.org/typed.js/2.0.12/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['面朝大海，春暖花开', '愿你一生努力，一生被爱', '想要的都拥有，得不到的都释怀'],
        startDelay: 0,
        typeSpeed: 200,
        loop: true,
        backSpeed: 100,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  
  
  

<div class="notice" style="margin-top:50px">
    <i class="ri-heart-fill"></i>
    <div class="notice-content" id="broad"></div>
</div>
<script type="text/javascript">
    fetch('https://v1.hitokoto.cn')
        .then(response => response.json())
        .then(data => {
            document.getElementById("broad").innerHTML = data.hitokoto;
        })
        .catch(console.error)
</script>

<style>
    .notice {
        padding: 20px;
        border: 1px dashed #e6e6e6;
        color: #969696;
        position: relative;
        display: inline-block;
        width: 100%;
        background: #fbfbfb50;
        border-radius: 10px;
    }

    .notice i {
        float: left;
        color: #999;
        font-size: 16px;
        padding-right: 10px;
        vertical-align: middle;
        margin-top: -2px;
    }

    .notice-content {
        display: initial;
        vertical-align: middle;
    }
</style>
  
  <article class="articles">
    
    
    
    
    <article
  id="post-JVM：方法区"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
	
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/07/19/JVM%EF%BC%9A%E6%96%B9%E6%B3%95%E5%8C%BA/"
    >方法区</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/07/19/JVM%EF%BC%9A%E6%96%B9%E6%B3%95%E5%8C%BA/" class="article-date">
  <time datetime="2022-07-19T07:56:03.000Z" itemprop="datePublished">2022-07-19</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/JVM/">JVM</a> / <a class="article-category-link" href="/categories/JVM/1-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/">1.内存与垃圾回收篇</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="栈、堆、方法区的交互关系"><a href="#栈、堆、方法区的交互关系" class="headerlink" title="栈、堆、方法区的交互关系"></a>栈、堆、方法区的交互关系</h1><p><strong>从线程共享与否的角度来看</strong></p>
<p>ThreadLocal：如何保证多个线程在并发环境下的安全性？典型场景就是数据库连接管理，以及会话管理。</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220717145145582.png" alt="image-20220717145145582"></p>
<p><strong>栈、堆、方法区的交互关系</strong></p>
<p><strong>下面涉及了对象的访问定位</strong></p>
<ol>
<li>Person 类的 .class 信息存放在方法区中</li>
<li>person 变量存放在 Java 栈的局部变量表中</li>
<li>真正的 person 对象存放在 Java 堆中</li>
<li>在 person 对象中，有个指针指向方法区中的 person 类型数据，表明这个 person 对象是用方法区中的 Person 类 new 出来的</li>
</ol>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220717145450730.png" alt="image-20220717145450730"></p>
<h1 id="方法区的理解"><a href="#方法区的理解" class="headerlink" title="方法区的理解"></a>方法区的理解</h1><blockquote>
<p><strong>官方文档</strong>：<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5.4">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5.4</a></p>
</blockquote>
<h2 id="方法区在哪里？"><a href="#方法区在哪里？" class="headerlink" title="方法区在哪里？"></a>方法区在哪里？</h2><ol>
<li>《Java虚拟机规范》中明确说明：尽管所有的方法区在逻辑上是属于堆的一部分，但一些简单的实现可能不会选择去进行垃圾收集或者进行压缩。但对于HotSpotJVM而言，方法区还有一个别名叫做Non-Heap（非堆），目的就是要和堆分开。</li>
<li>所以，<strong>方法区可以看作是一块独立于Java堆的内存空间</strong>。</li>
</ol>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220717150314133.png" alt="image-20220717150314133"></p>
<h2 id="方法区的基本理解"><a href="#方法区的基本理解" class="headerlink" title="方法区的基本理解"></a>方法区的基本理解</h2><p><strong>方法区主要存放的是 Class，而堆中主要存放的是实例化的对象</strong></p>
<ol>
<li>方法区（Method Area）与Java堆一样，是各个线程共享的内存区域。多个线程同时加载同一个类时，只能有一个线程能加载该类，其他线程只能等待该线程加载完毕，然后直接使用该类，即类只能加载一次。</li>
<li>方法区在JVM启动的时候被创建，并且它的实际的物理内存空间中和Java堆区一样都可以是不连续的。</li>
<li>方法区的大小，跟堆空间一样，可以选择固定大小或者可扩展。</li>
<li>方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机同样会抛出内存溢出错误：<code>java.lang.OutofMemoryError:PermGen space</code>或者<code>java.lang.OutOfMemoryError:Metaspace</code><ul>
<li>加载大量的第三方的jar包</li>
<li>Tomcat部署的工程过多（30~50个）</li>
<li>大量动态的生成反射类</li>
</ul>
</li>
<li>关闭JVM就会释放这个区域的内存</li>
</ol>
<p><strong>代码举例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodAreaDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;start...&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;end...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单的程序，加载了1600多个类</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220717151239529.png" alt="image-20220717151239529"></p>
<h2 id="HotSpot中方法区的演进"><a href="#HotSpot中方法区的演进" class="headerlink" title="HotSpot中方法区的演进"></a>HotSpot中方法区的演进</h2><ol>
<li>在 JDK7 及以前，习惯上把方法区，称为永久代。JDK8开始，使用元空间取代了永久代。我们可以将方法区类比为Java中的接口，将永久代或元空间类比为Java中具体的实现类</li>
<li>本质上，方法区和永久代并不等价。仅是对Hotspot而言的可以看作等价。《Java虚拟机规范》对如何实现方法区，不做统一要求。例如：BEAJRockit &#x2F; IBM J9 中不存在永久代的概念。<ul>
<li>现在来看，当年使用永久代，不是好的idea。导致Java程序更容易OOm（超过** **上限）</li>
</ul>
</li>
<li>而到了JDK8，终于完全废弃了永久代的概念，改用与JRockit、J9一样在本地内存中实现的元空间（Metaspace）来代替</li>
<li>元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代最大的区别在于：<strong>元空间不在虚拟机设置的内存中，而是使用本地内存</strong>。</li>
<li>永久代、元空间二者并不只是名字变了，内部结构也调整了</li>
<li>根据《Java虚拟机规范》的规定，如果方法区无法满足新的内存分配需求时，将抛出OOM异常</li>
</ol>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220718151943873.png" alt="image-20220718151943873"></p>
<h1 id="设置方法区大小与-OOM"><a href="#设置方法区大小与-OOM" class="headerlink" title="设置方法区大小与 OOM"></a>设置方法区大小与 OOM</h1><p>方法区的大小不必是固定的，JVM可以根据应用的需要动态调整。</p>
<h2 id="JDK7及以前-永久代"><a href="#JDK7及以前-永久代" class="headerlink" title="JDK7及以前(永久代)"></a>JDK7及以前(永久代)</h2><ol>
<li>通过**-XX:Permsize<strong>来设置永久代初始分配空间。</strong>默认值是20.75M**</li>
<li><strong>-XX:MaxPermsize</strong>来设定永久代最大可分配空间。<strong>32位机器默认是64M，64位机器模式是82M</strong></li>
<li>当JVM加载的类信息容量超过了这个值，会报异常OutofMemoryError:PermGen space。</li>
</ol>
<img src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_006/0006.png">

<h2 id="JDK8及以后-元空间"><a href="#JDK8及以后-元空间" class="headerlink" title="JDK8及以后(元空间)"></a>JDK8及以后(元空间)</h2><blockquote>
<p><strong>JDK8 版本设置元空间大小</strong></p>
</blockquote>
<ol>
<li><p>元数据区大小可以使用参数 <strong>-XX:MetaspaceSize</strong> 和 <strong>-XX:MaxMetaspaceSize</strong> 指定</p>
</li>
<li><p>默认值依赖于平台，<strong>Windows下，-XX:MetaspaceSize 约为21M，-XX:MaxMetaspaceSize的值是-1，即没有限制</strong>。</p>
</li>
<li><p>与永久代不同，如果不指定大小，默认情况下，虚拟机会耗尽所有的可用系统内存。如果元数据区发生溢出，虚拟机一样会抛出异常OutOfMemoryError:Metaspace</p>
</li>
<li><p>-XX:MetaspaceSize：设置初始的元空间大小。对于一个 64位 的服务器端 JVM 来说，其默认的 -XX:MetaspaceSize值为21MB。这就是初始的高水位线，一旦触及这个水位线，Full GC将会被触发并卸载没用的类（即这些类对应的类加载器不再存活），然后这个高水位线将会重置。新的高水位线的值取决于GC后释放了多少元空间。如果释放的空间不足，那么在不超过MaxMetaspaceSize时，适当提高该值。如果释放空间过多，则适当降低该值。</p>
</li>
<li><p>如果初始化的高水位线设置过低，上述高水位线调整情况会发生很多次。通过垃圾回收器的日志可以观察到Full GC多次调用。为了避免频繁地GC，<strong>建议将-XX:MetaspaceSize设置为一个相对较高的值</strong>。</p>
</li>
</ol>
<h2 id="方法区OOM"><a href="#方法区OOM" class="headerlink" title="方法区OOM"></a>方法区OOM</h2><p>举例：</p>
<p>代码：OOMTest 类继承 ClassLoader 类，获得 defineClass() 方法，可自己进行类的加载</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * jdk6/7中：</span></span><br><span class="line"><span class="comment"> * -XX:PermSize=10m -XX:MaxPermSize=10m</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * jdk8中：</span></span><br><span class="line"><span class="comment"> * -XX:MetaspaceSize=10m -XX:MaxMetaspaceSize=10m</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OOMTest</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">OOMTest</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OOMTest</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">                <span class="comment">//创建ClassWriter对象，用于生成类的二进制字节码</span></span><br><span class="line">                <span class="type">ClassWriter</span> <span class="variable">classWriter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassWriter</span>(<span class="number">0</span>);</span><br><span class="line">                <span class="comment">//指明版本号，修饰符，类名，包名，父类，接口</span></span><br><span class="line">                classWriter.visit(Opcodes.V1_8, Opcodes.ACC_PUBLIC, <span class="string">&quot;Class&quot;</span> + i, <span class="literal">null</span>, <span class="string">&quot;java/lang/Object&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">                <span class="comment">//返回byte[]</span></span><br><span class="line">                <span class="type">byte</span>[] code = classWriter.toByteArray();</span><br><span class="line">                <span class="comment">//类的加载</span></span><br><span class="line">                test.defineClass(<span class="string">&quot;Class&quot;</span> + i, code, <span class="number">0</span>, code.length);<span class="comment">//Class对象</span></span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>不设置元空间的上限</strong></p>
<p>使用默认的 JVM 参数，元空间不设置上限</p>
<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10000</span></span><br></pre></td></tr></table></figure>

<p><strong>设置元空间的上限</strong></p>
<p>JVM 参数</p>
<p>-XX:MetaspaceSize&#x3D;10m -XX:MaxMetaspaceSize&#x3D;10m</p>
<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3331</span></span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.OutOfMemoryError: Compressed <span class="keyword">class</span> <span class="title class_">space</span></span><br><span class="line">	at java.lang.ClassLoader.defineClass1(Native Method)</span><br><span class="line">	at java.lang.ClassLoader.defineClass(ClassLoader.java:<span class="number">763</span>)</span><br><span class="line">	at java.lang.ClassLoader.defineClass(ClassLoader.java:<span class="number">642</span>)</span><br><span class="line">	at com.ysy.methodarea.OOMTest.main(OOMTest.java:<span class="number">29</span>)</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h3 id="如何解决OOM"><a href="#如何解决OOM" class="headerlink" title="如何解决OOM"></a>如何解决OOM</h3><ol>
<li>要解决<strong>OOM异常或heap space的异常</strong>，一般的手段是首先通过内存映像分析工具（如Ec1ipse Memory Analyzer）对dump出来的堆转储快照进行分析，重点是确认内存中的对象是否是必要的，也就是要先分清楚到底是出现了<strong>内存泄漏（Memory Leak）还是内存溢出（Memory Overflow）</strong></li>
<li><strong>内存泄漏</strong>就是有大量的引用指向某些对象，但是这些对象以后不会使用了，但是因为它们还和<strong>GC ROOT</strong>有关联，所以导致以后这些对象也不会被回收，这就是内存泄漏的问题</li>
<li>如果是内存泄漏，可进一步通过工具查看泄漏对象到<strong>GC Roots</strong>的引用链。于是就能找到泄漏对象是通过怎样的路径与<strong>GC Roots</strong>相关联并导致垃圾收集器无法自动回收它们的。掌握了泄漏对象的类型信息，以及<strong>GC Roots</strong>引用链的信息，就可以比较准确地定位出泄漏代码的位置。</li>
<li>如果不存在内存泄漏，换句话说就是内存中的对象确实都还必须存活着，那就应当检查虚拟机的堆参数（**-Xmx与-Xms**），与机器物理内存对比看是否还可以调大，从代码上检查是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少程序运行期的内存消耗。</li>
</ol>
<h1 id="方法区的内部结构"><a href="#方法区的内部结构" class="headerlink" title="方法区的内部结构"></a>方法区的内部结构</h1><h2 id="方法区存储什么？"><a href="#方法区存储什么？" class="headerlink" title="方法区存储什么？"></a>方法区存储什么？</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220719133159128.png" alt="image-20220719133159128"></p>
<ul>
<li>《深入理解Java虚拟机》书中对方法区（Method Area）存储内容描述如下：它用于存储已被虚拟机加载的<strong>类型信息、常量、静态变量、即时编译器编译后的代码缓存</strong>等。</li>
</ul>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220719133402240.png" alt="image-20220719133402240"></p>
<p><strong>类型信息</strong></p>
<p>对每个加载的类型（类class、接口interface、枚举enum、注解annotation），JVM必须在方法区中存储以下类型信息：</p>
<ol>
<li>这个类型的完整有效名称（全名&#x3D;包名.类名）</li>
<li>这个类型直接父类的完整有效名（对于interface或是java.lang.Object，都没有父类）</li>
<li>这个类型的修饰符（public，abstract，final的某个子集）</li>
<li>这个类型直接接口的一个有序列表</li>
</ol>
<p><strong>域（Field）信息</strong></p>
<blockquote>
<p>也就是我们常说的成员变量，域信息是比较官方的称呼</p>
</blockquote>
<ol>
<li><p>JVM必须在方法区中保存类型的所有域的相关信息以及域的声明顺序。</p>
</li>
<li><p>域的相关信息包括：域名称，域类型，域修饰符（public，private，protected，static，final，volatile，transient的某个子集）</p>
</li>
</ol>
<p><strong>方法（Method）信息</strong></p>
<p>JVM必须保存所有方法的以下信息，同域信息一样包括声明顺序：</p>
<ol>
<li>方法名称</li>
<li>方法的返回类型（包括 void 返回类型），void 在 Java 中对应的为 void.class</li>
<li>方法参数的数量和类型（按顺序）</li>
<li>方法的修饰符（public，private，protected，static，final，synchronized，native，abstract的一个子集）</li>
<li>方法的字节码（bytecodes）、操作数栈、局部变量表及大小（abstract和native方法除外）</li>
<li>异常表（abstract和native方法除外），异常表记录每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引</li>
</ol>
<p><strong>举例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试方法区的内部构成</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodInnerStrucTest</span> <span class="keyword">extends</span> <span class="title class_">Object</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;String&gt;,Serializable &#123;</span><br><span class="line">    <span class="comment">//属性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;测试方法的内部结构&quot;</span>;</span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="comment">//方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;count = &quot;</span> + count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">test2</span><span class="params">(<span class="type">int</span> cal)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line">            result = value / cal;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(String o)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>javap -v -p MethodInnerStrucTest.class &gt; test.txt</code></p>
<ul>
<li>反编译字节码文件，并输出值文本文件中，便于查看。参数 -p 确保能查看 private 权限类型的字段或方法</li>
</ul>
<p>字节码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br></pre></td><td class="code"><pre><span class="line">Classfile /D:/JavaProjects/jvm/out/production/jvm02/com/ysy/methodarea/MethodInnerStrucTest.<span class="keyword">class</span></span><br><span class="line">  <span class="title class_">Last</span> modified <span class="number">2022</span>-<span class="number">7</span>-<span class="number">19</span>; size <span class="number">1630</span> bytes</span><br><span class="line">  MD5 checksum 7f8bc6364c6d3121721810737a6d4d24</span><br><span class="line">  Compiled from <span class="string">&quot;MethodInnerStrucTest.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">com</span>.ysy.methodarea.MethodInnerStrucTest <span class="keyword">extends</span> <span class="title class_">java</span>.lang.Object <span class="keyword">implements</span> <span class="title class_">java</span>.lang.Comparable&lt;java.lang.String&gt;, java.io.Serializable</span><br><span class="line">  minor version: <span class="number">0</span></span><br><span class="line">  major version: <span class="number">52</span></span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #<span class="number">1</span> = Methodref          #<span class="number">18.</span>#<span class="number">52</span>        <span class="comment">// java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">   #<span class="number">2</span> = Fieldref           #<span class="number">17.</span>#<span class="number">53</span>        <span class="comment">// com/ysy/methodarea/MethodInnerStrucTest.num:I</span></span><br><span class="line">   #<span class="number">3</span> = Fieldref           #<span class="number">54.</span>#<span class="number">55</span>        <span class="comment">// java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">   #<span class="number">4</span> = Class              #<span class="number">56</span>            <span class="comment">// java/lang/StringBuilder</span></span><br><span class="line">   #<span class="number">5</span> = Methodref          #<span class="number">4.</span>#<span class="number">52</span>         <span class="comment">// java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">   #<span class="number">6</span> = String             #<span class="number">57</span>            <span class="comment">// count =</span></span><br><span class="line">   #<span class="number">7</span> = Methodref          #<span class="number">4.</span>#<span class="number">58</span>         <span class="comment">// java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span></span><br><span class="line">   #<span class="number">8</span> = Methodref          #<span class="number">4.</span>#<span class="number">59</span>         <span class="comment">// java/lang/StringBuilder.append:(I)Ljava/lang/StringBuilder;</span></span><br><span class="line">   #<span class="number">9</span> = Methodref          #<span class="number">4.</span>#<span class="number">60</span>         <span class="comment">// java/lang/StringBuilder.toString:()Ljava/lang/String;</span></span><br><span class="line">  #<span class="number">10</span> = Methodref          #<span class="number">61.</span>#<span class="number">62</span>        <span class="comment">// java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">  #<span class="number">11</span> = Class              #<span class="number">63</span>            <span class="comment">// java/lang/Exception</span></span><br><span class="line">  #<span class="number">12</span> = Methodref          #<span class="number">11.</span>#<span class="number">64</span>        <span class="comment">// java/lang/Exception.printStackTrace:()V</span></span><br><span class="line">  #<span class="number">13</span> = Class              #<span class="number">65</span>            <span class="comment">// java/lang/String</span></span><br><span class="line">  #<span class="number">14</span> = Methodref          #<span class="number">17.</span>#<span class="number">66</span>        <span class="comment">// com/ysy/methodarea/MethodInnerStrucTest.compareTo:(Ljava/lang/String;)I</span></span><br><span class="line">  #<span class="number">15</span> = String             #<span class="number">67</span>            <span class="comment">// 测试方法的内部结构</span></span><br><span class="line">  #<span class="number">16</span> = Fieldref           #<span class="number">17.</span>#<span class="number">68</span>        <span class="comment">// com/ysy/methodarea/MethodInnerStrucTest.str:Ljava/lang/String;</span></span><br><span class="line">  #<span class="number">17</span> = Class              #<span class="number">69</span>            <span class="comment">// com/ysy/methodarea/MethodInnerStrucTest</span></span><br><span class="line">  #<span class="number">18</span> = Class              #<span class="number">70</span>            <span class="comment">// java/lang/Object</span></span><br><span class="line">  #<span class="number">19</span> = Class              #<span class="number">71</span>            <span class="comment">// java/lang/Comparable</span></span><br><span class="line">  #<span class="number">20</span> = Class              #<span class="number">72</span>            <span class="comment">// java/io/Serializable</span></span><br><span class="line">  #<span class="number">21</span> = Utf8               num</span><br><span class="line">  #<span class="number">22</span> = Utf8               I</span><br><span class="line">  #<span class="number">23</span> = Utf8               str</span><br><span class="line">  #<span class="number">24</span> = Utf8               Ljava/lang/String;</span><br><span class="line">  #<span class="number">25</span> = Utf8               &lt;init&gt;</span><br><span class="line">  #<span class="number">26</span> = Utf8               ()V</span><br><span class="line">  #<span class="number">27</span> = Utf8               Code</span><br><span class="line">  #<span class="number">28</span> = Utf8               LineNumberTable</span><br><span class="line">  #<span class="number">29</span> = Utf8               LocalVariableTable</span><br><span class="line">  #<span class="number">30</span> = Utf8               <span class="built_in">this</span></span><br><span class="line">  #<span class="number">31</span> = Utf8               Lcom/ysy/methodarea/MethodInnerStrucTest;</span><br><span class="line">  #<span class="number">32</span> = Utf8               test1</span><br><span class="line">  #<span class="number">33</span> = Utf8               count</span><br><span class="line">  #<span class="number">34</span> = Utf8               test2</span><br><span class="line">  #<span class="number">35</span> = Utf8               (I)I</span><br><span class="line">  #<span class="number">36</span> = Utf8               value</span><br><span class="line">  #<span class="number">37</span> = Utf8               e</span><br><span class="line">  #<span class="number">38</span> = Utf8               Ljava/lang/Exception;</span><br><span class="line">  #<span class="number">39</span> = Utf8               cal</span><br><span class="line">  #<span class="number">40</span> = Utf8               result</span><br><span class="line">  #<span class="number">41</span> = Utf8               StackMapTable</span><br><span class="line">  #<span class="number">42</span> = Class              #<span class="number">63</span>            <span class="comment">// java/lang/Exception</span></span><br><span class="line">  #<span class="number">43</span> = Utf8               compareTo</span><br><span class="line">  #<span class="number">44</span> = Utf8               (Ljava/lang/String;)I</span><br><span class="line">  #<span class="number">45</span> = Utf8               o</span><br><span class="line">  #<span class="number">46</span> = Utf8               (Ljava/lang/Object;)I</span><br><span class="line">  #<span class="number">47</span> = Utf8               &lt;clinit&gt;</span><br><span class="line">  #<span class="number">48</span> = Utf8               Signature</span><br><span class="line">  #<span class="number">49</span> = Utf8               Ljava/lang/Object;Ljava/lang/Comparable&lt;Ljava/lang/String;&gt;;Ljava/io/Serializable;</span><br><span class="line">  #<span class="number">50</span> = Utf8               SourceFile</span><br><span class="line">  #<span class="number">51</span> = Utf8               MethodInnerStrucTest.java</span><br><span class="line">  #<span class="number">52</span> = NameAndType        #<span class="number">25</span>:#<span class="number">26</span>        <span class="comment">// &quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">  #<span class="number">53</span> = NameAndType        #<span class="number">21</span>:#<span class="number">22</span>        <span class="comment">// num:I</span></span><br><span class="line">  #<span class="number">54</span> = Class              #<span class="number">73</span>            <span class="comment">// java/lang/System</span></span><br><span class="line">  #<span class="number">55</span> = NameAndType        #<span class="number">74</span>:#<span class="number">75</span>        <span class="comment">// out:Ljava/io/PrintStream;</span></span><br><span class="line">  #<span class="number">56</span> = Utf8               java/lang/StringBuilder</span><br><span class="line">  #<span class="number">57</span> = <span class="type">Utf8</span>               <span class="variable">count</span> <span class="operator">=</span></span><br><span class="line">  #<span class="number">58</span> = NameAndType        #<span class="number">76</span>:#<span class="number">77</span>        <span class="comment">// append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span></span><br><span class="line">  #<span class="number">59</span> = NameAndType        #<span class="number">76</span>:#<span class="number">78</span>        <span class="comment">// append:(I)Ljava/lang/StringBuilder;</span></span><br><span class="line">  #<span class="number">60</span> = NameAndType        #<span class="number">79</span>:#<span class="number">80</span>        <span class="comment">// toString:()Ljava/lang/String;</span></span><br><span class="line">  #<span class="number">61</span> = Class              #<span class="number">81</span>            <span class="comment">// java/io/PrintStream</span></span><br><span class="line">  #<span class="number">62</span> = NameAndType        #<span class="number">82</span>:#<span class="number">83</span>        <span class="comment">// println:(Ljava/lang/String;)V</span></span><br><span class="line">  #<span class="number">63</span> = Utf8               java/lang/Exception</span><br><span class="line">  #<span class="number">64</span> = NameAndType        #<span class="number">84</span>:#<span class="number">26</span>        <span class="comment">// printStackTrace:()V</span></span><br><span class="line">  #<span class="number">65</span> = Utf8               java/lang/String</span><br><span class="line">  #<span class="number">66</span> = NameAndType        #<span class="number">43</span>:#<span class="number">44</span>        <span class="comment">// compareTo:(Ljava/lang/String;)I</span></span><br><span class="line">  #<span class="number">67</span> = Utf8               测试方法的内部结构</span><br><span class="line">  #<span class="number">68</span> = NameAndType        #<span class="number">23</span>:#<span class="number">24</span>        <span class="comment">// str:Ljava/lang/String;</span></span><br><span class="line">  #<span class="number">69</span> = Utf8               com/ysy/methodarea/MethodInnerStrucTest</span><br><span class="line">  #<span class="number">70</span> = Utf8               java/lang/Object</span><br><span class="line">  #<span class="number">71</span> = Utf8               java/lang/Comparable</span><br><span class="line">  #<span class="number">72</span> = Utf8               java/io/Serializable</span><br><span class="line">  #<span class="number">73</span> = Utf8               java/lang/System</span><br><span class="line">  #<span class="number">74</span> = Utf8               out</span><br><span class="line">  #<span class="number">75</span> = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #<span class="number">76</span> = Utf8               append</span><br><span class="line">  #<span class="number">77</span> = Utf8               (Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">  #<span class="number">78</span> = Utf8               (I)Ljava/lang/StringBuilder;</span><br><span class="line">  #<span class="number">79</span> = Utf8               toString</span><br><span class="line">  #<span class="number">80</span> = Utf8               ()Ljava/lang/String;</span><br><span class="line">  #<span class="number">81</span> = Utf8               java/io/PrintStream</span><br><span class="line">  #<span class="number">82</span> = Utf8               println</span><br><span class="line">  #<span class="number">83</span> = Utf8               (Ljava/lang/String;)V</span><br><span class="line">  #<span class="number">84</span> = Utf8               printStackTrace</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> num;</span><br><span class="line">    descriptor: I</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> java.lang.String str;</span><br><span class="line">    descriptor: Ljava/lang/String;</span><br><span class="line">    flags: ACC_PRIVATE, ACC_STATIC</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> com.ysy.methodarea.MethodInnerStrucTest();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">         <span class="number">4</span>: aload_0</span><br><span class="line">         <span class="number">5</span>: bipush        <span class="number">10</span></span><br><span class="line">         <span class="number">7</span>: putfield      #<span class="number">2</span>                  <span class="comment">// Field num:I</span></span><br><span class="line">        <span class="number">10</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">7</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">9</span>: <span class="number">4</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>      <span class="number">11</span>     <span class="number">0</span>  <span class="built_in">this</span>   Lcom/ysy/methodarea/MethodInnerStrucTest;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">3</span>, locals=<span class="number">2</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: bipush        <span class="number">20</span></span><br><span class="line">         <span class="number">2</span>: istore_1</span><br><span class="line">         <span class="number">3</span>: getstatic     #<span class="number">3</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">         <span class="number">6</span>: <span class="keyword">new</span>           #<span class="number">4</span>                  <span class="comment">// class java/lang/StringBuilder</span></span><br><span class="line">         <span class="number">9</span>: dup</span><br><span class="line">        <span class="number">10</span>: invokespecial #<span class="number">5</span>                  <span class="comment">// Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">        <span class="number">13</span>: ldc           #<span class="number">6</span>                  <span class="comment">// String count =</span></span><br><span class="line">        <span class="number">15</span>: invokevirtual #<span class="number">7</span>                  <span class="comment">// Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span></span><br><span class="line">        <span class="number">18</span>: iload_1</span><br><span class="line">        <span class="number">19</span>: invokevirtual #<span class="number">8</span>                  <span class="comment">// Method java/lang/StringBuilder.append:(I)Ljava/lang/StringBuilder;</span></span><br><span class="line">        <span class="number">22</span>: invokevirtual #<span class="number">9</span>                  <span class="comment">// Method java/lang/StringBuilder.toString:()Ljava/lang/String;</span></span><br><span class="line">        <span class="number">25</span>: invokevirtual #<span class="number">10</span>                 <span class="comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">        <span class="number">28</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">14</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">15</span>: <span class="number">3</span></span><br><span class="line">        line <span class="number">16</span>: <span class="number">28</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>      <span class="number">29</span>     <span class="number">0</span>  <span class="built_in">this</span>   Lcom/ysy/methodarea/MethodInnerStrucTest;</span><br><span class="line">            <span class="number">3</span>      <span class="number">26</span>     <span class="number">1</span> count   I</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">test2</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line">    descriptor: (I)I</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">3</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: iconst_0</span><br><span class="line">         <span class="number">1</span>: istore_1</span><br><span class="line">         <span class="number">2</span>: bipush        <span class="number">30</span></span><br><span class="line">         <span class="number">4</span>: istore_2</span><br><span class="line">         <span class="number">5</span>: iload_2</span><br><span class="line">         <span class="number">6</span>: iload_0</span><br><span class="line">         <span class="number">7</span>: idiv</span><br><span class="line">         <span class="number">8</span>: istore_1</span><br><span class="line">         <span class="number">9</span>: goto          <span class="number">17</span></span><br><span class="line">        <span class="number">12</span>: astore_2</span><br><span class="line">        <span class="number">13</span>: aload_2</span><br><span class="line">        <span class="number">14</span>: invokevirtual #<span class="number">12</span>                 <span class="comment">// Method java/lang/Exception.printStackTrace:()V</span></span><br><span class="line">        <span class="number">17</span>: iload_1</span><br><span class="line">        <span class="number">18</span>: ireturn</span><br><span class="line">      Exception table:</span><br><span class="line">         from    to  target type</span><br><span class="line">             <span class="number">2</span>     <span class="number">9</span>    <span class="number">12</span>   Class java/lang/Exception</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">18</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">20</span>: <span class="number">2</span></span><br><span class="line">        line <span class="number">21</span>: <span class="number">5</span></span><br><span class="line">        line <span class="number">24</span>: <span class="number">9</span></span><br><span class="line">        line <span class="number">22</span>: <span class="number">12</span></span><br><span class="line">        line <span class="number">23</span>: <span class="number">13</span></span><br><span class="line">        line <span class="number">25</span>: <span class="number">17</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">5</span>       <span class="number">4</span>     <span class="number">2</span> value   I</span><br><span class="line">           <span class="number">13</span>       <span class="number">4</span>     <span class="number">2</span>     e   Ljava/lang/Exception;</span><br><span class="line">            <span class="number">0</span>      <span class="number">19</span>     <span class="number">0</span>   cal   I</span><br><span class="line">            <span class="number">2</span>      <span class="number">17</span>     <span class="number">1</span> result   I</span><br><span class="line">      StackMapTable: number_of_entries = <span class="number">2</span></span><br><span class="line">        frame_type = <span class="number">255</span> <span class="comment">/* full_frame */</span></span><br><span class="line">          offset_delta = <span class="number">12</span></span><br><span class="line">          locals = [ <span class="type">int</span>, <span class="type">int</span> ]</span><br><span class="line">          stack = [ <span class="keyword">class</span> <span class="title class_">java</span>/lang/Exception ]</span><br><span class="line">        frame_type = <span class="number">4</span> <span class="comment">/* same */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(java.lang.String)</span>;</span><br><span class="line">    descriptor: (Ljava/lang/String;)I</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">2</span>, args_size=<span class="number">2</span></span><br><span class="line">         <span class="number">0</span>: iconst_0</span><br><span class="line">         <span class="number">1</span>: ireturn</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">30</span>: <span class="number">0</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">2</span>     <span class="number">0</span>  <span class="built_in">this</span>   Lcom/ysy/methodarea/MethodInnerStrucTest;</span><br><span class="line">            <span class="number">0</span>       <span class="number">2</span>     <span class="number">1</span>     o   Ljava/lang/String;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(java.lang.Object)</span>;</span><br><span class="line">    descriptor: (Ljava/lang/Object;)I</span><br><span class="line">    flags: ACC_PUBLIC, ACC_BRIDGE, ACC_SYNTHETIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">2</span>, args_size=<span class="number">2</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="number">1</span>: aload_1</span><br><span class="line">         <span class="number">2</span>: checkcast     #<span class="number">13</span>                 <span class="comment">// class java/lang/String</span></span><br><span class="line">         <span class="number">5</span>: invokevirtual #<span class="number">14</span>                 <span class="comment">// Method compareTo:(Ljava/lang/String;)I</span></span><br><span class="line">         <span class="number">8</span>: ireturn</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">7</span>: <span class="number">0</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">9</span>     <span class="number">0</span>  <span class="built_in">this</span>   Lcom/ysy/methodarea/MethodInnerStrucTest;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> &#123;&#125;;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">0</span>, args_size=<span class="number">0</span></span><br><span class="line">         <span class="number">0</span>: ldc           #<span class="number">15</span>                 <span class="comment">// String 测试方法的内部结构</span></span><br><span class="line">         <span class="number">2</span>: putstatic     #<span class="number">16</span>                 <span class="comment">// Field str:Ljava/lang/String;</span></span><br><span class="line">         <span class="number">5</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">10</span>: <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">Signature: #<span class="number">49</span>                          <span class="comment">// Ljava/lang/Object;Ljava/lang/Comparable&lt;Ljava/lang/String;&gt;;Ljava/io/Serializable;</span></span><br><span class="line">SourceFile: <span class="string">&quot;MethodInnerStrucTest.java&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>类型信息</strong></p>
<p>在运行时方法区中，类信息中记录了哪个加载器加载了该类，同时类加载器也记录了它加载了哪些类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类型信息      </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">com</span>.atguigu.java.MethodInnerStrucTest <span class="keyword">extends</span> <span class="title class_">java</span>.lang.Object <span class="keyword">implements</span> <span class="title class_">java</span>.lang.Comparable&lt;java.lang.String&gt;, java.io.Serializable</span><br></pre></td></tr></table></figure>

<p><strong>域信息</strong></p>
<ol>
<li>descriptor: I 表示字段类型为 Integer</li>
<li>flags: ACC_PUBLIC 表示字段权限修饰符为 public</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//域信息</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> num;</span><br><span class="line">    descriptor: I</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> java.lang.String str;</span><br><span class="line">    descriptor: Ljava/lang/String;</span><br><span class="line">    flags: ACC_PRIVATE, ACC_STATIC</span><br></pre></td></tr></table></figure>

<p><strong>方法信息</strong></p>
<ol>
<li>descriptor: ()V 表示方法返回值类型为 void</li>
<li>flags: ACC_PUBLIC 表示方法权限修饰符为 public</li>
<li>stack&#x3D;3 表示操作数栈深度为 3</li>
<li>locals&#x3D;2 表示局部变量个数为 2 个（实例方法包含 this）</li>
<li>test1() 方法虽然没有参数，但是其 args_size&#x3D;1 ，这时因为将 this 作为了参数</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">3</span>, locals=<span class="number">2</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: bipush        <span class="number">20</span></span><br><span class="line">         <span class="number">2</span>: istore_1</span><br><span class="line">         <span class="number">3</span>: getstatic     #<span class="number">3</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">         <span class="number">6</span>: <span class="keyword">new</span>           #<span class="number">4</span>                  <span class="comment">// class java/lang/StringBuilder</span></span><br><span class="line">         <span class="number">9</span>: dup</span><br><span class="line">        <span class="number">10</span>: invokespecial #<span class="number">5</span>                  <span class="comment">// Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">        <span class="number">13</span>: ldc           #<span class="number">6</span>                  <span class="comment">// String count =</span></span><br><span class="line">        <span class="number">15</span>: invokevirtual #<span class="number">7</span>                  <span class="comment">// Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span></span><br><span class="line">        <span class="number">18</span>: iload_1</span><br><span class="line">        <span class="number">19</span>: invokevirtual #<span class="number">8</span>                  <span class="comment">// Method java/lang/StringBuilder.append:(I)Ljava/lang/StringBuilder;</span></span><br><span class="line">        <span class="number">22</span>: invokevirtual #<span class="number">9</span>                  <span class="comment">// Method java/lang/StringBuilder.toString:()Ljava/lang/String;</span></span><br><span class="line">        <span class="number">25</span>: invokevirtual #<span class="number">10</span>                 <span class="comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">        <span class="number">28</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">17</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">18</span>: <span class="number">3</span></span><br><span class="line">        line <span class="number">19</span>: <span class="number">28</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>      <span class="number">29</span>     <span class="number">0</span>  <span class="built_in">this</span>   Lcom/atguigu/java/MethodInnerStrucTest;</span><br><span class="line">            <span class="number">3</span>      <span class="number">26</span>     <span class="number">1</span> count   I</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="non-final-类型的类变量"><a href="#non-final-类型的类变量" class="headerlink" title="non-final 类型的类变量"></a>non-final 类型的类变量</h2><ol>
<li><p>静态变量和类关联在一起，随着类的加载而加载，他们成为类数据在逻辑上的一部分</p>
</li>
<li><p>类变量被类的所有实例共享，即使没有类实例时，你也可以访问它</p>
</li>
</ol>
<p><strong>举例</strong></p>
<ol>
<li>如下代码所示，即使我们把order设置为null，也不会出现空指针异常</li>
<li>这更加表明了 static 类型的字段和方法随着类的加载而加载，并不属于特定的类实例</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodAreaTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        order.hello();</span><br><span class="line">        System.out.println(order.count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Order</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello!</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<h3 id="全局常量：static-final"><a href="#全局常量：static-final" class="headerlink" title="全局常量：static final"></a>全局常量：static final</h3><ol>
<li><p>全局常量就是使用 static final 进行修饰</p>
</li>
<li><p>被声明为final的类变量的处理方法则不同，每个全局常量在编译的时候就会被分配了。</p>
</li>
</ol>
<p>查看上面代码，这部分的字节码指令</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Order</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> count;</span><br><span class="line">    descriptor: I</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> number;</span><br><span class="line">    descriptor: I</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC, ACC_FINAL</span><br><span class="line">    ConstantValue: <span class="type">int</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>可以发现 staitc和final同时修饰的number 的值在编译上的时候已经写死在字节码文件中了。</p>
<h2 id="运行时常量池-VS-常量池"><a href="#运行时常量池-VS-常量池" class="headerlink" title="运行时常量池 VS 常量池"></a>运行时常量池 VS 常量池</h2><blockquote>
<p><strong>官方文档</strong>：<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html</a></p>
</blockquote>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220719135454903.png" alt="image-20220719135454903"></p>
<ol>
<li>方法区，内部包含了运行时常量池</li>
<li>字节码文件，内部包含了常量池。（之前的字节码文件中已经看到了很多Constant pool的东西，这个就是常量池）</li>
<li>要弄清楚方法区，需要理解清楚ClassFile，因为加载类的信息都在方法区。</li>
<li>要弄清楚方法区的运行时常量池，需要理解清楚ClassFile中的常量池。</li>
</ol>
<h3 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h3><ol>
<li>一个有效的字节码文件中除了包含<strong>类的版本信息、字段、方法以及接口</strong>等描述符信息外。还包含一项信息就是<strong>常量池表</strong>（<strong>Constant Pool Table</strong>），包括各种字面量和对类型、域和方法的符号引用。</li>
<li>字面量： 10 ， “我是某某”这种数字和字符串都是字面量</li>
</ol>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220719135817127.png" alt="image-20220719135817127"></p>
<p><strong>为什么需要常量池？</strong></p>
<ul>
<li>一个java源文件中的类、接口，编译后产生一个字节码文件。而Java中的字节码需要数据支持，通常这种数据会很大以至于不能直接存到字节码里，换另一种方式，可以存到常量池。这个字节码包含了指向常量池的引用。在动态链接的时候会用到运行时常量池。</li>
</ul>
<p>比如：如下的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ol>
<li>虽然上述代码只有194字节，但是里面却使用了String、System、PrintStream及Object等结构。</li>
<li>比如说我们这个文件中有6个地方用到了”hello”这个字符串，如果不用常量池，就需要在6个地方全写一遍，造成臃肿。我们可以将”hello”等所需用到的结构信息记录在常量池中，并通过<strong>引用的方式</strong>，来加载、调用所需的结构</li>
<li>这里的代码量其实很少了，如果代码多的话，引用的结构将会更多，这里就需要用到常量池了。</li>
</ol>
<img src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_006/0011.png">

<p><strong>常量池中有啥？</strong></p>
<ol>
<li>数量值</li>
<li>字符串值</li>
<li>类引用</li>
<li>字段引用</li>
<li>方法引用</li>
</ol>
<p>MethodInnerStrucTest 的 test1方法的字节码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">0</span> bipush <span class="number">20</span></span><br><span class="line"> <span class="number">2</span> istore_1</span><br><span class="line"> <span class="number">3</span> getstatic #<span class="number">3</span> &lt;java/lang/System.out&gt;</span><br><span class="line"> <span class="number">6</span> <span class="keyword">new</span> #<span class="number">4</span> &lt;java/lang/StringBuilder&gt;</span><br><span class="line"> <span class="number">9</span> dup</span><br><span class="line"><span class="number">10</span> invokespecial #<span class="number">5</span> &lt;java/lang/StringBuilder.&lt;init&gt;&gt;</span><br><span class="line"><span class="number">13</span> ldc #<span class="number">6</span> &lt;count = &gt;</span><br><span class="line"><span class="number">15</span> invokevirtual #<span class="number">7</span> &lt;java/lang/StringBuilder.append&gt;</span><br><span class="line"><span class="number">18</span> iload_1</span><br><span class="line"><span class="number">19</span> invokevirtual #<span class="number">8</span> &lt;java/lang/StringBuilder.append&gt;</span><br><span class="line"><span class="number">22</span> invokevirtual #<span class="number">9</span> &lt;java/lang/StringBuilder.toString&gt;</span><br><span class="line"><span class="number">25</span> invokevirtual #<span class="number">10</span> &lt;java/io/PrintStream.println&gt;</span><br><span class="line"><span class="number">28</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<p>1、#3，#5等等这些带# 的，都是引用了常量池。</p>
<p><strong>常量池总结</strong></p>
<p>常量池、可以看做是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等类型。</p>
<h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><ol>
<li><p>运行时常量池（Runtime Constant Pool）是方法区的一部分。</p>
</li>
<li><p>常量池表（Constant Pool Table）是Class字节码文件的一部分，用于存放编译期生成的各种字面量与符号引用，<strong>这部分内容将在类加载后存放到方法区的运行时常量池中</strong>。（运行时常量池就是常量池在程序运行时的称呼）</p>
</li>
<li><p>运行时常量池，在加载类和接口到虚拟机后，就会创建对应的运行时常量池。</p>
</li>
<li><p>JVM为每个已加载的类型（类或接口）都维护一个常量池。池中的数据项像数组项一样，是<strong>通过索引访问</strong>的。</p>
</li>
<li><p>运行时常量池中包含多种不同的常量，包括编译期就已经明确的数值字面量，也包括到运行期解析后才能够获得的方法或者字段引用。<strong>此时不再是常量池中的符号地址了，这里换为真实地址</strong>。</p>
<ul>
<li>运行时常量池，相对于Class文件常量池的另一重要特征是：<strong>具备动态性</strong>。</li>
</ul>
</li>
<li><p>运行时常量池类似于传统编程语言中的符号表（symbol table），但是它所包含的数据却比符号表要更加丰富一些。</p>
</li>
<li><p>当创建类或接口的运行时常量池时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大值，则JVM会抛OutofMemoryError异常。</p>
</li>
</ol>
<h1 id="方法区的使用举例"><a href="#方法区的使用举例" class="headerlink" title="方法区的使用举例"></a>方法区的使用举例</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodAreaDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">500</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> x / y;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">50</span>;</span><br><span class="line">        System.out.println(a + b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>字节码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">Classfile /D:/JavaProjects/jvm/out/production/jvm02/com/ysy/methodarea/MethodAreaDemo.<span class="keyword">class</span></span><br><span class="line">  <span class="title class_">Last</span> modified <span class="number">2022</span>-<span class="number">7</span>-<span class="number">19</span>; size <span class="number">642</span> bytes</span><br><span class="line">  MD5 checksum db32eed8d47a557ade3b6d5d481463be</span><br><span class="line">  Compiled from <span class="string">&quot;MethodAreaDemo.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">com</span>.ysy.methodarea.MethodAreaDemo</span><br><span class="line">  minor version: <span class="number">0</span></span><br><span class="line">  major version: <span class="number">52</span></span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #<span class="number">1</span> = Methodref          #<span class="number">5.</span>#<span class="number">24</span>         <span class="comment">// java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">   #<span class="number">2</span> = Fieldref           #<span class="number">25.</span>#<span class="number">26</span>        <span class="comment">// java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">   #<span class="number">3</span> = Methodref          #<span class="number">27.</span>#<span class="number">28</span>        <span class="comment">// java/io/PrintStream.println:(I)V</span></span><br><span class="line">   #<span class="number">4</span> = Class              #<span class="number">29</span>            <span class="comment">// com/ysy/methodarea/MethodAreaDemo</span></span><br><span class="line">   #<span class="number">5</span> = Class              #<span class="number">30</span>            <span class="comment">// java/lang/Object</span></span><br><span class="line">   #<span class="number">6</span> = Utf8               &lt;init&gt;</span><br><span class="line">   #<span class="number">7</span> = Utf8               ()V</span><br><span class="line">   #<span class="number">8</span> = Utf8               Code</span><br><span class="line">   #<span class="number">9</span> = Utf8               LineNumberTable</span><br><span class="line">  #<span class="number">10</span> = Utf8               LocalVariableTable</span><br><span class="line">  #<span class="number">11</span> = Utf8               <span class="built_in">this</span></span><br><span class="line">  #<span class="number">12</span> = Utf8               Lcom/ysy/methodarea/MethodAreaDemo;</span><br><span class="line">  #<span class="number">13</span> = Utf8               main</span><br><span class="line">  #<span class="number">14</span> = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">  #<span class="number">15</span> = Utf8               args</span><br><span class="line">  #<span class="number">16</span> = Utf8               [Ljava/lang/String;</span><br><span class="line">  #<span class="number">17</span> = Utf8               x</span><br><span class="line">  #<span class="number">18</span> = Utf8               I</span><br><span class="line">  #<span class="number">19</span> = Utf8               y</span><br><span class="line">  #<span class="number">20</span> = Utf8               a</span><br><span class="line">  #<span class="number">21</span> = Utf8               b</span><br><span class="line">  #<span class="number">22</span> = Utf8               SourceFile</span><br><span class="line">  #<span class="number">23</span> = Utf8               MethodAreaDemo.java</span><br><span class="line">  #<span class="number">24</span> = NameAndType        #<span class="number">6</span>:#<span class="number">7</span>          <span class="comment">// &quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">  #<span class="number">25</span> = Class              #<span class="number">31</span>            <span class="comment">// java/lang/System</span></span><br><span class="line">  #<span class="number">26</span> = NameAndType        #<span class="number">32</span>:#<span class="number">33</span>        <span class="comment">// out:Ljava/io/PrintStream;</span></span><br><span class="line">  #<span class="number">27</span> = Class              #<span class="number">34</span>            <span class="comment">// java/io/PrintStream</span></span><br><span class="line">  #<span class="number">28</span> = NameAndType        #<span class="number">35</span>:#<span class="number">36</span>        <span class="comment">// println:(I)V</span></span><br><span class="line">  #<span class="number">29</span> = Utf8               com/ysy/methodarea/MethodAreaDemo</span><br><span class="line">  #<span class="number">30</span> = Utf8               java/lang/Object</span><br><span class="line">  #<span class="number">31</span> = Utf8               java/lang/System</span><br><span class="line">  #<span class="number">32</span> = Utf8               out</span><br><span class="line">  #<span class="number">33</span> = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #<span class="number">34</span> = Utf8               java/io/PrintStream</span><br><span class="line">  #<span class="number">35</span> = Utf8               println</span><br><span class="line">  #<span class="number">36</span> = Utf8               (I)V</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> com.ysy.methodarea.MethodAreaDemo();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">         <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">3</span>: <span class="number">0</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">5</span>     <span class="number">0</span>  <span class="built_in">this</span>   Lcom/ysy/methodarea/MethodAreaDemo;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(java.lang.String[])</span>;</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">3</span>, locals=<span class="number">5</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: sipush        <span class="number">500</span></span><br><span class="line">         <span class="number">3</span>: istore_1</span><br><span class="line">         <span class="number">4</span>: bipush        <span class="number">100</span></span><br><span class="line">         <span class="number">6</span>: istore_2</span><br><span class="line">         <span class="number">7</span>: iload_1</span><br><span class="line">         <span class="number">8</span>: iload_2</span><br><span class="line">         <span class="number">9</span>: idiv</span><br><span class="line">        <span class="number">10</span>: istore_3</span><br><span class="line">        <span class="number">11</span>: bipush        <span class="number">50</span></span><br><span class="line">        <span class="number">13</span>: istore        <span class="number">4</span></span><br><span class="line">        <span class="number">15</span>: getstatic     #<span class="number">2</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">        <span class="number">18</span>: iload_3</span><br><span class="line">        <span class="number">19</span>: iload         <span class="number">4</span></span><br><span class="line">        <span class="number">21</span>: iadd</span><br><span class="line">        <span class="number">22</span>: invokevirtual #<span class="number">3</span>                  <span class="comment">// Method java/io/PrintStream.println:(I)V</span></span><br><span class="line">        <span class="number">25</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">5</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">6</span>: <span class="number">4</span></span><br><span class="line">        line <span class="number">7</span>: <span class="number">7</span></span><br><span class="line">        line <span class="number">8</span>: <span class="number">11</span></span><br><span class="line">        line <span class="number">9</span>: <span class="number">15</span></span><br><span class="line">        line <span class="number">10</span>: <span class="number">25</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>      <span class="number">26</span>     <span class="number">0</span>  args   [Ljava/lang/String;</span><br><span class="line">            <span class="number">4</span>      <span class="number">22</span>     <span class="number">1</span>     x   I</span><br><span class="line">            <span class="number">7</span>      <span class="number">19</span>     <span class="number">2</span>     y   I</span><br><span class="line">           <span class="number">11</span>      <span class="number">15</span>     <span class="number">3</span>     a   I</span><br><span class="line">           <span class="number">15</span>      <span class="number">11</span>     <span class="number">4</span>     b   I</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: <span class="string">&quot;MethodAreaDemo.java&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="图解字节码指令执行流程"><a href="#图解字节码指令执行流程" class="headerlink" title="图解字节码指令执行流程"></a>图解字节码指令执行流程</h3><p>1、初始状态</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220719141526151.png" alt="image-20220719141526151"></p>
<p>2、首先将操作数500压入操作数栈中</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220719141655132.png"></p>
<p>3、然后操作数 500 从操作数栈中取出，存储到局部变量表中索引为 1 的位置</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220719141740626.png"></p>
<p>4、</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220719141900727.png" alt="image-20220719141900727"></p>
<p>5、</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220719141922429.png" alt="image-20220719141922429"></p>
<p>6、</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220719142000240.png" alt="image-20220719142000240"></p>
<p>7、</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220719142024493.png" alt="image-20220719142024493"></p>
<p>8、</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220719142158460.png" alt="image-20220719142158460"></p>
<p>9、</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220719142216996.png" alt="image-20220719142216996"></p>
<p>10、</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220719142237318.png" alt="image-20220719142237318"></p>
<p>11、图片写错了是#25和#26（获得System类）</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220719142324555.png" alt="image-20220719142324555"></p>
<p>12、</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220719142527219.png" alt="image-20220719142527219"></p>
<p>13、</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220719142558500.png" alt="image-20220719142558500"></p>
<p>15、执行加法运算后，将计算结果放在操作数栈顶</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220719142635557.png" alt="image-20220719142635557"></p>
<p>16、就是真正的打印</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220719142613281.png" alt="image-20220719142613281"></p>
<p>17、</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220719142813644.png" alt="image-20220719142813644"></p>
<p><strong>符号引用 –&gt; 直接引用</strong></p>
<ol>
<li>上面代码调用 System.out.println() 方法时，首先需要看看 System 类有没有加载，再看看 PrintStream 类有没有加载</li>
<li>如果没有加载，则执行加载，执行时，将常量池中的符号引用（字面量）转换为运行时常量池的直接引用（真正的地址值）</li>
</ol>
<h1 id="方法区演进细节"><a href="#方法区演进细节" class="headerlink" title="方法区演进细节"></a>方法区演进细节</h1><h2 id="永久代演进过程"><a href="#永久代演进过程" class="headerlink" title="永久代演进过程"></a>永久代演进过程</h2><ol>
<li><p>首先明确：<strong>只有Hotspot才有永久代</strong>。BEA JRockit、IBMJ9等来说，是不存在永久代的概念的。原则上如何实现方法区属于虚拟机实现细节，不受《Java虚拟机规范》管束，并不要求统一</p>
</li>
<li><p>Hotspot中方法区的变化：</p>
</li>
</ol>
<table>
<thead>
<tr>
<th>JDK1.6及以前</th>
<th align="left">有永久代（permanent generation），静态变量存储在永久代上</th>
</tr>
</thead>
<tbody><tr>
<td>JDK1.7</td>
<td align="left">有永久代，但已经逐步 “去永久代”，<strong>字符串常量池，静态变量移除，保存在堆中</strong></td>
</tr>
<tr>
<td>JDK1.8</td>
<td align="left">无永久代，类型信息，字段，方法，常量保存在本地内存的元空间，但字符串常量池、静态变量仍然在堆中。</td>
</tr>
</tbody></table>
<p><strong>JDK6</strong></p>
<p>方法区由永久代实现，使用 JVM 虚拟机内存（虚拟的内存）</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220719151237691.png" alt="image-20220719151237691"></p>
<p><strong>JDK7</strong></p>
<p>方法区由永久代实现，使用 JVM 虚拟机内存</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220719151316363.png" alt="image-20220719151316363"></p>
<p><strong>JDK8</strong></p>
<p>方法区由元空间实现，使用物理机本地内存</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220719151340845.png" alt="image-20220719151340845"></p>
<h3 id="永久代为什么要被元空间替代？"><a href="#永久代为什么要被元空间替代？" class="headerlink" title="永久代为什么要被元空间替代？"></a>永久代为什么要被元空间替代？</h3><blockquote>
<p><strong>官方文档</strong>：<a target="_blank" rel="noopener" href="http://openjdk.java.net/jeps/122">http://openjdk.java.net/jeps/122</a></p>
</blockquote>
<ol>
<li>随着Java8的到来，HotSpot VM中再也见不到永久代了。但是这并不意味着类的元数据信息也消失了。这些数据被移到了一个与堆不相连的本地内存区域，这个区域叫做元空间（Metaspace）。</li>
<li>由于类的元数据分配在本地内存中，元空间的最大可分配空间就是系统可用内存空间。</li>
<li>这项改动是很有必要的，原因有：<ol>
<li><strong>为永久代设置空间大小是很难确定的。</strong>在某些场景下，如果动态加载类过多，容易产生Perm区的OOM。比如某个实际Web工程中，因为功能点比较多，在运行过程中，要不断动态加载很多类，经常出现致命错误。<code>Exception in thread &#39;dubbo client x.x connector&#39; java.lang.OutOfMemoryError:PermGen space</code>而元空间和永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。 因此，默认情况下，元空间的大小仅受本地内存限制。</li>
<li><strong>对永久代进行调优是很困难的。</strong>方法区的垃圾收集主要回收两部分内容：<strong>常量池中废弃的常量和不再用的类型</strong>，方法区的调优主要是为了降低<strong>Full GC</strong><ol>
<li>有些人认为方法区（如HotSpot虚拟机中的元空间或者永久代）是没有垃圾收集行为的，其实不然。《Java虚拟机规范》对方法区的约束是非常宽松的，提到过可以不要求虚拟机在方法区中实现垃圾收集。事实上也确实有未实现或未能完整实现方法区类型卸载的收集器存在（如JDK11时期的ZGC收集器就不支持类卸载）。</li>
<li>一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻**。但是这部分区域的回收有时又确实是必要的。以前Sun公司的Bug列表中，曾出现过的若干个严重的Bug就是由于低版本的HotSpot虚拟机对此区域未完全回收而导致内存泄漏。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="字符串常量池"><a href="#字符串常量池" class="headerlink" title="字符串常量池"></a>字符串常量池</h2><p><strong>字符串常量池 StringTable 为什么要调整位置？</strong></p>
<ul>
<li><p>JDK7中将StringTable放到了堆空间中。因为永久代的回收效率很低，在Full GC的时候才会执行永久代的垃圾回收，而Full GC是老年代的空间不足、永久代不足时才会触发。</p>
</li>
<li><p>这就导致StringTable回收效率不高，而我们开发中会有大量的字符串被创建，回收效率低，导致永久代内存不足。放到堆里，能及时回收内存。</p>
</li>
</ul>
<h2 id="静态变量放在哪里"><a href="#静态变量放在哪里" class="headerlink" title="静态变量放在哪里"></a>静态变量放在哪里</h2><h3 id="对象实体在哪里放着？"><a href="#对象实体在哪里放着？" class="headerlink" title="对象实体在哪里放着？"></a>对象实体在哪里放着？</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 结论：</span></span><br><span class="line"><span class="comment"> * 1、静态引用对应的对象实体(也就是这个new byte[1024 * 1024 * 100])始终都存在堆空间，</span></span><br><span class="line"><span class="comment"> * 2、只是那个变量(相当于下面的arr变量名)在JDK6,JDK7,JDK8存放位置中有所变化</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * jdk7：</span></span><br><span class="line"><span class="comment"> * -Xms200m -Xmx200m -XX:PermSize=300m -XX:MaxPermSize=300m -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment"> * jdk 8：</span></span><br><span class="line"><span class="comment"> * -Xms200m -Xmx200m -XX:MetaspaceSize=300m -XX:MaxMetaspaceSize=300m -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticFieldTest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">byte</span>[] arr = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">100</span>];<span class="comment">//100MB</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(StaticFieldTest.arr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JDK6环境下</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220719153501056.png" alt="image-20220719153501056"></p>
<p>JDK7环境下</p>
<img src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_006/0032.png">

<p>JDK8环境</p>
<img src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_006/0033.png">

<h3 id="变量-名-存放在哪里？"><a href="#变量-名-存放在哪里？" class="headerlink" title="变量(名)存放在哪里？"></a>变量(名)存放在哪里？</h3><p>这个问题需要用JHSDB工具来进行分析，这个工具是JDK9开始自带的(JDK9以前没有)，在bin目录下可以找到</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.java1;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 《深入理解Java虚拟机》中的案例：</span></span><br><span class="line"><span class="comment"> * staticObj、instanceObj、localObj存放在哪里？</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticObjTest</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="type">ObjectHolder</span> <span class="variable">staticObj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectHolder</span>();</span><br><span class="line">        <span class="type">ObjectHolder</span> <span class="variable">instanceObj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectHolder</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">ObjectHolder</span> <span class="variable">localObj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectHolder</span>();</span><br><span class="line">            System.out.println(<span class="string">&quot;done&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ObjectHolder</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StaticObjTest</span>.Test();</span><br><span class="line">        test.foo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>JDK6环境下</strong></p>
<p>1、staticObj随着Test的类型信息存放在方法区</p>
<p>2、instanceObj随着Test的对象实例存放在Java堆</p>
<p>3、localObject则是存放在foo()方法栈帧的局部变量表中。</p>
<p>4、测试发现：三个对象的数据在内存中的地址都落在Eden区范围内，所以结论：<strong>只要是对象实例必然会在Java堆中分配</strong>。</p>
<img src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_006/0034.png">

<blockquote>
<p>1、0x00007f32c7800000(Eden区的起始地址)    —-   0x00007f32c7b50000(Eden区的终止地址)  </p>
<p>2、可以发现三个变量都在这个范围内</p>
<p>3、所以可以得到上面结论</p>
</blockquote>
<p>5、接着，找到了一个引用该staticObj对象的地方，是在一个java.lang.Class的实例里，并且给出了这个实例的地址，通过Inspector查看该对象实例，可以清楚看到这确实是一个java.lang.Class类型的对象实例，里面有一个名为staticobj的实例字段：</p>
<img src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_006/0035.png">

<p>从《Java虚拟机规范》所定义的概念模型来看，所有Class相关的信息都应该存放在方法区之中，但方法区该如何实现，《Java虚拟机规范》并未做出规定，这就成了一件允许不同虚拟机自己灵活把握的事情。JDK7及其以后版本的HotSpot虚拟机选择把静态变量与类型在Java语言一端的映射Class对象存放在一起，<strong>存储于Java堆之中</strong>，从我们的实验中也明确验证了这一点</p>
<h1 id="方法区的垃圾回收"><a href="#方法区的垃圾回收" class="headerlink" title="方法区的垃圾回收"></a>方法区的垃圾回收</h1><ol>
<li><p>有些人认为方法区（如Hotspot虚拟机中的元空间或者永久代）是没有垃圾收集行为的，其实不然。《Java虚拟机规范》对方法区的约束是非常宽松的，提到过可以不要求虚拟机在方法区中实现垃圾收集。事实上也确实有未实现或未能完整实现方法区<strong>类型卸载</strong>的收集器存在（如JDK11时期的ZGC收集器就不支持类卸载）。</p>
</li>
<li><p>一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻。但是这部分区域的回收有时又确实是必要的。以前sun公司的Bug列表中，曾出现过的若干个严重的Bug就是由于低版本的HotSpot虚拟机对此区域未完全回收而导致内存泄漏。</p>
</li>
<li><p>方法区的垃圾收集主要回收两部分内容：<strong>常量池中废弃的常量和不再使用的类型</strong>。</p>
</li>
<li><p>先来说说方法区内常量池之中主要存放的两大类常量：字面量和符号引用。字面量比较接近Java语言层次的常量概念，如文本字符串、被声明为final的常量值等。而符号引用则属于编译原理方面的概念，包括下面三类常量：</p>
<ul>
<li>类和接口的全限定名</li>
<li>字段的名称和描述符</li>
<li>方法的名称和描述符</li>
</ul>
</li>
<li><p>HotSpot虚拟机对常量池的回收策略是很明确的，只要常量池中的常量没有被任何地方引用，就可以被回收。</p>
</li>
<li><p>回收废弃常量与回收Java堆中的对象非常类似。（关于常量的回收比较简单，重点是类的回收）</p>
</li>
</ol>
<p>下面也称作<strong>类卸载</strong></p>
<p>1、判定一个常量是否“废弃”还是相对简单，而要判定一个类型是否属于“不再被使用的类”的条件就比较苛刻了。需要同时满足下面三个条件：</p>
<ul>
<li><p>该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例。</p>
</li>
<li><p>加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如OSGi、JSP的重加载等，否则通常是很难达成的。</p>
</li>
<li><p>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</p>
</li>
</ul>
<p>2、Java虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是“被允许”，而并不是和对象一样，没有引用了就必然会回收。关于是否要对类型进行回收，HotSpot虚拟机提供了<code>-Xnoclassgc</code>参数进行控制，还可以使用<code>-verbose:class</code> 以及 <code>-XX：+TraceClass-Loading</code>、<code>-XX：+TraceClassUnLoading</code>查看类加载和卸载信息</p>
<p>3、在大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及OSGi这类频繁自定义类加载器的场景中，通常都需要Java虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压力。</p>
<h1 id="运行时数据区总结"><a href="#运行时数据区总结" class="headerlink" title="运行时数据区总结"></a>运行时数据区总结</h1><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220719155003196.png" alt="image-20220719155003196"></p>
<h1 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h1><ol>
<li>百度<ul>
<li>三面：说一下JVM内存模型吧，有哪些区？分别干什么的？</li>
</ul>
</li>
<li>蚂蚁金服：<ul>
<li>Java8的内存分代改进</li>
<li>JVM内存分哪几个区，每个区的作用是什么？</li>
<li>一面：JVM内存分布&#x2F;内存结构？栈和堆的区别？堆的结构？为什么两个survivor区？</li>
<li>二面：Eden和survior的比例分配</li>
</ul>
</li>
<li>小米：<ul>
<li>jvm内存分区，为什么要有新生代和老年代</li>
</ul>
</li>
<li>字节跳动：<ul>
<li>二面：Java的内存分区</li>
<li>二面：讲讲vm运行时数据库区</li>
<li>什么时候对象会进入老年代？</li>
</ul>
</li>
<li>京东：<ul>
<li>JVM的内存结构，Eden和Survivor比例。</li>
<li>JVM内存为什么要分成新生代，老年代，持久代。新生代中为什么要分为Eden和survivor。</li>
</ul>
</li>
<li>天猫：<ul>
<li>一面：Jvm内存模型以及分区，需要详细到每个区放什么。</li>
<li>一面：JVM的内存模型，Java8做了什么改</li>
</ul>
</li>
<li>拼多多：<ul>
<li>JVM内存分哪几个区，每个区的作用是什么？</li>
</ul>
</li>
<li>美团：<ul>
<li>java内存分配</li>
<li>jvm的永久代中会发生垃圾回收吗？</li>
<li>一面：jvm内存分区，为什么要有新生代和老年代？</li>
</ul>
</li>
</ol>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-数据结构与算法：栈"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
	
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/07/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%9A%E6%A0%88/"
    >栈</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/07/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%9A%E6%A0%88/" class="article-date">
  <time datetime="2022-07-18T11:21:06.000Z" itemprop="datePublished">2022-07-18</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a> / <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%88/">栈</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h1><ul>
<li>栈的英文为(stack)</li>
<li>栈是一个<strong>先入后出</strong>(FILO-First In Last Out)的有序列表。</li>
<li>栈(stack)是限制线性表中元素的插入和删除<strong>只能在线性表的同一端</strong>进行的一种特殊线性表。允许插入和删除的一端，为变化的一端，称为栈顶(Top)，另一端为固定的一端，称为栈底(Bottom)。</li>
<li>根据栈的定义可知，最先放入栈中元素在栈底，最后放入的元素在栈顶，而删除元素刚好相反，最后放入的元素最先删除，最先放入的元素最后删除</li>
<li>图解方式说明**出栈(pop)<strong>和</strong>入栈(push)**的概念</li>
</ul>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220718192957959.png" alt="出栈入栈操作"></p>
<h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><ul>
<li>子程序的调用:在跳往子程序前，会先将下个指令的地址存到堆栈中，直到子程序执行完后再将地址取出，以回到原来的程序中。</li>
<li>处理递归调用:和子程序的调用类似，只是除了储存下一个指令的地址外，也将参数、区域变量等数据存入堆栈中。</li>
<li>表达式的转换[中缀表达式转后缀表达式]与求值(实际解决)。</li>
<li>二叉树的遍历。</li>
<li>图形的深度优先(depth一 first)搜索法。</li>
</ul>
<h1 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h1><ul>
<li><p>用数组模拟栈的使用，由于栈是一种有序列表，当然可以使用数组的结构来储存栈的数据内容，下面我们就用数组模拟栈的出栈，入栈等操作。</p>
</li>
<li><p><strong>思路分析</strong></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220718193728413.png" alt="image-20220718193728413"></p>
<ol>
<li>使用数组来模拟栈</li>
<li>定义一个<strong>top</strong>来表示栈顶，<strong>初始化为 -1</strong></li>
<li>入柱的操作：当有数据加入到栈时，<strong>top++；</strong>   <strong>stack[top] &#x3D;data；</strong></li>
<li>出栈的操作：<strong>int value &#x3D; stack[top]；  top–；   return value；</strong></li>
</ol>
</li>
<li><p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ysy.stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayStackDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//测试栈</span></span><br><span class="line">        <span class="type">ArrayStack</span> <span class="variable">stack</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayStack</span>(<span class="number">4</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">loop</span> <span class="operator">=</span> <span class="literal">true</span>;<span class="comment">//控制是否退出菜单</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span> (loop)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;show: 表示显示栈&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;exit: 表示退出栈&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;push: 表示入栈&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;pop: 表示出栈&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;请输入你的选择~&quot;</span>);</span><br><span class="line">            key = sc.next();</span><br><span class="line">            <span class="keyword">switch</span> (key)&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;show&quot;</span>:</span><br><span class="line">                    stack.list();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;push&quot;</span>:</span><br><span class="line">                    System.out.println(<span class="string">&quot;请输入一个数~&quot;</span>);</span><br><span class="line">                    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">                    stack.push(i);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;pop&quot;</span>:</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                        System.out.printf(<span class="string">&quot;出栈的数据是%d\n&quot;</span>, res);</span><br><span class="line"></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;exit&quot;</span>:</span><br><span class="line">                    sc.close();</span><br><span class="line">                    loop = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;程序已退出&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个ArrayStack,模拟出栈入栈操作</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayStack</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> maxSize;<span class="comment">//栈大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] stack;<span class="comment">//定义一个数组用来模拟栈</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">top</span> <span class="operator">=</span> -<span class="number">1</span>;<span class="comment">//定义一个**top**来表示栈顶，初始化为 -1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayStack</span><span class="params">(<span class="type">int</span> maxSize)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.maxSize = maxSize;</span><br><span class="line">        stack = <span class="keyword">new</span> <span class="title class_">int</span>[maxSize];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断栈满</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">return</span> <span class="variable">top</span> <span class="operator">=</span>= maxSize - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断栈空</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">return</span> <span class="variable">top</span> <span class="operator">=</span>= - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//入栈</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> value)</span>&#123;</span><br><span class="line">        <span class="comment">//判断栈是否满</span></span><br><span class="line">        <span class="keyword">if</span>(isFull())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;栈满&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        top++;</span><br><span class="line">        stack[top] = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//出栈</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//判断栈是否空</span></span><br><span class="line">        <span class="keyword">if</span>(isEmpty())&#123;</span><br><span class="line">            <span class="comment">//抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;栈空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> stack[top];</span><br><span class="line">        top--;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历栈，从栈顶开始</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">list</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isEmpty())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;栈空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> top; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;stack[%d]=%d\n&quot;</span>, i, stack[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="栈实现综合计算器-中缀表达式"><a href="#栈实现综合计算器-中缀表达式" class="headerlink" title="栈实现综合计算器(中缀表达式)"></a>栈实现综合计算器(中缀表达式)</h1><ul>
<li>就是最常见的运算表达式，如：(3 + 4) × 5 - 6</li>
<li>中缀表达式求值对计算机来说不好操作，因此在计算时往往转换为后缀表达式</li>
</ul>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220718202450431.png" alt="image-20220718202450431"></p>
<ul>
<li><p>请问:计算机底层是如何运算得到结果的? 注意不是简单的把算式列出运算,因为我们看这个算式7×2×2-5+1-5×3-3，但是计算机怎么理解这个算式的(对计算机而言，它接收到的就是一个字符串)，我们讨论的是这个问题</p>
</li>
<li><p><strong>思路分析</strong></p>
<ol>
<li><p>通过一个index值《索引》,来遍历我们的表达式</p>
</li>
<li><p>如果我们发现是一个数字,就直接入数栈</p>
<ul>
<li>当处理多位数时，需要向表达式的index后再看一位，如果是数就进行扫描，如果是符号才入栈</li>
</ul>
</li>
<li><p>如果发现扫描到是一个符号,就分如下情况</p>
<ul>
<li><p>如果发现当前的符号栈为空，就直接入栈</p>
</li>
<li><p>如果符号栈有操作符，就进行比较,如果<strong>当前的操作符的优先级小于或者等于栈中的操作符</strong>，就需要<strong>从数栈中pop出两个数,在从符号栈中pop出一个符号，进行运算，将得到结果，入数栈，然后将当前的操作符入符号栈</strong>，<strong>如果当前的操作符的优先级大于栈中的操作符,就直接入符号栈.</strong></p>
</li>
</ul>
</li>
<li><p>当表达式扫描完毕,就顺序的从数栈和符号栈中pop出相应的数和符号，并运行.</p>
</li>
<li><p>最后在数栈只有一个数字,就是表达式的结果</p>
</li>
</ol>
</li>
<li><p><strong>代码实现</strong></p>
</li>
</ul>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ysy.stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 一位数的加减乘除运算</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Calculator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//完成表达式的运算</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">expression</span> <span class="operator">=</span> <span class="string">&quot;70+2*6-4&quot;</span>;</span><br><span class="line">        <span class="comment">//创建两个栈：数栈和符号栈</span></span><br><span class="line">        <span class="type">ArrayStack2</span> <span class="variable">numStack</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayStack2</span>(<span class="number">10</span>);</span><br><span class="line">        <span class="type">ArrayStack2</span> <span class="variable">operStack</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayStack2</span>(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">//定义需要的相关变量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//用于扫描</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">oper</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> <span class="string">&#x27; &#x27;</span>;<span class="comment">//将每次扫描后的char保存到ch</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">keepNum</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;<span class="comment">//用于拼接多位数</span></span><br><span class="line">        <span class="comment">//开始while循环的扫描expression</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="comment">//依次得到expression的每个字符</span></span><br><span class="line">            ch = expression.substring(index, index+<span class="number">1</span>).charAt(<span class="number">0</span>);</span><br><span class="line">            <span class="comment">//判断是否是符号，然后做相应的处理</span></span><br><span class="line">            <span class="keyword">if</span>(operStack.isOper(ch))&#123;<span class="comment">//如果是运算符</span></span><br><span class="line">                <span class="comment">//判断符号栈是否为空</span></span><br><span class="line">                <span class="keyword">if</span>(!operStack.isEmpty())&#123;</span><br><span class="line">                    <span class="comment">// 如果符号栈有操作符，就进行比较,如果当前的操作符的优先级小于或者等于栈中的操作符，就需要从数栈中pop出两个数,</span></span><br><span class="line">                    <span class="comment">// 在从符号栈中pop出一个符号，进行运算，将得到结果，入数栈，然后将当前的操作符入符号栈，</span></span><br><span class="line">                    <span class="keyword">if</span>(operStack.priority(ch) &lt;= operStack.priority(operStack.peek()))&#123;</span><br><span class="line">                        num1 = numStack.pop();</span><br><span class="line">                        num2 = numStack.pop();</span><br><span class="line">                        oper = operStack.pop();</span><br><span class="line">                        res = numStack.cal(num1, num2, oper);</span><br><span class="line">                        <span class="comment">//把运算的结果入数栈</span></span><br><span class="line">                        numStack.push(res);</span><br><span class="line">                        <span class="comment">//将当前的操作符入符号栈</span></span><br><span class="line">                        operStack.push(ch);</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 如果当前的操作符的优先级大于栈中的操作符,就直接入符号栈.</span></span><br><span class="line">                        operStack.push(ch);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//如果发现当前的符号栈为空，就直接入栈</span></span><br><span class="line">                    operStack.push(ch);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//如果我们发现是一个数字,就直接入数栈</span></span><br><span class="line">                <span class="comment">//numStack.push(ch - 48);</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//处理多位数</span></span><br><span class="line">                keepNum += ch;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//如果ch已经是expression的最后一位，就直接入栈</span></span><br><span class="line">                <span class="keyword">if</span>(index == expression.length() - <span class="number">1</span>)&#123;</span><br><span class="line">                    numStack.push(Integer.parseInt(keepNum));</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//当处理多位数时，需要向expression表达式的index后再看一位，如果是数就进行扫描，如果是符号才入栈</span></span><br><span class="line">                    <span class="keyword">if</span>(operStack.isOper(expression.substring(index+<span class="number">1</span>, index+<span class="number">2</span>).charAt(<span class="number">0</span>)))&#123;</span><br><span class="line">                        <span class="comment">//后一位是运算符</span></span><br><span class="line">                        numStack.push(Integer.parseInt(keepNum));</span><br><span class="line">                        <span class="comment">//清空keepNum</span></span><br><span class="line">                        keepNum = <span class="string">&quot;&quot;</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//index+1，并判断是否扫描到expression的最后</span></span><br><span class="line">            index++;</span><br><span class="line">            <span class="keyword">if</span>(index &gt;= expression.length())&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当表达式扫描完毕,就顺序的从数栈和符号栈中pop出相应的数和符号，并运行</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="comment">//如果符号栈为空，则数栈中只有一个数-&gt;结果</span></span><br><span class="line">            <span class="keyword">if</span>(operStack.isEmpty())&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            num1 = numStack.pop();</span><br><span class="line">            num2 = numStack.pop();</span><br><span class="line">            oper = operStack.pop();</span><br><span class="line">            res = numStack.cal(num1, num2, oper);</span><br><span class="line">            numStack.push(res);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.printf(<span class="string">&quot;表达式 %s = %d&quot;</span>, expression, numStack.pop());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个ArrayStack,模拟出栈入栈操作</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayStack2</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> maxSize;<span class="comment">//栈大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] stack;<span class="comment">//定义一个数组用来模拟栈</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">top</span> <span class="operator">=</span> -<span class="number">1</span>;<span class="comment">//定义一个**top**来表示栈顶，初始化为 -1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayStack2</span><span class="params">(<span class="type">int</span> maxSize)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.maxSize = maxSize;</span><br><span class="line">        stack = <span class="keyword">new</span> <span class="title class_">int</span>[maxSize];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回当前栈顶的值，不是pop</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack[top];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断栈满</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">return</span> <span class="variable">top</span> <span class="operator">=</span>= maxSize - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断栈空</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">return</span> <span class="variable">top</span> <span class="operator">=</span>= - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//入栈</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> value)</span>&#123;</span><br><span class="line">        <span class="comment">//判断栈是否满</span></span><br><span class="line">        <span class="keyword">if</span>(isFull())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;栈满&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        top++;</span><br><span class="line">        stack[top] = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//出栈</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//判断栈是否空</span></span><br><span class="line">        <span class="keyword">if</span>(isEmpty())&#123;</span><br><span class="line">            <span class="comment">//抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;栈空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> stack[top];</span><br><span class="line">        top--;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历栈，从栈顶开始</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">list</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isEmpty())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;栈空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> top; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;stack[%d]=%d\n&quot;</span>, i, stack[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回运算符的优先级，优先级由程序员确定，使用数字表示，数字越大，优先级越大</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">priority</span><span class="params">(<span class="type">int</span> oper)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(oper == <span class="string">&#x27;*&#x27;</span> || oper == <span class="string">&#x27;/&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(oper == <span class="string">&#x27;+&#x27;</span> || oper == <span class="string">&#x27;-&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">return</span> -<span class="number">1</span>;<span class="comment">//假设目前的表达式只有+, -, *, /</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断是否是运算符</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isOper</span><span class="params">(<span class="type">char</span> val)</span>&#123;</span><br><span class="line">        <span class="type">return</span> <span class="variable">val</span> <span class="operator">=</span>= <span class="string">&#x27;+&#x27;</span> || val == <span class="string">&#x27;-&#x27;</span> || val == <span class="string">&#x27;*&#x27;</span> || val == <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">cal</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2, <span class="type">int</span> oper)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//用于存储计算结果</span></span><br><span class="line">        <span class="keyword">switch</span> (oper) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                res = num1 + num2;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                res = num2 - num1;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                res = num1 * num2;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">                res = num2 / num1;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="前缀表达式-波兰表达式"><a href="#前缀表达式-波兰表达式" class="headerlink" title="前缀表达式(波兰表达式)"></a>前缀表达式(波兰表达式)</h1><ul>
<li>前缀表达式的运算符位于操作数之前</li>
<li>前缀表达式的计算机求值<ul>
<li>从右至左扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算（栈顶元素和次顶元素)，并将结果入栈;重复上述过程直到表达式最左端，最后运算得出的值即为表达式的结果</li>
<li>例如：<code>(3 + 4) × 5 - 6</code> 对应的前缀表达式为 <code>- × + 3 4 5 6</code>，求值步骤如下<ol>
<li>从右至左扫描，将6、5、4、3压入堆栈</li>
<li>遇到 + 运算符，因此弹出3和4(3为栈顶元素，4为次顶元素），计算出 3 + 4 的值，得7, 再将7入栈</li>
<li>接下来是 × 运算符，因此弹出7和5，计算出7 × 5 &#x3D; 35，将35入栈</li>
<li>最后是 - 运算符，计算出35 - 6的值，即29，由此得出最终结果</li>
</ol>
</li>
</ul>
</li>
</ul>
<h1 id="后缀表达式-逆波兰表达式"><a href="#后缀表达式-逆波兰表达式" class="headerlink" title="后缀表达式(逆波兰表达式)"></a>后缀表达式(逆波兰表达式)</h1><ul>
<li><p>后缀表达式的运算符位于操作数之后</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220720200654526.png" alt="image-20220720200654526"></p>
</li>
<li><p>后缀表达式的计算机求值</p>
<ul>
<li>从左至右扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算（次顶元素和栈顶元素〉，并将结果入栈;重复上述过程直到表达式最右端，最后运算得出的值即为表达式的结果</li>
<li>例如：<code>(3 + 4) × 5 - 6</code> 对应的后缀表达式就是 <code>3 4 + 5 × 6 -</code>，求值步骤如下<ol>
<li>从左至右扫描，将3和4压入堆栈;</li>
<li>遇到 + 运算符，因此弹出4和3(4为栈顶元素，3为次顶元素），计算出3+4的值，得7，再将7入栈;</li>
<li>将5入栈;</li>
<li>接下来是 × 运算符，因此弹出5和7，计算出7×5&#x3D;35，将35入栈;</li>
<li>将6入栈;</li>
<li>最后是 - 运算符，计算出35-6的值，即29，由此得出最终结果</li>
</ol>
</li>
</ul>
</li>
</ul>
<h1 id="逆波兰计算器"><a href="#逆波兰计算器" class="headerlink" title="逆波兰计算器"></a>逆波兰计算器</h1><ul>
<li>输入一个逆波兰表达式，使用栈计算其结果</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ysy.stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PolandNotation</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//先定义一个逆波兰表达式</span></span><br><span class="line">        <span class="comment">//(3 + 4) × 5 - 6 对应的后缀表达式就是 3 4 + 5 × 6 -</span></span><br><span class="line">        <span class="comment">//为了方便，逆波兰表达式中的数字和符号使用空格隔开</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">suffixExpression</span> <span class="operator">=</span> <span class="string">&quot;3 4 + 5 * 6 -&quot;</span>;</span><br><span class="line">        <span class="comment">//思路</span></span><br><span class="line">        <span class="comment">//1.先将suffixExpression=&gt;放到ArrayList中</span></span><br><span class="line">        <span class="comment">//2.将ArrayList传递给一个方法，遍历ArrayList，配合栈运算</span></span><br><span class="line">        List&lt;String&gt; rpnList = getListString(suffixExpression);</span><br><span class="line">        System.out.println(rpnList);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> calculate(rpnList);</span><br><span class="line">        System.out.println(<span class="string">&quot;(3 + 4) × 5 - 6 = &quot;</span> + res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//一个逆波兰表达式，依次将数据和运算符 放入到ArrayList中</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">getListString</span><span class="params">(String suffixExpression)</span>&#123;</span><br><span class="line">        <span class="comment">//将suffixExpression分割</span></span><br><span class="line">        String[] split = suffixExpression.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String s : split) &#123;</span><br><span class="line">            list.add(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//完成对逆波兰表达式的运算</span></span><br><span class="line">    <span class="comment">/*1. 从左至右扫描，将3和4压入堆栈;</span></span><br><span class="line"><span class="comment">        2. 遇到 + 运算符，因此弹出4和3(4为栈顶元素，3为次顶元素），计算出3+4的值，得7，再将7入栈;</span></span><br><span class="line"><span class="comment">        3. 将5入栈;</span></span><br><span class="line"><span class="comment">        4. 接下来是 × 运算符，因此弹出5和7，计算出7×5=35，将35入栈;</span></span><br><span class="line"><span class="comment">        5. 将6入栈;</span></span><br><span class="line"><span class="comment">        6. 最后是 - 运算符，计算出35-6的值，即29，由此得出最终结果*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">calculate</span><span class="params">(List&lt;String&gt; ls)</span>&#123;</span><br><span class="line">        <span class="comment">//创建栈，只需要一个</span></span><br><span class="line">        Stack&lt;String&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//遍历ls</span></span><br><span class="line">        <span class="keyword">for</span> (String item : ls) &#123;</span><br><span class="line">            <span class="comment">//正则表达式取值</span></span><br><span class="line">            <span class="keyword">if</span>(item.matches(<span class="string">&quot;\\d+&quot;</span>))&#123;<span class="comment">//匹配的是多位数</span></span><br><span class="line">                <span class="comment">//入栈</span></span><br><span class="line">                stack.push(item);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//pop出两个数，并运算，再入栈</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> Integer.parseInt(stack.pop());</span><br><span class="line">                <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> Integer.parseInt(stack.pop());</span><br><span class="line">                <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(item.equals(<span class="string">&quot;+&quot;</span>))&#123;</span><br><span class="line">                    res = num1 + num2;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(item.equals(<span class="string">&quot;-&quot;</span>))&#123;</span><br><span class="line">                    res = num1 - num2;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(item.equals(<span class="string">&quot;*&quot;</span>))&#123;</span><br><span class="line">                    res = num1 * num2;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(item.equals(<span class="string">&quot;/&quot;</span>))&#123;</span><br><span class="line">                    res = num1 / num2;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;运算符有误&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//把res入栈</span></span><br><span class="line">                stack.push(res + <span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后留在stack中的数据是运算结果</span></span><br><span class="line">        <span class="keyword">return</span> Integer.parseInt(stack.pop());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="中缀表达式转后缀表达式"><a href="#中缀表达式转后缀表达式" class="headerlink" title="中缀表达式转后缀表达式"></a>中缀表达式转后缀表达式</h1><ul>
<li><p><strong>思路</strong></p>
<ol>
<li>初始化两个栈:运算符栈s1和储存中间结果的栈s2;</li>
<li>从左至右扫描中缀表达式;</li>
<li>遇到操作数时，将其压s2;</li>
<li>遇到运算符时，比较其与s1栈顶运算符的优先级:<ol>
<li>如果s1为空，或栈顶运算符为左括号“(”，则直接将此运算符入栈;</li>
<li>否则，若优先级比栈顶运算符的高，也将运算符压入s1;</li>
<li>否则，将s1栈顶的运算符弹出并压入到s2中，再次转到(4.1)与s1中新的栈顶运算符相比较;</li>
</ol>
</li>
<li>遇到括号时:<ol>
<li>如果是左括号“(”，则直接压入s1</li>
<li>如果是右括号“)”，则依次弹出s1栈顶的运算符，并压入s2，直到遇到左括号为止，此时将这一对括号丢弃</li>
</ol>
</li>
<li>重复步骤2至5，直到表达式的最右边</li>
<li>将s1中剩余的运算符依次弹出并压入s2</li>
<li>依次弹出s2中的元素并输出，结果的逆序即为中缀表达式对应的后缀表达式</li>
</ol>
</li>
<li><p><strong>实例</strong></p>
<ul>
<li><p>将中缀表达式 <code>1 + ((2 + 3) × 4) - 5</code> 转换为后缀表达式的过程如下</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220720210413100.png" alt="image-20220720210413100"></p>
</li>
</ul>
</li>
<li><p><strong>代码实现</strong></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ysy.stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InfixToSuffix</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//完成将中缀表达式转换为后缀表达式</span></span><br><span class="line">        <span class="comment">//1 + ((2 + 3) × 4) - 5 =》1 2 3 + 4 * + 5 -</span></span><br><span class="line">        <span class="comment">//直接对str进行操作，不方便，因此 先将中缀表达式转为对应的ArrayList</span></span><br><span class="line">        <span class="comment">//将得到的中缀表达式对应的List =&gt; 后缀表达式对应的List</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">expression</span> <span class="operator">=</span> <span class="string">&quot;1+((2+3)*4)-5&quot;</span>;</span><br><span class="line">        List&lt;String&gt; infixExpressionList = toInfixExpressionList(expression);</span><br><span class="line">        System.out.println(<span class="string">&quot;中缀表达式对应的List：&quot;</span> + infixExpressionList);<span class="comment">//[1, +, (, (, 2, +, 3, ), ×, 4, ), -, 5]</span></span><br><span class="line">        List&lt;String&gt; suffixExpressionList = parseSuffixExpressionList(infixExpressionList);</span><br><span class="line">        System.out.println(<span class="string">&quot;后缀表达式对应的List：&quot;</span> + suffixExpressionList);</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> calculate(suffixExpressionList);</span><br><span class="line">        System.out.println(<span class="string">&quot;1 + ((2 + 3) × 4) - 5 = &quot;</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将得到的中缀表达式对应的List =&gt; 后缀表达式对应的List</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">parseSuffixExpressionList</span><span class="params">(List&lt;String&gt; ls)</span>&#123;</span><br><span class="line">        <span class="comment">//定义两个栈</span></span><br><span class="line">        Stack&lt;String&gt; s1 = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;String&gt;();<span class="comment">//符号栈</span></span><br><span class="line">        <span class="comment">//因为s2在整个转换过程中没有pop操作，且后面还要逆序输出，因此直接使用List&lt;String&gt;代替</span></span><br><span class="line">        List&lt;String&gt; s2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//遍历ls</span></span><br><span class="line">        <span class="keyword">for</span> (String item : ls) &#123;</span><br><span class="line">            <span class="comment">//如果是一个数，就加入到s2</span></span><br><span class="line">            <span class="keyword">if</span>(item.matches(<span class="string">&quot;\\d+&quot;</span>))&#123;</span><br><span class="line">                s2.add(item);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(item.equals(<span class="string">&quot;(&quot;</span>))&#123;</span><br><span class="line">                s1.push(item);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(item.equals(<span class="string">&quot;)&quot;</span>))&#123;</span><br><span class="line">                <span class="comment">//如果是右括号“)”，则依次弹出s1栈顶的运算符，并压入s2，直到遇到左括号为止，此时将这一对括号丢弃</span></span><br><span class="line">                <span class="keyword">while</span> (!s1.peek().equals(<span class="string">&quot;(&quot;</span>))&#123;</span><br><span class="line">                    s2.add(s1.pop());</span><br><span class="line">                &#125;</span><br><span class="line">                s1.pop();<span class="comment">//!!!将 （ 弹出s1栈，消除小括号</span></span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//当item的优先级小于等于栈顶运算符，将s1栈顶的运算符弹出并压入到s2中，再次转到(4-1)与s1中新的栈顶运算符相比较</span></span><br><span class="line">                <span class="keyword">while</span> (s1.size() != <span class="number">0</span> &amp;&amp; Operation.getValue(s1.peek()) &gt;= Operation.getValue(item))&#123;</span><br><span class="line">                    s2.add(s1.pop());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//还需要将item压入栈中</span></span><br><span class="line">                s1.push(item);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将s1中剩余的运算符依次弹出并压入s2</span></span><br><span class="line">        <span class="keyword">while</span> (s1.size() != <span class="number">0</span>)&#123;</span><br><span class="line">            s2.add(s1.pop());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> s2;<span class="comment">//因为是存放到List，因此按顺序输出就是对应的后缀表达式对应的List</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将中缀表达式转成对应的list</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">toInfixExpressionList</span><span class="params">(String s)</span>&#123;</span><br><span class="line">        <span class="comment">//定义一个List，存放中缀表达式对应的内容</span></span><br><span class="line">        List&lt;String&gt; ls = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//指针，用来遍历中缀表达式的内容</span></span><br><span class="line">        String str;<span class="comment">//对多位数进行拼接</span></span><br><span class="line">        <span class="type">char</span> c;<span class="comment">//每遍历到一个字符，就放入c</span></span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            <span class="comment">//如果C是一个非数字，加入到ls</span></span><br><span class="line">            <span class="keyword">if</span>((c=s.charAt(i)) &lt; <span class="number">48</span> || (c=s.charAt(i)) &gt; <span class="number">57</span>)&#123;</span><br><span class="line">                ls.add(c + <span class="string">&quot;&quot;</span>);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//如果是一个数，需要考虑多位数问题</span></span><br><span class="line">                str = <span class="string">&quot;&quot;</span>;<span class="comment">//将str置空</span></span><br><span class="line">                <span class="keyword">while</span> (i &lt; s.length() &amp;&amp; (c=s.charAt(i)) &gt;= <span class="number">48</span> &amp;&amp; (c=s.charAt(i)) &lt;= <span class="number">57</span>)&#123;</span><br><span class="line">                    str += c;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                ls.add(str);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">while</span> (i &lt; s.length());</span><br><span class="line">        <span class="keyword">return</span> ls;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//一个逆波兰表达式，依次将数据和运算符 放入到ArrayList中</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">getListString</span><span class="params">(String suffixExpression)</span>&#123;</span><br><span class="line">        <span class="comment">//将suffixExpression分割</span></span><br><span class="line">        String[] split = suffixExpression.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String s : split) &#123;</span><br><span class="line">            list.add(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//完成对逆波兰表达式的运算</span></span><br><span class="line">    <span class="comment">/*1. 从左至右扫描，将3和4压入堆栈;</span></span><br><span class="line"><span class="comment">        2. 遇到 + 运算符，因此弹出4和3(4为栈顶元素，3为次顶元素），计算出3+4的值，得7，再将7入栈;</span></span><br><span class="line"><span class="comment">        3. 将5入栈;</span></span><br><span class="line"><span class="comment">        4. 接下来是 × 运算符，因此弹出5和7，计算出7×5=35，将35入栈;</span></span><br><span class="line"><span class="comment">        5. 将6入栈;</span></span><br><span class="line"><span class="comment">        6. 最后是 - 运算符，计算出35-6的值，即29，由此得出最终结果*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">calculate</span><span class="params">(List&lt;String&gt; ls)</span>&#123;</span><br><span class="line">        <span class="comment">//创建栈，只需要一个</span></span><br><span class="line">        Stack&lt;String&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//遍历ls</span></span><br><span class="line">        <span class="keyword">for</span> (String item : ls) &#123;</span><br><span class="line">            <span class="comment">//正则表达式取值</span></span><br><span class="line">            <span class="keyword">if</span>(item.matches(<span class="string">&quot;\\d+&quot;</span>))&#123;<span class="comment">//匹配的是多位数</span></span><br><span class="line">                <span class="comment">//入栈</span></span><br><span class="line">                stack.push(item);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//pop出两个数，并运算，再入栈</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> Integer.parseInt(stack.pop());</span><br><span class="line">                <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> Integer.parseInt(stack.pop());</span><br><span class="line">                <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(item.equals(<span class="string">&quot;+&quot;</span>))&#123;</span><br><span class="line">                    res = num1 + num2;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(item.equals(<span class="string">&quot;-&quot;</span>))&#123;</span><br><span class="line">                    res = num1 - num2;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(item.equals(<span class="string">&quot;*&quot;</span>))&#123;</span><br><span class="line">                    res = num1 * num2;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(item.equals(<span class="string">&quot;/&quot;</span>))&#123;</span><br><span class="line">                    res = num1 / num2;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;运算符有误&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//把res入栈</span></span><br><span class="line">                stack.push(res + <span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后留在stack中的数据是运算结果</span></span><br><span class="line">        <span class="keyword">return</span> Integer.parseInt(stack.pop());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//编写一个类Operation，返回一个运算符对应的优先级</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Operation</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">ADD</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">SUB</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MUL</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">DIV</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getValue</span><span class="params">(String operation)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">switch</span> (operation) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;+&quot;</span>:</span><br><span class="line">                result = ADD;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;-&quot;</span>:</span><br><span class="line">                result = SUB;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;*&quot;</span>:</span><br><span class="line">                result = MUL;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;/&quot;</span>:</span><br><span class="line">                result = DIV;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;不存在该运算符~&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-数据结构与算法：约瑟夫环"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
	
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/07/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%9A%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF/"
    >(单向环形链表)约瑟夫环</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/07/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%9A%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF/" class="article-date">
  <time datetime="2022-07-16T13:31:05.000Z" itemprop="datePublished">2022-07-16</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a> / <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/">链表</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h1><ul>
<li>Joseph(约瑟夫、约瑟夫环)问题<ul>
<li>设编号为1，2，… n的n个人围坐一圈，约定编号为k (&lt;&#x3D;k&lt;&#x3D;n)的人从1开始报数，数到m 的那个人出列,它的下一位又从1开始报数，数到m的那个人又出列，依次类推，直到所有人出列为止，由此产生一个出队编号的序列。</li>
</ul>
</li>
</ul>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220716213807128.png" alt="image-20220716213807128"></p>
<ul>
<li><p>提示</p>
<ul>
<li>用一个不带头结点的循环链表来处理Josephu问题:先构成一个有n个结点的单循环链表，然后由k结点起从1开始计数，计到m时，对应结点从链表中删除，然后再从被删除结点的下一个结点又从1开始计数，直到最后一个结点从链表中删除算法结束。</li>
</ul>
</li>
<li><p>Joseph问题–&gt;创建单向环形链表思路</p>
<ul>
<li><p>构建一个单向的环形链表思路</p>
<ol>
<li>先创建第一个节点,让 first 指向该节点,并形成环形</li>
<li>后面当我们每创建一个新的节点，就把该节点，加入到已有的环形链表中即可</li>
</ol>
</li>
<li><p>遍历环形链表</p>
<ol>
<li>先让一个辅助指针(变量)curBoy，指向first节点</li>
<li>然后通过一个while循环遍历该环形链表即可 <strong>curBoy.next &#x3D;&#x3D; first</strong> 结束</li>
</ol>
</li>
</ul>
</li>
<li><p>Joseph问题–&gt;小孩出圈思路</p>
<ul>
<li>根据用户的输入，生成一个小孩出圈的顺序：n &#x3D; 5 ,即有5个人；k &#x3D; 1,从第一个人开始报数；m &#x3D; 2,数2下<ol>
<li>需求创建一个<strong>辅助指针(变量) helper ,事先应该指向环形链表的最后这个节点</strong>.<br>补充:小孩报数前，先让first和 helper移动k-1次</li>
<li>当小孩报数时，让first和helper指针同时的移动 <strong>m -1</strong>次</li>
<li>这时就可以将first指向的小孩节点出圈<br><strong>first &#x3D; first.next</strong><br><strong>helper.next &#x3D;first</strong><br>原来first指向的节点就没有任何引用，就会被回收</li>
<li>出圈的顺序<br>2-&gt;4-&gt;1-&gt;5-&gt;3</li>
</ol>
</li>
</ul>
</li>
</ul>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ysy.linkedlist;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Joseph</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//测试构建环形链表，并遍历</span></span><br><span class="line">        <span class="type">CircleSingleLinkedList</span> <span class="variable">circleSingleLinkedList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CircleSingleLinkedList</span>();</span><br><span class="line">        circleSingleLinkedList.addBoy(<span class="number">5</span>);</span><br><span class="line">        circleSingleLinkedList.showBoy();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试小孩出圈</span></span><br><span class="line">        circleSingleLinkedList.countBoy(<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个环形的单向链表</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CircleSingleLinkedList</span>&#123;</span><br><span class="line">    <span class="comment">//创建一个first节点，当前没有编号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Boy</span> <span class="variable">first</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Boy</span>(-<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//添加小孩节点，构成一个环形的单向链表</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addBoy</span><span class="params">(<span class="type">int</span> nums)</span>&#123;</span><br><span class="line">        <span class="comment">//nums做一个校验</span></span><br><span class="line">        <span class="keyword">if</span>(nums &lt; <span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;nums值不正确&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Boy</span> <span class="variable">curBoy</span> <span class="operator">=</span> <span class="literal">null</span>;<span class="comment">//辅助指针，帮助构建环形链表</span></span><br><span class="line">        <span class="comment">//使用for循环创建环形链表</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= nums; i++)&#123;</span><br><span class="line">            <span class="comment">//根据编号创建小孩节点</span></span><br><span class="line">            <span class="type">Boy</span> <span class="variable">boy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Boy</span>(i);</span><br><span class="line">            <span class="comment">//如果i=1</span></span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">1</span>)&#123;</span><br><span class="line">                first = boy;</span><br><span class="line">                first.setNext(first);<span class="comment">//构成环</span></span><br><span class="line">                curBoy = first;<span class="comment">//让curBoy指向第一个节点</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                curBoy.setNext(boy);</span><br><span class="line">                boy.setNext(first);</span><br><span class="line">                curBoy = boy;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历当前环形链表</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showBoy</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//判断链表是否为空</span></span><br><span class="line">        <span class="keyword">if</span>(first == <span class="literal">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;没有任何小孩~&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//first不能动，使用辅助指针</span></span><br><span class="line">        <span class="type">Boy</span> <span class="variable">curBoy</span> <span class="operator">=</span> first;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;小孩的编号%d \n&quot;</span>, curBoy.getNumber());</span><br><span class="line">            <span class="keyword">if</span>(curBoy.getNext() == first)&#123;</span><br><span class="line">                <span class="comment">//遍历完毕</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            curBoy = curBoy.getNext();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据用户的输入，计算出小孩的出圈顺序</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> startNumber 表示从第几个小孩开始数数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> countNumber 表示数几下</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums 表示小孩个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">countBoy</span><span class="params">(<span class="type">int</span> startNumber, <span class="type">int</span> countNumber, <span class="type">int</span> nums)</span>&#123;</span><br><span class="line">        <span class="comment">//先对数据校验</span></span><br><span class="line">        <span class="keyword">if</span>(first == <span class="literal">null</span> || startNumber &lt; <span class="number">1</span> || startNumber &gt; nums)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;参数输入有误，请重新输入~&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//辅助指针first，帮助小孩出圈</span></span><br><span class="line">        <span class="type">Boy</span> <span class="variable">helper</span> <span class="operator">=</span> first;</span><br><span class="line">        <span class="comment">//创建辅助指针helper，事先指向环形链表的最后一个节点</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(helper.getNext() == first)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            helper = helper.getNext();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//小孩报数前，先让first和 helper移动k-1次</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span><span class="number">0</span>; j &lt; startNumber - <span class="number">1</span>; j++)&#123;</span><br><span class="line">            first = first.getNext();</span><br><span class="line">            helper = helper.getNext();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当小孩报数时，让first和helper指针同时的移动 m-1 次，然后出圈</span></span><br><span class="line">        <span class="comment">//循环操作，直到圈中只有一个小孩</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(helper == first)&#123;</span><br><span class="line">                <span class="comment">//只有一个小孩</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//让first和helper指针同时的移动 countNumber-1 次</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; countNumber - <span class="number">1</span>; j++)&#123;</span><br><span class="line">                first = first.getNext();</span><br><span class="line">                helper = helper.getNext();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//这时first指向的节点就是要出圈的小孩</span></span><br><span class="line">            System.out.printf(<span class="string">&quot;小孩%d出圈 \n&quot;</span>, first.getNumber());</span><br><span class="line">            <span class="comment">//小孩出圈</span></span><br><span class="line">            first = first.getNext();</span><br><span class="line">            helper.setNext(first);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.printf(<span class="string">&quot;最后留在圈中的小孩编号为%d \n&quot;</span>, first.getNumber());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个Boy类，表示一个节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Boy</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> number;<span class="comment">//编号</span></span><br><span class="line">    <span class="keyword">private</span> Boy next;<span class="comment">//指向下一个节点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Boy</span><span class="params">(<span class="type">int</span> number)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.number = number;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNumber</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> number;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNumber</span><span class="params">(<span class="type">int</span> number)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.number = number;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Boy <span class="title function_">getNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNext</span><span class="params">(Boy next)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-JVM：堆"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
	
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/07/16/JVM%EF%BC%9A%E5%A0%86/"
    >堆</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/07/16/JVM%EF%BC%9A%E5%A0%86/" class="article-date">
  <time datetime="2022-07-16T09:53:17.000Z" itemprop="datePublished">2022-07-16</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/JVM/">JVM</a> / <a class="article-category-link" href="/categories/JVM/1-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/">1.内存与垃圾回收篇</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="堆的核心概述"><a href="#堆的核心概述" class="headerlink" title="堆的核心概述"></a>堆的核心概述</h1><h2 id="堆与进程"><a href="#堆与进程" class="headerlink" title="堆与进程"></a>堆与进程</h2><ul>
<li>堆针对一个JVM进程来说是唯一的。也就是<strong>一个进程只有一个JVM实例</strong>，一个JVM实例中就有一个运行时数据区，一个运行时数据区只有一个堆和一个方法区。</li>
<li>但是<strong>进程包含多个线程，他们是共享同一个堆空间的</strong>。</li>
</ul>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220714163810628.png" alt="image-20220714163810628"></p>
<ul>
<li><p><strong>一个JVM实例只存在一个堆内存</strong>，堆也是Java内存管理的核心区域。</p>
</li>
<li><p>Java堆区在JVM启动的时候即被创建，其空间大小也就确定了，堆是JVM管理的最大一块内存空间</p>
<ul>
<li>堆内存的大小是可以调节的。</li>
</ul>
</li>
<li><p>《Java虚拟机规范》规定，堆可以处于<strong>物理上不连续</strong>的内存空间中，但在<strong>逻辑上</strong>它应该被视为<strong>连续的</strong>。</p>
</li>
<li><p><strong>所有的线程共享Java堆</strong>，（<strong>不是全部的堆空间都是共享的</strong>）在这里还可以划分线程私有的<strong>缓冲区</strong>（Thread Local Allocation Buffer，<u><strong>TLAB</strong></u>）。</p>
</li>
<li><p>《Java虚拟机规范》中对Java堆的描述是：<strong>所有的对象实例以及数组都应当在运行时分配在堆上</strong>。（The heap is the run-time data area from which memory for all class instances and arrays is allocated）</p>
<ul>
<li>从实际使用角度看：<strong>“几乎”所有的对象实例都在堆分配内存，但并非全部</strong>。<strong>因为还有一些对象是在栈上分配的（逃逸分析，标量替换）</strong></li>
</ul>
</li>
<li><p>数组和对象可能永远不会存储在栈上（<strong>不一定</strong>），因为栈帧中保存引用，这个引用指向对象或者数组在堆中的位置。</p>
</li>
<li><p>在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会被移除</p>
<ul>
<li>也就是触发了GC的时候，才会进行回收</li>
<li>如果堆中对象马上被回收，那么用户线程就会收到影响，因为有stop the word</li>
</ul>
</li>
<li><p>堆，是GC（Garbage Collection，垃圾收集器）执行垃圾回收的重点区域。</p>
</li>
</ul>
<blockquote>
<p>随着JVM的迭代升级，原来一些绝对的事情，在后续版本中也开始有了特例，变的不再那么绝对。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleHeap</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;<span class="comment">//属性、成员变量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SimpleHeap</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;My ID is &quot;</span> + id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SimpleHeap</span> <span class="variable">sl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleHeap</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="type">SimpleHeap</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleHeap</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">        Object[] arr1 = <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">10</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220714163451758.png" alt="image-20220714163451758"></p>
<h2 id="堆内存细分"><a href="#堆内存细分" class="headerlink" title="堆内存细分"></a>堆内存细分</h2><p>现代垃圾收集器大部分都基于分代收集理论设计，堆空间细分为：</p>
<ul>
<li><p><strong>Java7 及之前</strong>堆内存<u>逻辑</u>上分为三部分：<strong>新生区+养老区+永久区</strong></p>
<ul>
<li>Young Generation Space    新生区      Young&#x2F;New<ul>
<li>又被划分为Eden区和Survivor区</li>
</ul>
</li>
<li>Old generation space    养老区           Old&#x2F;Tenure</li>
<li>Permanent Space   永久区                   Perm</li>
</ul>
</li>
<li><p><strong>Java 8及之后</strong>堆内存<u>逻辑</u>上分为三部分：<strong>新生区+养老区+元空间</strong></p>
<ul>
<li>Young Generation Space 新生区<ul>
<li>又被划分为Eden区和Survivor区</li>
</ul>
</li>
<li>Old generation space 养老区</li>
<li>Meta Space 元空间 Meta</li>
</ul>
</li>
</ul>
<p>约定：新生区 &lt;–&gt; 新生代 &lt;–&gt; 年轻代 、 养老区 &lt;–&gt; 老年区 &lt;–&gt; 老年代、 永久区 &lt;–&gt; 永久代</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220714165759710.png" alt="image-20220714165759710"></p>
<ul>
<li>堆空间内部结构，JDK1.8之前从永久代 替换成 元空间</li>
</ul>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220714170445635.png" alt="image-20220714170445635"></p>
<h2 id="JVisualVM可视化查看堆内存"><a href="#JVisualVM可视化查看堆内存" class="headerlink" title="JVisualVM可视化查看堆内存"></a>JVisualVM可视化查看堆内存</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeapDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;start...&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.MINUTES.sleep(<span class="number">30</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;end...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>1、双击jdk目录下的这个文件</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220714200614776.png" alt="image-20220714200614776"></p>
<p>2、工具 -&gt; 插件 -&gt; 安装Visual GC插件</p>
<p>3、运行上面的代码</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220714204024940.png" alt="image-20220714204024940"></p>
<h1 id="设置堆内存大小与-OOM"><a href="#设置堆内存大小与-OOM" class="headerlink" title="设置堆内存大小与 OOM"></a>设置堆内存大小与 OOM</h1><h2 id="设置堆内存"><a href="#设置堆内存" class="headerlink" title="设置堆内存"></a>设置堆内存</h2><ul>
<li><p>Java堆区用于存储Java对象实例，那么堆的大小在JVM启动时就已经设定好了，大家可以通过选项”-Xms”和”-Xmx”来进行设置。</p>
<ul>
<li><strong>-Xms</strong>用于表示堆区的起始内存，等价于**-XX:InitialHeapSize**</li>
<li><strong>-Xmx</strong>则用于表示堆区的最大内存，等价于**-XX:MaxHeapSize**</li>
</ul>
</li>
<li><p><strong>一旦堆区中的内存大小超过“-Xmx”所指定的最大内存时，将会抛出OutofMemoryError异常。</strong></p>
</li>
<li><p>通常会将-Xms和-Xmx两个参数配置相同的值</p>
<ul>
<li>原因：假设两个不一样，初始内存小，最大内存大。在运行期间如果堆内存不够用了，会一直扩容直到最大内存。如果内存够用且多了，也会不断的缩容释放。频繁的扩容和释放造成不必要的压力，避免在GC之后调整堆内存给服务器带来压力。</li>
<li>如果两个设置一样的就少了频繁扩容和缩容的步骤。内存不够了就直接报OOM</li>
</ul>
</li>
<li><p>默认情况下</p>
<ul>
<li>初始内存大小：物理电脑内存大小&#x2F;64</li>
<li>最大内存大小：物理电脑内存大小&#x2F;4</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1. 设置堆空间大小的参数</span></span><br><span class="line"><span class="comment"> * -Xms 用来设置堆空间（年轻代+老年代）的初始内存大小</span></span><br><span class="line"><span class="comment"> *      -X 是jvm的运行参数</span></span><br><span class="line"><span class="comment"> *      ms 是memory start</span></span><br><span class="line"><span class="comment"> * -Xmx 用来设置堆空间（年轻代+老年代）的最大内存大小</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 2. 默认堆空间的大小</span></span><br><span class="line"><span class="comment"> *    初始内存大小：物理电脑内存大小 / 64</span></span><br><span class="line"><span class="comment"> *             最大内存大小：物理电脑内存大小 / 4</span></span><br><span class="line"><span class="comment"> * 3. 手动设置：-Xms600m -Xmx600m</span></span><br><span class="line"><span class="comment"> *     开发中建议将初始堆内存和最大的堆内存设置成相同的值。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 4. 查看设置的参数：方式一： jps   /  jstat -gc 进程id</span></span><br><span class="line"><span class="comment"> *                  方式二：-XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeapSpaceInitial</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回Java虚拟机中的堆内存总量</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">initialMemory</span> <span class="operator">=</span> Runtime.getRuntime().totalMemory() / <span class="number">1024</span> / <span class="number">1024</span>;</span><br><span class="line">        <span class="comment">//返回Java虚拟机试图使用的最大堆内存量</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">maxMemory</span> <span class="operator">=</span> Runtime.getRuntime().maxMemory() / <span class="number">1024</span> / <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;-Xms : &quot;</span> + initialMemory + <span class="string">&quot;M&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;-Xmx : &quot;</span> + maxMemory + <span class="string">&quot;M&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;系统内存大小为：&quot;</span> + initialMemory * <span class="number">64.0</span> / <span class="number">1024</span> + <span class="string">&quot;G&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;系统内存大小为：&quot;</span> + maxMemory * <span class="number">4.0</span> / <span class="number">1024</span> + <span class="string">&quot;G&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-Xms : 245M</span><br><span class="line">-Xmx : 3621M</span><br><span class="line">系统内存大小为：<span class="number">15.</span>3125G</span><br><span class="line">系统内存大小为：<span class="number">14.</span>14453125G</span><br></pre></td></tr></table></figure>

<p>1、笔者电脑内存大小是16G，不足16G的原因是操作系统自身还占据了一些。</p>
<p>2、两个不一样的原因待会再说</p>
<p>设置下参数再看</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220714205213109.png" alt="image-20220714205213109"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeapSpaceInitial</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回Java虚拟机中的堆内存总量</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">initialMemory</span> <span class="operator">=</span> Runtime.getRuntime().totalMemory() / <span class="number">1024</span> / <span class="number">1024</span>;</span><br><span class="line">        <span class="comment">//返回Java虚拟机试图使用的最大堆内存量</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">maxMemory</span> <span class="operator">=</span> Runtime.getRuntime().maxMemory() / <span class="number">1024</span> / <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;-Xms : &quot;</span> + initialMemory + <span class="string">&quot;M&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;-Xmx : &quot;</span> + maxMemory + <span class="string">&quot;M&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-Xms : 575M</span><br><span class="line">-Xmx : 575M</span><br></pre></td></tr></table></figure>

<p><strong>为什么会少25M</strong></p>
<p><strong>方式一： jps   &#x2F;  jstat -gc 进程id</strong></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220714205555288.png" alt="image-20220714205555288"></p>
<blockquote>
<p>jps：查看java进程</p>
<p>jstat：查看某进程内存使用情况</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SOC: S0区总共容量</span><br><span class="line">S1C: S1区总共容量</span><br><span class="line">S0U: S0区使用的量</span><br><span class="line">S1U: S1区使用的量</span><br><span class="line">EC: 伊甸园区总共容量</span><br><span class="line">EU: 伊甸园区使用的量</span><br><span class="line">OC: 老年代总共容量</span><br><span class="line">OU: 老年代使用的量</span><br></pre></td></tr></table></figure>

<p>1、</p>
<p>25600+25600+153600+409600 &#x3D; 614400K</p>
<p>614400 &#x2F;1024 &#x3D; 600M</p>
<p>2、</p>
<p>25600+153600+409600 &#x3D; 588800K</p>
<p>588800 &#x2F;1024 &#x3D; 575M</p>
<p>3、</p>
<p>并非巧合，S0区和S1区两个只有一个能使用，另一个用不了（后面会详解）</p>
<p><strong>方式二：-XX:+PrintGCDetails</strong></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220714210113267.png" alt="image-20220714210113267"></p>
<h2 id="OOM"><a href="#OOM" class="headerlink" title="OOM"></a>OOM</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OOMTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;Picture&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">20</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            list.add(<span class="keyword">new</span> <span class="title class_">Picture</span>(<span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">1024</span> * <span class="number">1024</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Picture</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span>[] pixels;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Picture</span><span class="params">(<span class="type">int</span> length)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.pixels = <span class="keyword">new</span> <span class="title class_">byte</span>[length];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1、设置虚拟机参数</p>
<p><code>-Xms600m -Xmx600m</code></p>
<p>最终输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">	at com.ysy.Picture.&lt;init&gt;(OOMTest.java:<span class="number">24</span>)</span><br><span class="line">	at com.ysy.OOMTest.main(OOMTest.java:<span class="number">15</span>)</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>2、堆内存变化图</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220714214614901.png" alt="image-20220714214614901"></p>
<p>3、原因：大对象导致堆内存溢出</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220714215106589.png" alt="image-20220714215106589"></p>
<h1 id="年轻代与老年代"><a href="#年轻代与老年代" class="headerlink" title="年轻代与老年代"></a>年轻代与老年代</h1><ul>
<li><p>存储在JVM中的Java对象可以被划分为两类：（从生命周期角度看）</p>
<ul>
<li>一类是生命周期较短的瞬时对象，这类对象的创建和消亡都非常迅速</li>
<li>另外一类对象的生命周期却非常长，在某些极端的情况下还能够与JVM的生命周期保持一致</li>
</ul>
</li>
<li><p>Java堆区进一步细分的话，可以划分为年轻代（YoungGen）和老年代（oldGen）</p>
</li>
<li><p>其中<strong>年轻代又可以划分为Eden空间、Survivor0空间和Survivor1空间（有时也叫做from区、to区）</strong></p>
</li>
</ul>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220714215440653.png" alt="image-20220714215440653"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220714215812289.png" alt="image-20220714215812289"></p>
<ul>
<li><p>配置<strong>新生代与老年代在堆结构的占比</strong></p>
<ul>
<li><p>命令行查看：jinfo -flag NewRatio 进程号</p>
</li>
<li><p>默认**-XX:NewRatio**&#x3D;2，表示新生代占1，老年代占2，<strong>新生代占整个堆的1&#x2F;3</strong></p>
</li>
<li><p>可以修改**-XX:NewRatio**&#x3D;4，表示新生代占1，老年代占4，新生代占整个堆的1&#x2F;5</p>
</li>
</ul>
</li>
<li><p>在HotSpot中，Eden空间和另外两个survivor空间缺省所占的<strong>默认比例是8 : 1 : 1，实际上不是，而是6：1：1</strong></p>
<ul>
<li>命令行查看：jinfo -flag SurvivorRatio 进程号</li>
</ul>
</li>
<li><p>当然开发人员可以通过选项<strong>XX:SurvivorRatio</strong>调整这个空间比例（默认是8 ）。比如-XX:SurvivorRatio&#x3D;8</p>
</li>
<li><p><strong>几乎所有的Java对象都是在Eden区被new出来的。</strong></p>
</li>
<li><p>绝大部分的Java对象的销毁都在新生代进行了（有些大的对象在Eden区无法存储时候，将直接进入老年代）</p>
<ul>
<li>IBM公司的专门研究表明，新生代中80%的对象都是“朝生夕死”的。</li>
</ul>
</li>
<li><p>可以使用选项”-Xmn”设置新生代最大内存大小，但这个参数一般使用默认值就可以了。</p>
</li>
<li><p><strong>-XX:NewRatio</strong> ： 设置新生代与老年代的比例。默认值是2.</p>
</li>
</ul>
<ul>
<li><strong>-XX:SurvivorRatio</strong> ：设置新生代中Eden区与Survivor区的比例。默认值是8</li>
<li><strong>-XX:-UseAdaptiveSizePolicy</strong> ：关闭自适应的内存分配策略</li>
<li><strong>-Xmn</strong> :设置新生代的空间的大小。 （一般不设置）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * -Xms600m -Xmx600m</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * -XX:NewRatio ： 设置新生代与老年代的比例。默认值是2.</span></span><br><span class="line"><span class="comment"> * -XX:SurvivorRatio ：设置新生代中Eden区与Survivor区的比例。默认值是8</span></span><br><span class="line"><span class="comment"> * -XX:-UseAdaptiveSizePolicy ：关闭自适应的内存分配策略  （暂时用不到）</span></span><br><span class="line"><span class="comment"> * -Xmn:设置新生代的空间的大小。 （一般不设置）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shkstart  shkstart@126.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020  17:23</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EdenSurvivorTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我只是来打个酱油~&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="图解对象分配过程"><a href="#图解对象分配过程" class="headerlink" title="图解对象分配过程"></a>图解对象分配过程</h1><p>为新对象分配内存是一件非常严谨和复杂的任务，JVM的设计者们不仅需要考虑内存如何分配、在哪里分配等问题，并且由于内存分配算法与内存回收算法密切相关，所以还需要考虑GC执行完内存回收后是否会在内存空间中产生内存碎片。</p>
<p><strong>具体过程</strong></p>
<ol>
<li>new的对象先放伊甸园区。此区有大小限制。</li>
<li>当伊甸园的空间填满时，程序又需要创建对象，JVM的垃圾回收器将对伊甸园区进行垃圾回收（<strong>MinorGC&#x2F;YGC</strong>），将伊甸园区中的不再被其他对象所引用的对象进行销毁。再加载新的对象放到伊甸园区。</li>
<li>然后将伊甸园中的剩余对象移动到幸存者0区。</li>
<li>如果再次触发垃圾回收，此时上次幸存下来的放到幸存者0区的，如果没有回收，就会放到幸存者1区。</li>
<li>如果再次经历垃圾回收，此时会重新放回幸存者0区，接着再去幸存者1区。</li>
<li>啥时候能去养老区呢？可以设置次数。默认是15次。可以设置新生区进入养老区的年龄限制，设置 JVM 参数：**-XX:MaxTenuringThreshold**&#x3D;N 进行设置</li>
<li>在养老区，相对悠闲。当养老区内存不足时，再次触发GC：Major GC，进行养老区的内存清理</li>
<li>若养老区执行了Major GC之后，发现依然无法进行对象的保存，就会产生OOM异常。</li>
</ol>
<h2 id="图解对象分配（一般情况）"><a href="#图解对象分配（一般情况）" class="headerlink" title="图解对象分配（一般情况）"></a>图解对象分配（一般情况）</h2><p>1、我们创建的对象，一般都是存放在Eden区的，<strong>当我们Eden区满了后，就会触发GC操作</strong>，一般被称为 YGC &#x2F; Minor GC操作</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220714221943450.png" alt="image-20220714221943450"></p>
<p>2、当我们进行一次垃圾收集后，红色的对象将会被回收，而绿色的独享还被占用着，存放在S0(Survivor From)区。同时我们给每个对象设置了一个<strong>年龄计数器</strong>，经过一次回收后还存在的对象，将其年龄加 1。</p>
<p>3、同时Eden区继续存放对象，当Eden区再次存满的时候，又会触发一个MinorGC操作，此时GC将会把 Eden和Survivor From中的对象进行一次垃圾收集，把存活的对象放到 Survivor To（S1）区，同时让存活的对象年龄 + 1</p>
<blockquote>
<p>下一次再进行GC的时候，</p>
<p>1、这一次的s0区为空，所以成为下一次GC的S1区</p>
<p>2、这一次的s1区则成为下一次GC的S0区</p>
<p>3、也就是说s0区和s1区在互相转换。</p>
</blockquote>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220714222053094.png" alt="image-20220714222053094"> </p>
<p>4、我们继续不断的进行对象生成和垃圾回收，当Survivor中的对象的年龄达到15的时候，将会触发一次 Promotion 晋升的操作，也就是将年轻代中的对象晋升到老年代中</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220714222029089.png" alt="image-20220714222029089"></p>
<ul>
<li>针对幸存者S0，S1区的总结：复制之后有交换，谁空谁是to</li>
<li>关于垃圾回收：频繁在新生区收集，很少在养老区收集，几乎不在永久区&#x2F;元空间收集。</li>
</ul>
<h2 id="特殊情况说明"><a href="#特殊情况说明" class="headerlink" title="特殊情况说明"></a>特殊情况说明</h2><p><strong>对象分配的特殊情况</strong></p>
<ul>
<li><p>如果来了一个新对象，先看看 Eden 是否放的下？</p>
<ul>
<li>如果 Eden 放得下，则直接放到 Eden 区</li>
<li>如果 Eden 放不下，则触发 YGC ，执行垃圾回收，看看还能不能放下？</li>
</ul>
</li>
<li><p>将对象放到老年区又有两种情况</p>
<ul>
<li>如果 Eden 执行了 YGC 还是无法放不下该对象，那没得办法，只能说明是超大对象，只能直接放到老年代</li>
<li>那万一老年代都放不下，则先触发FullGC ，再看看能不能放下，放得下最好，但如果还是放不下，那只能报 OOM</li>
</ul>
</li>
<li><p>如果 Eden 区满了，将对象往幸存区拷贝时，发现幸存区放不下啦，那只能便宜了某些新对象，让他们直接晋升至老年区</p>
</li>
</ul>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220715201748058.png" alt="image-20220715201748058"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ysy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * -Xms600m -Xmx600m</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> YSY</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeapInstanceTest</span> &#123;</span><br><span class="line">    <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">1024</span> * <span class="number">208</span>)];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;HeapInstanceTest&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;HeapInstanceTest&gt;();</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> <span class="title class_">HeapInstanceTest</span>());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220715210637110.png" alt="image-20220715210637110"></p>
<h2 id="常用调优工具"><a href="#常用调优工具" class="headerlink" title="常用调优工具"></a>常用调优工具</h2><ol>
<li>JDK命令行</li>
<li>Eclipse：Memory Analyzer Tool</li>
<li>Jconsole</li>
<li>Visual VM（实时监控，推荐）</li>
<li>Jprofiler（软件及IDEA插件）</li>
<li>Java Flight Recorder（实时监控）</li>
<li>GCViewer</li>
<li>GCEasy</li>
</ol>
<h1 id="GC分类"><a href="#GC分类" class="headerlink" title="GC分类"></a>GC分类</h1><ul>
<li><p>我们都知道，JVM的调优的一个环节，也就是垃圾收集，我们需要尽量的避免垃圾回收，因为在垃圾回收的过程中，容易出现STW（Stop the World）的问题，<strong>而 Major GC 和 Full GC出现STW的时间，是Minor GC的10倍以上</strong></p>
</li>
<li><p>JVM在进行GC时，并非每次都对上面三个内存区域(新生代、老年代、方法区)一起回收的，大部分时候回收的都是指新生代。</p>
</li>
<li><p>针对Hotspot VM的实现，它里面的GC按照回收区域又分为两大种类型：一种是<strong>部分收集（Partial GC）</strong>，一种是<strong>整堆收集（FullGC）</strong></p>
<ul>
<li><p><strong>部分收集</strong>：不是完整收集整个Java堆的垃圾收集。其中又分为：</p>
<ul>
<li><p><strong>新生代收集</strong>（<strong>Minor GC&#x2F;Young GC</strong>）：只是新生代（Eden，s0，s1）的垃圾收集</p>
</li>
<li><p><strong>老年代收集</strong>（<strong>Major GC&#x2F;Old GC</strong>）：只是老年代的圾收集</p>
<p>目前，只有<strong>CMS GC</strong>会有单独收集老年代的行为</p>
<p>注意，很多时候Major GC会和Full GC 混淆使用，需要具体分辨是老年代回收还是整堆回收。</p>
</li>
<li><p>混合收集（Mixed GC）：收集整个新生代以及部分老年代的垃圾收集。目前，只有G1 GC会有这种行为</p>
</li>
</ul>
</li>
<li><p><strong>整堆收集</strong>（Full GC）：收集整个java堆和方法区的垃圾收集。</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>由于历史原因，外界各种解读，majorGC和Full GC有些混淆。</p>
</blockquote>
<h2 id="Young-GC"><a href="#Young-GC" class="headerlink" title="Young GC"></a>Young GC</h2><p><strong>年轻代 GC（Minor GC）触发机制</strong></p>
<ul>
<li>当<strong>年轻代空间不足时，</strong>就会触发Minor GC，<strong>这里的年轻代满指的是Eden代满</strong>。Survivor满不会主动引发GC，在Eden区满的时候，会顺带触发s0区的GC，也就是被动触发GC（每次Minor GC会清理年轻代的内存）</li>
<li>因为Java对象大多都具备<strong>朝生夕灭</strong>的特性，所以Minor GC非常频繁，一般回收速度也比较快。这一定义既清晰又易于理解。</li>
<li>Minor GC 会引发STW（Stop The World），暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行</li>
</ul>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220715214703319.png" alt="image-20220715214703319"></p>
<h2 id="Major-x2F-Full-GC"><a href="#Major-x2F-Full-GC" class="headerlink" title="Major&#x2F;Full GC"></a>Major&#x2F;Full GC</h2><blockquote>
<p>Full GC有争议，后续详解两者区别，暂时先看着</p>
</blockquote>
<p><strong>老年代GC（MajorGC）触发机制</strong></p>
<ul>
<li><p>指发生在老年代的GC，对象从老年代消失时，我们说 “Major Gc” 或 “Full GC” 发生了</p>
</li>
<li><p>出现了MajorGc，经常会伴随至少一次的Minor GC。（但非绝对的，在Parallel Scavenge收集器的收集策略里就有直接进行MajorGC的策略选择过程）</p>
<ul>
<li>也就是在老年代空间不足时，会先尝试触发Minor GC（哈？我有点迷？），如果之后空间还不足，则触发Major GC</li>
</ul>
</li>
<li><p>Major GC的速度一般会比Minor GC慢10倍以上，STW的时间更长。</p>
</li>
<li><p>如果Major GC后，内存还不足，就报OOM了</p>
</li>
</ul>
<p><strong>Full GC 触发机制（后面细讲）</strong></p>
<p><strong>触发Full GC执行的情况有如下五种：</strong></p>
<ol>
<li>调用System.gc()时，系统建议执行FullGC，但是不必然执行</li>
<li>老年代空间不足</li>
<li>方法区空间不足</li>
<li>通过Minor GC后进入老年代的平均大小大于老年代的可用内存</li>
<li>由Eden区、survivor space0（From Space）区向survivor space1（To Space）区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小</li>
</ol>
<p>说明：<strong>Full GC 是开发或调优中尽量要避免的。这样STW时间会短一些</strong></p>
<h2 id="GC日志分析"><a href="#GC日志分析" class="headerlink" title="GC日志分析"></a>GC日志分析</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试MinorGC 、 MajorGC、FullGC</span></span><br><span class="line"><span class="comment"> * -Xms9m -Xmx9m -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shkstart  shkstart@126.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020  14:19</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GCTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;atguigu.com&quot;</span>;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                list.add(a);</span><br><span class="line">                a = a + a;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            t.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">&quot;遍历次数为：&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[GC (Allocation Failure) [PSYoungGen: 2031K-&gt;492K(2560K)] 2031K-&gt;897K(9728K), <span class="number">0.0086456</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.01</span> secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 2136K-&gt;496K(2560K)] 2541K-&gt;2089K(9728K), <span class="number">0.0005972</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 1957K-&gt;496K(2560K)] 3550K-&gt;2801K(9728K), <span class="number">0.0005695</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">[Full <span class="title function_">GC</span> <span class="params">(Ergonomics)</span> [PSYoungGen: 1354K-&gt;0K(2560K)] [ParOldGen: 6529K-&gt;4817K(7168K)] 7883K-&gt;4817K(9728K), [Metaspace: 3188K-&gt;3188K(1056768K)], <span class="number">0.0056880</span> secs] [Times: user=<span class="number">0.06</span> sys=<span class="number">0.00</span>, real=<span class="number">0.01</span> secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 0K-&gt;0K(2560K)] 4817K-&gt;4817K(9728K), <span class="number">0.0002837</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">[Full <span class="title function_">GC</span> <span class="params">(Allocation Failure)</span> [PSYoungGen: 0K-&gt;0K(2560K)] [ParOldGen: 4817K-&gt;4799K(7168K)] 4817K-&gt;4799K(9728K), [Metaspace: 3188K-&gt;3188K(1056768K)], <span class="number">0.0048352</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">遍历次数为：<span class="number">16</span></span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 2560K, used 89K [<span class="number">0x00000000ffd00000</span>, <span class="number">0x0000000100000000</span>, <span class="number">0x0000000100000000</span>)</span><br><span class="line">  eden space 2048K, <span class="number">4</span>% used [<span class="number">0x00000000ffd00000</span>,<span class="number">0x00000000ffd16608</span>,<span class="number">0x00000000fff00000</span>)</span><br><span class="line">  from space 512K, <span class="number">0</span>% used [<span class="number">0x00000000fff80000</span>,<span class="number">0x00000000fff80000</span>,<span class="number">0x0000000100000000</span>)</span><br><span class="line">  to   space 512K, <span class="number">0</span>% used [<span class="number">0x00000000fff00000</span>,<span class="number">0x00000000fff00000</span>,<span class="number">0x00000000fff80000</span>)</span><br><span class="line"> ParOldGen       total 7168K, used 4799K [<span class="number">0x00000000ff600000</span>, <span class="number">0x00000000ffd00000</span>, <span class="number">0x00000000ffd00000</span>)</span><br><span class="line">  object space 7168K, <span class="number">66</span>% used [<span class="number">0x00000000ff600000</span>,<span class="number">0x00000000ffaafdd8</span>,<span class="number">0x00000000ffd00000</span>)</span><br><span class="line"> Metaspace       used 3254K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">space</span>    used 353K, capacity 388K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[GC (Allocation Failure) [PSYoungGen: 2037K-&gt;504K(2560K)] 2037K-&gt;728K(9728K), <span class="number">0.0455865</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.06</span> secs] </span><br></pre></td></tr></table></figure>

<ul>
<li><p>[PSYoungGen: 2037K-&gt;504K(2560K)]：年轻代总空间为 2560K ，当前占用 2037K ，经过垃圾回收后剩余504K</p>
</li>
<li><p>2037K-&gt;728K(9728K)：堆内存总空间为 9728K ，当前占用2037K ，经过垃圾回收后剩余728K</p>
</li>
</ul>
<h1 id="堆空间分代思想"><a href="#堆空间分代思想" class="headerlink" title="堆空间分代思想"></a>堆空间分代思想</h1><p>为什么要把Java堆分代？不分代就不能正常工作了吗？经研究，不同对象的生命周期不同。70%-99%的对象是临时对象。</p>
<ul>
<li>新生代：有Eden、两块大小相同的survivor（又称为from&#x2F;to或s0&#x2F;s1）构成，to总为空。</li>
<li>老年代：存放新生代中经历多次GC仍然存活的对象。</li>
</ul>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220715220541682.png" alt="image-20220715220541682"></p>
<p>其实不分代完全可以，<strong>分代的唯一理由就是优化GC性能</strong>。</p>
<ul>
<li>如果没有分代，那所有的对象都在一块，就如同把一个学校的人都关在一个教室。GC的时候要找到哪些对象没用，这样就会对堆的所有区域进行扫描。（性能低）</li>
</ul>
<ul>
<li>而很多对象都是朝生夕死的，如果分代的话，把新创建的对象放到某一地方，当GC的时候先把这块存储“朝生夕死”对象的区域进行回收，这样就会腾出很大的空间出来。（多回收新生代，少回收老年代，性能会提高很多）</li>
</ul>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220715220617592.png" alt="image-20220715220617592"></p>
<h1 id="对象内存分配策略"><a href="#对象内存分配策略" class="headerlink" title="对象内存分配策略"></a>对象内存分配策略</h1><ol>
<li>如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并将对象年龄设为1。</li>
<li>对象在Survivor区中每熬过一次MinorGC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁，其实每个JVM、每个GC都有所不同）时，就会被晋升到老年代</li>
<li>对象晋升老年代的年龄阀值，可以通过选项**-XX:MaxTenuringThreshold**来设置</li>
</ol>
<p><strong>针对不同年龄段的对象分配原则如下所示：</strong></p>
<ul>
<li><p><strong>优先分配到Eden</strong></p>
<ul>
<li>开发中比较长的字符串或者数组，会直接存在老年代，但是因为新创建的对象都是朝生夕死的，所以这个大对象可能也很快被回收，但是因为老年代触发Major GC的次数比 Minor GC要更少，因此可能回收起来就会比较慢</li>
</ul>
</li>
<li><p><strong>大对象直接分配到老年代</strong></p>
<ul>
<li>尽量避免程序中出现过多的大对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ysy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试：大对象直接进入老年代</span></span><br><span class="line"><span class="comment"> * -Xms60m -Xmx60m -XX:NewRatio=2 -XX:SurvivorRatio=8 -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">YoungOldAreaTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">20</span>];<span class="comment">//20m</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 18432K, used 2631K [<span class="number">0x00000000fec00000</span>, <span class="number">0x0000000100000000</span>, <span class="number">0x0000000100000000</span>)</span><br><span class="line">  eden space 16384K, <span class="number">16</span>% used [<span class="number">0x00000000fec00000</span>,<span class="number">0x00000000fee91ea0</span>,<span class="number">0x00000000ffc00000</span>)</span><br><span class="line">  from space 2048K, <span class="number">0</span>% used [<span class="number">0x00000000ffe00000</span>,<span class="number">0x00000000ffe00000</span>,<span class="number">0x0000000100000000</span>)</span><br><span class="line">  to   space 2048K, <span class="number">0</span>% used [<span class="number">0x00000000ffc00000</span>,<span class="number">0x00000000ffc00000</span>,<span class="number">0x00000000ffe00000</span>)</span><br><span class="line"> ParOldGen       total 40960K, used 20480K [<span class="number">0x00000000fc400000</span>, <span class="number">0x00000000fec00000</span>, <span class="number">0x00000000fec00000</span>)</span><br><span class="line">  object space 40960K, <span class="number">50</span>% used [<span class="number">0x00000000fc400000</span>,<span class="number">0x00000000fd800010</span>,<span class="number">0x00000000fec00000</span>)</span><br><span class="line"> Metaspace       used 3243K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">space</span>    used 352K, capacity 388K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>长期存活的对象分配到老年代</strong></p>
</li>
<li><p><strong>动态对象年龄判断</strong></p>
<ul>
<li>如果Survivor区中<strong>相同年龄的所有对象大小的总和大于Survivor空间的一半</strong>，<strong>年龄大于或等于该年龄的对象可以直接进入老年代</strong>，无须等到MaxTenuringThreshold中要求的年龄。</li>
</ul>
</li>
<li><p><strong>空间分配担保</strong></p>
<ul>
<li>-XX:HandlePromotionFailure</li>
</ul>
</li>
</ul>
<h1 id="TLAB为对象分配内存（保证线程安全）"><a href="#TLAB为对象分配内存（保证线程安全）" class="headerlink" title="TLAB为对象分配内存（保证线程安全）"></a>TLAB为对象分配内存（保证线程安全）</h1><h2 id="为什么有-TLAB"><a href="#为什么有-TLAB" class="headerlink" title="为什么有 TLAB"></a>为什么有 TLAB</h2><ol>
<li>堆区是线程共享区域，任何线程都可以访问到堆区中的共享数据</li>
<li>由于对象实例的创建在JVM中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的</li>
<li>为避免多个线程操作同一地址，需要使用<strong>加锁等机制</strong>，进而影响分配速度。</li>
</ol>
<h2 id="什么是-TLAB"><a href="#什么是-TLAB" class="headerlink" title="什么是 TLAB"></a>什么是 TLAB</h2><p><strong>TLAB（Thread Local Allocation Buffer）</strong></p>
<ul>
<li>从内存模型而不是垃圾收集的角度，对Eden区域继续进行划分，<strong>JVM为每个线程分配了一个私有缓存区域，它包含在Eden空间内</strong></li>
<li>多线程同时分配内存时，使用TLAB可以避免一系列的非线程安全问题，同时还能够提升内存分配的吞吐量，因此我们可以将这种内存分配方式称之为<strong>快速分配策略</strong></li>
<li>所有OpenJDK衍生出来的JVM都提供了TLAB的设计。</li>
</ul>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220716164606465.png" alt="image-20220716164606465"></p>
<ol>
<li>每个线程都有一个TLAB空间</li>
<li>当一个线程的TLAB存满时，可以使用公共区域（蓝色）的</li>
</ol>
<h2 id="TLAB再说明"><a href="#TLAB再说明" class="headerlink" title="TLAB再说明"></a>TLAB再说明</h2><ul>
<li>尽管不是所有的对象实例都能够在TLAB中成功分配内存，但<strong>JVM确实是将TLAB作为内存分配的首选</strong></li>
<li>在程序中，开发人员可以通过选项“**-XX:UseTLAB**”设置是否开启TLAB空间。（默认开启）</li>
<li>默认情况下，TLAB空间的内存非常小，<strong>仅占有整个Eden空间的1%<strong>，当然我们可以通过选项“</strong>-XX:TLABWasteTargetPercent</strong>”设置TLAB空间所占用Eden空间的百分比大小</li>
<li>一旦对象在TLAB空间分配内存失败时，JVM就会尝试着通过<strong>使用加锁机制确保数据操作的原子性</strong>，从而直接在Eden空间中分配内存。</li>
</ul>
<blockquote>
<p>1、哪个线程要分配内存，就在哪个线程的本地缓冲区中分配，只有本地缓冲区用完 了，<strong>分配新的缓存区时才需要同步锁定</strong>                                              —-这是《深入理解JVM》–第三版里说的</p>
<p>2、和这里讲的有点不同。我猜测说的意思是某一次分配，如果TLAB用完了，那么<strong>这一次</strong>先在Eden区直接分配。空闲下来后再加锁分配新的TLAB（TLAB内存较大，分配时间应该较长）</p>
</blockquote>
<p><strong>TLAB 分配过程</strong></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220716165016387.png" alt="image-20220716165016387"></p>
<h1 id="堆空间参数设置"><a href="#堆空间参数设置" class="headerlink" title="堆空间参数设置"></a>堆空间参数设置</h1><h2 id="常用参数设置"><a href="#常用参数设置" class="headerlink" title="常用参数设置"></a>常用参数设置</h2><blockquote>
<p><strong>官方文档</strong>：<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html">https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html</a></p>
<p>我们只说常用的</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试堆空间常用的jvm参数：</span></span><br><span class="line"><span class="comment"> * -XX:+PrintFlagsInitial : 查看所有的参数的默认初始值</span></span><br><span class="line"><span class="comment"> * -XX:+PrintFlagsFinal  ：查看所有的参数的最终值（可能会存在修改，不再是初始值）</span></span><br><span class="line"><span class="comment"> *      具体查看某个参数的指令： jps：查看当前运行中的进程</span></span><br><span class="line"><span class="comment"> *                             jinfo -flag SurvivorRatio 进程id</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * -Xms：初始堆空间内存 （默认为物理内存的1/64）</span></span><br><span class="line"><span class="comment"> * -Xmx：最大堆空间内存（默认为物理内存的1/4）</span></span><br><span class="line"><span class="comment"> * -Xmn：设置新生代的大小。(初始值及最大值)</span></span><br><span class="line"><span class="comment"> * -XX:NewRatio：配置新生代与老年代在堆结构的占比</span></span><br><span class="line"><span class="comment"> * -XX:SurvivorRatio：设置新生代中Eden和S0/S1空间的比例</span></span><br><span class="line"><span class="comment"> * -XX:MaxTenuringThreshold：设置新生代垃圾的最大年龄（最大15，GC年龄在对象头只占4位）</span></span><br><span class="line"><span class="comment"> * -XX:+PrintGCDetails：输出详细的GC处理日志</span></span><br><span class="line"><span class="comment"> * 打印gc简要信息：① -XX:+PrintGC   ② -verbose:gc</span></span><br><span class="line"><span class="comment"> * -XX:HandlePromotionFailure：是否设置空间分配担保</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h2 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h2><p><strong>在发生Minor GC之前，虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象的总空间。</strong></p>
<ul>
<li>如果<strong>大于</strong>，则此次Minor GC是<strong>安全</strong>的</li>
<li>如果<strong>小于</strong>，则虚拟机会查看**-XX:HandlePromotionFailure**设置值是否允担保失败。<ul>
<li>如果HandlePromotionFailure&#x3D;true，那么会继续检查<strong>老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小</strong>。<ul>
<li>如果<strong>大于</strong>，则尝试进行一次Minor GC，但这次Minor GC依然是<strong>有风险</strong>的；</li>
<li>如果<strong>小于</strong>，则进行一次<strong>Full GC</strong>。</li>
</ul>
</li>
<li>如果HandlePromotionFailure&#x3D;false，则进行一次Full GC。</li>
</ul>
</li>
</ul>
<p><strong>历史版本</strong></p>
<ol>
<li>在JDK6 Update 24（JDK7）之后，HandlePromotionFailure参数不会再影响到虚拟机的空间分配担保策略，观察openJDK中的源码变化，虽然源码中还定义了HandlePromotionFailure参数，但是在代码中已经不会再使用它。</li>
<li>JDK6 Update 24 （JDK7）之后的规则变为<strong>只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行Minor GC</strong>，否则将进行Full GC。即 HandlePromotionFailure&#x3D;true</li>
</ol>
<h1 id="堆是分配对象的唯一选择么？"><a href="#堆是分配对象的唯一选择么？" class="headerlink" title="堆是分配对象的唯一选择么？"></a>堆是分配对象的唯一选择么？</h1><p><strong>在《深入理解Java虚拟机》中关于Java堆内存有这样一段描述：</strong></p>
<ol>
<li><p>随着JIT编译期的发展与<strong>逃逸分析技术</strong>逐渐成熟，<strong>栈上分配、标量替换优化技术</strong>将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。</p>
</li>
<li><p>在Java虚拟机中，对象是在Java堆中分配内存的，这是一个普遍的常识。但是，有一种特殊情况，那就是<strong>如果经过逃逸分析（Escape Analysis）后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配</strong>。这样就无需在堆上分配内存，也无须进行垃圾回收了。这也是最常见的堆外存储技术。</p>
</li>
<li><p>此外，前面提到的基于OpenJDK深度定制的TaoBao VM，其中创新的GCIH（GC invisible heap）技术实现off-heap，将生命周期较长的Java对象从heap中移至heap外，并且GC不能管理GCIH内部的Java对象，以此达到降低GC的回收频率和提升GC的回收效率的目的。</p>
</li>
</ol>
<h2 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h2><ol>
<li>如何将堆上的对象分配到栈，需要使用逃逸分析手段。</li>
<li>这是一种可以有效减少Java程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。</li>
<li>通过逃逸分析，Java Hotspot编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。</li>
<li>逃逸分析的基本行为就是分析对象动态作用域：<ul>
<li>当一个对象在方法中被定义后，<strong>对象只在方法内部使用</strong>，<strong>则认为没有发生逃逸。</strong></li>
<li>当一个对象在方法中被定义后，它<strong>被外部方法所引用，则认为发生逃逸</strong>。例如作为调用参数传递到其他地方中。</li>
</ul>
</li>
</ol>
<p><strong>逃逸分析举例</strong></p>
<p>1、没有发生逃逸的对象，则可以分配到栈（无线程安全问题）上，随着方法执行的结束，栈空间就被移除（也就无需GC）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">my_method</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">V</span> <span class="variable">v</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">V</span>();</span><br><span class="line">    <span class="comment">// use v</span></span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">    v = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、下面代码中的 StringBuffer sb 发生了逃逸，不能在栈上分配</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> StringBuffer <span class="title function_">createStringBuffer</span><span class="params">(String s1, String s2)</span> &#123;</span><br><span class="line">    <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">    sb.append(s1);</span><br><span class="line">    sb.append(s2);</span><br><span class="line">    <span class="keyword">return</span> sb;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果想要StringBuffer sb不发生逃逸，可以这样写</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">createStringBuffer</span><span class="params">(String s1, String s2)</span> &#123;</span><br><span class="line">    <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">    sb.append(s1);</span><br><span class="line">    sb.append(s2);</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 逃逸分析</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  如何快速的判断是否发生了逃逸分析，大家就看new的对象实体是否有可能在方法外被调用。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EscapeAnalysis</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> EscapeAnalysis obj;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    方法返回EscapeAnalysis对象，发生逃逸</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> EscapeAnalysis <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">return</span> <span class="variable">obj</span> <span class="operator">=</span>= <span class="literal">null</span>? <span class="keyword">new</span> <span class="title class_">EscapeAnalysis</span>() : obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    为成员属性赋值，发生逃逸</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setObj</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.obj = <span class="keyword">new</span> <span class="title class_">EscapeAnalysis</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//思考：如果当前的obj引用声明为static的？仍然会发生逃逸。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    对象的作用域仅在当前方法中有效，没有发生逃逸</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">useEscapeAnalysis</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">EscapeAnalysis</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EscapeAnalysis</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    引用成员变量的值，发生逃逸</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">useEscapeAnalysis1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">EscapeAnalysis</span> <span class="variable">e</span> <span class="operator">=</span> getInstance();</span><br><span class="line">        <span class="comment">//getInstance().xxx()同样会发生逃逸</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>逃逸分析参数设置</strong></p>
<ol>
<li><p>在JDK 1.7 版本之后，HotSpot中默认就已经开启了逃逸分析</p>
</li>
<li><p>如果使用的是较早的版本，开发人员则可以通过：</p>
<ul>
<li>选项“**-XX:+DoEscapeAnalysis**”显式开启逃逸分析</li>
<li>通过选项“**-XX:+PrintEscapeAnalysis**”查看逃逸分析的筛选结果</li>
</ul>
</li>
</ol>
<p><strong>总结</strong></p>
<p><code>开发中能使用局部变量的，就不要使用在方法外定义</code></p>
<h2 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h2><p>使用逃逸分析，编译器可以对代码做如下优化：</p>
<ol>
<li><strong>栈上分配</strong>：将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会发生逃逸，对象可能是栈上分配的候选，而不是堆上分配</li>
<li><strong>同步省略</strong>：如果一个对象被发现只有一个线程被访问到，那么对于这个对象的操作可以不考虑同步。</li>
<li><strong>分离对象或标量替换</strong>：有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在CPU寄存器中。</li>
</ol>
<h3 id="栈上分配"><a href="#栈上分配" class="headerlink" title="栈上分配"></a>栈上分配</h3><ul>
<li>JIT编译器在编译期间根据逃逸分析的结果，发现如果一个对象并没有逃逸出方法的话，就可能被优化成栈上分配。分配完成后，继续在调用栈内执行，<strong>最后线程结束，栈空间被回收，局部变量对象也被回收。这样就无须进行垃圾回收了。</strong></li>
<li>常见的栈上分配的场景<ul>
<li>在逃逸分析中，已经说明了，分别是给成员变量赋值、方法返回值、实例引用传递。</li>
</ul>
</li>
</ul>
<p><strong>栈上分配举例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 栈上分配测试</span></span><br><span class="line"><span class="comment"> * -Xmx128m -Xms128m -XX:-DoEscapeAnalysis -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StackAllocation</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++) &#123;</span><br><span class="line">            alloc();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 查看执行时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;花费的时间为： &quot;</span> + (end - start) + <span class="string">&quot; ms&quot;</span>);</span><br><span class="line">        <span class="comment">// 为了方便查看堆内存中对象个数，线程sleep</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e1) &#123;</span><br><span class="line">            e1.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">alloc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();<span class="comment">//未发生逃逸</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[GC (Allocation Failure) [PSYoungGen: 33280K-&gt;808K(38400K)] 33280K-&gt;816K(125952K), 0.0006822 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 34088K-&gt;808K(38400K)] 34096K-&gt;816K(125952K), 0.0006364 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 34088K-&gt;744K(38400K)] 34096K-&gt;752K(125952K), 0.0006288 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 34024K-&gt;792K(38400K)] 34032K-&gt;800K(125952K), 0.0004811 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">花费的时间为： 37 ms</span><br></pre></td></tr></table></figure>

<p>1、JVM 参数设置</p>
<p>-Xmx128m -Xms128m -XX:-DoEscapeAnalysis -XX:+PrintGCDetails</p>
<p>2、日志打印：发生了GC ，耗时37ms</p>
<p><strong>开启逃逸分析的情况</strong></p>
<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">花费的时间为： 4 ms</span><br></pre></td></tr></table></figure>

<p>1、参数设置</p>
<p>-Xmx128m -Xms128m -XX:+DoEscapeAnalysis -XX:+PrintGCDetails</p>
<p>2、日志打印：并没有发生 GC ，耗时4ms 。</p>
<h3 id="同步省略（同步消除）"><a href="#同步省略（同步消除）" class="headerlink" title="同步省略（同步消除）"></a>同步省略（同步消除）</h3><ol>
<li><p>线程同步的代价是相当高的，同步的后果是降低并发性和性能。</p>
</li>
<li><p>在动态编译同步块的时候，JIT编译器可以借助逃逸分析来<strong>判断同步块所使用的锁对象是否只能够被一个线程访问而没有被发布到其他线程</strong>。如果没有，那么JIT编译器在编译这个同步块的时候就会取消对这部分代码的同步。这样就能大大提高并发性和性能。这个<strong>取消同步的过程就叫同步省略，也叫锁消除</strong>。</p>
</li>
</ol>
<p>例如下面的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">hollis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">synchronized</span>(hollis) &#123;</span><br><span class="line">        System.out.println(hollis);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码中对hollis这个对象加锁，但是hollis对象的生命周期只在f()方法中，并不会被其他线程所访问到，所以在JIT编译阶段就会被优化掉，优化成：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">hellis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">	System.out.println(hellis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>字节码分析</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">hollis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        <span class="keyword">synchronized</span>(hollis) &#123;</span><br><span class="line">            System.out.println(hollis);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">0</span> <span class="keyword">new</span> #<span class="number">2</span> &lt;java/lang/Object&gt;</span><br><span class="line"> <span class="number">3</span> dup</span><br><span class="line"> <span class="number">4</span> invokespecial #<span class="number">1</span> &lt;java/lang/Object.&lt;init&gt;&gt;</span><br><span class="line"> <span class="number">7</span> astore_1</span><br><span class="line"> <span class="number">8</span> aload_1</span><br><span class="line"> <span class="number">9</span> dup</span><br><span class="line"><span class="number">10</span> astore_2</span><br><span class="line"><span class="number">11</span> monitorenter</span><br><span class="line"><span class="number">12</span> getstatic #<span class="number">3</span> &lt;java/lang/System.out&gt;</span><br><span class="line"><span class="number">15</span> aload_1</span><br><span class="line"><span class="number">16</span> invokevirtual #<span class="number">4</span> &lt;java/io/PrintStream.println&gt;</span><br><span class="line"><span class="number">19</span> aload_2</span><br><span class="line"><span class="number">20</span> monitorexit</span><br><span class="line"><span class="number">21</span> goto <span class="number">29</span> (+<span class="number">8</span>)</span><br><span class="line"><span class="number">24</span> astore_3</span><br><span class="line"><span class="number">25</span> aload_2</span><br><span class="line"><span class="number">26</span> monitorexit</span><br><span class="line"><span class="number">27</span> aload_3</span><br><span class="line"><span class="number">28</span> athrow</span><br><span class="line"><span class="number">29</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<p>注意：字节码文件中并没有进行优化，可以看到加锁和释放锁的操作依然存在，<strong>同步省略操作是在解释运行时发生的</strong></p>
<h3 id="标量替换"><a href="#标量替换" class="headerlink" title="标量替换"></a>标量替换</h3><p><strong>分离对象或标量替换</strong></p>
<ol>
<li><p>标量（scalar）是指一个无法再分解成更小的数据的数据。Java中的原始数据类型就是标量。</p>
</li>
<li><p>相对的，那些还可以分解的数据叫做聚合量（Aggregate），Java中的对象就是聚合量，因为他可以分解成其他聚合量和标量。</p>
</li>
<li><p>在JIT阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过JIT优化，就会把这个对象拆解成若干个其中包含的若干个成员变量来代替。这个过程就是标量替换。</p>
</li>
</ol>
<p><strong>标量替换举例</strong></p>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">    alloc();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">alloc</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Point</span> <span class="variable">point</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;point.x&quot;</span> + point.x + <span class="string">&quot;;point.y&quot;</span> + point.y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码，经过标量替换后，就会变成</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">alloc</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    System.out.println(<span class="string">&quot;point.x = &quot;</span> + x + <span class="string">&quot;; point.y=&quot;</span> + y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>可以看到，Point这个聚合量经过逃逸分析后，发现他并没有逃逸，就被替换成两个聚合量了。</li>
<li>那么标量替换有什么好处呢？就是可以大大减少堆内存的占用。因为一旦不需要创建对象了，那么就不再需要分配堆内存了。</li>
<li>标量替换为栈上分配提供了很好的基础。</li>
</ol>
<p><strong>标量替换参数设置</strong></p>
<p>参数 <strong>-XX:+ElimilnateAllocations</strong>：开启了标量替换（默认打开），允许将对象打散分配在栈上。</p>
<p><strong>代码示例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 标量替换测试</span></span><br><span class="line"><span class="comment"> *  -Xmx100m -Xms100m -XX:+DoEscapeAnalysis -XX:+PrintGC -XX:-EliminateAllocations</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shkstart  shkstart@126.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020  12:01</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScalarReplace</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> id;</span><br><span class="line">        <span class="keyword">public</span> String name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">alloc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">u</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();<span class="comment">//未发生逃逸</span></span><br><span class="line">        u.id = <span class="number">5</span>;</span><br><span class="line">        u.name = <span class="string">&quot;www.atguigu.com&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++) &#123;</span><br><span class="line">            alloc();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;花费的时间为： &quot;</span> + (end - start) + <span class="string">&quot; ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>未开启标量替换</strong></p>
<p>1、JVM 参数</p>
<p>-Xmx100m -Xms100m -XX:+DoEscapeAnalysis -XX:+PrintGC -XX:-EliminateAllocations</p>
<p>2、日志</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[GC (Allocation Failure)  25600K-&gt;752K(98304K), <span class="number">0.0008537</span> secs]</span><br><span class="line">[GC (Allocation Failure)  26352K-&gt;736K(98304K), <span class="number">0.0006501</span> secs]</span><br><span class="line">[GC (Allocation Failure)  26336K-&gt;688K(98304K), <span class="number">0.0009307</span> secs]</span><br><span class="line">[GC (Allocation Failure)  26288K-&gt;704K(98304K), <span class="number">0.0006730</span> secs]</span><br><span class="line">[GC (Allocation Failure)  26304K-&gt;744K(98304K), <span class="number">0.0005924</span> secs]</span><br><span class="line">[GC (Allocation Failure)  26344K-&gt;728K(101376K), <span class="number">0.0007893</span> secs]</span><br><span class="line">[GC (Allocation Failure)  32472K-&gt;644K(101376K), <span class="number">0.0017907</span> secs]</span><br><span class="line">[GC (Allocation Failure)  32388K-&gt;644K(101376K), <span class="number">0.0003030</span> secs]</span><br><span class="line">花费的时间为： <span class="number">55</span> ms</span><br></pre></td></tr></table></figure>

<p><strong>开启标量替换</strong></p>
<p>1、JVM 参数</p>
<p>-Xmx100m -Xms100m -XX:+DoEscapeAnalysis -XX:+PrintGC -XX:+EliminateAllocations</p>
<p>2、日志：时间减少很多，且无GC</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">花费的时间为： <span class="number">5</span> ms</span><br></pre></td></tr></table></figure>

<p>上述代码在主函数中调用了1亿次alloc()方法，进行对象创建由于User对象实例需要占据约16字节的空间，因此累计分配空间达到将近1.5GB。如果堆空间小于这个值，就必然会发生GC。使用如下参数运行上述代码：</p>
<p><code>-server -Xmx100m -Xms100m -XX:+DoEscapeAnalysis -XX:+PrintGC -XX:+EliminateAllocations</code></p>
<p>这里设置参数如下：</p>
<ol>
<li>参数 -server：启动Server模式，因为在server模式下，才可以启用逃逸分析。</li>
<li>参数 -XX:+DoEscapeAnalysis：启用逃逸分析</li>
<li>参数 -Xmx10m：指定了堆空间最大为10MB</li>
<li>参数 -XX:+PrintGC：将打印GC日志。</li>
<li>参数 -XX:+EliminateAllocations：开启了标量替换（默认打开），允许将对象打散分配在栈上，比如对象拥有id和name两个字段，那么这两个字段将会被视为两个独立的局部变量进行分配</li>
</ol>
<h2 id="逃逸分析的不足"><a href="#逃逸分析的不足" class="headerlink" title="逃逸分析的不足"></a>逃逸分析的不足</h2><ol>
<li>关于逃逸分析的论文在1999年就已经发表了，但直到JDK1.6才有实现，而且这项技术到如今也并不是十分成熟的。</li>
<li>其根本原因就是<strong>无法保证逃逸分析的性能消耗一定能高于他的消耗。虽然经过逃逸分析可以做标量替换、栈上分配、和锁消除。但是逃逸分析自身也是需要进行一系列复杂的分析的，这其实也是一个相对耗时的过程</strong>。</li>
<li>一个极端的例子，就是经过逃逸分析之后，发现没有一个对象是不逃逸的。那这个逃逸分析的过程就白白浪费掉了。</li>
<li>虽然这项技术并不十分成熟，但是它也是<strong>即时编译器优化技术中一个十分重要的手段</strong>。</li>
<li>注意到有一些观点，认为通过逃逸分析，JVM会在栈上分配那些不会逃逸的对象，这在理论上是可行的，但是取决于JVM设计者的选择。据我所知，<strong>Oracle Hotspot JVM中并未这么做</strong>（刚刚演示的效果，是因为HotSpot实现了标量替换），这一点在逃逸分析相关的文档里已经说明，<strong>所以可以明确在HotSpot虚拟机上，所有的对象实例都是创建在堆上</strong>。</li>
<li>目前很多书籍还是基于JDK7以前的版本，JDK已经发生了很大变化，intern字符串的缓存和静态变量曾经都被分配在永久代上，而永久代已经被元数据区取代。但是<strong>intern字符串缓存和静态变量并不是被转移到元数据区，而是直接在堆上分配</strong>，<strong>所以这一点同样符合前面一点的结论：对象实例都是分配在堆上</strong>。</li>
</ol>
<blockquote>
<p><strong>堆是分配对象的唯一选择么？</strong></p>
</blockquote>
<p>综上：<strong>对象实例都是分配在堆上</strong>。What the fuck？</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li><p>年轻代是对象的诞生、成长、消亡的区域，一个对象在这里产生、应用，最后被垃圾回收器收集、结束生命。</p>
</li>
<li><p>老年代放置长生命周期的对象，通常都是从Survivor区域筛选拷贝过来的Java对象。当然，也有特殊情况，我们知道普通的对象可能会被分配在TLAB上；如果对象较大，无法分配在 TLAB 上，则JVM会试图直接分配在Eden其他位置上；如果对象太大，完全无法在新生代找到足够长的连续空闲空间，JVM就会直接分配到老年代。</p>
</li>
<li><p>当GC只发生在年轻代中，回收年轻代对象的行为被称为Minor GC。当GC发生在老年代时则被称为Major GC或者Full GC。一般的，Minor GC的发生频率要比Major GC高很多，即老年代中垃圾回收发生的频率将大大低于年轻代。</p>
</li>
</ol>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-框架：SpringMvc"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
	
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/07/15/%E6%A1%86%E6%9E%B6%EF%BC%9ASpringMvc/"
    >SpringMvc</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/07/15/%E6%A1%86%E6%9E%B6%EF%BC%9ASpringMvc/" class="article-date">
  <time datetime="2022-07-15T14:11:46.000Z" itemprop="datePublished">2022-07-15</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%A1%86%E6%9E%B6/">框架</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="1-Web开发的发展"><a href="#1-Web开发的发展" class="headerlink" title="1. Web开发的发展"></a>1. Web开发的发展</h1><h2 id="1-1-model1的开发方式"><a href="#1-1-model1的开发方式" class="headerlink" title="1.1 model1的开发方式"></a>1.1 model1的开发方式</h2><p>统一把显示层、控制层、数据层的操作全部交给 JSP 或者 JavaBean 来进行处理</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20210308143854691.png" alt="image-20210308143854691"></p>
<p><strong>出现的弊端：</strong></p>
<ul>
<li><p>JSP 和 Java Bean 之间严重耦合，Java 代码和 HTML 代码也耦合在了一起</p>
</li>
<li><p>要求开发者不仅要掌握 Java ，还要有高超的前端水平</p>
</li>
<li><p>前端和后端相互依赖，前端需要等待后端完成，后端也依赖前端完成，才能进行有效的测试</p>
</li>
<li><p>代码难以复用</p>
</li>
</ul>
<hr>
<h2 id="1-2-model2的开发方式"><a href="#1-2-model2的开发方式" class="headerlink" title="1.2 model2的开发方式"></a>1.2 model2的开发方式</h2><p>Servlet + JSP + Java Bean</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20210308144038275.png" alt="image-20210308144038275"></p>
<p>首先用户的请求会到达 Servlet，然后根据请求调用相应的 Java Bean，并把所有的显示结果交给 JSP 去完成，这样的模式我们就称为 MVC 模式。</p>
<ul>
<li><strong>M 代表 模型（Model）</strong><br>模型是什么呢？ 模型就是数据，就是 dao,bean</li>
<li><strong>V 代表 视图（View）</strong><br>视图是什么呢？ 就是网页, JSP，用来展示模型中的数据</li>
<li><strong>C 代表 控制器（controller)</strong><br>控制器是什么？ 控制器的作用就是把不同的数据(Model)，显示在不同的视图(View)上，Servlet 扮演的就是这样的角色。</li>
</ul>
<hr>
<h1 id="2-Spring-MVC-框架介绍"><a href="#2-Spring-MVC-框架介绍" class="headerlink" title="2. Spring MVC 框架介绍"></a>2. Spring MVC 框架介绍</h1><p>SpringMVC 是类似于 Struts2 的一个 <strong>MVC 框架</strong>，在实际开发中，接收浏览器的请求响应，对数据进行处理，然后返回页面进行显示，但是上手难度却比 Struts2 简单多了。而且由于 Struts2 所暴露出来的安全问题，SpringMVC 已经成为了大多数企业优先选择的框架。</p>
<ul>
<li><strong>特点：</strong><ul>
<li>结构松散，几乎可以在 Spring MVC 中使用各类视图</li>
<li>松耦合，各个模块分离</li>
<li><strong>与 Spring 无缝集成</strong></li>
</ul>
</li>
</ul>
<hr>
<h1 id="3-SpringMvc的执行流程"><a href="#3-SpringMvc的执行流程" class="headerlink" title="3. SpringMvc的执行流程"></a>3. SpringMvc的执行流程</h1><img src="D:/桌面文件/Java/Springmvc.assets/image-20210309195355880.png" alt="image-20210309195355880" style="zoom:200%;" />

<ul>
<li>一个请求匹配<strong>前端控制器 DispatcherServlet</strong> 的请求映射路径(在 web.xml中指定), WEB 容器将该<strong>请求转交给 DispatcherServlet 处理</strong></li>
<li>DispatcherServlet 接收到请求后，解析URL，将根据请求信息交给<strong>处理器映射器 （HandlerMapping）</strong></li>
<li>HandlerMapping 根据用户的url请求 <strong>查找匹配该url的 Handler</strong>，并<strong>返回一个执行链</strong> </li>
<li><strong>DispatcherServlet 再 请求 处理器适配器(HandlerAdapter)</strong> 调用相应的 <strong>Handler</strong> 进行处理并返回 <strong>ModelAndView 给 DispatcherServlet</strong></li>
<li>DispatcherServlet 将 ModelAndView <strong>请求 ViewReslover（视图解析器）解析，返回具体 View</strong></li>
<li>DispatcherServlet <strong>对 View 进行渲染视图</strong>（即将模型数据填充至视图中）</li>
<li><strong>DispatcherServlet 将页面响应给用户</strong></li>
</ul>
<hr>
<h1 id="4-SpringMvc应用程序的编写"><a href="#4-SpringMvc应用程序的编写" class="headerlink" title="4. SpringMvc应用程序的编写"></a>4. SpringMvc应用程序的编写</h1><h2 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--只需要引入这一个依赖即可,因为这个依赖包含  beans  core  context   web ..--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet.jsp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet.jsp-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>jstl<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jstl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>taglibs<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>standard<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="创建Spring与SpringMvc配置文件"><a href="#创建Spring与SpringMvc配置文件" class="headerlink" title="创建Spring与SpringMvc配置文件"></a>创建Spring与SpringMvc配置文件</h2><ul>
<li><code>applicationContext.xml</code></li>
<li><code>spring-mvc.xml</code></li>
</ul>
<h2 id="修改web-xml"><a href="#修改web-xml" class="headerlink" title="修改web.xml"></a>修改web.xml</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--Spring的配置文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--    监听tomcat的启动,在启动时初始化容器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置springmvc的前端控制器--&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:spring-mvc.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--大于0:代表tomcat启动时加载这个Servlet,小于等于0:代表第一次访问时加载这个Servlet--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.do<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="编写spring的applicationContext-xml配置文件"><a href="#编写spring的applicationContext-xml配置文件" class="headerlink" title="编写spring的applicationContext.xml配置文件"></a>编写spring的<code>applicationContext.xml</code>配置文件</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置注解扫描器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.xzy.spring&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="编写springmvc配置文件-spring-mvc-xml"><a href="#编写springmvc配置文件-spring-mvc-xml" class="headerlink" title="编写springmvc配置文件  spring-mvc.xml"></a>编写springmvc配置文件  <code>spring-mvc.xml</code></h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:mvc</span>=<span class="string">&quot;http://www.springframework.org/schema/mvc&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/aop/spring-aop.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/mvc</span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置前端控制器(在web.xml中配置)--&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置处理器映射器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--处理器适配器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置视图解析器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--必须配置处理器的包扫描路径,如果想要去掉applicationContext中的这个注解,就要把这个扫描路径配置成父类的--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.xzy.spring.controller&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="编写处理器-Controller"><a href="#编写处理器-Controller" class="headerlink" title="编写处理器(Controller)"></a>编写处理器(Controller)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzy.spring.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.xzy.spring.service.UserService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.ModelAndView;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/login&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ModelAndView <span class="title function_">login</span><span class="params">()</span> &#123;</span><br><span class="line">        userService.login();</span><br><span class="line">        <span class="type">ModelAndView</span> <span class="variable">modelAndView</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>();</span><br><span class="line">        modelAndView.setViewName(<span class="string">&quot;/login.jsp&quot;</span>);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        map.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;age&quot;</span>, <span class="number">20</span>);</span><br><span class="line">        modelAndView.addObject(map);</span><br><span class="line">        <span class="keyword">return</span> modelAndView;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="编写视图"><a href="#编写视图" class="headerlink" title="编写视图"></a>编写视图</h2><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> isELIgnored=<span class="string">&quot;false&quot;</span> %&gt;</span><br><span class="line">&lt;%@ taglib uri=<span class="string">&quot;http://java.sun.com/jsp/jstl/core&quot;</span> prefix=<span class="string">&quot;c&quot;</span>  %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        登录视图$&#123;requestScope.user&#125;</span><br><span class="line">        &lt;%= request.getAttribute(<span class="string">&quot;user&quot;</span>)%&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="5-浏览器访问"><a href="#5-浏览器访问" class="headerlink" title="5. 浏览器访问"></a>5. 浏览器访问</h1><blockquote>
<p><a target="_blank" rel="noopener" href="http://localhost:8080/user/login.do">http://localhost:8080/user/login.do</a></p>
</blockquote>
<p>DispatcherServlet会接收到这个请求,并且去掉<code>.do</code>去到相应的处理器</p>
<hr>
<h1 id="6-SpringMvc接收客户端的请求参数"><a href="#6-SpringMvc接收客户端的请求参数" class="headerlink" title="6. SpringMvc接收客户端的请求参数"></a>6. SpringMvc接收客户端的请求参数</h1><p><code>http://localhost:8080/user/login.do?username=admin&amp;password=admin123</code></p>
<h2 id="6-1-通过servlet原始的api接收参数-了解"><a href="#6-1-通过servlet原始的api接收参数-了解" class="headerlink" title="6.1 通过servlet原始的api接收参数(了解)"></a>6.1 通过servlet原始的api接收参数(了解)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/login&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ModelAndView <span class="title function_">login</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="6-2-通过springmvc自带的功能完成参数的接收-重要"><a href="#6-2-通过springmvc自带的功能完成参数的接收-重要" class="headerlink" title="6.2 通过springmvc自带的功能完成参数的接收(重要)"></a>6.2 通过springmvc自带的功能完成参数的接收(重要)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/login&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ModelAndView <span class="title function_">login</span><span class="params">(<span class="meta">@RequestParam(&quot;username&quot;)</span> String uname, <span class="meta">@RequestParam(&quot;password&quot;)</span> String upassword,<span class="meta">@RequestParam(&quot;loves&quot;)</span> List&lt;String&gt; loves)</span> &#123;</span><br><span class="line">    System.out.println(uname);</span><br><span class="line">    System.out.println(upassword);</span><br><span class="line">    <span class="type">ModelAndView</span> <span class="variable">modelAndView</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>();</span><br><span class="line">    <span class="keyword">return</span> modelAndView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是我们如果接收很多的参数每个参数都需要添加<code>@RequestParam</code>注解,这样就显得很繁琐,我们可以省略<code>@RequestParam</code>注解,那么就需要让我们<strong>形参的名称</strong>和<strong>请求的参数的名称</strong>一致;</p>
<p>eg:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/login&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ModelAndView <span class="title function_">login</span><span class="params">(String username,String password)</span> &#123;</span><br><span class="line">    System.out.println(username);</span><br><span class="line">    System.out.println(password);</span><br><span class="line">    <span class="type">ModelAndView</span> <span class="variable">modelAndView</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>();</span><br><span class="line">    <span class="keyword">return</span> modelAndView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="6-3-接收参数使用实体类来进行接收"><a href="#6-3-接收参数使用实体类来进行接收" class="headerlink" title="6.3 接收参数使用实体类来进行接收"></a>6.3 接收参数使用实体类来进行接收</h2><p>注意: 实体类必须是一个标准的JavaBean(setter方法);</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(value = &quot;/login.do&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ModelAndView <span class="title function_">login</span><span class="params">(User user)</span> &#123;</span><br><span class="line">    System.out.println(user.getName());</span><br><span class="line">    System.out.println(user.getAge());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="6-4-获取Rest请求风格的参数-路径参数-x3D-x3D-讲到这了-x3D-x3D"><a href="#6-4-获取Rest请求风格的参数-路径参数-x3D-x3D-讲到这了-x3D-x3D" class="headerlink" title="6.4 获取Rest请求风格的参数(路径参数) &#x3D;&#x3D;讲到这了&#x3D;&#x3D;"></a>6.4 获取Rest请求风格的参数(路径参数) &#x3D;&#x3D;讲到这了&#x3D;&#x3D;</h2><p>什么是RestFul?</p>
<p>RESTFUL是一种网络应用程序的设计风格和开发方式;</p>
<p>Post</p>
<p>Put</p>
<p>Get</p>
<p>Delete</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">查询:</span><br><span class="line">GET /user/selectUser?id=10   #传统方式</span><br><span class="line">GET /user/10            #RestFul的方式</span><br><span class="line"></span><br><span class="line">删除:</span><br><span class="line">POST /user/deleteUser?id=10   #传统方式</span><br><span class="line">DELETE  /user/10    #RestFul的方式</span><br><span class="line"></span><br><span class="line">修改:</span><br><span class="line">POST /user/updateUser?id=10    #传统方式</span><br><span class="line"> 	xxxxxx</span><br><span class="line">PUT  /user/10  #RestFul的方式</span><br><span class="line">	xxxx</span><br></pre></td></tr></table></figure>

<p>请求url:</p>
<p>POST: <code>http://localhost:8080/user</code></p>
<p>DELET:<code>http://localhost:8080/user/10</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加用户</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">@PostMapping()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;添加用户:name=&quot;</span> + name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加用户</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">@DeleteMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">del</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> String id)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;删除:id=&quot;</span> + id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>@PathVariable</code>注解不能省略;</p>
<hr>
<h2 id="6-5-获取请求实体的内容"><a href="#6-5-获取请求实体的内容" class="headerlink" title="6.5 获取请求实体的内容"></a>6.5 获取请求实体的内容</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20210311203740472.png" alt="image-20210311203740472"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//需要添加 &lt;mvc:annotation-driven/&gt; 高级功能支持</span></span><br><span class="line"><span class="meta">@PostMapping(value = &quot;/login&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ModelAndView <span class="title function_">login</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span> &#123;</span><br><span class="line">    System.out.println(user);</span><br><span class="line">    <span class="type">ModelAndView</span> <span class="variable">modelAndView</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>();</span><br><span class="line">    modelAndView.setViewName(<span class="string">&quot;index.jsp&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> modelAndView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意</p>
</blockquote>
<ul>
<li><p>导入依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.11.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>spring-mvc.xml</code>配置高级注解功能的支持</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--@RequestBody注解必须得配置这一项--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>此注解需要配置在<bean/>之前</strong></p>
</li>
</ul>
<hr>
<h1 id="7-SpringMvc的响应处理"><a href="#7-SpringMvc的响应处理" class="headerlink" title="7. SpringMvc的响应处理"></a>7. SpringMvc的响应处理</h1><h2 id="7-1-方法的返回值为void"><a href="#7-1-方法的返回值为void" class="headerlink" title="7.1 方法的返回值为void"></a>7.1 方法的返回值为void</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(value = &quot;/login&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">login</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">    request.setAttribute(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;admin678&quot;</span>);</span><br><span class="line">    request.getRequestDispatcher(<span class="string">&quot;/index01.jsp&quot;</span>).forward(request, response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-2-方法的返回值为String类型"><a href="#7-2-方法的返回值为String类型" class="headerlink" title="7.2 方法的返回值为String类型"></a>7.2 方法的返回值为String类型</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(value = &quot;/login&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">login</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Model model)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">//这个model里面的数据会被携带到视图中去</span></span><br><span class="line">    model.addAttribute(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;admin234&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;/index01.jsp&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="7-3-方法的返回值为ModelAndView"><a href="#7-3-方法的返回值为ModelAndView" class="headerlink" title="7.3 方法的返回值为ModelAndView"></a>7.3 方法的返回值为ModelAndView</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(value = &quot;/login&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ModelAndView <span class="title function_">login</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">ModelAndView</span> <span class="variable">modelAndView</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>();</span><br><span class="line">    modelAndView.setViewName(<span class="string">&quot;/index01.jsp&quot;</span>);</span><br><span class="line">    modelAndView.addObject(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;admin&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> modelAndView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="8-mvc-annotation-driven"><a href="#8-mvc-annotation-driven" class="headerlink" title="8. mvc:annotation-driven"></a>8. mvc:annotation-driven</h1><p>我们如果使用springmvc的基础功能比如:<code>@Controller</code>  <code>@RequestMapping</code> <code>@RequestParam</code>,是不需要添加 <strong>mvc:annotation-driven</strong>的支持,但是我们如果要使用高级功能,例如: <code>@RequestBody</code> <code>@ResponseBody</code>这一些高级功能注解就需要添加<strong>mvc:annotation-driven</strong>的支持了;</p>
<p>我们要在 <code>spring-mvc.xml</code>的配置文件中配置高级功能注解的支持</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:mvc</span>=<span class="string">&quot;http://www.springframework.org/schema/mvc&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/aop/spring-aop.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/mvc</span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--高级功能注解的扩展支持(一定要放在其他配置的最前面,要不然不生效)--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:annotation-driven</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--注册处理器映射器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;requestMappingHandlerMapping&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--注册处理器适配器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--视图解析器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--开启Springmvc的注解扫描,主要扫描处理器的注解  @Controller  @RequestMapping  @GetMapping  @PostMapping--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.xzy.goods.controller&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>mvc:annotation-driven</strong>一定要放在其他注解之前,要不然不会生效;</p>
<hr>
<h1 id="9-ReponseBody注解"><a href="#9-ReponseBody注解" class="headerlink" title="9. @ReponseBody注解"></a>9. @ReponseBody注解</h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--返回的对象转换成json字符串必须导入jackson的依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.11.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-annotations<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.11.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.11.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>@ReponseBody</code>和<code>@Controller</code>进行结合使用,可以直接返回json对象给客户端</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzy.goods.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.xzy.goods.entity.User;</span><br><span class="line"><span class="keyword">import</span> com.xzy.goods.service.UserService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PostMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestBody;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ResponseBody;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.ModelAndView;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(value = &quot;/login&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">login</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span> &#123;</span><br><span class="line">        System.out.println(user);</span><br><span class="line">        user.setId(<span class="number">1001</span>);</span><br><span class="line">        <span class="keyword">return</span> user;<span class="comment">// 返回一个对象,在springmvc的底层会把对象自动转换为json字符串进行返回,还自动添加了 Content-Type: application/json</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是我们如果在每个方法上面都添加ReponseBody注解实在太繁琐了,所以Spring给我们提供了一种非常好的解决方案: <code>@RestController</code></p>
<p>通过源码可知:</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20210311220719635.png" alt="image-20210311220719635"><code>@RestController</code> &#x3D;<code>@Controller</code>+ <code>@ResponseBody</code></p>
<hr>
<h1 id="10-SpringMvc的请求转发与请求重定向"><a href="#10-SpringMvc的请求转发与请求重定向" class="headerlink" title="10. SpringMvc的请求转发与请求重定向"></a>10. SpringMvc的请求转发与请求重定向</h1><h2 id="10-1-传统的Servlet的方式"><a href="#10-1-传统的Servlet的方式" class="headerlink" title="10.1 传统的Servlet的方式"></a>10.1 传统的Servlet的方式</h2><p>请求转发:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//请求转发</span></span><br><span class="line">request.setAttribute(<span class="string">&quot;orderNum&quot;</span>, <span class="string">&quot;7823432&quot;</span>);</span><br><span class="line">request.getRequestDispatcher(<span class="string">&quot;/orderList.jsp&quot;</span>).forward(request, response);</span><br></pre></td></tr></table></figure>

<p>请求重定向:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//传统方式的请求重定向</span></span><br><span class="line">response.sendRedirect(<span class="string">&quot;/orderList.jsp&quot;</span>);</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="10-2-SpringMvc提供的方式"><a href="#10-2-SpringMvc提供的方式" class="headerlink" title="10.2 SpringMvc提供的方式"></a>10.2 SpringMvc提供的方式</h2><p>请求转发:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/findById&quot;)</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法的返回值为String类型,返回的是视图逻辑名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">findById</span><span class="params">(Model model)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">    model.addAttribute(<span class="string">&quot;orderNum&quot;</span>, <span class="number">220</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;/orderList.jsp&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请求重定向:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">findById</span><span class="params">(Model model)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">    <span class="comment">//重定向时会把orderNum以参数的形式携带在url中</span></span><br><span class="line">    model.addAttribute(<span class="string">&quot;orderNum&quot;</span>, <span class="number">220</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;redirect:/orderList.jsp&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="11-Springmvc中的拦截器"><a href="#11-Springmvc中的拦截器" class="headerlink" title="11. Springmvc中的拦截器"></a>11. Springmvc中的拦截器</h1><p>SpringMVC 中的Interceptor 拦截器是有相当重要的，它的主要作用是拦截用户的请求并进行相应的处理;</p>
<p>定义拦截器可以通过两种方式:</p>
<ul>
<li>通过实现 HandlerInterceptor 接口或继承 HandlerInterceptor 接口的实现类来定义；</li>
<li>通过实现 WebRequestInterceptor 接口或继承 WebRequestInterceptor 接口的实现类来定义。</li>
</ul>
<h2 id="编写拦截器"><a href="#编写拦截器" class="headerlink" title="编写拦截器"></a><strong>编写拦截器</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzy.goods.interceptor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.HandlerInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.ModelAndView;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAllRequestInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyAllRequestInterceptor...请求处理之前....&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyAllRequestInterceptor...请求处理之后......&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyAllRequestInterceptor...视图渲染结束之后&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>拦截器的定义中实现了 HandlerInterceptor 接口，并实现了接口中的 3 个方法。</p>
<ul>
<li>preHandle 方法：该方法在控制器的处理请求方法前执行，其返回值表示是否中断后续操作，返回 true 表示继续向下执行，返回 false 表示中断后续操作。</li>
<li>postHandle 方法：该方法在控制器的处理请求方法调用之后、解析视图之前执行，可以通过此方法对请求域中的模型和视图做进一步的修改。</li>
<li>afterCompletion 方法：该方法在控制器的处理请求方法执行完成后执行，即视图渲染结束后执行，可以通过此方法实现一些资源清理、记录日志信息等工作。</li>
</ul>
<hr>
<h2 id="注册拦截器"><a href="#注册拦截器" class="headerlink" title="注册拦截器"></a>注册拦截器</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置全局拦截器,拦截所有请求--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.xzy.goods.interceptor.MyAllRequestInterceptor&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置某个请求的拦截器,可以使用/**通配符--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/user/findById.do&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.xzy.goods.interceptor.Interceptor01&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="拦截器与过滤器的区别"><a href="#拦截器与过滤器的区别" class="headerlink" title="拦截器与过滤器的区别"></a>拦截器与过滤器的区别</h2><p>过滤器是原生的servlet中提供的过滤请求的一种机制</p>
<p>拦截器是SpringMvc中基于Aop的一种过滤handler的一种机制</p>
<p>在纯Servlet开发中不能直接使用拦截器,拦截器只能在SpringMvc中使用,</p>
<p>在SpringMvc中是直接可以使用过滤器的</p>
<hr>
<h1 id="12-SpringMvc请求参数限定"><a href="#12-SpringMvc请求参数限定" class="headerlink" title="12. SpringMvc请求参数限定"></a>12. SpringMvc请求参数限定</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/findById&quot;)</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">findById</span><span class="params">(<span class="meta">@RequestParam(name = &quot;id&quot;,required = false,defaultValue = &quot;110&quot;)</span> Integer id)</span> &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(id, <span class="string">&quot;admin&quot;</span>, <span class="string">&quot;admin123&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>required: 默认为true,也就是说发送的请求必须要传递这个参数,不传递就会报错,我们想要不传递也不报错就要设置为<code>false</code></p>
<p>defaultValue: 不传递时的默认值,一般与 <code>required = false</code>来进行结合使用;</p>
<hr>
<h1 id="13-SpringMvc接收数组参数"><a href="#13-SpringMvc接收数组参数" class="headerlink" title="13. SpringMvc接收数组参数"></a>13. SpringMvc接收数组参数</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 接收数组参数,前端访问的格式: /user/u3.do?loves=java&amp;loves=python</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> loves</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@GetMapping(&quot;/u3&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">u3</span><span class="params">(String[] loves)</span> &#123;</span><br><span class="line">      System.out.println(Arrays.toString(loves));</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;/login.jsp&quot;</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h1 id="14-跨域问题"><a href="#14-跨域问题" class="headerlink" title="14. 跨域问题"></a>14. 跨域问题</h1><p>一个域的三要素:</p>
<ul>
<li>协议</li>
<li>主机&#x2F;域名</li>
<li>端口</li>
</ul>
<p><code>默认浏览器中不支持后台的ajax跨域访问的;处于安全因素考虑的</code></p>
<p>浏览器对于javascript的同源策略的限制,例如<a href="https://link.zhihu.com/?target=http://a.cn">http://a.cn</a>下面的js不能调用<a href="https://link.zhihu.com/?target=http://b.cn">http://b.cn</a>中的js对象或数据(因为<a href="https://link.zhihu.com/?target=http://a.cn">http://a.cn</a>和<a href="https://link.zhihu.com/?target=http://b.cn">http://b.cn</a>是不同域)</p>
<p>同源策略会阻止一个域的JavaScript脚本和另一个域的内容进行交互</p>
<p>跨域问题的解决方案:</p>
<ul>
<li><p>前端解决(通过代理的方式解决,不推荐)</p>
</li>
<li><p>后端解决(真正意义上解决了跨域问题)</p>
</li>
<li><p><strong>CORS方案，就是通过服务器设置响应头来实现跨域</strong> 。</p>
<p>CORS才是解决跨域的真正解决方案。<br>前端需要做什么？</p>
<p>无需做任何事情，正常发送Ajax请求即可。</p>
<p>后端需要做什么？</p>
<p>需要加响应头 。或者使用第三方模块 cors 。</p>
<p>WebConfig配置类解决跨域问题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> &#123;</span><br><span class="line">        <span class="comment">//设置允许跨域的路径</span></span><br><span class="line">        registry.addMapping(<span class="string">&quot;/**&quot;</span>)</span><br><span class="line">                <span class="comment">//设置允许跨域请求的域名</span></span><br><span class="line">                .allowedOriginPatterns(<span class="string">&quot;*&quot;</span>)</span><br><span class="line">                <span class="comment">//是否允许cookie</span></span><br><span class="line">                .allowCredentials(<span class="literal">true</span>)</span><br><span class="line">                <span class="comment">//设置允许的请求方式</span></span><br><span class="line">                .allowedMethods(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;POST&quot;</span>, <span class="string">&quot;DELETE&quot;</span>, <span class="string">&quot;PUT&quot;</span>)</span><br><span class="line">                <span class="comment">//设置允许的header属性</span></span><br><span class="line">                .allowedHeaders(<span class="string">&quot;*&quot;</span>)</span><br><span class="line">                <span class="comment">//跨域允许时间</span></span><br><span class="line">                .maxAge(<span class="number">3600</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-数据结构与算法：双向链表"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
	
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/07/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%9A%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/"
    >双向链表</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/07/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%9A%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/" class="article-date">
  <time datetime="2022-07-11T12:04:19.000Z" itemprop="datePublished">2022-07-11</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a> / <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/">链表</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h1><p><code>使用带head头的双向链表实现—水浒英雄排行榜</code></p>
<ul>
<li><p>单向链表的缺点</p>
<ul>
<li>单向链表，查找的方向只能是一个方向，而双向链表可以向前或者向后查找</li>
<li>单向链表不能自我删除，需要靠辅助节点，而双向链表，则可以自我删除，所以前面我们单链表删除时节点，总是找到temp,temp是待删除节点的前一个节点(认真体会).</li>
</ul>
</li>
<li><p>双向链表遍历，添加，修改和删除的思路</p>
</li>
</ul>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220711203520468.png" alt="image-20220711203520468"></p>
<ul>
<li><p><strong>遍历</strong></p>
<ul>
<li>方法和单链表一样，只是可以向前，也可以向后查找</li>
</ul>
</li>
<li><p><strong>添加</strong>(默认添加到双向链表的最后)</p>
<ol>
<li>先找到双向链表的最后这个节点</li>
<li>temp.next &#x3D; newHeroNode</li>
<li>newHeroNode.pre &#x3D; temp</li>
</ol>
</li>
<li><p><strong>添加</strong>(按排名添加)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (temp.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">    heroNode.next=temp.next;</span><br><span class="line">    temp.next.pre=heroNode;</span><br><span class="line">    temp.next=heroNode;</span><br><span class="line">    heroNode.pre=temp;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    temp.next = heroNode;<span class="comment">//后指前</span></span><br><span class="line">    heroNode.pre = temp;<span class="comment">//前指后</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>修改</strong></p>
<p>思路和原来的单向链表一样</p>
</li>
<li><p>删除</p>
<ol>
<li>因为是双向链表，因此，我们可以实现自我删除某个节点</li>
<li>直接找到要删除的这个节点，比如 temp</li>
<li>temp.pre.next &#x3D; temp.next</li>
<li>temp.next.pre &#x3D;temp.pre</li>
</ol>
</li>
</ul>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ysy.linkedlist;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DoubleLinkedListDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//双向链表的测试</span></span><br><span class="line">        System.out.println(<span class="string">&quot;双向链表的测试&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建节点</span></span><br><span class="line">        <span class="type">HeroNode2</span> <span class="variable">heroNode1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode2</span>(<span class="number">1</span>, <span class="string">&quot;宋江&quot;</span>, <span class="string">&quot;及时雨&quot;</span>);</span><br><span class="line">        <span class="type">HeroNode2</span> <span class="variable">heroNode2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode2</span>(<span class="number">2</span>, <span class="string">&quot;卢俊义&quot;</span>, <span class="string">&quot;玉麒麟&quot;</span>);</span><br><span class="line">        <span class="type">HeroNode2</span> <span class="variable">heroNode3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode2</span>(<span class="number">3</span>, <span class="string">&quot;吴用&quot;</span>, <span class="string">&quot;智多星&quot;</span>);</span><br><span class="line">        <span class="type">HeroNode2</span> <span class="variable">heroNode4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode2</span>(<span class="number">4</span>, <span class="string">&quot;林冲&quot;</span>, <span class="string">&quot;豹子头&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建双向链表</span></span><br><span class="line">        <span class="type">DoubleLinkedList</span> <span class="variable">doubleLinkedList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DoubleLinkedList</span>();</span><br><span class="line"><span class="comment">//        //测试添加（无序）</span></span><br><span class="line"><span class="comment">//        doubleLinkedList.add(heroNode1);</span></span><br><span class="line"><span class="comment">//        doubleLinkedList.add(heroNode2);</span></span><br><span class="line"><span class="comment">//        doubleLinkedList.add(heroNode3);</span></span><br><span class="line"><span class="comment">//        doubleLinkedList.add(heroNode4);</span></span><br><span class="line">        <span class="comment">//测试添加（有序）</span></span><br><span class="line">        doubleLinkedList.addByOrder(heroNode1);</span><br><span class="line">        doubleLinkedList.addByOrder(heroNode4);</span><br><span class="line">        doubleLinkedList.addByOrder(heroNode2);</span><br><span class="line">        doubleLinkedList.addByOrder(heroNode3);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出原链表</span></span><br><span class="line">        System.out.println(<span class="string">&quot;原双向链表~&quot;</span>);</span><br><span class="line">        doubleLinkedList.list();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试更新</span></span><br><span class="line">        <span class="type">HeroNode2</span> <span class="variable">newHeroNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode2</span>(<span class="number">2</span>, <span class="string">&quot;小卢&quot;</span>, <span class="string">&quot;玉麒麟&quot;</span>);</span><br><span class="line">        doubleLinkedList.update(newHeroNode);</span><br><span class="line">        System.out.println(<span class="string">&quot;更新后的链表~&quot;</span>);</span><br><span class="line">        doubleLinkedList.list();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试删除</span></span><br><span class="line">        doubleLinkedList.del(<span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;删除后的链表&quot;</span>);</span><br><span class="line">        doubleLinkedList.list();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个双向链表类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DoubleLinkedList</span>&#123;</span><br><span class="line">    <span class="comment">//初始化一个头节点，不要动，不存放具体的数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">HeroNode2</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode2</span>(<span class="number">0</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> HeroNode2 <span class="title function_">getHead</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加节点到单向列表中</span></span><br><span class="line">    <span class="comment">//思路：不考虑编号顺序</span></span><br><span class="line">    <span class="comment">//1.找到当前链表的最后节点</span></span><br><span class="line">    <span class="comment">//2.将最后节点的next指向新的节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(HeroNode2 heroNode)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//因为head绩点不能动，所以需要一个辅助遍历temp</span></span><br><span class="line">        <span class="type">HeroNode2</span> <span class="variable">temp</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">//遍历链表，找到最后</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="comment">//找到链表的最后</span></span><br><span class="line">            <span class="keyword">if</span>(temp.next == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果没有找到最后，将temp后移</span></span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//出循环代表temp已指向了链表的最后</span></span><br><span class="line">        <span class="comment">//将最后这个节点指向新节点</span></span><br><span class="line">        temp.next = heroNode;</span><br><span class="line">        heroNode.pre = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据排名添加节点到链表中，如果排名存在，则输出添加失败</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addByOrder</span><span class="params">(HeroNode2 heroNode)</span>&#123;</span><br><span class="line">        <span class="comment">//头节点不能动，使用辅助变量temp来寻找添加的位置</span></span><br><span class="line">        <span class="comment">//temp是位于添加位置的前一个节点，否则插入不了</span></span><br><span class="line">        <span class="type">HeroNode2</span> <span class="variable">temp</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;<span class="comment">//标志添加的编号是否存在</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="comment">//链表已到最后</span></span><br><span class="line">            <span class="keyword">if</span>(temp.next == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(temp.next.number &gt; heroNode.number)&#123;<span class="comment">//位置找到，插在后面</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(temp.next.number == heroNode.number)&#123;</span><br><span class="line">                flag = <span class="literal">true</span>;<span class="comment">//说明标号存在</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;<span class="comment">//后移，遍历链表</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;编号 %d 已存在，不能添加\n&quot;</span>, heroNode.number);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//插入链表中，temp后面</span></span><br><span class="line">            <span class="keyword">if</span> (temp.next != <span class="literal">null</span>)&#123;</span><br><span class="line">                heroNode.next = temp.next;</span><br><span class="line">                temp.next.pre = heroNode;</span><br><span class="line">                temp.next = heroNode;</span><br><span class="line">                heroNode.pre = temp;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                temp.next = heroNode;<span class="comment">//后指前</span></span><br><span class="line">                heroNode.pre = temp;<span class="comment">//前指后</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据number来修改节点信息，number不能改</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(HeroNode2 newHeroNode)</span>&#123;</span><br><span class="line">        <span class="comment">//判断是否为空</span></span><br><span class="line">        <span class="keyword">if</span>(head.next == <span class="literal">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空~&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//找到需要修改的节点，根据number编号</span></span><br><span class="line">        <span class="comment">//辅助变量，遍历链表</span></span><br><span class="line">        <span class="type">HeroNode2</span> <span class="variable">temp</span> <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(temp == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;<span class="comment">//链表遍历完成</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(temp.number == newHeroNode.number)&#123;</span><br><span class="line">                <span class="comment">//找到</span></span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//根据flag判断是否找到要修改的节点</span></span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            temp.name = newHeroNode.name;</span><br><span class="line">            temp.nickName = newHeroNode.nickName;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;没有找到编号 %d 的节点\n&quot;</span>, newHeroNode.number);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除节点</span></span><br><span class="line">    <span class="comment">//思路</span></span><br><span class="line">    <span class="comment">//1.对于双向链表，可以直接找到要删除的节点</span></span><br><span class="line">    <span class="comment">//2.找到后，自我删除</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">del</span><span class="params">(<span class="type">int</span> number)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head.next == <span class="literal">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空，无法删除&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">HeroNode2</span> <span class="variable">temp</span> <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;<span class="comment">//标志是否找到要删除的节点</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(temp == <span class="literal">null</span>)&#123;<span class="comment">//链表已到最后</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(temp.number == number)&#123;</span><br><span class="line">                <span class="comment">//找到</span></span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;<span class="comment">//temp后移，遍历链表</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断flag</span></span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            temp.pre.next = temp.next;</span><br><span class="line">            <span class="comment">//删除的节点是最后一个节点时有问题</span></span><br><span class="line">            <span class="comment">//如果删除的是最后一个节点，就不需要执行这行，否则会出现空指针 temp.next.pre = temp.pre</span></span><br><span class="line">            <span class="keyword">if</span>(temp.next != <span class="literal">null</span>)&#123;</span><br><span class="line">                temp.next.pre = temp.pre;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;要删除的 %d 节点不存在\n&quot;</span>, number);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//显示链表，遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">list</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//判断链表是否为空</span></span><br><span class="line">        <span class="keyword">if</span>(head.next == <span class="literal">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//因为头节点不能动，所以辅助变量temp遍历</span></span><br><span class="line">        <span class="type">HeroNode2</span> <span class="variable">temp</span> <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="comment">//判断链表是否走到最后</span></span><br><span class="line">            <span class="keyword">if</span>(temp == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//输出节点信息</span></span><br><span class="line">            System.out.println(temp);</span><br><span class="line">            <span class="comment">//将temp后移</span></span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义HeroNode，每个HeroNode对象就是一个节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HeroNode2</span>&#123;</span><br><span class="line">    <span class="comment">//data域</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> number;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> String nickName;</span><br><span class="line">    <span class="comment">//next域</span></span><br><span class="line">    <span class="keyword">public</span> HeroNode2 next;</span><br><span class="line">    <span class="comment">//pre域</span></span><br><span class="line">    <span class="keyword">public</span> HeroNode2 pre;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HeroNode2</span><span class="params">(<span class="type">int</span> number, String name, String nickName)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.number = number;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.nickName = nickName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 为了显示方法，重回写toString方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;HeroNode&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;number=&quot;</span> + number +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, nickName=&#x27;&quot;</span> + nickName + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-JVM：本地方法栈"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
	
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/07/11/JVM%EF%BC%9A%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88/"
    >本地方法栈</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/07/11/JVM%EF%BC%9A%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88/" class="article-date">
  <time datetime="2022-07-11T11:44:18.000Z" itemprop="datePublished">2022-07-11</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/JVM/">JVM</a> / <a class="article-category-link" href="/categories/JVM/1-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/">1.内存与垃圾回收篇</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <ul>
<li><p><strong>Java虚拟机栈用于管理Java方法的调用，而本地方法栈用于管理本地方法的调用</strong>。</p>
</li>
<li><p>本地方法栈，也是线程私有的。</p>
</li>
<li><p>允许被实现成固定或者是可动态扩展的内存大小。（在内存溢出方面是相的)</p>
<ul>
<li>如果线程请求分配的栈容量超过本地方法栈允许的最大容量，Java虚拟机将会抛出一个stackoverflowError异常。</li>
<li>如果本地方法栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存,或者在创建新的线程时没有足够的内存去创建对应的本地方法栈，那么Java虚拟机将会抛出一个outofMemoryError异常。</li>
</ul>
</li>
<li><p>本地方法是使用c语言实现的。</p>
</li>
<li><p>它的具体做法是Native Method stack中登记native方法，在Execution Engine执行时加载本地方法库。</p>
</li>
</ul>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220711194941019.png" alt="HotSpot JVM Architecture"></p>
<ul>
<li><p><strong>当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界。它和虚拟机拥有同样的权限。</strong></p>
<ul>
<li><strong>本地方法可以通过本地方法接口来访问虚拟机内部的运行时数据区</strong>。</li>
<li>它甚至可以直接使用本地处理器中的寄存器</li>
<li>直接从本地内存的堆中分配任意数量的内存。</li>
</ul>
</li>
<li><p><strong>并不是所有的JVM都支持本地方法。因为Java虚拟机规范并没有明确要求本地方法栈的使用语言、具体实现方式、数据结构等</strong>。如果JVM产品不打算支持native方法，也可以无需实现本地方法栈。</p>
</li>
<li><p>在Hotspot JVM中，直接将本地方法栈和虚拟机栈合二为一。</p>
</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-JVM：本地方法接口"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
	
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/07/11/JVM%EF%BC%9A%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%8E%A5%E5%8F%A3/"
    >本地方法接口</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/07/11/JVM%EF%BC%9A%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%8E%A5%E5%8F%A3/" class="article-date">
  <time datetime="2022-07-11T11:21:28.000Z" itemprop="datePublished">2022-07-11</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/JVM/">JVM</a> / <a class="article-category-link" href="/categories/JVM/1-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/">1.内存与垃圾回收篇</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h1><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220711192334155.png" alt="image-20220711192334155"></p>
<ul>
<li>简单地讲，<strong>一个Native Method就是一个Java调用非Java代码的接口</strong>。一个Native Method是这样一个Java方法:该方法的实现由非Java语言实现，比如<br>c。这个特征并非Java所特有，很多其它的编程语言都有这一机制，比如在c++中，你可以用extern “c”告知C++编译器去调用一个c的函数。</li>
<li>“Anative methoq ia code Whose implemetation is provided by non-java code. “</li>
<li>在定义一个native method时，并<strong>不提供实现体</strong>（有些像定义一个Javainterface) ，因为其实现体是由非java语言在外面实现的。</li>
<li>本地接口的作用是<strong>融合不同的编程语言为Java所用</strong>，它的初衷是融合c&#x2F;C++程序。</li>
<li>标识符native可以与所有其它的java标识符连用，但是<strong>abstract除外</strong></li>
</ul>
<h1 id="为什么使用Native-Method"><a href="#为什么使用Native-Method" class="headerlink" title="为什么使用Native Method?"></a>为什么使用Native Method?</h1><p>Java使用起来非常方便，然而有些层次的任务用Java实现起来不容易，或者我们对程序的效率很在意时，问题就来了。</p>
<ul>
<li><p><strong>与Java环境外交互</strong></p>
<ul>
<li>有时<strong>Java应用需要与Java外面的环境交互，这是本地方法存在的主要原因</strong>。你可以想想Java需要与一些底层系统，如操作系统或某些硬件交换信息时的情况。本地方法正是这样一种交流机制:它为我们提供了一个非常简洁的接口，而且我们无需去了解Java应用之外的繁琐的细节。</li>
</ul>
</li>
<li><p><strong>与操作系统交互</strong></p>
<ul>
<li>JVM支持着Java语言本身和运行时库，它是Java程序赖以生存的平台，它由一个解释器（解释字节码）和一些连接到本地代码的库组成。然而不管怎样，它毕竟不是一个完整的系统，它经常依赖于一些底层系统的支持。这些底层系统常常是强大的操作系统。<strong>通过使用本地方法。我们得以用Java实现了jre的与底层系统的交互，甚至JVM的一些部分就是用c写的</strong>。还有，如果我们要使用一些Java语言本身没有提供封装的操作系统的特性时，我们也需要使用本地方法。</li>
</ul>
</li>
<li><p><strong>sun ‘s Java</strong></p>
<ul>
<li><strong>sun的解释器是用c实现的，这使得它能像一些普通的c一样与外部交互</strong>。jre大部分是用Java实现的，它也通过一些本地方法与外界交互。例如:类java. lang.Thread的 setPriority()方法是用Java实现的，但是它实现调用的是该类里的本地方法setPriority0()。这个本地方法是用c实现的，并被植入JVM内部，在windows 95的平台上，这个本地方法最终将调用win32 setPriority () API。这是一个本地方法的具体实现由JVM直接提供，更多的情况是本地方法由外部的动态链接库(external dynamic link library）提供，然后被JVM调用。</li>
</ul>
</li>
</ul>
<h1 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h1><p><strong>目前该方法使用的越来越少了，除非是与硬件有关的应用</strong>，比如通过Java程序驱动打印机或者Java系统管理生产设备，在企业级应用中已经比较少见。因为现在的异构领域间的通信很发达，比如可以使用socket通信，也可以使用web service等等，不多做介绍。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-JVM：虚拟机栈"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
	
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/07/10/JVM%EF%BC%9A%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/"
    >虚拟机栈</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/07/10/JVM%EF%BC%9A%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/" class="article-date">
  <time datetime="2022-07-10T14:03:26.000Z" itemprop="datePublished">2022-07-10</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/JVM/">JVM</a> / <a class="article-category-link" href="/categories/JVM/1-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/">1.内存与垃圾回收篇</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h2 id="虚拟机栈的出现背景"><a href="#虚拟机栈的出现背景" class="headerlink" title="虚拟机栈的出现背景"></a>虚拟机栈的出现背景</h2><ul>
<li>由于<strong>跨平台性</strong>的设计，Java的指令都是根据<code>栈</code>来设计的。不同平台CPU架构不同，所以不能设计为基于寄存器的【如果设计成基于寄存器的，耦合度高，性能会有所提升，因为可以对具体的CPU架构进行优化，但是跨平台性大大降低】。</li>
<li>优点是<strong>跨平台，指令集小，编译器容易实现</strong>，缺点是<strong>性能下降，实现同样的功能需要更多的指令</strong>。</li>
</ul>
<h2 id="内存中的栈与堆"><a href="#内存中的栈与堆" class="headerlink" title="内存中的栈与堆"></a>内存中的栈与堆</h2><ul>
<li><code>栈是运行时的单位，而堆是存储的单位</code></li>
<li>即：栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。堆解决的是数据存储的问题，即数据怎么放，放哪里</li>
</ul>
<h2 id="虚拟机栈基本内容"><a href="#虚拟机栈基本内容" class="headerlink" title="虚拟机栈基本内容"></a>虚拟机栈基本内容</h2><ul>
<li><p>Java虚拟机栈是什么？</p>
<ul>
<li>Java虚拟机栈（Java Virtual Machine Stack），早期也叫Java栈。每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧（Stack Frame），<strong>对应着一次次的Java方法调用</strong>，栈是线程私有的</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StackTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">StackTest</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StackTest</span>();</span><br><span class="line">        test.methodA();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">        methodB();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">40</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220709155549895.png" alt="Java虚拟机栈"></p>
<ul>
<li><p>虚拟机栈的生命周期</p>
<ul>
<li><strong>生命周期和线程一致，也就是线程结束了，该虚拟机栈也销毁了</strong></li>
</ul>
</li>
<li><p>虚拟机栈的作用</p>
<p>主管Java程序的运行，它保存方法的局部变量（8 种基本数据类型、对象的引用地址）、部分结果，并参与方法的调用和返回</p>
<ul>
<li>局部变量，它是相比于成员变量来说的（或属性）</li>
<li>基本数据类型变量 ，它是相比于引用类型变量（类、数组、接口）</li>
</ul>
</li>
</ul>
<h2 id="虚拟机栈的特点"><a href="#虚拟机栈的特点" class="headerlink" title="虚拟机栈的特点"></a>虚拟机栈的特点</h2><ul>
<li><p>栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器。</p>
</li>
<li><p>JVM直接对Java栈的操作只有两个：</p>
<ul>
<li>每个方法执行，伴随着<strong>进栈</strong>（入栈、压栈）</li>
<li>执行结束后的<strong>出栈</strong>工作</li>
</ul>
</li>
<li><p>对于栈来说不存在垃圾回收问题</p>
<ul>
<li><code>栈不存在GC，但是可能存在OOM</code></li>
</ul>
</li>
</ul>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220709163124431.png" alt="Java栈操作"></p>
<h2 id="虚拟机栈的异常"><a href="#虚拟机栈的异常" class="headerlink" title="虚拟机栈的异常"></a>虚拟机栈的异常</h2><p><strong>面试题：栈中可能出现的异常？</strong></p>
<ul>
<li><p>Java 虚拟机规范允许Java栈的大小是<strong>动态的或者是固定不变的</strong>。</p>
<ul>
<li><p>如果采用固定大小的Java虚拟机栈，那每一个线程的Java虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过Java虚拟机栈允许的最大容量，Java虚拟机将会抛出一个<strong>StackoverflowError</strong> 异常。<strong>例如</strong>：程序不断的进行递归调用，没有退出条件，就会不断地进行压栈，从而发生栈溢出错误。</p>
</li>
<li><p>如果Java虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那Java虚拟机将会抛出一个 <strong>OutofMemoryError</strong> 异常。</p>
</li>
</ul>
</li>
</ul>
<h2 id="设置栈内存大小"><a href="#设置栈内存大小" class="headerlink" title="设置栈内存大小"></a>设置栈内存大小</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><blockquote>
<p>多去官方文档看看：<a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/11/tools/java.html#GUID-3B1CE181-CD30-4178-9602-230B800D4FAE">https://docs.oracle.com/en/java/javase/11/tools/java.html#GUID-3B1CE181-CD30-4178-9602-230B800D4FAE</a></p>
<p>地址经常变</p>
</blockquote>
<p>我们可以使用参数 <strong>-Xss</strong> 选项来设置线程的最大栈空间，栈的大小直接决定了函数调用的最大可达深度。</p>
<blockquote>
<p>Sets the thread stack size (in bytes). Append the letter <code>k</code> or <code>K</code> to indicate KB, <code>m</code> or <code>M</code> to indicate MB, and <code>g</code> or <code>G</code> to indicate GB. The default value depends on the platform:</p>
<ul>
<li>Linux&#x2F;x64 (64-bit): 1024 KB</li>
<li>macOS (64-bit): 1024 KB</li>
<li>Oracle Solaris&#x2F;x64 (64-bit): 1024 KB</li>
<li>Windows: The default value depends on virtual memory</li>
</ul>
</blockquote>
<p>The following examples set the thread stack size to 1024 KB in different units:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-Xss1m</span><br><span class="line">-Xss1024k</span><br><span class="line">-Xss1048576</span><br></pre></td></tr></table></figure>

<h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StackErrorTest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(count);</span><br><span class="line">        count++;</span><br><span class="line">        main(args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>没设置参数前</strong></p>
<p>部分输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">11418</span></span><br><span class="line"><span class="number">11419</span></span><br><span class="line"><span class="number">11420</span></span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.StackOverflowError</span><br><span class="line">	at sun.nio.cs.UTF_8$Encoder.encodeLoop(UTF_8.java:<span class="number">691</span>)</span><br></pre></td></tr></table></figure>

<p>说明栈在11406这个深度溢出了</p>
<p><strong>设置栈参数之后</strong></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220709181539874.png" alt="-Xss参数设置"></p>
<p>部分输出结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2474</span></span><br><span class="line"><span class="number">2475</span></span><br><span class="line"><span class="number">2476</span></span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.StackOverflowError</span><br><span class="line">	at sun.nio.cs.UTF_8.updatePositions(UTF_8.java:<span class="number">77</span>)</span><br></pre></td></tr></table></figure>

<p>说明参数起作用了</p>
<h1 id="栈的存储单位"><a href="#栈的存储单位" class="headerlink" title="栈的存储单位"></a>栈的存储单位</h1><h2 id="栈中存储什么？"><a href="#栈中存储什么？" class="headerlink" title="栈中存储什么？"></a>栈中存储什么？</h2><ul>
<li>每个线程都有自己的栈，栈中的数据都是以<strong>栈帧</strong>（Stack Frame）的格式存在</li>
<li>在这个线程上正在执行的<strong>每个方法都各自对应一个栈帧</strong>（Stack Frame）</li>
<li>栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息</li>
</ul>
<h2 id="栈运行原理"><a href="#栈运行原理" class="headerlink" title="栈运行原理"></a>栈运行原理</h2><ul>
<li>JVM直接对Java栈的操作只有两个，就是对栈帧的<strong>压栈和出栈</strong>，遵循 <code>先进后出（后进先出）</code>原则</li>
<li>在一条活动线程中，一个时间点上，只会有一个活动的栈帧。即只有当前正在执行的方法的栈帧（栈顶栈帧）是有效的。这个栈帧被称为<strong>当前栈帧（Current Frame）</strong>，与当前栈帧相对应的方法就是<strong>当前方法（Current Method）</strong>，定义这个方法的类就是<strong>当前类（Current Class）</strong></li>
<li>执行引擎运行的所有字节码指令只针对当前栈帧进行操作</li>
<li>如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，成为新的当前帧</li>
</ul>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220709162020104.png" alt="栈运行原理"></p>
<ul>
<li><strong>不同线程中所包含的栈帧是不允许存在相互引用的</strong>，即不可能在一个栈帧之中引用另外一个线程的栈帧</li>
<li>如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧</li>
<li>Java方法有两种返回函数的方式<ol>
<li>一种是正常的函数返回，使用return指令。</li>
<li>另一种是方法执行中出现未捕获处理的异常，以抛出异常的方式结束。</li>
<li>但不管使用哪种方式，都会导致栈帧被弹出。</li>
</ol>
</li>
</ul>
<h2 id="栈帧的内部结构"><a href="#栈帧的内部结构" class="headerlink" title="栈帧的内部结构"></a>栈帧的内部结构</h2><p>每个栈帧中存储着：</p>
<ul>
<li><p><code>局部变量表（Local Variables）</code></p>
</li>
<li><p><code>操作数栈（Operand Stack）（或表达式栈）</code></p>
</li>
<li><p>动态链接（Dynamic Linking）（或指向运行时常量池的方法引用）</p>
</li>
<li><p>方法返回地址（Return Address）（或方法正常退出或者异常退出的定义）</p>
</li>
<li><p>一些附加信息</p>
</li>
</ul>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220709163457332.png" alt="栈帧的内部结构"></p>
<ul>
<li>并行每个线程下的栈都是私有的，因此每个线程都有自己各自的栈，并且每个栈里面都有很多栈帧，栈帧的大小主要由局部变量表 和 操作数栈决定的</li>
</ul>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220709164108522.png" alt="并行下的栈帧"></p>
<h1 id="局部变量表-Local-Variables"><a href="#局部变量表-Local-Variables" class="headerlink" title="局部变量表(Local Variables)"></a>局部变量表(Local Variables)</h1><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><ul>
<li><p>局部变量表也被称之为局部变量数组或本地变量表</p>
</li>
<li><p>定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量<strong>，这些数据类型包括各类基本数据类型、对象引用（reference），以及returnAddress返回值类型</strong></p>
</li>
<li><p>由于局部变量表是建立在线程的栈上，是线程的私有数据，因此<strong>不存在数据安全问题</strong></p>
</li>
<li><p><strong>局部变量表所需的容量大小是在编译期确定下来的</strong>，并保存在方法的Code属性的 <strong>maximum local variables</strong> 数据项中。在方法运行期间是不会改变局部变量表的大小的</p>
</li>
<li><p><strong>方法嵌套调用的次数由栈的大小决定</strong>。一般来说，<strong>栈越大，方法嵌套调用次数越多</strong></p>
<ul>
<li>对一个函数而言，它的参数和局部变量越多，使得局部变量表膨胀，它的栈帧就越大，以满足方法调用所需传递的信息增大的需求</li>
<li>进而函数调用就会占用更多的栈空间，导致其嵌套调用次数就会减少</li>
</ul>
</li>
<li><p><strong>局部变量表中的变量只在当前方法调用中有效</strong></p>
<ul>
<li>在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程</li>
<li><strong>当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁</strong></li>
</ul>
</li>
</ul>
<h2 id="举例-1"><a href="#举例-1" class="headerlink" title="举例"></a>举例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LocalVariablesTest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">LocalVariablesTest</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LocalVariablesTest</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        test.test1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//练习：</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testStatic</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">LocalVariablesTest</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LocalVariablesTest</span>();</span><br><span class="line">        <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        System.out.println(count);</span><br><span class="line">        <span class="comment">//因为this变量不存在于当前方法的局部变量表中！！</span></span><br><span class="line"><span class="comment">//        System.out.println(this.count);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关于Slot的使用的理解</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LocalVariablesTest</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.count = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        <span class="type">String</span> <span class="variable">name1</span> <span class="operator">=</span> <span class="string">&quot;atguigu.com&quot;</span>;</span><br><span class="line">        test2(date, name1);</span><br><span class="line">        System.out.println(date + name1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">test2</span><span class="params">(Date dateP, String name2)</span> &#123;</span><br><span class="line">        dateP = <span class="literal">null</span>;</span><br><span class="line">        name2 = <span class="string">&quot;songhongkang&quot;</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">weight</span> <span class="operator">=</span> <span class="number">130.5</span>;<span class="comment">//占据两个slot</span></span><br><span class="line">        <span class="type">char</span> <span class="variable">gender</span> <span class="operator">=</span> <span class="string">&#x27;男&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> dateP + name2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            b = a + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//变量c使用之前已经销毁的变量b占据的slot的位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220709171432102.png" alt="局部变量表大小示例"></p>
<p>看完字节码后，可得结论：所以局部变量表所需的容量大小是在编译期确定下来的。</p>
<h3 id="部分详解"><a href="#部分详解" class="headerlink" title="部分详解"></a>部分详解</h3><p>为了更好讲解，我们直接用jclasslib来看字节码，以main方法为例来讲解。一些一目了然的就不讲了</p>
<ul>
<li>方法名、返回值、参数、修饰符</li>
</ul>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220709173848417.png" alt="image-20220709173848417"></p>
<ul>
<li>0-15  也就是有16行字节码</li>
</ul>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220709171741891.png" alt="image-20220709171741891"></p>
<ul>
<li>方法异常信息表</li>
</ul>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220709171839417.png" alt="image-20220709171839417"></p>
<ul>
<li>杂项(Misc)</li>
</ul>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220709171910169.png" alt="image-20220709171910169"></p>
<ul>
<li>行号表<ul>
<li>Java代码的行号和字节码指令行号的对应关系</li>
</ul>
</li>
</ul>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220709172506969.png" alt="image-20220709172506969"></p>
<ul>
<li>注意：生效行数和剩余有效行数都是针对于字节码文件的行数</li>
</ul>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220709173126144.png" alt="image-20220709173126144"></p>
<ol>
<li>图中圈的东西表示该局部变量的作用域范围</li>
<li>Start PC&#x3D;&#x3D;11表示在字节码的11行开始生效，也就是Java代码对应的第11行。而声明int num在java代码的是第10行，说明是从声明的下一行开始生效</li>
<li>Length&#x3D;&#x3D; 5表示局部变量剩余有效行数，main方法字节码指令总共有16行，从11行开始生效，那么剩下就是16-11 &#x3D;&#x3D;5</li>
<li><code>Ljava/lang/String</code>   前面的L表示引用类型</li>
</ol>
<h2 id="Slot（一个Slot四个字节）"><a href="#Slot（一个Slot四个字节）" class="headerlink" title="Slot（一个Slot四个字节）"></a>Slot（一个Slot四个字节）</h2><ul>
<li><p>参数值的存放总是从局部变量数组<strong>索引 0</strong> 的位置开始，到<strong>数组长度-1</strong>的索引结束</p>
</li>
<li><p>局部变量表，<strong>最基本的存储单元是Slot（变量槽）</strong></p>
</li>
<li><p>局部变量表中存放编译期可知的各种基本数据类型（8种），引用类型（reference），returnAddress类型的变量。</p>
</li>
<li><p>在局部变量表里，<u><strong>32位以内的类型只占用一个slot</strong></u>（包括returnAddress类型），<strong>64位的类型占用两个slot</strong>（long和double）。</p>
<ul>
<li>byte、short、char在储存前被转换为int，boolean也被转换为int，0表示false，非0表示true</li>
<li>long和double则占据两个slot</li>
</ul>
</li>
<li><p>JVM会为局部变量表中的每一个Slot都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值</p>
</li>
<li><p>当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会<strong>按照顺序被复制</strong>到局部变量表中的每一个slot上</p>
</li>
<li><p>如果需要访问局部变量表中一个64bit的局部变量值时，只需要使用前一个索引**(起始索引)**即可。（比如：访问long或double类型变量）</p>
</li>
<li><p>如果当前帧是由构造方法或者实例方法(非静态方法)创建的，那么<strong>该对象引用this将会存放在index为0的slot处</strong>，其余的参数按照参数表顺序继续排列。（this也相当于一个变量）（<u>this变量不存在于当前方法的局部变量表中，即静态方法中，不能使用this</u>）</p>
</li>
</ul>
<h2 id="Slot代码示例"><a href="#Slot代码示例" class="headerlink" title="Slot代码示例"></a>Slot代码示例</h2><p><strong>this 存放在 index &#x3D; 0 的位置：</strong></p>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testStatic</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">LocalVariablesTest</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LocalVariablesTest</span>();</span><br><span class="line">    <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    System.out.println(count);</span><br><span class="line">    <span class="comment">//因为this变量不存在于当前方法的局部变量表中！！</span></span><br><span class="line">    <span class="comment">//System.out.println(this.count);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//关于Slot的使用的理解</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LocalVariablesTest</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.count = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>局部变量表：this 存放在 index &#x3D; 0 的位置</li>
<li>实例方法：this 存放在 index &#x3D; 0 的位置</li>
</ul>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220709175325077.png" alt="image-20220709175325077"></p>
<ul>
<li>构造器方法：this 存放在 index &#x3D; 0 的位置</li>
</ul>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220709175441856.png" alt="image-20220709175441856"></p>
<ul>
<li>静态方法：局部变量表中无this变量，<strong>static 无法调用 this</strong></li>
</ul>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220709175630711.png" alt="image-20220709175630711"></p>
<ul>
<li><p><strong>64位的类型（1ong和double）占用两个slot</strong></p>
</li>
<li><p>代码</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">test2</span><span class="params">(Date dateP, String name2)</span> &#123;</span><br><span class="line">      dateP = <span class="literal">null</span>;</span><br><span class="line">      name2 = <span class="string">&quot;songhongkang&quot;</span>;</span><br><span class="line">      <span class="type">double</span> <span class="variable">weight</span> <span class="operator">=</span> <span class="number">130.5</span>;<span class="comment">//占据两个slot</span></span><br><span class="line">      <span class="type">char</span> <span class="variable">gender</span> <span class="operator">=</span> <span class="string">&#x27;男&#x27;</span>;</span><br><span class="line">      <span class="keyword">return</span> dateP + name2;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>weight 为 double 类型，index 直接从 3 蹦到了 5</li>
</ul>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220709180113818.png" alt="image-20220709180113818"></p>
<h2 id="Slot的重复利用"><a href="#Slot的重复利用" class="headerlink" title="Slot的重复利用"></a>Slot的重复利用</h2><ul>
<li><p><strong>栈帧中的局部变量表中的槽位是可以重用的</strong>，如果一个局部变量过了其作用域，那么在其作用域之后申明新的局部变量变就很有可能会复用过期局部变量的槽位，从而达到节省资源的目的。</p>
</li>
<li><p>代码</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        b = a + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//变量c使用之前已经销毁的变量b占据的slot的位置</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>局部变量 c 重用了局部变量 b 的 slot 位置</li>
</ul>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220709180423297.png" alt="image-20220709180423297"></p>
<h2 id="静态变量与局部变量的对比"><a href="#静态变量与局部变量的对比" class="headerlink" title="静态变量与局部变量的对比"></a>静态变量与局部变量的对比</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">变量的分类：</span><br><span class="line"><span class="number">1</span>、按照数据类型分：① 基本数据类型  ② 引用数据类型</span><br><span class="line"><span class="number">2</span>、按照在类中声明的位置分：</span><br><span class="line">  <span class="number">2</span>-<span class="number">1</span>、成员变量：在使用前，都经历过默认初始化赋值</span><br><span class="line">       <span class="number">2</span>-<span class="number">1</span>-<span class="number">1</span>、类变量: linking的prepare阶段：给类变量默认赋值</span><br><span class="line">              			---&gt; initial阶段：给类变量显式赋值即静态代码块赋值</span><br><span class="line">       <span class="number">2</span>-<span class="number">1</span>-<span class="number">2</span>、实例变量：随着对象的创建，会在堆空间中分配实例变量空间，并进行默认赋值</span><br><span class="line">  <span class="number">2</span>-<span class="number">2</span>、局部变量：在使用前，必须要进行显式赋值的！否则，编译不通过。</span><br></pre></td></tr></table></figure>

<ul>
<li>参数表分配完毕之后，再根据方法体内定义的变量的顺序和作用域分配</li>
<li>成员变量有两次初始化的机会<strong>，</strong>第一次是在“准备阶段”，执行系统初始化，对类变量设置零值，另一次则是在“初始化”阶段，赋予程序员在代码中定义的初始值</li>
<li>和类变量初始化不同的是，<strong>局部变量表不存在系统初始化的过程</strong>，这意味着一旦定义了局部变量则必须人为的初始化，否则无法使用</li>
</ul>
<h3 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h3><ul>
<li>在栈帧中，与性能调优关系最为密切的部分就是前面提到的局部变量表。在方法执行时，虚拟机使用局部变量表完成方法的传递</li>
<li><strong>局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收</strong></li>
</ul>
<h1 id="操作数栈-Operand-Stack"><a href="#操作数栈-Operand-Stack" class="headerlink" title="操作数栈(Operand Stack)"></a>操作数栈(Operand Stack)</h1><p><code>数组实现</code></p>
<h2 id="操作数栈的特点"><a href="#操作数栈的特点" class="headerlink" title="操作数栈的特点"></a>操作数栈的特点</h2><ul>
<li>每一个独立的栈帧除了包含局部变量表以外，还包含一个后进先出（Last - In - First -Out）的 操作数栈，也可以称之为<strong>表达式栈</strong>（Expression Stack）</li>
<li>操作数栈，在方法执行过程中，<strong>根据字节码指令，往栈中写入数据或提取数据</strong>，即入栈（push）和 出栈（pop）<ul>
<li>某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈。使用它们后再把结果压入栈</li>
<li>比如：执行复制、交换、求和等操作</li>
</ul>
</li>
</ul>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220710155140595.png" alt="image-20220710155140595"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220710155217596.png" alt="image-20220710155217596"></p>
<h2 id="操作数栈的作用"><a href="#操作数栈的作用" class="headerlink" title="操作数栈的作用"></a>操作数栈的作用</h2><ul>
<li><p>操作数栈，<strong>主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间</strong></p>
</li>
<li><p>操作数栈就是JVM执行引擎的一个工作区，当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，<strong>这时方法的操作数栈是空的</strong></p>
</li>
<li><p><strong>每一个操作数栈都会拥有一个明确的栈深度用于存储数值</strong>，其所需的最大深度在<strong>编译期就定义好了</strong>，保存在方法的Code属性中，为<strong>max_stack</strong>的值</p>
</li>
<li><p>栈中的任何一个元素都是可以任意的Java数据类型</p>
<ul>
<li>32bit的类型占用一个栈单位深度</li>
<li>64bit的类型占用两个栈单位深度</li>
</ul>
</li>
<li><p><strong>操作数栈并非采用访问索引的方式来进行数据访问的</strong>，而是只能通过标准的入栈和出栈操作来完成一次数据访问。<u><strong>只不过操作数栈是用数组这个结构来实现的而已</strong></u></p>
</li>
<li><p><strong>如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中，</strong>并更新PC寄存器中下一条需要执行的字节码指令</p>
</li>
<li><p>操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译器期间进行验证，同时在类加载过程中的类检验阶段的数据流分析阶段要再次验证</p>
</li>
<li><p><strong>Java虚拟机的解释引擎是基于栈的执行引擎，其中的栈指的就是操作数栈</strong></p>
</li>
</ul>
<img src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_004/0020.jpg">

<p>局部变量表就相当于食材</p>
<p>操作数栈就相当于做法步骤</p>
<h2 id="操作数栈代码追踪"><a href="#操作数栈代码追踪" class="headerlink" title="操作数栈代码追踪"></a>操作数栈代码追踪</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testAddOperation</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="comment">//byte、short、char、boolean：都以int型来保存</span></span><br><span class="line">       <span class="type">byte</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">15</span>;</span><br><span class="line">       <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line">       <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> i + j;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// int m = 800;</span></span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>对应字节码指令</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">0</span> bipush <span class="number">15</span></span><br><span class="line"> <span class="number">2</span> istore_1</span><br><span class="line"> <span class="number">3</span> bipush <span class="number">8</span></span><br><span class="line"> <span class="number">5</span> istore_2</span><br><span class="line"> <span class="number">6</span> iload_1</span><br><span class="line"> <span class="number">7</span> iload_2</span><br><span class="line"> <span class="number">8</span> iadd</span><br><span class="line"> <span class="number">9</span> istore_3</span><br><span class="line"><span class="number">10</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220710160334929.png" alt="image-20220710160334929"></p>
<h3 id="一步一步看流程"><a href="#一步一步看流程" class="headerlink" title="一步一步看流程"></a>一步一步看流程</h3><p>1、首先执行第一条语句，PC寄存器指向的是0，也就是指令地址为0，然后使用bipush让操作数15入操作数栈。</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220710161128378.png" alt="image-20220710161128378"></p>
<p>2、执行完后，PC寄存器往下移，指向下一行代码，下一行代码就是将操作数栈的元素存储到局部变量表1的位置（istore_1），我们可以看到局部变量表的已经增加了一个元素。并且操作数栈为空了</p>
<ul>
<li>解释为什么局部变量表索引从 1 开始，因为该方法为实例方法，局部变量表索引为 0 的位置存放的是 this</li>
</ul>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220710161210317.png" alt="image-20220710161210317"></p>
<p>3、然后PC下移，指向的是下一行。让操作数8也入栈，同时执行store操作，存入局部变量表中</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220710161411467.png" alt="image-20220710161411467"></p>
<p>4、然后从局部变量表中，依次将数据放在操作数栈中，等待执行 add 操作</p>
<p>iload_1：取出局部变量表中索引为1的数据入操作数栈</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220710161551816.png" alt="image-20220710161551816"></p>
<p>5、然后将操作数栈中的两个元素执行相加操作，并存储在局部变量表3的位置</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220710161726152.png" alt="image-20220710161726152"></p>
<h3 id="小问题"><a href="#小问题" class="headerlink" title="小问题"></a>小问题</h3><p><strong>关于类型转换的说明</strong></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220710162410311.png" alt="image-20220710162410311"></p>
<ul>
<li>因为 8 可以存放在 byte 类型中，所以压入操作数栈的类型为 byte ，而不是 int ，所以执行的字节码指令为 bipush 8</li>
<li>但是<strong>存储</strong>在局部变量的时候，会转成 int 类型的变量：istore_4</li>
</ul>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220710162505146.png" alt="image-20220710162505146"></p>
<ul>
<li>m改成800之后，byte存储不了，就成了short型，sipush 800</li>
</ul>
<p><strong>如果被调用的方法带有返回值，返回值入操作数栈</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSum</span><span class="params">()</span>&#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">      <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">      <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> m + n;</span><br><span class="line">      <span class="keyword">return</span> k;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGetSum</span><span class="params">()</span>&#123;</span><br><span class="line">      <span class="comment">//获取上一个栈桢返回的结果，并保存在操作数栈中</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> getSum();</span><br><span class="line">      <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>getSum() 方法字节码指令：最后带着个 ireturn</li>
</ul>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220710162834972.png" alt="image-20220710162834972"></p>
<ul>
<li>testGetSum() 方法字节码指令：一上来就加载 getSum() 方法的返回值()</li>
<li>获取上一个栈帧返回的结果，并保存在操作数栈中</li>
</ul>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220710162953695.png" alt="image-20220710162953695"></p>
<h2 id="栈顶缓存技术-Top-Of-Stack-Cashing"><a href="#栈顶缓存技术-Top-Of-Stack-Cashing" class="headerlink" title="栈顶缓存技术(Top Of Stack Cashing)"></a>栈顶缓存技术(Top Of Stack Cashing)</h2><ul>
<li>前面提过，基于栈式架构的虚拟机所使用的零地址指令更加紧凑，但完成一项操作的时候必然需要使用更多的入栈和出栈指令，这同时也就意味着将需要更多的指令分派（instruction dispatch）次数（也就是你会发现指令很多）和导致内存读&#x2F;写次数多，效率不高。</li>
<li>由于操作数是存储在内存中的，因此频繁地执行内存读&#x2F;写操作必然会影响执行速度。为了解决这个问题，HotSpot JVM的设计者们提出了栈顶缓存（Tos，Top-of-Stack Cashing）技术，<strong>将栈顶元素全部缓存在物理CPU的寄存器中，以此降低对内存的读&#x2F;写次数，提升执行引擎的执行效率。</strong></li>
<li>寄存器的主要优点：指令更少，执行速度快，但是指令集（也就是指令种类）很多</li>
</ul>
<h1 id="动态链接-Dynamic-Linking"><a href="#动态链接-Dynamic-Linking" class="headerlink" title="动态链接(Dynamic Linking)"></a>动态链接(Dynamic Linking)</h1><p><strong>动态链接（或指向运行时常量池的方法引用）</strong></p>
<ul>
<li>每一个栈帧内部都包含<strong>一个指向运行时常量池中该栈帧所属方法的引用</strong>。包含这个引用的目的就是<strong>为了支持当前方法的代码能够实现动态链接</strong>（Dynamic Linking），比如：invokedynamic指令</li>
<li>在Java源文件被编译到字节码文件中时，<strong>所有的变量和方法引用都作为符号引用</strong>（Symbolic Reference）保存在<strong>class文件的常量池</strong>里。比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么<strong>动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DynamicLinkingTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;methodA()....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;methodB()....&quot;</span>);</span><br><span class="line"></span><br><span class="line">        methodA();</span><br><span class="line"></span><br><span class="line">        num++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对应字节码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line">Classfile /D:/JavaProjects/jvm/out/production/jvm01/com/ysy/DynamicLinkingTest.<span class="keyword">class</span></span><br><span class="line">  <span class="title class_">Last</span> modified <span class="number">2022</span>-<span class="number">7</span>-<span class="number">10</span>; size <span class="number">692</span> bytes</span><br><span class="line">  MD5 checksum 746188f57e388e00c568b7021f590e85</span><br><span class="line">  Compiled from <span class="string">&quot;DynamicLinkingTest.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">com</span>.ysy.DynamicLinkingTest</span><br><span class="line">  minor version: <span class="number">0</span></span><br><span class="line">  major version: <span class="number">52</span></span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #<span class="number">1</span> = Methodref          #<span class="number">9.</span>#<span class="number">23</span>         <span class="comment">// java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">   #<span class="number">2</span> = Fieldref           #<span class="number">8.</span>#<span class="number">24</span>         <span class="comment">// com/ysy/DynamicLinkingTest.num:I</span></span><br><span class="line">   #<span class="number">3</span> = Fieldref           #<span class="number">25.</span>#<span class="number">26</span>        <span class="comment">// java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">   #<span class="number">4</span> = String             #<span class="number">27</span>            <span class="comment">// methodA()....</span></span><br><span class="line">   #<span class="number">5</span> = Methodref          #<span class="number">28.</span>#<span class="number">29</span>        <span class="comment">// java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">   #<span class="number">6</span> = String             #<span class="number">30</span>            <span class="comment">// methodB()....</span></span><br><span class="line">   #<span class="number">7</span> = Methodref          #<span class="number">8.</span>#<span class="number">31</span>         <span class="comment">// com/ysy/DynamicLinkingTest.methodA:()V</span></span><br><span class="line">   #<span class="number">8</span> = Class              #<span class="number">32</span>            <span class="comment">// com/ysy/DynamicLinkingTest</span></span><br><span class="line">   #<span class="number">9</span> = Class              #<span class="number">33</span>            <span class="comment">// java/lang/Object</span></span><br><span class="line">  #<span class="number">10</span> = Utf8               num</span><br><span class="line">  #<span class="number">11</span> = Utf8               I</span><br><span class="line">  #<span class="number">12</span> = Utf8               &lt;init&gt;</span><br><span class="line">  #<span class="number">13</span> = Utf8               ()V</span><br><span class="line">  #<span class="number">14</span> = Utf8               Code</span><br><span class="line">  #<span class="number">15</span> = Utf8               LineNumberTable</span><br><span class="line">  #<span class="number">16</span> = Utf8               LocalVariableTable</span><br><span class="line">  #<span class="number">17</span> = Utf8               <span class="built_in">this</span></span><br><span class="line">  #<span class="number">18</span> = Utf8               Lcom/ysy/DynamicLinkingTest;</span><br><span class="line">  #<span class="number">19</span> = Utf8               methodA</span><br><span class="line">  #<span class="number">20</span> = Utf8               methodB</span><br><span class="line">  #<span class="number">21</span> = Utf8               SourceFile</span><br><span class="line">  #<span class="number">22</span> = Utf8               DynamicLinkingTest.java</span><br><span class="line">  #<span class="number">23</span> = NameAndType        #<span class="number">12</span>:#<span class="number">13</span>        <span class="comment">// &quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">  #<span class="number">24</span> = NameAndType        #<span class="number">10</span>:#<span class="number">11</span>        <span class="comment">// num:I</span></span><br><span class="line">  #<span class="number">25</span> = Class              #<span class="number">34</span>            <span class="comment">// java/lang/System</span></span><br><span class="line">  #<span class="number">26</span> = NameAndType        #<span class="number">35</span>:#<span class="number">36</span>        <span class="comment">// out:Ljava/io/PrintStream;</span></span><br><span class="line">  #<span class="number">27</span> = Utf8               <span class="title function_">methodA</span><span class="params">()</span>....</span><br><span class="line">  #<span class="number">28</span> = Class              #<span class="number">37</span>            <span class="comment">// java/io/PrintStream</span></span><br><span class="line">  #<span class="number">29</span> = NameAndType        #<span class="number">38</span>:#<span class="number">39</span>        <span class="comment">// println:(Ljava/lang/String;)V</span></span><br><span class="line">  #<span class="number">30</span> = Utf8               <span class="title function_">methodB</span><span class="params">()</span>....</span><br><span class="line">  #<span class="number">31</span> = NameAndType        #<span class="number">19</span>:#<span class="number">13</span>        <span class="comment">// methodA:()V</span></span><br><span class="line">  #<span class="number">32</span> = Utf8               com/ysy/DynamicLinkingTest</span><br><span class="line">  #<span class="number">33</span> = Utf8               java/lang/Object</span><br><span class="line">  #<span class="number">34</span> = Utf8               java/lang/System</span><br><span class="line">  #<span class="number">35</span> = Utf8               out</span><br><span class="line">  #<span class="number">36</span> = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #<span class="number">37</span> = Utf8               java/io/PrintStream</span><br><span class="line">  #<span class="number">38</span> = Utf8               println</span><br><span class="line">  #<span class="number">39</span> = Utf8               (Ljava/lang/String;)V</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> num;</span><br><span class="line">    descriptor: I</span><br><span class="line">    flags:</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> com.ysy.DynamicLinkingTest();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">         <span class="number">4</span>: aload_0</span><br><span class="line">         <span class="number">5</span>: bipush        <span class="number">10</span></span><br><span class="line">         <span class="number">7</span>: putfield      #<span class="number">2</span>                  <span class="comment">// Field num:I</span></span><br><span class="line">        <span class="number">10</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">3</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">5</span>: <span class="number">4</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>      <span class="number">11</span>     <span class="number">0</span>  <span class="built_in">this</span>   Lcom/ysy/DynamicLinkingTest;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: getstatic     #<span class="number">3</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">         <span class="number">3</span>: ldc           #<span class="number">4</span>                  <span class="comment">// String methodA()....</span></span><br><span class="line">         <span class="number">5</span>: invokevirtual #<span class="number">5</span>                  <span class="comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">         <span class="number">8</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">8</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">9</span>: <span class="number">8</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">9</span>     <span class="number">0</span>  <span class="built_in">this</span>   Lcom/ysy/DynamicLinkingTest;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">()</span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">3</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: getstatic     #<span class="number">3</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">         <span class="number">3</span>: ldc           #<span class="number">6</span>                  <span class="comment">// String methodB()....</span></span><br><span class="line">         <span class="number">5</span>: invokevirtual #<span class="number">5</span>                  <span class="comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">         <span class="number">8</span>: aload_0</span><br><span class="line">         <span class="number">9</span>: invokevirtual #<span class="number">7</span>                  <span class="comment">// Method methodA:()V</span></span><br><span class="line">        <span class="number">12</span>: aload_0</span><br><span class="line">        <span class="number">13</span>: dup</span><br><span class="line">        <span class="number">14</span>: getfield      #<span class="number">2</span>                  <span class="comment">// Field num:I</span></span><br><span class="line">        <span class="number">17</span>: iconst_1</span><br><span class="line">        <span class="number">18</span>: iadd</span><br><span class="line">        <span class="number">19</span>: putfield      #<span class="number">2</span>                  <span class="comment">// Field num:I</span></span><br><span class="line">        <span class="number">22</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">12</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">14</span>: <span class="number">8</span></span><br><span class="line">        line <span class="number">16</span>: <span class="number">12</span></span><br><span class="line">        line <span class="number">17</span>: <span class="number">22</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>      <span class="number">23</span>     <span class="number">0</span>  <span class="built_in">this</span>   Lcom/ysy/DynamicLinkingTest;</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: <span class="string">&quot;DynamicLinkingTest.java&quot;</span></span><br></pre></td></tr></table></figure>

<p>1、在字节码指令中，methodB() 方法中通过 invokevirtual #7 指令调用了方法 A ，那么 #7 是个啥呢？</p>
<p>2、往上面翻，找到常量池的定义：<code>#7 = Methodref #8.#31</code></p>
<ul>
<li>先找 #8 ：<ul>
<li><code>#8 = Class #32</code> ：去找 #32</li>
<li><code>#32 = Utf8 com/atguigu/java1/DynamicLinkingTest</code></li>
<li>结论：通过 #8 我们找到了 <code>DynamicLinkingTest</code> 这个类</li>
</ul>
</li>
<li>再来找 #31：<ul>
<li><code>#31 = NameAndType #19:#13</code> ：去找 #19 和 #13</li>
<li><code>#19 = Utf8 methodA</code> ：方法名为 methodA</li>
<li><code>#13 = Utf8 ()V</code> ：方法没有形参，返回值为 void</li>
</ul>
</li>
</ul>
<p>3、结论：通过 #7 我们就能找到需要调用的 DynamicLinkingTest 类中的 methodA() 方法，并进行调用</p>
<p>4、在上面，其实还有很多符号引用，比如 Object、System、PrintStream 等等</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220710165535085.png" alt="image-20220710165535085"></p>
<p><u><strong>为什么要用常量池呢？</strong></u></p>
<ol>
<li><p>因为在不同的方法，都可能调用常量或者方法，所以只需要存储一份即可，然后记录其引用即可，节省了空间。</p>
</li>
<li><p>常量池的作用：就是为了提供一些符号和常量，便于指令的识别</p>
</li>
</ol>
<h2 id="方法的调用"><a href="#方法的调用" class="headerlink" title="方法的调用"></a>方法的调用</h2><p><code>在JVM中，将符号引用转换为调用方法的直接引用与方法的绑定机制相关</code></p>
<h3 id="静态链接与动态链接"><a href="#静态链接与动态链接" class="headerlink" title="静态链接与动态链接"></a>静态链接与动态链接</h3><ul>
<li><p><strong>静态链接</strong></p>
<ul>
<li>当一个字节码文件被装载进JVM内部时，如果被调用的目标方法在<strong>编译期确定，且运行期保持不变</strong>时，这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接</li>
</ul>
</li>
<li><p><strong>动态链接</strong></p>
<ul>
<li>如果被调用的方法在编译期无法被确定下来，也就是说，<strong>只能够在程序运行期</strong>将调用的方法的符号转换为直接引用，由于这种引用转换过程具备动态性，因此也被称之为动态链接。</li>
</ul>
</li>
</ul>
<h3 id="早期绑定与晚期绑定"><a href="#早期绑定与晚期绑定" class="headerlink" title="早期绑定与晚期绑定"></a>早期绑定与晚期绑定</h3><blockquote>
<p>静态链接与动态链接针对的是方法。早期绑定和晚期绑定范围更广。早期绑定涵盖了静态链接，晚期绑定涵盖了动态链接。</p>
</blockquote>
<p>静态链接和动态链接对应的方法的绑定机制为：早期绑定（Early Binding）和晚期绑定（Late Binding）。<strong>绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程</strong>，<strong>这仅仅发生一次</strong>。</p>
<ul>
<li><p><strong>早期绑定</strong></p>
<ul>
<li>早期绑定就是指被调用的目标方法如果在<strong>编译期可知，且运行期保持不变</strong>时，即可将这个方法与所属的类型进行绑定，这样一来，由于明确了被调用的目标方法究竟是哪一个，因此也就<strong>可以使用静态链接的方式将符号引用转换为直接引用</strong>。</li>
</ul>
</li>
<li><p><strong>晚期绑定</strong></p>
<ul>
<li>如果被调用的方法在编译期无法被确定下来，<strong>只能够在程序运行期根据实际的类型绑定相关的方法</strong>，这种绑定方式也就被称之为晚期绑定。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*早期绑定与晚期绑定的例子</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;动物进食&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Huntable</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">hunt</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> <span class="keyword">implements</span> <span class="title class_">Huntable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;狗吃骨头&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hunt</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;捕食耗子，多管闲事&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> <span class="keyword">implements</span> <span class="title class_">Huntable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Cat</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();<span class="comment">//表现为：早期绑定</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Cat</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>();<span class="comment">//表现为：早期绑定</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.eat();<span class="comment">//表现为：早期绑定</span></span><br><span class="line">        System.out.println(<span class="string">&quot;猫吃鱼&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hunt</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;捕食耗子，天经地义&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnimalTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showAnimal</span><span class="params">(Animal animal)</span> &#123;</span><br><span class="line">        animal.eat();<span class="comment">//表现为：晚期绑定</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showHunt</span><span class="params">(Huntable h)</span> &#123;</span><br><span class="line">        h.hunt();<span class="comment">//表现为：晚期绑定</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>部分字节码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> com.atguigu.java2.AnimalTest();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">         <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">54</span>: <span class="number">0</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">5</span>     <span class="number">0</span>  <span class="built_in">this</span>   Lcom/atguigu/java2/AnimalTest;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showAnimal</span><span class="params">(com.atguigu.java2.Animal)</span>;</span><br><span class="line">    descriptor: (Lcom/atguigu/java2/Animal;)V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">2</span>, args_size=<span class="number">2</span></span><br><span class="line">         <span class="number">0</span>: aload_1</span><br><span class="line">         <span class="number">1</span>: invokevirtual #<span class="number">2</span>                  <span class="comment">// Method com/atguigu/java2/Animal.eat:()V</span></span><br><span class="line">         <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">56</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">57</span>: <span class="number">4</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">5</span>     <span class="number">0</span>  <span class="built_in">this</span>   Lcom/atguigu/java2/AnimalTest;</span><br><span class="line">            <span class="number">0</span>       <span class="number">5</span>     <span class="number">1</span> animal   Lcom/atguigu/java2/Animal;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showHunt</span><span class="params">(com.atguigu.java2.Huntable)</span>;</span><br><span class="line">    descriptor: (Lcom/atguigu/java2/Huntable;)V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">2</span>, args_size=<span class="number">2</span></span><br><span class="line">         <span class="number">0</span>: aload_1</span><br><span class="line">         <span class="number">1</span>: invokeinterface #<span class="number">3</span>,  <span class="number">1</span>            <span class="comment">// InterfaceMethod com/atguigu/java2/Huntable.hunt:()V</span></span><br><span class="line">         <span class="number">6</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">60</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">61</span>: <span class="number">6</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">7</span>     <span class="number">0</span>  <span class="built_in">this</span>   Lcom/atguigu/java2/AnimalTest;</span><br><span class="line">            <span class="number">0</span>       <span class="number">7</span>     <span class="number">1</span>     h   Lcom/atguigu/java2/Huntable;</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: <span class="string">&quot;AnimalTest.java&quot;</span></span><br></pre></td></tr></table></figure>

<p>invokevirtual 体现为晚期绑定</p>
<p>invokeinterface 体现为晚期绑定</p>
<p>invokespecial 体现为早期绑定</p>
<h3 id="多态与绑定"><a href="#多态与绑定" class="headerlink" title="多态与绑定"></a>多态与绑定</h3><ul>
<li>随着高级语言的横空出世，类似于Java一样的基于面向对象的编程语言如今越来越多，尽管这类编程语言在语法风格上存在一定的差别，但是它们彼此之间始终保持着一个共性，那就是都支持封装、继承和多态等面向对象特性，既然<strong>这一类的编程语言具备多态特性，那么自然也就具备早期绑定和晚期绑定两种绑定方式</strong>。</li>
<li>Java中任何一个普通的方法其实都<strong>具备虚函数的特征</strong>，它们相当于C++语言中的虚函数（C++中则需要使用关键字virtual来显式定义）。如果在Java程序中不希望某个方法拥有虚函数的特征时，则可以使用关键字final来标记这个方法。</li>
</ul>
<h3 id="虚方法与非虚方法"><a href="#虚方法与非虚方法" class="headerlink" title="虚方法与非虚方法"></a>虚方法与非虚方法</h3><p><strong>虚方法与非虚方法的区别</strong></p>
<ol>
<li><strong>如果方法在编译期就确定了具体的调用版本，这个版本在运行时是不可变的。这样的方法称为非虚方法。</strong></li>
<li><strong>静态方法、私有方法、final方法、实例构造器、父类方法</strong>都是非虚方法。</li>
<li>其他方法称为虚方法，与晚期绑定或动态链接对应。</li>
</ol>
<p><strong>子类对象的多态的使用前提</strong></p>
<ol>
<li>类的继承关系</li>
<li>方法的重写</li>
</ol>
<p><strong>虚拟机中调用方法的指令</strong></p>
<ul>
<li><strong>普通指令：</strong></li>
</ul>
<ol>
<li>invokestatic：调用静态方法，解析阶段确定唯一方法版本</li>
<li>invokespecial：调用<code>&lt;init&gt;</code>方法、私有及父类方法，解析阶段确定唯一方法版本</li>
<li>invokevirtual：调用所有虚方法</li>
<li>invokeinterface：调用接口方法</li>
</ol>
<ul>
<li><p><strong>动态调用指令</strong></p>
<ul>
<li>invokedynamic：动态解析出需要调用的方法，然后执行</li>
</ul>
</li>
<li><p>前四条指令固化在虚拟机内部，方法的调用执行不可人为干预。而invokedynamic指令则支持由用户确定方法版本。</p>
</li>
<li><p>其中<strong>invokestatic指令和invokespecial指令调用的方法称为非虚方法</strong>，其余的（final修饰的除外）称为虚方法。</p>
</li>
</ul>
<h4 id="举例-2"><a href="#举例-2" class="headerlink" title="举例"></a>举例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Father</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;father的构造器&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">showStatic</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;father &quot;</span> + str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">showFinal</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;father show final&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showCommon</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;father 普通方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Son</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//invokespecial</span></span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Son</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="comment">//invokespecial</span></span><br><span class="line">        <span class="built_in">this</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//不是重写的父类的静态方法，因为静态方法不能被重写！</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">showStatic</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;son &quot;</span> + str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">showPrivate</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;son private&quot;</span> + str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//invokestatic</span></span><br><span class="line">        showStatic(<span class="string">&quot;atguigu.com&quot;</span>);</span><br><span class="line">        <span class="comment">//invokestatic</span></span><br><span class="line">        <span class="built_in">super</span>.showStatic(<span class="string">&quot;good!&quot;</span>);</span><br><span class="line">        <span class="comment">//invokespecial</span></span><br><span class="line">        showPrivate(<span class="string">&quot;hello!&quot;</span>);</span><br><span class="line">        <span class="comment">//invokespecial</span></span><br><span class="line">        <span class="built_in">super</span>.showCommon();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//invokevirtual</span></span><br><span class="line">        showFinal();<span class="comment">//因为此方法声明有final，不能被子类重写，所以也认为此方法是非虚方法。</span></span><br><span class="line">        <span class="comment">//虚方法如下：</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">       invokevirtual  你没有显示的加super.，编译器认为你可能调用子类的showCommon(即使son子类没有重写，也会认为)，所以编译期间确定不下来，就是虚方法。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        showCommon();</span><br><span class="line">        info();</span><br><span class="line"></span><br><span class="line">        <span class="type">MethodInterface</span> <span class="variable">in</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//invokeinterface</span></span><br><span class="line">        in.methodA();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">info</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">(Father f)</span> &#123;</span><br><span class="line">        f.showCommon();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Son</span> <span class="variable">so</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line">        so.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">MethodInterface</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Son 类中 show() 方法的字节码指令如下</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220710180716788.png" alt="image-20220710180716788"></p>
<h4 id="invokedynamic-指令"><a href="#invokedynamic-指令" class="headerlink" title="invokedynamic 指令"></a>invokedynamic 指令</h4><ul>
<li>JVM字节码指令集一直比较稳定，<strong>一直到Java7中才增加了一个invokedynamic指令</strong>，这是Java为了实现【动态类型语言】支持而做的一种改进。</li>
<li>但是在Java7中并没有提供直接生成invokedynamic指令的方法，需要借助ASM这种底层字节码工具来产生invokedynamic指令。</li>
<li><strong>直到Java8的Lambda表达式的出现，invokedynamic指令的生成，在Java中才有了直接的生成方式。</strong></li>
<li>Java7中增加的动态语言类型支持的本质是对Java虚拟机规范的修改，而不是对Java语言规则的修改，这一块相对来讲比较复杂，增加了虚拟机中的方法调用，最直接的受益者就是运行在Java平台的动态语言的编译器。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Func</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">func</span><span class="params">(String str)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lambda</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lambda</span><span class="params">(Func func)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Lambda</span> <span class="variable">lambda</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Lambda</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Func</span> <span class="variable">func</span> <span class="operator">=</span> s -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        lambda.lambda(func);</span><br><span class="line"></span><br><span class="line">        lambda.lambda(s -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220710181524449.png" alt="image-20220710181524449"></p>
<h4 id="动态语言和静态语言"><a href="#动态语言和静态语言" class="headerlink" title="动态语言和静态语言"></a>动态语言和静态语言</h4><ul>
<li>动态类型语言和静态类型语言两者的区别就在于<strong>对类型的检查是在编译期还是在运行期</strong>，满足前者就是静态类型语言，反之是动态类型语言。</li>
<li>说的再直白一点就是，<strong>静态类型语言是判断变量自身的类型信息；动态类型语言是判断变量值的类型信息</strong>，<strong>变量没有类型信息，变量值才有类型信息</strong>，这是动态语言的一个重要特征。<ul>
<li><strong>Java</strong>：String info &#x3D; “mogu blog”;     (<strong>Java是静态类型语言的，会先编译再进行类型检查</strong>)</li>
<li><strong>JS</strong>：var name &#x3D; “shkstart”;    var name &#x3D; 10;（运行时才进行检查）</li>
<li><strong>Python</strong>: info &#x3D; 130.5 (运行时才检查)</li>
</ul>
</li>
</ul>
<h3 id="Java语言中方法重写的本质"><a href="#Java语言中方法重写的本质" class="headerlink" title="Java语言中方法重写的本质"></a>Java语言中方法重写的本质</h3><ol>
<li>找到操作数栈顶的第一个元素所执行的对象的实际类型，记作C。</li>
<li>如果在类型C中找到与常量中的描述符合简单名称都相符的方法，则进行访问权限校验。<ul>
<li>如果通过则返回这个方法的直接引用，查找过程结束</li>
<li>如果不通过，则返回java.lang.IllegalAccessError 异常</li>
</ul>
</li>
<li>否则，按照继承关系从下往上依次对C的各个父类进行第2步的搜索和验证过程。</li>
<li>如果始终没有找到合适的方法，则抛出java.lang.AbstractMethodError异常。</li>
</ol>
<blockquote>
<p>上面这个过程称为<strong>动态分派</strong></p>
</blockquote>
<p><strong>IllegalAccessError介绍</strong></p>
<ul>
<li>程序试图访问或修改一个属性或调用一个方法，这个属性或方法，你没有权限访问。一般的，这个会引起编译器异常。这个错误如果发生在运行时，就说明一个类发生了不兼容的改变。</li>
<li>比如，你把应该有的jar包放从工程中拿走了，或者Maven中存在jar包冲突</li>
</ul>
<h3 id="虚方法表"><a href="#虚方法表" class="headerlink" title="虚方法表"></a>虚方法表</h3><ul>
<li>在面向对象的编程中，会很频繁的使用到<strong>动态分派</strong>，如果在每次动态分派的过程中都要重新在类的方法元数据中搜索合适的目标的话就可能影响到执行效率。因此，为了提高性能，<strong>JVM采用在类的方法区建立一个虚方法表（virtual method table）来实现</strong>，非虚方法不会出现在表中。使用索引表来代替查找。【上面动态分派的过程，我们可以看到如果子类找不到，还要从下往上找其父类，非常耗时】</li>
<li>每个类中都有一个虚方法表，表中存放着各个方法的实际入口。</li>
<li>虚方法表是什么时候被创建的呢？<ul>
<li><strong>虚方法表会在类加载的链接(解析)阶段被创建并开始初始化</strong>，类的变量初始值准备完成之后，JVM会把该类的虚方法表也初始化完毕。</li>
</ul>
</li>
</ul>
<p><strong>例1</strong></p>
<p>如图所示：如果类中重写了方法，那么调用的时候，就会直接在该类的虚方法表中查找</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220710205856127.png" alt="image-20220710205856127"></p>
<ol>
<li>比如说son在调用toString的时候，Son没有重写过，Son的父类Father也没有重写过，那就直接调用Object类的toString。那么就直接在虚方法表里指明toString直接指向Object类。</li>
<li>下次Son对象再调用toString就直接去找Object，不用先找Son–&gt;再找Father–&gt;最后才到Object的这样的一个过程。</li>
</ol>
<p><strong>例2</strong></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220710210625236.png" alt="image-20220710210625236"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220710210832947.png" alt="image-20220710210832947"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220710211027380.png" alt="image-20220710211027380"></p>
<h1 id="方法返回地址-Return-Address"><a href="#方法返回地址-Return-Address" class="headerlink" title="方法返回地址(Return Address)"></a>方法返回地址(Return Address)</h1><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220710212217315.png" alt="image-20220710212217315"></p>
<blockquote>
<p><u>在一些帖子里，方法返回地址、动态链接、一些附加信息  也叫做帧数据区</u></p>
</blockquote>
<ul>
<li><p>存放调用该方法的pc寄存器的值。</p>
</li>
<li><p>一个方法的结束，有两种方式：</p>
<ul>
<li>正常执行完成</li>
<li>出现未处理的异常，非正常退出</li>
</ul>
</li>
<li><p>无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置。方法正常退出时，<strong>调用者的pc计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址</strong>。而通过异常退出的，返回地址是要通过<strong>异常表</strong>来确定，栈帧中一般不会保存这部分信息。</p>
</li>
<li><p>本质上，<strong>方法的退出就是当前栈帧出栈的过程</strong>。此时，需要<strong>恢复上层方法的局部变量表、操作数栈、将返回值压入调用者栈帧的操作数栈、设置PC寄存器值等，让调用者方法继续执行下去。</strong></p>
</li>
<li><p>正常完成出口和异常完成出口的区别在于：<strong>通过异常完成出口退出的不会给他的上层调用者产生任何的返回值</strong>。</p>
</li>
</ul>
<h2 id="方法退出的两种方式"><a href="#方法退出的两种方式" class="headerlink" title="方法退出的两种方式"></a><strong>方法退出的两种方式</strong></h2><p>当一个方法开始执行后，只有两种方式可以退出这个方法，</p>
<p><strong>正常退出：</strong></p>
<ol>
<li>执行引擎遇到任意一个方法返回的字节码指令（return），会有返回值传递给上层的方法调用者，简称<strong>正常完成出口</strong>；</li>
<li>一个方法在正常调用完成之后，究竟需要使用哪一个返回指令，还需要根据方法返回值的实际数据类型而定。</li>
<li>在字节码指令中，返回指令包含：<ul>
<li><p>ireturn：当返回值是boolean，byte，char，short和int类型时使用</p>
</li>
<li><p>lreturn：Long类型</p>
</li>
<li><p>freturn：Float类型</p>
</li>
<li><p>dreturn：Double类型</p>
</li>
<li><p>areturn：引用类型</p>
</li>
<li><p>return：返回值类型为void的方法、实例初始化方法、类和接口的初始化方法</p>
</li>
</ul>
</li>
</ol>
<p><strong>异常退出：</strong></p>
<ol>
<li><p>在方法执行过程中遇到异常（Exception），并且这个异常没有在方法内进行处理，也就是只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，简称<strong>异常完成出口</strong>。</p>
</li>
<li><p>方法执行过程中，抛出异常时的异常处理，存储在一个异常处理表，方便在发生异常的时候找到处理异常的代码</p>
</li>
</ol>
<img src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_004/0040.png">

<p><strong>异常处理表：</strong></p>
<ul>
<li>反编译字节码文件，可得到 Exception table</li>
<li>from ：字节码指令起始地址</li>
<li>to ：字节码指令结束地址</li>
<li>target ：出现异常跳转至地址为 11 的指令执行</li>
<li>type ：捕获异常的类型</li>
</ul>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220710213452785.png" alt="image-20220710213452785"></p>
<h1 id="一些附加信息"><a href="#一些附加信息" class="headerlink" title="一些附加信息"></a>一些附加信息</h1><p>栈帧中还允许携带与Java虚拟机实现相关的一些附加信息。例如：对程序调试提供支持的信息。</p>
<h1 id="栈相关面试题"><a href="#栈相关面试题" class="headerlink" title="栈相关面试题"></a>栈相关面试题</h1><h2 id="举例栈溢出的情况？"><a href="#举例栈溢出的情况？" class="headerlink" title="举例栈溢出的情况？"></a>举例栈溢出的情况？</h2><p>SOF（StackOverflowError），栈大小分为固定的和动态变化。如果是固定的就可能出现StackOverflowError。如果是动态变化的，内存不足时就可能出现OOM</p>
<ol>
<li>局部数组过大。当函数内部的数组过大时，有可能导致堆栈溢出。当系统栈设置比较小时，会导致栈溢出。当程序确实需要大数组时，可以设置为静态变量或全局变量。</li>
<li>递归调用层次太多。递归函数在运行时会执行压栈操作，当压栈次数太多时，也会导致堆栈溢出。</li>
<li>指针或数组越界。这种情况最常见，例如进行字符串拷贝，或处理用户输入等等。</li>
</ol>
<h2 id="调整栈大小，就能保证不出现溢出么？"><a href="#调整栈大小，就能保证不出现溢出么？" class="headerlink" title="调整栈大小，就能保证不出现溢出么？"></a>调整栈大小，就能保证不出现溢出么？</h2><ul>
<li><p>不能保证不溢出，只能保证SOF出现的几率小（例如无退出条件递归）</p>
</li>
<li><p>调整栈的大小，只能有一个延缓作用，像死循环这种无法保证，一个无限的递归程序也会出现溢出。</p>
</li>
</ul>
<h2 id="分配的栈内存越大越好么？"><a href="#分配的栈内存越大越好么？" class="headerlink" title="分配的栈内存越大越好么？"></a>分配的栈内存越大越好么？</h2><ul>
<li><p>不是，一定时间内降低了OOM概率，但是会挤占其它的线程空间，因为整个虚拟机的内存空间是有限的</p>
</li>
<li><p>一个线程分配的栈越大，那么其他线程分配的就会相对小，这样系统效率未必能提高。</p>
</li>
</ul>
<h2 id="垃圾回收是否涉及到虚拟机栈？"><a href="#垃圾回收是否涉及到虚拟机栈？" class="headerlink" title="垃圾回收是否涉及到虚拟机栈？"></a>垃圾回收是否涉及到虚拟机栈？</h2><p><strong>不会</strong></p>
<table>
<thead>
<tr>
<th align="left">Rutime Data Area</th>
<th>是否存在OOM</th>
<th>是否存在GC</th>
</tr>
</thead>
<tbody><tr>
<td align="left">PC计数器</td>
<td>不存在</td>
<td>不存在</td>
</tr>
<tr>
<td align="left">虚拟机栈</td>
<td>存在，SOF</td>
<td>不存在</td>
</tr>
<tr>
<td align="left">本地方法栈(在HotSpot的实现中和虚拟机栈一样)</td>
<td>存在</td>
<td>不存在</td>
</tr>
<tr>
<td align="left">堆</td>
<td>存在</td>
<td>存在</td>
</tr>
<tr>
<td align="left">方法区</td>
<td>存在</td>
<td>存在</td>
</tr>
</tbody></table>
<h2 id="方法中定义的局部变量是否线程安全？"><a href="#方法中定义的局部变量是否线程安全？" class="headerlink" title="方法中定义的局部变量是否线程安全？"></a>方法中定义的局部变量是否线程安全？</h2><p>具体问题具体分析</p>
<ol>
<li>如果只有一个线程才可以操作此数据，则必是线程安全的。</li>
<li>如果有多个线程操作此数据，则此数据是共享数据。如果不考虑同步机制的话，会存在线程安全问题。</li>
</ol>
<p><strong>具体问题具体分析：</strong></p>
<ul>
<li>如果对象是在内部产生，并在内部消亡，没有返回到外部，那么它就是线程安全的，反之则是线程不安全的。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 面试题：</span></span><br><span class="line"><span class="comment"> * 方法中定义的局部变量是否线程安全？具体情况具体分析</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   何为线程安全？</span></span><br><span class="line"><span class="comment"> *      如果只有一个线程才可以操作此数据，则必是线程安全的。</span></span><br><span class="line"><span class="comment"> *      如果有多个线程操作此数据，则此数据是共享数据。如果不考虑同步机制的话，会存在线程安全问题。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringBuilderTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//s1的声明方式是线程安全的（只在方法内部用了）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//StringBuilder:线程不安全</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        s1.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        s1.append(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//sBuilder的操作过程：是线程不安全的（作为参数传进来，可能被其它线程操作）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">(StringBuilder sBuilder)</span>&#123;</span><br><span class="line">        sBuilder.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        sBuilder.append(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//s1的操作：是线程不安全的（有返回值，可能被其它线程操作）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> StringBuilder <span class="title function_">method3</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        s1.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        s1.append(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> s1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//s1的操作： s1是线程安全的（s1自己消亡了，最后返回的只是s1.toString的一个新对象是线程不安全的）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">method4</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        s1.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        s1.append(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> s1.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            s.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">            s.append(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        method2(s);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-数据结构与算法：单向链表"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
	
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%9A%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/"
    >单向链表</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/07/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%9A%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/" class="article-date">
  <time datetime="2022-07-08T14:29:07.000Z" itemprop="datePublished">2022-07-08</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a> / <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/">链表</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h1><p><strong>链表是有序的列表</strong>，它在内存中的存储如下图：</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220708223029607.png" alt="单链表示意图"></p>
<ul>
<li>链表是以节点的方式来存储,是<strong>链式存储</strong></li>
<li>每个节点包含data 域，next域：指向下一个节点</li>
<li>如图：<strong>链表的各个节点不一定是连续存储</strong></li>
<li>链表分<strong>带头节点的链表和没有头节点的链表</strong>，根据实际的需求来确定</li>
</ul>
<h1 id="单向链表的应用实例"><a href="#单向链表的应用实例" class="headerlink" title="单向链表的应用实例"></a>单向链表的应用实例</h1><p>使用带head头的单向链表实现：水浒英雄排行榜管理完成对英雄人物的增删改查操作</p>
<ul>
<li>在添加英雄时，直接添加到链表的尾部</li>
</ul>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220708223511347.png" alt="无序添加"></p>
<p><code>添加(创建)</code></p>
<p>a. 先创建一个head头节点，作用就是表示单链表的头</p>
<p>b. 每添加一个节点，就直接加入到链表的最后</p>
<p><code>遍历</code>：通过一个辅助变量遍历，帮助遍历整个链表</p>
<ul>
<li>在添加英雄时，根据排名将英雄插入到指定位置(如果有这个排名，则添加失败，并给出提示)</li>
</ul>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220708223953385.png" alt="有序添加"></p>
<p>​	需要按照编号的顺序添加</p>
<ol>
<li>首先找到新添加的节点的位置,是通过辅助变量({指针),通过遍历来搞定</li>
<li><strong>新的节点.next &#x3D;temp.next</strong></li>
<li><strong>将temp.next&#x3D;新的节点</strong></li>
</ol>
<ul>
<li><p>修改节点功能</p>
<p>思路：(1)先找到该节点,通过遍历  (2) <strong>temp.name &#x3D; newHeroNode .name</strong> ; <strong>temp. nickname&#x3D; newHeroNode .nickname</strong></p>
</li>
<li><p>删除节点</p>
</li>
</ul>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220708224237886.png" alt="删除节点"></p>
<p>从单链表中删除一个节点的思路</p>
<ol>
<li>先找到需要删除的这个节点的<strong>前一个节点temp</strong></li>
<li><strong>termn.next &#x3D; temp.next.next</strong></li>
<li>被删除的节点，将不会有其它引用指向，会被垃圾回收机制回收</li>
</ol>
<ul>
<li>代码实现</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ysy.linkedlist;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingleLinkedListDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//测试</span></span><br><span class="line">        <span class="comment">//先创建节点</span></span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">heroNode1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">1</span>, <span class="string">&quot;宋江&quot;</span>, <span class="string">&quot;及时雨&quot;</span>);</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">heroNode2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">2</span>, <span class="string">&quot;卢俊义&quot;</span>, <span class="string">&quot;玉麒麟&quot;</span>);</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">heroNode3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">3</span>, <span class="string">&quot;吴用&quot;</span>, <span class="string">&quot;智多星&quot;</span>);</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">heroNode4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">4</span>, <span class="string">&quot;林冲&quot;</span>, <span class="string">&quot;豹子头&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建单向链表</span></span><br><span class="line">        <span class="type">SingleLinkedList</span> <span class="variable">singleLinkedList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SingleLinkedList</span>();</span><br><span class="line">        <span class="comment">//加入节点,无排名</span></span><br><span class="line"><span class="comment">//        singleLinkedList.add(heroNode1);</span></span><br><span class="line"><span class="comment">//        singleLinkedList.add(heroNode4);</span></span><br><span class="line"><span class="comment">//        singleLinkedList.add(heroNode2);</span></span><br><span class="line"><span class="comment">//        singleLinkedList.add(heroNode3);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//加入节点，按照编号</span></span><br><span class="line">        singleLinkedList.addByOrder(heroNode1);</span><br><span class="line">        singleLinkedList.addByOrder(heroNode4);</span><br><span class="line">        singleLinkedList.addByOrder(heroNode2);</span><br><span class="line">        singleLinkedList.addByOrder(heroNode3);</span><br><span class="line"><span class="comment">//        singleLinkedList.addByOrder(heroNode3);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出链表</span></span><br><span class="line">        singleLinkedList.list();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试修改节点的代码</span></span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">newHeroNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">2</span>, <span class="string">&quot;小卢&quot;</span>, <span class="string">&quot;玉麒麟&quot;</span>);</span><br><span class="line">        singleLinkedList.update(newHeroNode);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;修改后的链表~&quot;</span>);</span><br><span class="line">        singleLinkedList.list();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//删除一个节点</span></span><br><span class="line">        singleLinkedList.del(<span class="number">3</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;删除后的链表~&quot;</span>);</span><br><span class="line">        singleLinkedList.list();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingleLinkedList</span>&#123;</span><br><span class="line">    <span class="comment">//初始化一个头节点，不要动，不存放具体的数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">HeroNode</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">0</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    </span><br><span class="line">     <span class="comment">//返回头节点</span></span><br><span class="line">    <span class="keyword">public</span> HeroNode <span class="title function_">getHead</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setHead</span><span class="params">(HeroNode head)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.head = head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加节点到单向列表中</span></span><br><span class="line">    <span class="comment">//思路：不考虑编号顺序</span></span><br><span class="line">    <span class="comment">//1.找到当前链表的最后节点</span></span><br><span class="line">    <span class="comment">//2.将最后节点的next指向新的节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(HeroNode heroNode)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//因为head绩点不能动，所以需要一个辅助遍历temp</span></span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">temp</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">//遍历链表，找到最后</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="comment">//找到链表的最后</span></span><br><span class="line">            <span class="keyword">if</span>(temp.next == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果没有找到最后，将temp后移</span></span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//出循环代表temp已指向了链表的最后</span></span><br><span class="line">        <span class="comment">//将最后这个节点指向新节点</span></span><br><span class="line">        temp.next = heroNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据排名添加节点到链表中，如果排名存在，则输出添加失败</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addByOrder</span><span class="params">(HeroNode heroNode)</span>&#123;</span><br><span class="line">        <span class="comment">//头节点不能动，使用辅助变量temp来寻找添加的位置</span></span><br><span class="line">        <span class="comment">//temp是位于添加位置的前一个节点，否则插入不了</span></span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">temp</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;<span class="comment">//标志添加的编号是否存在</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="comment">//链表已到最后</span></span><br><span class="line">            <span class="keyword">if</span>(temp.next == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(temp.next.number &gt; heroNode.number)&#123;<span class="comment">//位置找到，插在后面</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(temp.next.number == heroNode.number)&#123;</span><br><span class="line">                flag = <span class="literal">true</span>;<span class="comment">//说明标号存在</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;<span class="comment">//后移，遍历链表</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;编号 %d 已存在，不能添加\n&quot;</span>, heroNode.number);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//插入链表中，temp后面</span></span><br><span class="line">            heroNode.next = temp.next;</span><br><span class="line">            temp.next = heroNode;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据number来修改节点信息，number不能改</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(HeroNode newHeroNode)</span>&#123;</span><br><span class="line">        <span class="comment">//判断是否为空</span></span><br><span class="line">        <span class="keyword">if</span>(head.next == <span class="literal">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空~&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//找到需要修改的节点，根据number编号</span></span><br><span class="line">        <span class="comment">//辅助变量，遍历链表</span></span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">temp</span> <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(temp == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;<span class="comment">//链表遍历完成</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(temp.number == newHeroNode.number)&#123;</span><br><span class="line">                <span class="comment">//找到</span></span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//根据flag判断是否找到要修改的节点</span></span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            temp.name = newHeroNode.name;</span><br><span class="line">            temp.nickName = newHeroNode.nickName;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;没有找到编号 %d 的节点\n&quot;</span>, newHeroNode.number);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除节点</span></span><br><span class="line">    <span class="comment">//思路</span></span><br><span class="line">    <span class="comment">//1.head不能动，因此我们需要---个temp辅助节点找到待删除节点的前一个节点</span></span><br><span class="line">    <span class="comment">//2.说明我们在比较时，是temp.next.no和需要删除的节点的no比较</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">del</span><span class="params">(<span class="type">int</span> number)</span>&#123;</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">temp</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;<span class="comment">//标志是否找到要删除的节点</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(temp.next == <span class="literal">null</span>)&#123;<span class="comment">//链表已到最后</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(temp.next.number == number)&#123;</span><br><span class="line">                <span class="comment">//找到</span></span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;<span class="comment">//temp后移，遍历链表</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断flag</span></span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            temp.next = temp.next.next;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;要删除的 %d 节点不存在\n&quot;</span>, number);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//显示链表，遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">list</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//判断链表是否为空</span></span><br><span class="line">        <span class="keyword">if</span>(head.next == <span class="literal">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//因为头节点不能动，所以辅助变量temp遍历</span></span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">temp</span> <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="comment">//判断链表是否走到最后</span></span><br><span class="line">            <span class="keyword">if</span>(temp == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//输出节点信息</span></span><br><span class="line">            System.out.println(temp);</span><br><span class="line">            <span class="comment">//将temp后移</span></span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义HeroNode，每个HeroNode对象就是一个节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HeroNode</span>&#123;</span><br><span class="line">    <span class="comment">//data域</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> number;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> String nickName;</span><br><span class="line">    <span class="comment">//next域</span></span><br><span class="line">    <span class="keyword">public</span> HeroNode next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HeroNode</span><span class="params">(<span class="type">int</span> number, String name, String nickName)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.number = number;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.nickName = nickName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 为了显示方法，重回写toString方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;HeroNode&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;number=&quot;</span> + number +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, nickName=&#x27;&quot;</span> + nickName + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="单向链表面试题"><a href="#单向链表面试题" class="headerlink" title="单向链表面试题"></a>单向链表面试题</h1><ul>
<li><p>求单链表中节点的个数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法：获取单链表的节点的个数(如果是带头结点的链表，需求不统计头节点)</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> head 链表的头节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 有效节点个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getLength</span><span class="params">(HeroNode head)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head.next == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="comment">//空链表</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//定义一个辅助的变量</span></span><br><span class="line">    <span class="type">HeroNode</span> <span class="variable">cur</span> <span class="operator">=</span> head.next;</span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="literal">null</span>)&#123;</span><br><span class="line">        length++;</span><br><span class="line">        cur = cur.next;<span class="comment">//遍历</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查找单链表中的倒数第k个结点[新浪面试题]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查找单链表中的倒数第k个结点</span></span><br><span class="line"><span class="comment">//思路：</span></span><br><span class="line"><span class="comment">//1.编写一个方法，接收head节点，同时接受一个index</span></span><br><span class="line"><span class="comment">//2.index 表示是倒数第index个节点</span></span><br><span class="line"><span class="comment">//3.先把链表从头到尾遍历，得到链表的总的长度 getLength</span></span><br><span class="line"><span class="comment">//4.得到size后，从链表的第一个开始遍历(size - index)个，就可以得到</span></span><br><span class="line"><span class="comment">//5.如果找到了，则返回该节点，否则返回null</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> HeroNode <span class="title function_">findLastIndexNode</span><span class="params">(HeroNode head, <span class="type">int</span> index)</span>&#123;</span><br><span class="line">    <span class="comment">//判断链表是否为空</span></span><br><span class="line">    <span class="keyword">if</span>(head.next == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;<span class="comment">//没有找到</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//第一次遍历得到链表的长度(节点个数)</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> getLength(head);</span><br><span class="line">    <span class="comment">//第二次遍历 size-index 位置，就是倒数第K个点</span></span><br><span class="line">    <span class="comment">//先做一个index的校验</span></span><br><span class="line">    <span class="keyword">if</span>(index &lt;= <span class="number">0</span> || index &gt; size)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//定义辅助变量,for 循环定位到倒数的index</span></span><br><span class="line">    <span class="type">HeroNode</span> <span class="variable">cur</span> <span class="operator">=</span> head.next;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>; i &lt; size-index; i++)&#123;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>单链表的反转[腾讯面试题]</p>
<p><strong>思路</strong></p>
<ol>
<li>先定义一个节点reverseHead&#x3D;new HeroNode();</li>
<li>从头到尾遍历原来的链表，每遍历一个节点，就将其取出，并放在新的链表reverseHead的最前端.</li>
<li>原来的链表的head.next &#x3D;reverseHead.next</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将单链表反转</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">reverseList</span><span class="params">(HeroNode head)</span>&#123;</span><br><span class="line">    <span class="comment">//如果当前链表为空，或者只有一个节点，无需反转，直接返回</span></span><br><span class="line">    <span class="keyword">if</span>(head.next == <span class="literal">null</span> || head.next.next == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个辅助指针，帮助我们遍历链表</span></span><br><span class="line">    <span class="type">HeroNode</span> <span class="variable">cur</span> <span class="operator">=</span> head.next;</span><br><span class="line">    <span class="type">HeroNode</span> <span class="variable">next</span> <span class="operator">=</span> <span class="literal">null</span>;<span class="comment">//记录当前节点的下一个节点</span></span><br><span class="line">    <span class="type">HeroNode</span> <span class="variable">reverseHead</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">0</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从头到尾遍历原来的链表,每遍历一个节点，就将其取出，并放在新的链表reverseHead的最前端.</span></span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">null</span>)&#123;</span><br><span class="line">        next = cur.next;<span class="comment">//先暂时保存当前节点的下一个节点，因为后面需要使用</span></span><br><span class="line">        cur.next = reverseHead.next;<span class="comment">//将cur的下一个节点指向新的链表的最前端</span></span><br><span class="line">        reverseHead.next = cur;<span class="comment">//将cur连接到新的链表上</span></span><br><span class="line">        cur = next;<span class="comment">//让cur指向后一个节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将head.next指向reverseHead.next，实现反转</span></span><br><span class="line">    head.next = reverseHead.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>从尾到头打印单链表[百度，要求方式1:反向遍历。方式2: Stack栈]</p>
<p><strong>思路</strong></p>
<ul>
<li>方式1:先将单链表进行反转操作，然后再遍历即可，这样的做的问题是会破坏原来的单链表的结构，不建议</li>
<li>方式2:可以利用栈这个数据结构，将各个节点压入到栈中，然后利用栈的先进后出的特点，就实现了逆序打印的效果.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从尾到头打印单链表(栈)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">reversePrint</span><span class="params">(HeroNode head)</span> &#123;</span><br><span class="line">    <span class="comment">//如果当前链表为空，不能打印</span></span><br><span class="line">    <span class="keyword">if</span>(head.next == <span class="literal">null</span> || head.next.next == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建栈，将节点压入栈</span></span><br><span class="line">    Stack&lt;HeroNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    <span class="type">HeroNode</span> <span class="variable">cur</span> <span class="operator">=</span> head.next;</span><br><span class="line">    <span class="comment">//将链表的所有节点压入栈</span></span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">null</span>)&#123;</span><br><span class="line">        stack.push(cur);</span><br><span class="line">        cur = cur.next;<span class="comment">//cur后移，这样就可以压入下一个节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将栈中的节点进行打印，pop出栈</span></span><br><span class="line">    <span class="keyword">while</span> (stack.size() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        System.out.println(stack.pop());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
  </article>
  

  
  <nav class="page-nav">
    
    <a class="extend prev" rel="prev" href="/">上一页</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2022
        <i class="ri-heart-fill heart_icon"></i> Shiyu Yang
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="Healer"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>