<!DOCTYPE html>


<html lang="en">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title> Healer</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    <link rel="alternate" href="/atom.xml" title="Healer" type="application/atom+xml">
</head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      
<section class="cover">
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover1.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">Healer</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.staticfile.org/typed.js/2.0.12/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['面朝大海，春暖花开', '愿你一生努力，一生被爱', '想要的都拥有，得不到的都释怀'],
        startDelay: 0,
        typeSpeed: 200,
        loop: true,
        backSpeed: 100,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  
  
  

<div class="notice" style="margin-top:50px">
    <i class="ri-heart-fill"></i>
    <div class="notice-content" id="broad"></div>
</div>
<script type="text/javascript">
    fetch('https://v1.hitokoto.cn')
        .then(response => response.json())
        .then(data => {
            document.getElementById("broad").innerHTML = data.hitokoto;
        })
        .catch(console.error)
</script>

<style>
    .notice {
        padding: 20px;
        border: 1px dashed #e6e6e6;
        color: #969696;
        position: relative;
        display: inline-block;
        width: 100%;
        background: #fbfbfb50;
        border-radius: 10px;
    }

    .notice i {
        float: left;
        color: #999;
        font-size: 16px;
        padding-right: 10px;
        vertical-align: middle;
        margin-top: -2px;
    }

    .notice-content {
        display: initial;
        vertical-align: middle;
    }
</style>
  
  <article class="articles">
    
    
    
    
    <article
  id="post-JavaSE"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
	
		置顶
	
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/06/28/JavaSE/"
    >JavaSE
  <i class="article-topping">Sticky</i>
</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/06/28/JavaSE/" class="article-date">
  <time datetime="2022-06-28T05:58:06.000Z" itemprop="datePublished">2022-06-28</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/JavaSE/">JavaSE</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="Java-概述"><a href="#Java-概述" class="headerlink" title="Java 概述"></a>Java 概述</h1><h2 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h2><p>计算机执行某些操作或解决某个问题而编写的一系列有序指令的集合</p>
<h2 id="Java-重要特点"><a href="#Java-重要特点" class="headerlink" title="Java 重要特点"></a>Java 重要特点</h2><ol>
<li><p>Java 语言是<strong>面向对象</strong>的(oop)</p>
</li>
<li><p>Java 语言是<strong>健壮</strong>的。Java 的强类型机制、异常处理、垃圾的自动收集等是 Java 程序健壮性的重要保证 </p>
</li>
<li><p>Java 语言是<strong>跨平台性</strong>的。[即: 一个编译好的.class 文件可以在多个系统下运行，这种特性称为跨平台]</p>
</li>
<li><p>Java 语言是<strong>解释型</strong>的。</p>
</li>
</ol>
<p>​		<strong>解释性语言：javascript,PHP, java</strong> </p>
<p>​		<strong>编译性语言: c &#x2F; c++</strong> </p>
<p>​		区别是：解释性语言，编译后的代码，不能直接被机器执行,需要解释器来执行, 编译性语言, 编译后的代码, 可以直接被机器执行, c &#x2F;c+</p>
<h2 id="JDK，JRE介绍"><a href="#JDK，JRE介绍" class="headerlink" title="JDK，JRE介绍"></a>JDK，JRE介绍</h2><p>1）JDK 的全称(Java Development Kit Java 开发工具包)</p>
<pre><code>     **JDK = JRE + java 开发工具集 **   [java, javac,javadoc,javap,java编译工具等] 
</code></pre>
<p>​		JDK 是提供给 Java 开发人员使用的，其中包含了 java 的开发工具，也包括了 JRE。所以安装了 JDK，就不用在单独安装 JRE了</p>
<p>2）JRE(Java Runtime Environment Java 运行环境)</p>
<p>​		 <strong>JRE &#x3D; JVM + Java 的核心类库[类]</strong> </p>
<p>​		包括 Java 虚拟机(JVM Java Virtual Machine)和 Java 程序所需的核心类库等，如果想要运行一个开发好的 Java 程序， 计算机中只需要安装 JRE 即可。</p>
<h2 id="Java虚拟机-JVM"><a href="#Java虚拟机-JVM" class="headerlink" title="Java虚拟机-JVM"></a>Java虚拟机-JVM</h2><ol>
<li><p>JVM 是一个虚拟的计算机，具有指令集并使用不同的存储区域。负责执行指令，管理数据、内存、寄存器，<strong>包含在 JDK 中</strong>. </p>
</li>
<li><p>对于不同的平台，有不同的虚拟机。 </p>
</li>
<li><p>Java 虚拟机机制屏蔽了底层运行平台的差别，实现了“<strong>一次编译，到处运行”</strong></p>
</li>
</ol>
<h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><p>私有:java虚拟机栈，程序计数器，本地方法栈 共享:java堆，方法区</p>
<ol>
<li><p>栈： 一般存放基本数据类型(局部变量) </p>
</li>
<li><p>堆： 存放对象(Cat cat , 数组等) </p>
</li>
<li><p>方法区：常量池(常量，比如字符串)， 类加载信息</p>
</li>
</ol>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220511221502453.png" alt="image-20220511221502453"></p>
<h2 id="Java-转义字符"><a href="#Java-转义字符" class="headerlink" title="Java 转义字符"></a>Java 转义字符</h2><p>在控制台使用 <strong>tab</strong> 可补全命令</p>
<p>\t ：一个制表位，实现对齐的功能 </p>
<p>\n ：换行符 </p>
<p>\ \：一个\</p>
<p>\ &quot; :一个”</p>
<p>\ &#39; ：一个’ </p>
<p>\r :一个回车</p>
<p>\0:空字符</p>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>用于注解说明解释程序的文字，提高了代码的阅读性(可读性)</p>
<p>被注释的文字，不会被 JVM（java 虚拟机）解释执行</p>
<p> 多行注释里面不允许有多行注释嵌套</p>
<p>文档注释：javadoc -d 文件名 -author -version xx.java</p>
<h2 id="常用dos命令"><a href="#常用dos命令" class="headerlink" title="常用dos命令"></a>常用dos命令</h2><ol>
<li><p>查看当前目录是有什么内容：dir </p>
</li>
<li><p>切换到其他盘下：盘符号 + ：</p>
</li>
<li><p>切换到上一级：cd .. </p>
</li>
<li><p>切换到根目录：cd \ </p>
</li>
<li><p>查看指定的目录下所有的子级目录：tree</p>
</li>
<li><p>清屏：cls </p>
</li>
<li><p>退出：exit</p>
</li>
</ol>
<h2 id="成员方法传参机制"><a href="#成员方法传参机制" class="headerlink" title="成员方法传参机制"></a>成员方法传参机制</h2><p><strong>实参定义</strong></p>
<p>实参全称为实际参数，是在调用时传递给函数的参数。实参可以是常量、变量、表达式、函数等，无论实参是何种类型的量，在进行函数调用时，它们都必须具有确定的值，以便把这些值 传送给形参因此应预先用赋值，输入等办法使实参获得确定值。</p>
<p><strong>形参定义</strong></p>
<p>形参全称为形式参数，由于它不是实际存在变量，所以又称虚拟变量。是在定义函数名和函数体的时候使用的参数,目的是用来接收调用该函数时传入的参数.在调用函数时，实参将赋值给形参。因而，必须注意实参的个数，类型应与形参-一对应， 并且实参必须要有确定的值。</p>
<ol>
<li><p>基本数据类型，传递的是值（值拷贝），形参的改变不影响实参</p>
</li>
<li><p>引用数据类型,，传递的是地址（传递也是值，但是值是地址），可以通过形参影响实参</p>
</li>
</ol>
<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220517173202743.png" alt="image-20220517173202743"></p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220517173304401.png" alt="image-20220517173304401"></p>
<h3 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h3><p>默认int</p>
<p>计算机底层存储的都是<strong>补码</strong>，并以补码进行数据运算，显示的是原码</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220517173405866.png"></p>
<h3 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a>浮点类型</h3><p>默认float</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220517175012934.png" alt="image-20220517175012934"></p>
<ol>
<li><p>关于浮点数在机器中存放形式的简单说明，浮点数&#x3D;符号位+指数位+尾数位 </p>
</li>
<li><p>尾数部分可能丢失，造成精度损失(小数都是近似值)</p>
</li>
</ol>
<h3 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h3><p>字符类型可以表示单个字符,字符类型是 char，char 是两个字节(可以存放汉字)，多个字符用字符串 String</p>
<p>字符型存储到计算机中，是对应的ASCII码值</p>
<h3 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h3><p>只允许取值true和false，无null，占一个字节</p>
<h2 id="基本数据类型转换"><a href="#基本数据类型转换" class="headerlink" title="基本数据类型转换"></a>基本数据类型转换</h2><p>自动类型转换：进行赋值或运算时，精度小的类型自动转换为精度大的数据类型(byte–&gt;short–&gt;int–&gt;long–&gt;float–&gt;double)(char–&gt;int–&gt;long–&gt;float–&gt;double)</p>
<p>​							byte, short 和 char 之间不会相互自动转换，但可以计算，在计算时首先转换成int类型</p>
<p>强制类型转换：将容量大的数据类型转换成容量小的数据类型</p>
<p>​							使用时要加上强制转换符()，但可能造成精度降低或溢出</p>
<p>基本数据类型和String类型的转换：基本–&gt;String：将基本数据类型的值+””</p>
<p>​															 String–&gt;基本：通过基本类型的包装类调用parseXXX方法</p>
<h2 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220517191425976.png" alt="image-20220517191425976"></p>
<p>Unicode：将世界上所有的符号都纳入其中，每个符号都给予一个独一无二的编码，使用Unicode没有乱码问题</p>
<h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220517193700932.png" alt="image-20220517193700932"></p>
<h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><p>1）基本赋值运算符   int a &#x3D; 10;</p>
<p>2）复合赋值运算符 +&#x3D; ，-&#x3D; ，*&#x3D; ， &#x2F;&#x3D; ，%&#x3D; 等</p>
<p>复合赋值运算符会进行类型转换。例如：b +&#x3D; 2; &#x2F;&#x2F; 等价 b &#x3D; (byte)(b+2)</p>
<h2 id="关系运算符-比较运算符"><a href="#关系运算符-比较运算符" class="headerlink" title="关系运算符(比较运算符)"></a>关系运算符(比较运算符)</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220517193743927.png" alt="image-20220517193743927"></p>
<h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><ol>
<li><p>短路与 &amp;&amp; ， 短路或 ||，取反 ! </p>
</li>
<li><p>逻辑与 &amp;，逻辑或 |，^ 逻辑异或</p>
</li>
</ol>
<h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220517195010581.png" alt="image-20220517195010581"></p>
<ol>
<li><p>算术右移 &gt;&gt;：低位溢出,符号位不变,并用符号位补溢出的高位 int a&#x3D;1&gt;&gt;2; &#x2F;&#x2F;1 &#x3D;&gt; 00000001 &#x3D;&gt; 00000000 本质 1&#x2F;2&#x2F;2&#x3D;0</p>
</li>
<li><p>算术左移 &lt;&lt;: 符号位不变,低位补 0 int c&#x3D;1&lt;&lt;2; &#x2F;&#x2F;1 &#x3D;&gt; 00000001 &#x3D;&gt; 00000100 本质 1 * 2 * 2 &#x3D; 4</p>
</li>
<li><blockquote>
<blockquote>
<blockquote>
<p> 逻辑右移也叫无符号右移,运算规则是: 低位溢出，高位补 0</p>
</blockquote>
</blockquote>
</blockquote>
</li>
</ol>
<h2 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h2><p>条件表达式 ? 表达式 1: 表达式 2; </p>
<p>运算规则：1）如果条件表达式为 true，运算后的结果是表达式 1； </p>
<p>​					2）如果条件表达式为 false，运算后的结果是表达式 2；</p>
<h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><p>1）由26个英文字母大小写，0-9，_或$组成</p>
<p>2）数字不能开头</p>
<p>3）不可以使用关键字和保留字，但能包含关键字和保留字</p>
<p>4）不能包含空格</p>
<h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><p><strong>都小写</strong></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220517194602552.png" alt="image-20220517194602552"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220517194633358.png" alt="image-20220517194633358"></p>
<p><strong>volatile与synchronized的区别：</strong></p>
<p>volatile本质是在告诉jvm当前变量在寄存器中的值是不确定的,需要从主存中读取,synchronized则是锁定当前变量,只有当前线程可以访问该变量,其他线程被阻塞住</p>
<p>volatile仅能使用在变量级别,synchronized则可以使用在变量,方法.</p>
<p>volatile仅能实现变量的修改可见性,但不具备原子特性,而synchronized则可以保证变量的修改可见性和原子性.</p>
<p>volatile不会造成线程的阻塞,而synchronized可能会造成线程的阻塞.</p>
<p>volatile标记的变量不会被编译器优化,而synchronized标记的变量可以被编译器优化.</p>
<p>synchronized很强大，既可以保证可见性，又可以保证原子性，而volatile不能保证原子性！</p>
<h2 id="保留字"><a href="#保留字" class="headerlink" title="保留字"></a>保留字</h2><p>Java 保留字：现有 Java 版本尚未使用，但以后版本可能会作为关键字使用。自己命名标识符时要避免使用这些保留字 byValue、cast、future、 generic、inner、 operator、 outer、 rest、 var 、 goto</p>
<h2 id="原码、反码、补码"><a href="#原码、反码、补码" class="headerlink" title="原码、反码、补码"></a>原码、反码、补码</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220517194927173.png" alt="image-20220517194927173"></p>
<h1 id="程序控制结构"><a href="#程序控制结构" class="headerlink" title="程序控制结构"></a>程序控制结构</h1><p>switch(表达式)中表达式的返回值必须是：byte, short, int, char, enum, String</p>
<p>break 语句用于终止某个语句块的执行，一般使用在 switch 或者循环[for, while, do-while]中</p>
<p>continue 语句用于结束本次循环，继续执行下一次循环，出现在多层嵌套的循环语句体中时，可以通过标签指明要跳过的是哪一层循环 </p>
<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>存放多个同一类型的数据，是一种<strong>引用类型</strong>数据</p>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>动态初始化：数据类型 数组名[] &#x3D; new  数据类型[大小] 例：int a[] &#x3D; new int[5]</p>
<p>​						数据类型 数组名[]；数组名 &#x3D; new  数据类型[大小] </p>
<p>​						数据类型 数组名[[]][[][] &#x3D; new  数据类型[大小] [大小]</p>
<p>​						数据类型 数组名[[]][[][] &#x3D; new  数据类型[大小] []</p>
<p>静态初始化：数据类型 数组名[] &#x3D; {元素值，元素值, … }</p>
<h2 id="数组细节"><a href="#数组细节" class="headerlink" title="数组细节"></a>数组细节</h2><p>1）数组是多个相同类型数据的组合</p>
<p>2）数组创建后，如果没有赋值，有默认值</p>
<p>​		int 0，short 0, byte 0, long 0, float 0.0,double 0.0，char \u0000，boolean false，String null</p>
<p>3）数组属于引用类型，数组型数据是对象(Object)</p>
<h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>1）区分相同名字的类</p>
<p>2）当类很多时，可以更好的管理类</p>
<p>3）控制访问范围</p>
<h3 id="常用的包"><a href="#常用的包" class="headerlink" title="常用的包"></a>常用的包</h3><ol>
<li><p>java.lang.* &#x2F;&#x2F;lang 包是基本包，默认引入，不需要再引入. </p>
</li>
<li><p>java.util.* &#x2F;&#x2F;util 包，系统提供的工具包, 工具类，使用 Scanner </p>
</li>
<li><p>java.net.* &#x2F;&#x2F;网络包，网络开发 </p>
</li>
<li><p>java.awt.* &#x2F;&#x2F;是做 java的界面开发，GUI</p>
</li>
</ol>
<h2 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h2><p>java 提供四种访问控制修饰符号，用于控制方法和属性(成员变量)的访问权限（范围）</p>
<ol>
<li><p>公开级别:用 <strong>public</strong> 修饰,对外公开 </p>
</li>
<li><p>受保护级别:用 <strong>protected</strong> 修饰,对子类和同一个包中的类公开</p>
</li>
<li><p>默认级别:没有修饰符号,向同一个包的类公开</p>
</li>
<li><p>私有级别:用 <strong>private</strong> 修饰,只有类本身可以访问,不对外公开</p>
</li>
</ol>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>修饰符可以修饰类中的属性，成员方法以及类</p>
<p>只有默认的和public才能修饰类</p>
<h1 id="OOP"><a href="#OOP" class="headerlink" title="OOP"></a>OOP</h1><h2 id="面向对象编程三大特征"><a href="#面向对象编程三大特征" class="headerlink" title="面向对象编程三大特征"></a>面向对象编程三大特征</h2><p>封装、继承和多态</p>
<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>把抽象出的数据[属性]和对数据的操作[方法]封装在一起，数据被保护在内部，程序的其他部分只能通过被授权的操作[方法]，才能对数据进行操作</p>
<ol>
<li><p>将属性进行私有化private</p>
</li>
<li><p>提供一个公共的set方法，用户对数据进行赋值</p>
</li>
<li><p>提供一个公共的get方法，用于获取属性的值</p>
</li>
</ol>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>继承可以解决代码复用,让我们的编程更加靠近人类思维.当多个类存在相同的属性(变量)和方法时,可以从这些类中抽象出父类,在父类中定义这些相同的属性和方法，所有的子类不需要重新定义这些属性和方法，只需要通过 extends 来声明继承父类即可。</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220503220735855.png" alt="image-20220503220735855"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220503220812342.png" alt="image-20220503220812342"></p>
<p>继承的深入讨论&#x2F;细节问题</p>
<ol>
<li><p>子类继承了所有的属性和方法，非私有的属性和方法可以在子类直接访问, 但是私有属性和方法不能在子类直接访 问，要通过父类提供公共的方法去访问</p>
</li>
<li><p>子类必须调用父类的构造器， 完成父类的初始化 </p>
</li>
<li><p>当创建子类对象时，不管使用子类的哪个构造器，默认情况下总会去调用父类的无参构造器，如果父类没有提供无参构造器，则必须在子类的构造器中用super</p>
<p>  去指定使用父类的哪个构造器完成对父类的初始化工作，否则，编译不会通过</p>
</li>
<li><p>如果希望指定去调用父类的某个构造器，则显式的调用一下 : super(参数列表)</p>
</li>
<li><p>super 在使用时，必须放在构造器第一行(super只能在构造器中使用) </p>
</li>
<li><p>super() 和 this() 都只能放在构造器第一行，因此这两个方法不能共存在一个构造器</p>
</li>
<li><p>java 所有类都是 Object 类的子类, Object 是所有类的基类. </p>
</li>
<li><p>父类构造器的调用不限于直接父类！将一直往上追溯直到 Object 类(顶级父类) </p>
</li>
<li><p>子类最多只能继承一个父类(指直接继承)，即 java 中是单继承机制。 思考：如何让 A 类继承 B 类和 C 类？ 【A 继承 B， B 继承 C】 </p>
</li>
<li><p>不能滥用继承，子类和父类之间必须满足 <strong>is-a</strong> 的逻辑</p>
</li>
</ol>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>方法或对象具有多种形态。是面向对象的第三大特征，多态是建立在封装和继承基础之上的。</p>
<ol>
<li>方法的多态：重写和重载就体现多态</li>
</ol>
<p>2）<strong>对象的多态</strong></p>
<p>a.一个对象的编译类型和运行类型可以不一致</p>
<p>b.编译类型在定义对象时就确定了，不能改变</p>
<p>c.运行类型可以改变</p>
<p><strong>d.编译看左，运行看右</strong></p>
<h4 id="多态的注意事项"><a href="#多态的注意事项" class="headerlink" title="多态的注意事项"></a>多态的注意事项</h4><p>多态的<strong>前提</strong>是：两个对象(类)存在继承关系</p>
<p><strong>多态的向上转型</strong></p>
<p>​		本质：父类引用指向子类对象</p>
<p>​		语法：父类类型 引用名 &#x3D; new 子类类型()；</p>
<p>​		特点：<strong>编译看左，运行看右</strong></p>
<p>​					可以调用父类中的所有成员</p>
<p>​					不能调用子类中的特有成员</p>
<p>​					最终运行效果看子类的具体实现</p>
<p><strong>多态的向下转型</strong></p>
<p>​		语法：子类类型 引用名 &#x3D; (子类类型) 父类引用；</p>
<p>​		特点：只能强转父类的引用，不能强转父类的对象</p>
<p>​					要求父类的引用必须指向的是当前目标类型的对象</p>
<p>​					向下转型后可以调用子类类型中的所有成员</p>
<p><strong>instanceOf</strong> 比较操作符，用于判断对象的运行类型是否为 XX 类型或 XX 类型的子类型</p>
<h4 id="java-的动态绑定机制"><a href="#java-的动态绑定机制" class="headerlink" title="java 的动态绑定机制"></a>java 的动态绑定机制</h4><p>1）当调用对象方法的时候，该方法会与该对象的内存地址&#x2F;运行类型绑定</p>
<p>2）当调用对象属性的时候，没有动态绑定机制，哪里声明，哪里使用</p>
<h2 id="super-关键字"><a href="#super-关键字" class="headerlink" title="super 关键字"></a>super 关键字</h2><p>super代表父类的引用，用于访问父类的属性、方法、构造器。</p>
<h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>1）访问父类的属性，但不能访问父类的private属性  例：super.属性名</p>
<p>2）访问父类的方法，但不能访问父类的private方法  例：super.方法名(参数列表)</p>
<p>3）访问父类的构造器 例：super(参数列表) 只能放在构造器的第一句，只能出现一句</p>
<h3 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h3><p>1）调用父类的构造器（分工明确，父类属性由父类初始化，子类属性由子类初始化）</p>
<p>2）当子类中有和父类中的成员（属性和方法）重名时，为了访问父类的成员，必须通过super</p>
<p>3）super的访问不限于直接父类，如果爷爷类有和本类中有同名的成员，也可以使用super去访问爷爷类的成员；</p>
<p>​		如果多个基类中都有相同的成员，则super访问遵循就近原则</p>
<h3 id="super与this的比较"><a href="#super与this的比较" class="headerlink" title="super与this的比较"></a>super与this的比较</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220505145216027.png" alt="image-20220505145216027"></p>
<h2 id="方法重写-x2F-覆盖-override"><a href="#方法重写-x2F-覆盖-override" class="headerlink" title="方法重写&#x2F;覆盖(override)"></a>方法重写&#x2F;覆盖(override)</h2><p>子类中有一个方法，和父类的某个方法的名称、返回值类型、参数一样</p>
<h3 id="重写与重载的区别"><a href="#重写与重载的区别" class="headerlink" title="重写与重载的区别"></a>重写与重载的区别</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220505145536052.png" alt="image-20220505145536052"></p>
<h2 id="Object-类"><a href="#Object-类" class="headerlink" title="Object 类"></a>Object 类</h2><p><img src="https://uploadfiles.nowcoder.com/images/20200717/257056865_1594996230591_77654A637F366FC03F9C293582926971" alt="img"></p>
<p><img src="https://uploadfiles.nowcoder.com/images/20190412/242025553_1555068065653_1F768A0737B2E9FBB49649C7465CBFCE" alt="img"></p>
<h3 id="equals方法"><a href="#equals方法" class="headerlink" title="equals方法"></a>equals方法</h3><h4 id="x3D-x3D-和-equals比较"><a href="#x3D-x3D-和-equals比较" class="headerlink" title="&#x3D;&#x3D;和 equals比较"></a>&#x3D;&#x3D;和 equals比较</h4><p>&#x3D;&#x3D;是一个比较运算符</p>
<p>1）&#x3D;&#x3D;：既可以判断基本类型，又可以判断引用类型</p>
<p>2）&#x3D;&#x3D;：如果判断基本类型，判断的是<strong>值</strong>是否相等</p>
<p>3）&#x3D;&#x3D;：如果判断引用类型，判断的是**地址值 **是否相等</p>
<p>4）equals：是Object类中的方法，只能判断引用类型，默认判断的是地址值是否相等，子类中往往重写该方法，用于判断<strong>内容</strong>是否相等（例：Integer, String）</p>
<h3 id="hashCode方法"><a href="#hashCode方法" class="headerlink" title="hashCode方法"></a>hashCode方法</h3><ol>
<li><p>返回对象的哈希码值，提高具有哈希结构的容器的效率！ </p>
</li>
<li><p>两个引用，如果指向的是同一个对象，则哈希值肯定是一样的！ </p>
</li>
<li><p>两个引用，如果指向的是不同对象，则哈希值是不一样的 </p>
</li>
<li><p>哈希值主要根据地址号来的！不能完全将哈希值等价于地址</p>
</li>
</ol>
<h3 id="toString-方法"><a href="#toString-方法" class="headerlink" title="toString 方法"></a>toString 方法</h3><ol>
<li>基本介绍</li>
</ol>
<p>​	默认返回：全类名+@+哈希值的十六进制</p>
<p>​	子类往往重写 toString 方法，用于返回对象的属性信息 </p>
<ol start="2">
<li><p>重写 toString 方法，打印对象或拼接对象时，都会自动调用该对象的 toString 形式</p>
</li>
<li><p>当直接输出一个对象时，toString 方法会被默认的调用</p>
</li>
</ol>
<h3 id="finalize-方法"><a href="#finalize-方法" class="headerlink" title="finalize 方法"></a>finalize 方法</h3><ol>
<li><p>当对象被回收时，系统自动调用该对象的 finalize 方法。子类可以重写该方法，做一些释放资源的操作</p>
</li>
<li><p>什么时候被回收：当某个对象没有任何引用时，则 jvm 就认为这个对象是一个垃圾对象，就会使用垃圾回收机制来销毁该对象，在销</p>
</li>
</ol>
<p>​		毁该对象前，会先调用finalize 方法。 </p>
<ol start="3">
<li>垃圾回收机制的调用，是由系统来决定(即有自己的 GC 算法), 也可以通过 System.gc() 主动触发垃圾回收机制</li>
</ol>
<h2 id="类变量和类方法（静态变量和静态方法）"><a href="#类变量和类方法（静态变量和静态方法）" class="headerlink" title="类变量和类方法（静态变量和静态方法）"></a>类变量和类方法（静态变量和静态方法）</h2><h3 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h3><p>​	特点：会被本类的所有的对象实例共享，随着类的加载而创建，可以直接通过类名调用</p>
<p>​	<strong>内存布局</strong>：在堆的永久生成区域中</p>
<p>​	定义：访问修饰符 static 数据类型 变量名；</p>
<p>​	访问：类名.变量名[前提：满足访问修饰符的访问权限和范围]</p>
<p>​	生命周期：随类的加载开始，随类的消亡而销毁</p>
<h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>​	特点：不创建实例，也可以调用，可通过类名调用；不允许使用与对象有关的关键字，<strong>this、super</strong></p>
<p>​	定义：访问修饰符 static 数据返回类型 方法名(){}</p>
<p><strong>静态方法，只能访问静态的成员，非静态方法，可以访问静态成员和非静态成员</strong></p>
<h2 id="main方法"><a href="#main方法" class="headerlink" title="main方法"></a>main方法</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220505162645471.png" alt="image-20220505162645471"></p>
<p>在main方法中，可以直接调用main方法所在类的静态方法或静态属性</p>
<p>但是，不能直接访问该类中的非静态成员，必须创建该类的一个实例对象后，才能通过这个对象去访问类中的非静态成员</p>
<h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><p>又称初始化块，属于类中的成员，类似于方法，将逻辑语句封装在方法体中，通过{}包围起来</p>
<p>但和方法不同，没有方法名，没有返回，没有参数，只有方法体，而且不能通过对象或类显示调用，而是加载类时，或创建对象时隐式调用</p>
<p>两类：静态代码块和普通&#x2F;非静态代码块</p>
<p>相当于另一种形式的构造器，可以做初始化操作</p>
<h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><p>1）静态代码块随着类的加载而执行，并且只会执行一次</p>
<p>2）<strong>类加载时间</strong></p>
<p>​		a.创建对象实例时(new)</p>
<p>​		b.创建子类对象实例，父类也会被加载</p>
<p>​		c.使用类的静态成员时</p>
<p>3）普通代码块，在创建对象实例时，会被隐式的调用</p>
<p>​		<strong>创建一次，调用一次</strong></p>
<p>4）创建对象时，类的调用顺序</p>
<p>​		a.调用静态代码块和静态属性初始化(优先级一样，按定义顺序调用)</p>
<p>​		b.调用普通代码块和普通属性初始化(优先级一样，按定义顺序调用)</p>
<p>​		c.调用构造方法</p>
<p>5）子父类的调用顺序</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220505172401550.png" alt="image-20220505172401550"></p>
<h2 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h2><p>设计模式是在大量的实践中总结和理论化之后优化的代码结构、编程风格、以及解决问题的思考方式。</p>
<p>单例设计模式：采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法</p>
<p>方式：1）饿汉式；2）懒汉式</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220506133052141.png" alt="image-20220506133052141"></p>
<ol>
<li>将构造器私有化</li>
<li>在类的内部直接创建对象(该对象是 static) </li>
<li>提供一个公共的 static 方法，返回对象</li>
</ol>
<h2 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h2><p><strong>可以修饰类、属性、方法和局部变量，不能修饰构造器</strong></p>
<p>1）被final修饰的类，不能被继承，但可以实例化</p>
<p>2）被final修饰的方法，不能被子类重写</p>
<p>3）被final修饰的局部变量或类中的某个属性，又叫常量，不能被修改</p>
<p>4）final修饰的属性在定义时，<strong>必须赋初值</strong>，赋值可以在以下位置：</p>
<p>​		a.定义时 b.在构造器中 c.在代码块中</p>
<p>5）如果final修饰的属性是静态的，则初始化的位置只能是a.定义时 b.在静态代码块中，不能在构造器中赋值</p>
<p>6）如果一个类已经是final类，就没有必要再将方法修饰成final方法</p>
<p>7）final和static往往搭配使用，效率更高，<strong>不会导致类加载</strong>，底层编译器做了优化处理</p>
<p>8）包装类，String类都是final类</p>
<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>当父类的一些方法不能确定时，可以用abstract关键字来修饰该方法，这个方法就是抽象方法，用abstract来修饰该类就是抽象类</p>
<p>1）抽象类不能被实例化</p>
<p>2）abstract只能修饰类和方法，不能修饰属性和其它的</p>
<p>3）抽象类的本质还是类，可以有任意成员，例如：非抽象方法、构造器、静态属性等</p>
<p>4）抽象方法不能有主体，即不能实现</p>
<p>5）一个类继承了抽象类，则它必须实现抽象类的所有抽象方法</p>
<p>6）<strong>抽象方法不能使用private、final和static来修饰，因为这些关键字都是和重写相违背的</strong></p>
<p>关于抽象类</p>
<p><strong>JDK 1.8以前</strong>，抽象类的方法默认访问权限为<strong>protected</strong></p>
<p><strong>JDK 1.8时</strong>，抽象类的方法默认访问权限变为<strong>default</strong></p>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>给出一些没有实现的方法，封装在一起，到某个类要使用的时候，再根据具体情况把这些方法写出来</p>
<p>接口体现了程序设计的多态和高内聚低耦合的设计思想</p>
<p>JDK7.0中接口是更加抽象的抽象类，抽象类里的方法可以有方法体，接口里的方法都没有方法体</p>
<p>JDK8.0后接口类可以有静态方法、默认方法，也就是说接口中可以有方法的具体实现</p>
<p><strong>接口中的属性，只能是final的，而且是public static final修饰符，必须初始化</strong></p>
<p>接口不能继承其他的类，但是可以继承多个接口</p>
<p><strong>接口的修饰符只能是public和默认，这点和类的修饰符一样</strong></p>
<p><strong>like-a</strong>的关系</p>
<p>关于接口</p>
<p><strong>JDK 1.8以前</strong>，接口中的方法必须是<strong>public</strong>的</p>
<p><strong>JDK 1.8时</strong>，接口中的方法可以是<strong>public</strong>的，也可以是<strong>default</strong>的</p>
<p><strong>JDK 1.9时</strong>，接口中的方法可以是<strong>private</strong>的</p>
<p><strong>高内聚低耦合</strong>，是<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/25279">软件工程</a>中的概念，是判断软件设计好坏的标准，主要用于程序的<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/2262089">面向对象</a>的设计，主要看类的内聚性是否高，<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E8%80%A6%E5%90%88%E5%BA%A6/2603938">耦合度</a>是否低。目的是使程序模块的可重用性、移植性大大增强。通常程序结构中各模块的内聚程度越高，模块间的耦合程度就越低。内聚是从功能角度来度量模块内的联系，一个好的内聚模块应当恰好做一件事，它描述的是模块内的功能联系；耦合是软件结构中各模块之间相互连接的一种<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%BA%A6%E9%87%8F/34036">度量</a>，耦合强弱取决于模块间接口的复杂程度、进入或访问一个模块的点以及通过接口的数据。</p>
<h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><p>类的五大成员：<strong>属性、方法、构造器、代码块、内部类</strong></p>
<p>类在局部位置(方法中&#x2F;代码块)：<strong>局部内部类、匿名内部类</strong></p>
<p>类在成员位置：<strong>成员内部类、静态内部类</strong></p>
<p>特点：可以直接访问私有属性，并且可以体现类与类之间的包含关系</p>
<h3 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220506150105202.png" alt="image-20220506150105202"></p>
<h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220506150255497.png" alt="image-20220506150255497"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220506150420023.png" alt="image-20220506150420023"></p>
<h3 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220506150551210.png" alt="image-20220506150551210"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220506150620993.png" alt="image-20220506150620993"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220506150656265.png" alt="image-20220506150656265"></p>
<h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220506150811300.png" alt="image-20220506150811300"></p>
<h2 id="枚举-enum"><a href="#枚举-enum" class="headerlink" title="枚举(enum)"></a>枚举(enum)</h2><p>枚举是一组常量的集合</p>
<p>枚举是一种特殊的类，里面包含一组有限的特定的对象</p>
<h3 id="自定义类实现枚举"><a href="#自定义类实现枚举" class="headerlink" title="自定义类实现枚举"></a>自定义类实现枚举</h3><p>可以提供getXxx方法，不需要提供setXxx方法，防止属性被修改，因为枚举对象通常为只读</p>
<p>对枚举对象&#x2F;属性使用final+static共同修饰，实现底层优化</p>
<p>枚举对象名全部大写</p>
<p>将构造器私有化，目的防止直接 new</p>
<p>本类内部创建一组对象</p>
<p>对外暴露对象（通过为对象添加 public final static修饰符）</p>
<h3 id="enum-关键字实现枚举"><a href="#enum-关键字实现枚举" class="headerlink" title="enum 关键字实现枚举"></a>enum 关键字实现枚举</h3><p>使用关键字 enum 替代 class</p>
<p> enum 关键字开发一个枚举类时，默认会<strong>继承 Enum 类</strong>, 而且是一个 final 类</p>
<p>public static final Season SPRING &#x3D; new Season(“春天”, “温暖”) 直接使用  SPRING(“春天”, “温暖”)    解读：<strong>常量名(实参列表)</strong></p>
<p>如果有多个常量(对象)， 使用<strong>逗号</strong>间隔，<strong>分号</strong>结尾</p>
<p>enum 来实现枚举，要求将定义常量对象，写在前面</p>
<p>如果使用无参构造器创建 枚举对象，则实参列表和小括号都可以省略</p>
<h3 id="Enum-类"><a href="#Enum-类" class="headerlink" title="Enum 类"></a>Enum 类</h3><ol>
<li><p>toString：Enum 类已经重写过了，返回的是当前对象名,子类可以重写该方法，用于返回对象的属性信息 </p>
</li>
<li><p>name：返回当前对象名（常量名），子类中不能重写 </p>
</li>
<li><p>ordinal：返回当前对象的位置号，默认从 0 开始 </p>
</li>
<li><p>values：返回当前枚举类中所有的常量</p>
</li>
<li><p>valueOf：将字符串转换成枚举对象，要求字符串必须为已有的常量名，否则报异常！</p>
</li>
<li><p>compareTo：比较两个枚举常量，比较的就是编号！</p>
</li>
</ol>
<h3 id="enum-实现接口"><a href="#enum-实现接口" class="headerlink" title="enum 实现接口"></a>enum 实现接口</h3><ol>
<li><p>使用 enum 关键字后，就不能再继承其它类了，因为 enum 会隐式继承 Enum，而 Java 是单继承机制。</p>
</li>
<li><p>枚举类和普通类一样，可以实现接口，如下形式。 enum 类名 implements 接口 1，接口 2{}</p>
</li>
</ol>
<h2 id="注解-Annotation"><a href="#注解-Annotation" class="headerlink" title="注解(Annotation)"></a>注解(Annotation)</h2><ol>
<li><p>注解(Annotation)也被称为元数据(Metadata)，用于修饰解释包、类、方法、属性、构造器、局部变量等数据信息。 </p>
</li>
<li><p>和注释一样，注解不影响程序逻辑，但注解可以被编译或运行，相当于嵌入在代码中的补充信息。 </p>
</li>
<li><p>在 JavaSE 中，注解的使用目的比较简单，例如标记过时的功能，忽略警告等。在 JavaEE 中注解占据了更重要的角 色，例如用来配置应用程序的任何切面，代	替 java EE 旧版中所遗留的繁冗代码和 XML 配置等</p>
</li>
</ol>
<p>使用 Annotation 时要在其前面增加 @ 符号, 并把该 Annotation 当成一个修饰符使用。用于修饰它支持的程序元素</p>
<p>三个基本的 Annotation: </p>
<ol>
<li>@Override: 限定某个方法，是重写父类方法, 该注解只能用于方法</li>
</ol>
<p>​	如果写了@Override 注解，编译器就会去检查该方法是否真的重写了父类的 方法，如果的确重写了，则编译通过，如果没有构成重写，则编译错误</p>
<p>​	 @Override注解源码：@Target(ElementType.METHOD)，说明只能修饰方法，不能修饰其它类、包、和属性等</p>
<ol start="2">
<li>@Deprecated: 用于表示某个程序元素(类, 方法等)已过时，即不在推荐使用，但是仍然可以使用</li>
</ol>
<p>​	@Deprecated 注解类的源码：@Target(value&#x3D;{CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE}，说明可以修饰方法，</p>
<p>​	类，字段, 包, 参数等等</p>
<p>​	@Deprecated 可以做版本升级过渡使用</p>
<ol start="3">
<li>@SuppressWarnings: 抑制编译器警告，在{“”} 中，可以写入你希望抑制(不显示)警告信息</li>
</ol>
<p>​	@SuppressWarnings 源码：@Target({TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE})，通常我们可以放置具体的语句, 方法, 类</p>
<p>​	可以指定的警告类型有 </p>
<p>​	&#x2F;&#x2F;all，抑制所有警告</p>
<p>​	&#x2F;&#x2F;boxing，抑制与封装&#x2F;拆装作业相关的警告</p>
<p>​	&#x2F;&#x2F;cast，抑制与强制转型作业相关的警告 </p>
<p>​	&#x2F;&#x2F;dep-ann，抑制与淘汰注释相关的警告</p>
<p>​	&#x2F;&#x2F;deprecation，抑制与淘汰的相关警告</p>
<p>​	&#x2F;&#x2F;fallthrough，抑制与 switch 陈述式中遗漏 break 相关的警告</p>
<p>​	&#x2F;&#x2F;finally，抑制与未传回 finally 区块相关的警告 </p>
<p>​	hiding，抑制与隐藏变数的区域变数相关的警告</p>
<p>​	&#x2F;&#x2F;incomplete-switch，抑制与 switch 陈述式(enum case)中遗漏项目相关的警告  </p>
<p>​	&#x2F;&#x2F;javadoc，抑制与 javadoc 相关的警告</p>
<p>​	&#x2F;&#x2F;nls，抑制与非 nls 字串文字相关的警告</p>
<p>​	&#x2F;&#x2F;null，抑制与空值分析相关的警告 </p>
<p>​	&#x2F;&#x2F;rawtypes，抑制与使用 raw 类型相关的警告</p>
<p>​	&#x2F;&#x2F;resource，抑制与使用 Closeable 类型的资源相关的警告 </p>
<p>​	&#x2F;&#x2F;restriction，抑制与使用不建议或禁止参照相关的警告  </p>
<p>​	&#x2F;&#x2F;serial，抑制与可序列化的类别遗漏 serialVersionUID 栏位相关的警告 </p>
<p>​	&#x2F;&#x2F;static-access，抑制与静态存取不正确相关的警告</p>
<p>​	&#x2F;&#x2F;static-method，抑制与可能宣告为 static 的方法相关的警告</p>
<p>​	&#x2F;&#x2F;super，抑制与置换方法相关但不含 super 呼叫的警告</p>
<p>​	&#x2F;&#x2F;synthetic-access，抑制与内部类别的存取未最佳化相关的警告</p>
<p>​	&#x2F;&#x2F;sync-override，抑制因为置换同步方法而遗漏同步化的警告</p>
<p>​	&#x2F;&#x2F;unchecked，抑制与未检查的作业相关的警告</p>
<p>​	&#x2F;&#x2F;unqualified-field-access，抑制与栏位存取不合格相关的警告 </p>
<p>​	&#x2F;&#x2F;unused，抑制与未用的程式码及停用的程式码相关的警告</p>
<h2 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h2><p>JDK 的元 Annotation 用于修饰其他 Annotation</p>
<p>元注解的种类：</p>
<ol>
<li>Retention &#x2F;&#x2F;指定注解的作用范围，三种 SOURCE,CLASS,RUNTIME</li>
</ol>
<p>​	只能用于修饰一个 Annotation 定义, 用于指定该 Annotation 可以保留多长时间, @Rentention 包含一个 RetentionPolicy 类型的成员变量, 使用 @Rentention 	时必须为该 value</p>
<p>@Retention 的三种值 </p>
<p>a. RetentionPolicy.SOURCE: 编译器使用后，直接丢弃这种策略的注释 </p>
<p>b. RetentionPolicy.CLASS: 编译器将把注解记录在 class 文件中. 	当运行 Java 程序时, JVM 不会保留注解。 这是默认值</p>
<p>c. RetentionPolicy.RUNTIME:编译器将把注解记录在 class 文件中. 当运行 Java 程序时, JVM 会保留注解. 程序可以 通过反射获取该注解</p>
<ol start="2">
<li><p>Target &#x2F;&#x2F; 指定注解可以在哪些地方使用 </p>
</li>
<li><p>Documented &#x2F;&#x2F;指定该注解是否会在 javadoc 体现</p>
</li>
<li><p>Inherited &#x2F;&#x2F;子类会继承父类注解</p>
</li>
</ol>
<h2 id="异常-Exception"><a href="#异常-Exception" class="headerlink" title="异常-Exception"></a>异常-Exception</h2><p>java语言中，将程序执行中发生的不正常情况称为“异常”(开发过程中的语法错误和逻辑错误不是异常)</p>
<p>两类：Error—Java虚拟机无法解决的严重问题，如：JVM系统内部错误、资源耗尽等情况</p>
<p>​			Exception—其他因编程错误或偶然的外在因素导致的一般性问题，可以使用针对性的代码进行处理。例如：空指针访问、试图读取不存在的文件、网络连接中断等，分为：运行时异常(可以不做处理，默认就是throws的方式处理，若全处理可能会对程序的可读性和运行效率产生影响)和编译时异常(必须处置，否则代码不能通过编译)。</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220506214357718.png" alt="image-20220506214357718"></p>
<h3 id="常见的运行时异常"><a href="#常见的运行时异常" class="headerlink" title="常见的运行时异常"></a>常见的运行时异常</h3><ol>
<li>NullPointerException 空指针异常</li>
</ol>
<p>​	当应用程序试图在需要对象的地方使用 null 时，抛出该异常</p>
<ol start="2">
<li>ArithmeticException 数学运算异常</li>
</ol>
<p>​	当出现异常的运算条件时，抛出此异常。例如，一个整数“除以零”时，抛出此类的一个实例</p>
<ol start="3">
<li>ArrayIndexOutOfBoundsException 数组下标越界异常</li>
</ol>
<p>​	用非法索引访问数组时抛出的异常。如果索引为负或大于等于数组大小，则该索引为非法索引</p>
<ol start="4">
<li>ClassCastException 类型转换异常</li>
</ol>
<p>​	当试图将对象强制转换为不是实例的子类时，抛出该异常。</p>
<ol start="5">
<li>NumberFormatException 数字格式不正确异常</li>
</ol>
<p>​	当应用程序试图将字符串转换成一种数值类型，但该字符串不能转换为适当格式时，抛出该异常 &#x3D;&gt; 使用异常我们 可以确保输入是满足条件数字</p>
<h3 id="常见的编译时异常"><a href="#常见的编译时异常" class="headerlink" title="常见的编译时异常"></a>常见的编译时异常</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220506215045615.png" alt="image-20220506215045615"></p>
<h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220506215331954.png" alt="image-20220506215331954"></p>
<h4 id="try-catch-finally"><a href="#try-catch-finally" class="headerlink" title="try-catch-finally"></a>try-catch-finally</h4><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220506215507298.png" alt="image-20220506215507298"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220506215617489.png" alt="image-20220506215617489"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220506220317153.png" alt="image-20220506220317153"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220506215812627.png" alt="image-20220506215812627"></p>
<h4 id="throws"><a href="#throws" class="headerlink" title="throws"></a>throws</h4><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220506220018705.png" alt="image-20220506220018705"></p>
<h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><p>当程序中出现了某些错误，但该错误信息并没有在Throwable子类中描述处理，则可以自己设计异常类，用于描述该错误信息。</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220506220807103.png" alt="image-20220506220807103"></p>
<h3 id="throw-和-throws-的区别"><a href="#throw-和-throws-的区别" class="headerlink" title="throw 和 throws 的区别"></a>throw 和 throws 的区别</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220506221123112.png" alt="image-20220506221123112"></p>
<h1 id="常用类"><a href="#常用类" class="headerlink" title="常用类"></a>常用类</h1><h2 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h2><ol>
<li><p>针对八种基本数据类型相应的引用类型—包装类 </p>
</li>
<li><p>有了类的特点，就可以调用类中的方法。</p>
</li>
</ol>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220507143234839.png" alt="image-20220507143234839"></p>
<h3 id="装箱与拆箱"><a href="#装箱与拆箱" class="headerlink" title="装箱与拆箱"></a>装箱与拆箱</h3><p>包装类与基本数据类型之间的相互转换</p>
<p>JDK5.0以后(含5.0)有自动拆装箱</p>
<p>自动拆装箱底层调用的是<strong>valueOf方法</strong>，例如：Integer.valueOf();</p>
<h3 id="Integer-类和-Character-类的常用方法"><a href="#Integer-类和-Character-类的常用方法" class="headerlink" title="Integer 类和 Character 类的常用方法"></a>Integer 类和 Character 类的常用方法</h3><p>(Integer.MIN_VALUE); &#x2F;&#x2F;返回最小值</p>
<p>(Integer.MAX_VALUE);&#x2F;&#x2F;返回最大值</p>
<p>(Character.isDigit(‘a’));&#x2F;&#x2F;判断是不是数字</p>
<p>(Character.isLetter(‘a’));&#x2F;&#x2F;判断是不是字母 </p>
<p>(Character.isUpperCase(‘a’));&#x2F;&#x2F;判断是不是大写 </p>
<p>(Character.isLowerCase(‘a’));&#x2F;&#x2F;判断是不是小写 </p>
<p>(Character.isWhitespace(‘a’));&#x2F;&#x2F;判断是不是空格 </p>
<p>(Character.toUpperCase(‘a’));&#x2F;&#x2F;转成大写 </p>
<p>(Character.toLowerCase(‘A’));&#x2F;&#x2F;转成小写</p>
<h2 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h2><p>1）String对象用于保存字符串，也就是一组字符序列</p>
<p>2）字符串常量对象是用双引号括起的字符序列</p>
<p>3）字符串的字符使用的是Unicode字符编码，一个字符(不区分字母还是汉字)占两个字节</p>
<p>4）String 类实现了接口 Serializable【String 可以串行化:可以在网络传输】  接口 Comparable [String 对象可以比较大小]</p>
<p>5）String 是 final 类，不能被其他的类继承，代表不可变的字符序列</p>
<p>6）String 有属性 private final char value[]： 用于存放字符串内容 </p>
<p>7）一定要注意：value 是一个 final 类型， 不可以修改(需要功力)：即 value 不能指向新的地址，但是单个字符内容是可以变化</p>
<p>8）字符串是不可变的。一个字符串对象一旦被分配，其内容是不可变的</p>
<p>9）intern方法：最终返回的是常量池的地址(对象)</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220507145402726.png" alt="image-20220507145402726"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220507145435192.png" alt="image-20220507145435192"></p>
<p>10）String类是保存字符串常量的。每次更新都需要重新开辟空间，效率极低，因此Java设计者还提供了StringBuilder和StringBuffer来增强String的功能</p>
<h3 id="String类常用方法"><a href="#String类常用方法" class="headerlink" title="String类常用方法"></a>String类常用方法</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220507155349012.png" alt="image-20220507155349012"></p>
<p>1）toUpperCase 转换成大写</p>
<p>2）toLowerCase 转换成小写</p>
<p>3）concat 拼接字符串</p>
<p>4）replace 替换字符串中的字符</p>
<p>5）split 分割字符串, 对于某些分割字符，我们需要转义比如 | \\等</p>
<p>6）toCharArray 转换成字符数组</p>
<p>7）compareTo 比较两个字符串的大小，如果前者大，则返回正数，后者大，则返回负数，如果相等，返回 0</p>
<p>8）format 格式字符串(占位符有:%s 字符串 %c 字符 %d 整型 %.2f 浮点)</p>
<h2 id="StringBuffer类"><a href="#StringBuffer类" class="headerlink" title="StringBuffer类"></a>StringBuffer类</h2><p><strong>可变的字符序列</strong>，可以对字符串内容进行增删(**线程安全)**。</p>
<p>很多方法与String相同，但StringBuffer是可变长度的。</p>
<p>StringBuffer是一个<strong>容器</strong>。</p>
<p>StringBuffer 的直接父类 是 AbstractStringBuilder</p>
<p>StringBuffer 实现了 Serializable, 即 StringBuffer 的对象可以串行化</p>
<p>在父类中 AbstractStringBuilder 有属性 char[] value,不是 fina，该 value 数组存放字符串内容，引出存放在堆中的</p>
<p>StringBuffer 是一个 final 类，不能被继承</p>
<p>因为 StringBuffer 字符内容是存在 char[] value, 在变化(增加&#x2F;删除)时，不用每次都更换地址(即不是每次创建新对象)， 所以效率高于 String</p>
<h3 id="String与StringBuffer的转换"><a href="#String与StringBuffer的转换" class="headerlink" title="String与StringBuffer的转换"></a>String与StringBuffer的转换</h3><h4 id="String—-gt-StringBuffer"><a href="#String—-gt-StringBuffer" class="headerlink" title="String—&gt;StringBuffer"></a>String—&gt;StringBuffer</h4><p>1）使用构造器：StringBuffer stringBuffer &#x3D; new StringBuffer(str)</p>
<p>2）使用的是 append 方法：StringBuffer stringBuffer &#x3D; new StringBuffer(); stringBuffer &#x3D; stringBuffer.append(str)</p>
<h4 id="StringBuffer—-gt-String"><a href="#StringBuffer—-gt-String" class="headerlink" title="StringBuffer—&gt;String"></a>StringBuffer—&gt;String</h4><p>StringBuffer stringBuffer &#x3D; new StringBuffer(“韩顺平教育”);</p>
<p>1）使用 StringBuffer 提供的 toString 方法：String s &#x3D; stringBuffer.toString()</p>
<p>2）使用构造器：String s &#x3D; new String(stringBuffer)</p>
<h3 id="StringBuffer类常用方法"><a href="#StringBuffer类常用方法" class="headerlink" title="StringBuffer类常用方法"></a>StringBuffer类常用方法</h3><p>1）增：append</p>
<p>2）删：delete</p>
<p>3）改：replace</p>
<p>4）查：indexOf</p>
<p>5）插：insert</p>
<p>6）长度：length</p>
<h2 id="StringBuilder-类"><a href="#StringBuilder-类" class="headerlink" title="StringBuilder 类"></a>StringBuilder 类</h2><p>一个可变的字符序列。此类提供一个与StringBuffer兼容的API，但不保证同步(<strong>线程不安全</strong>)。</p>
<p>StringBuilder 的方法，没有做互斥的处理,即没有 synchronized 关键字,因此在单线程的情况下使用</p>
<p>该类用在字符串缓冲区被单个线程使用的时候，<strong>比StringBuffer要快</strong>。</p>
<p>在StringBuilder上的主要操作是append和insert方法，可重载这些方法，已接受任意类型的数据</p>
<p>StringBuilder 接父类 是 AbstractStringBuilder</p>
<p>StringBuilder 实现了 Serializable, 即 StringBuilder 的对象可以串行化</p>
<p>在父类中 AbstractStringBuilder 有属性 char[] value,不是 fina，该 value 数组存放字符串内容，引出存放在堆中的</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220507164322409.png" alt="image-20220507164322409"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220507164338156.png" alt="image-20220507164338156"></p>
<h3 id="String、StringBuffer-和-StringBuilder-的选择"><a href="#String、StringBuffer-和-StringBuilder-的选择" class="headerlink" title="String、StringBuffer 和 StringBuilder 的选择"></a>String、StringBuffer 和 StringBuilder 的选择</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220507164449875.png" alt="image-20220507164449875"></p>
<h2 id="Math-类"><a href="#Math-类" class="headerlink" title="Math 类"></a>Math 类</h2><p>Math 类包含用于执行基本数学运算的方法，如初等指数、对数、平方根和三角函数。均为静态方法</p>
<p>abs 绝对值</p>
<p>pow 求幂</p>
<p>ceil 向上取整，返回&gt;&#x3D;该参数的最小整数(转成 double)</p>
<p>floor 向下取整，返回&lt;&#x3D;该参数的最大整数(转成 double)</p>
<p>round 四舍五入</p>
<p>sqrt 求开方</p>
<p>random 求随机数  返回的是 0 &lt;&#x3D; x &lt; 1 之间的一个随机小数</p>
<h2 id="Arrays-类"><a href="#Arrays-类" class="headerlink" title="Arrays 类"></a>Arrays 类</h2><p>Arrays里面包含了一系列静态方法，用于管理或操作数组(例如排序和搜素)</p>
<p>1）toString 返回数组的字符串形式</p>
<p>2）sort 排序</p>
<p>3）binarySearch 通过二分搜索法进行查找，要求必须排好序</p>
<p>4）copyOf 数组元素的复制</p>
<p>5）fill 数组元素的填充</p>
<p>6）equals 比较两个数组元素内容是否完全一致</p>
<p>7）asList 将一组值转换成List</p>
<h2 id="System-类"><a href="#System-类" class="headerlink" title="System 类"></a>System 类</h2><p>1）exit 退出当前程序</p>
<p>2）arraycopy 复制数组元素，比较适合底层调用，一般使用Arrays.copyOf完成复制数组</p>
<p>3）currentTimeMillens 返回当前时间距离1970-1-1的毫秒数</p>
<p>4）gc 运行垃圾回收机制</p>
<p>5）fill 数组元素的填充</p>
<p>6）equals 比较两个数组元素内容是否完全一致</p>
<p>7）asList 将一组值转换成List</p>
<h2 id="BigInteger-和-BigDecimal-类"><a href="#BigInteger-和-BigDecimal-类" class="headerlink" title="BigInteger 和 BigDecimal 类"></a>BigInteger 和 BigDecimal 类</h2><p>BigInteger 适合保存比较大的整型</p>
<p>BigDecimal适合保存精度更高的浮点型</p>
<h3 id="常见方法"><a href="#常见方法" class="headerlink" title="常见方法"></a>常见方法</h3><p>1）add 加</p>
<p>2）subtract 减</p>
<p>3）multiply 乘</p>
<p>4）divide 除</p>
<h2 id="日期类"><a href="#日期类" class="headerlink" title="日期类"></a>日期类</h2><h3 id="第一代日期类"><a href="#第一代日期类" class="headerlink" title="第一代日期类"></a>第一代日期类</h3><p>1.Date：精确到毫秒，代表特定的瞬间</p>
<p>2.SimpleDateFormat：格式和解析日期的类</p>
<h3 id="第二代日期类"><a href="#第二代日期类" class="headerlink" title="第二代日期类"></a>第二代日期类</h3><p>Calendar类：抽象类，他为特定瞬间与一组诸如YEAR、MONTH、DAY_OF_MONTH、HOUR等日历字段之间的转换提供了一些方法，并为操作日历字段提供了一</p>
<p>些方法。</p>
<h3 id="第三代日期类"><a href="#第三代日期类" class="headerlink" title="第三代日期类"></a>第三代日期类</h3><p>LocalDate：只包含日期，可以获得日期字段</p>
<p>LocalTime：只包含时间，可以获得时间字段</p>
<p>LocalDateTime：包含日期+时间，可以获取日期和时间字段</p>
<h3 id="DateTimeFormatter-格式日期类"><a href="#DateTimeFormatter-格式日期类" class="headerlink" title="DateTimeFormatter 格式日期类"></a>DateTimeFormatter 格式日期类</h3><h3 id="Instant-时间戳"><a href="#Instant-时间戳" class="headerlink" title="Instant 时间戳"></a>Instant 时间戳</h3><h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><p>数组缺点：长度开始时必须指定，而且一旦指定，不能更改</p>
<p>​					保存的必须为同一类型的元素</p>
<p>​					使用数组进行增删改查比较麻烦</p>
<p>集合：可以<strong>动态保存</strong>任意多个对象</p>
<p>​			提供了一系列方便的操作对象的方法：add、remove、set、get等</p>
<p>​			使用集合添加、删除新元素简单</p>
<p>Java的集合类主要分为两大类</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220510195334921.png" alt="image-20220510195334921"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220510195351280.png" alt="image-20220510195351280"></p>
<p><img src="http://uploadfiles.nowcoder.com/images/20151109/403938_1447079573733_4F723777B74785B7A07A73C9792B8F6F" alt="img"></p>
<p>集合主要是两组(单列集合，双列集合)</p>
<p>Collection接口有两个重要的子接口List Set，他们的实现子类都是单列集合</p>
<p>Map接口的实现子类是双列集合，存放的是K-V</p>
<h2 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a>Collection接口</h2><p>Collection实现子类可以存放多个元素，每个元素可以是Object</p>
<p>有些实现子类可以存放重复元素，有些不可以</p>
<p>有些实现子类是有序的(List)，有些是无序的(Set)</p>
<p>Collection接口没有直接的实现子类，是通过他的子接口Set和List来实现的</p>
<h3 id="Collection-接口常用方法"><a href="#Collection-接口常用方法" class="headerlink" title="Collection 接口常用方法"></a>Collection 接口常用方法</h3><p>add:添加单个元素</p>
<p>remove:删除指定元素</p>
<p>contains:查找元素是否存在</p>
<p>size:获取元素个数</p>
<p>isEmpty:判断是否为空</p>
<p>clear:清空</p>
<p>addAll:添加多个元素</p>
<p>containsAll:查找多个元素是否都存在</p>
<p>removeAll：删除多个元素</p>
<h3 id="Collection-接口遍历元素"><a href="#Collection-接口遍历元素" class="headerlink" title="Collection 接口遍历元素"></a>Collection 接口遍历元素</h3><h4 id="Iterator-迭代器"><a href="#Iterator-迭代器" class="headerlink" title="Iterator(迭代器)"></a>Iterator(迭代器)</h4><p>所有实现了Collection接口的集合类都有一个iterator()方法，用以返回一个实现了Iterator接口的对象，即可以返回一个迭代器</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220510200811204.png" alt="image-20220510200811204"></p>
<h4 id="for-循环增强"><a href="#for-循环增强" class="headerlink" title="for 循环增强"></a>for 循环增强</h4><p>语法：for(元素类型 元素名：集合名或数组名){</p>
<p>​						访问元素</p>
<p>​			}</p>
<h2 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a>List接口</h2><p>Collection接口的子接口</p>
<p>List集合类中<strong>元素有序</strong>(添加顺序与取出顺序一致)、<strong>可重复</strong></p>
<p>List集合中的每个元素都有其对应的顺序索引，即支持索引</p>
<p>List容器中的元素都对应一个整数型的序号记载其在容器中的位置，可以根据序号存取容器中的元素</p>
<h3 id="List的遍历"><a href="#List的遍历" class="headerlink" title="List的遍历"></a>List的遍历</h3><p>使用iterator</p>
<p>增强for</p>
<p>普通for</p>
<h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><p>由数组实现数据存储</p>
<p>可以加入<strong>null</strong>，并且<strong>多个</strong></p>
<p>基本等同于<strong>Vector</strong>，除了**ArrayList是线程不安全的(执行效率高)**，多线程情况下，不建议使用ArrayList</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220510203244326.png" alt="image-20220510203244326"></p>
<h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h3><p>线程同步，即<strong>线程安全</strong>，Vector类的操作方法带有<strong>synchronized</strong></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220510204207739.png" alt="image-20220510204207739"></p>
<h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><p>底层实现了双向链表和双端队列的特点</p>
<p>可以添加任意元素(元素可以重复)，包括null</p>
<p>线程不安全，没有实现同步</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220510204439516.png" alt="image-20220510204439516"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220510204620749.png" alt="image-20220510204620749"></p>
<h2 id="Set接口"><a href="#Set接口" class="headerlink" title="Set接口"></a>Set接口</h2><p><strong>无序</strong>(添加和取出的顺序不一致)，没有索引</p>
<p><strong>不允许重复元素</strong>，最多只能包含一个null</p>
<h3 id="Set的遍历"><a href="#Set的遍历" class="headerlink" title="Set的遍历"></a>Set的遍历</h3><p>使用迭代器</p>
<p>增强for</p>
<p>不能使用索引的方式来获取</p>
<h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><p>底层是HashMap，HashMap的底层是数组+链表+红黑树</p>
<p>可以存放null值，但是只能有一个</p>
<p>不能有重复元素</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220510205506684.png" alt="image-20220510205506684"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220510205702116.png" alt="image-20220510205702116"></p>
<h3 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h3><p>HashSet的子类</p>
<p>底层是LinkedHashMap，底层维护了一个数组+双向链表</p>
<p>根据元素的hashCode值来决定元素的存储位置，同时使用链表维护元素的次序，这使元素看起来是以插入顺序保存的</p>
<p>不允许添加重复元素</p>
<h2 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h2><p><strong>Map与Collection并列存在</strong>，用于保存具有映射关系的数据：Key-Value</p>
<p>Key和Value可以是任何引用类型的数据，会封装到HashMap$Node对象中</p>
<p><strong>Key不允许重复</strong>，原因和HashSet一样</p>
<p><strong>Value可以重复</strong></p>
<p><strong>Key与Value可为null</strong></p>
<p>常用String类作为Map的Key</p>
<p>Key与Value存在<strong>单向一对一</strong>关系，即通过指定的Key总能找到对应的value</p>
<p>一对K-V是存放在一个HashMap$Node中的，Node实现了Entry接口，故也可说，一对k-v就是一个Entry</p>
<h3 id="Map接口常用方法"><a href="#Map接口常用方法" class="headerlink" title="Map接口常用方法"></a>Map接口常用方法</h3><p>put：添加数据，若key相等，则替换key对应的value值</p>
<p>remove：根据键删除映射关系</p>
<p>get：根据键获取值</p>
<p>size：获取元素个数</p>
<p>isEmpty：判断个数是否为 0</p>
<p>clear：清除 k-v</p>
<p>containsKey：查找键是否存在</p>
<h3 id="Map的遍历"><a href="#Map的遍历" class="headerlink" title="Map的遍历"></a>Map的遍历</h3><p>1）containsKey：查找键是否存在</p>
<p>2）KeySet：获取所有的键</p>
<p>3）entrySet：获取所有关系</p>
<p>4）values：获取所有的值</p>
<h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p>是Map接口使用频率最高的实现类</p>
<p>以<strong>key-value</strong>对的方式来存储数据(HashMap$Node类型)</p>
<p>key不能重复，但是值可以，允许使用null键和null值</p>
<p>如果添加相同的key，则会覆盖原来的key-value，等同于修改</p>
<p><strong>无序</strong>，与HashSet一样，不保证映射的顺序，因为底层是以hash表的方式来存储的</p>
<p>Hash没有实现同步，因此是<strong>线程不安全</strong>的，方法没有做同步互斥的操作，没有synchronized</p>
<p>扩容机制</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220512151107133.png" alt="image-20220512151107133"></p>
<h3 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h3><p>存放的元素是键值对：k-v</p>
<p>hashTable的键和值都<strong>不能为null</strong>，否则会抛出NullPointerException</p>
<p>hashTable使用方法基本与hashMap一样</p>
<p>**线程安全(synchronized)**，hashMap线程不安全</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220512151637502.png" alt="image-20220512151637502"></p>
<h3 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h3><p>继承HashTable类，并实现了Map接口，也是使用一种键值对的形式来保存数据</p>
<p>使用特点和HashTable类似</p>
<p>可用于从xxx.properties文件中，加载数据到Properties类对象，并进行读取和修改</p>
<p>专门用于读写配置文件的集合类，配置文件的格式：键&#x3D;值，键值对不需要有空格，值不需要用引号一起来，默认类型是String</p>
<p>常见方法：</p>
<p>1）load：加载配置文件的键值对到Properties对象</p>
<p>2）list：将数据显示到指定设备</p>
<p>3）getProperty(key)：根据键获取值</p>
<p>4）setProperty(key, value)：设置键值对到Properties对象</p>
<p>5）store：将Properties中的键值对存储到配置文件，在idea中，保存信息到配置文件，如果含有中文，会存储为unicode码</p>
<h2 id="集合实现类的选取"><a href="#集合实现类的选取" class="headerlink" title="集合实现类的选取"></a>集合实现类的选取</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220512152145730.png" alt="image-20220512152145730"></p>
<h2 id="Collections-工具类"><a href="#Collections-工具类" class="headerlink" title="Collections 工具类"></a>Collections 工具类</h2><p>操作Set、List、和Map等集合的工具类</p>
<p>提供了一系列<strong>静态方法</strong>对集合元素进行排序、查询和修改等操作</p>
<h3 id="排序操作"><a href="#排序操作" class="headerlink" title="排序操作"></a>排序操作</h3><p>reverse(List)：反转 List 中元素的顺序</p>
<p>shuffle(List)：对 List 集合元素进行随机排序</p>
<p>sort(List)：根据元素的自然顺序对指定 List 集合元素按升序排序</p>
<p>sort(List，Comparator)：根据指定的 Comparator 产生的顺序对 List 集合元素进行排序</p>
<p>swap(List，int， int)：将指定 list 集合中的 i 处元素和 j 处元素进行交换</p>
<h3 id="查找、替换"><a href="#查找、替换" class="headerlink" title="查找、替换"></a>查找、替换</h3><p>Object max(Collection)：根据元素的自然顺序，返回给定集合中的最大元素</p>
<p>Object max(Collection，Comparator)：根据 Comparator 指定的顺序，返回给定集合中的最大元素</p>
<p>int frequency(Collection，Object)：返回指定集合中指定元素的出现次数</p>
<p>void copy(List dest,List src)：将 src 中的内容复制到 dest 中</p>
<p>boolean replaceAll(List list，Object oldVal，Object newVal)：使用新值替换 List 对象的所有旧值</p>
<h1 id="泛型E"><a href="#泛型E" class="headerlink" title="泛型E"></a>泛型E</h1><p>传统方法不能对加入到集合中的数据类型进行约束(不安全)</p>
<p>遍历的时候需要进行类型转换，如果集合中的数据量较大，对效率有影响</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220512160747944.png" alt="image-20220512160747944"></p>
<p>作用：可以在类声明时通过一个标识表示类中某个属性的类型，或者是某个方法的返回值的类型，或者是参数类型。</p>
<p>泛型的声明：interface 接口<T>{}和class 类&lt;K,V&gt;{}</p>
<p>​						T、K、V不代表值，而是表示类型，只能是<strong>引用类型</strong></p>
<p>泛型的实例化：要在类名后面指定类型参数的值(类型)</p>
<p>在给泛型指定具体类型后，可以传入该类型或者子类类型</p>
<h2 id="自定义泛型类"><a href="#自定义泛型类" class="headerlink" title="自定义泛型类"></a>自定义泛型类</h2><p>class 类名&lt;T, R…&gt;{</p>
<p>​		成员</p>
<p>}</p>
<p>普通成员可以使用泛型，静态不可以</p>
<p>使用泛型的数组，不能初始化</p>
<p>静态方法中不能使用类的泛型</p>
<p>泛型类的类型，是在创建对象的时候确定的(因为创建对象时，需要指定确定类型</p>
<p>如果在创建对象时，没有指定类型，默认为Object</p>
<h2 id="自定义泛型接口"><a href="#自定义泛型接口" class="headerlink" title="自定义泛型接口"></a>自定义泛型接口</h2><p>interface 接口名&lt;T,R…&gt;{}</p>
<p>接口中，静态成员也不能使用泛型</p>
<p>泛型接口的类型，在继承接口或者实现接口时确定</p>
<p>没有指定类型，默认为Object</p>
<h2 id="自定义泛型方法"><a href="#自定义泛型方法" class="headerlink" title="自定义泛型方法"></a>自定义泛型方法</h2><p>修饰符 &lt;T,R&gt;返回类型 方法名(参数列表){}</p>
<p>泛型方法，可以定义在普通类中，也可以定义在泛型类中</p>
<p>泛型方法被调用时，类型会确定</p>
<h2 id="泛型的继承和通配符"><a href="#泛型的继承和通配符" class="headerlink" title="泛型的继承和通配符"></a>泛型的继承和通配符</h2><p>泛型不具备继承性</p>
<p>&lt; ? &gt;：支持任意泛型类型</p>
<p>&lt; ? extends A &gt;：支持A类以及A类的子类，规定了泛型的上限</p>
<p>&lt; ? super A &gt;：支持A类以及A类的父类，不限于直接父类，规定了泛型的下限</p>
<h2 id="JUnit"><a href="#JUnit" class="headerlink" title="JUnit"></a>JUnit</h2><p>一个类有很多功能代码需要测试，为了测试，就需要写入到main方法中，如果有多个功能代码测试，就需要来回注销，切换很麻烦</p>
<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>进程是指运行中的程序，比如我们使用QQ，就启动了一个进程，操作系统就会为该进程分配内存空间。当我们使用迅雷，又启动了一个进程，操作系统将为迅雷分配性的内存空间。</p>
<p>进程是程序的一次执行过程，或是正在运行的一个程序。是动态过程：有他自身的产生、存在和消亡的过程。</p>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>由进程创建，是进程的一个实体</p>
<p>一个进程可以拥有多个线程</p>
<p>单线程：同一时刻，只允许执行一个线程</p>
<p>多线程：同一时刻，可以执行多个线程，比如：一个QQ进程，可以同时打开多个聊天窗口，一个迅雷进程，可以同时下载多个文件</p>
<p>并发：同一时刻，多个任务交替执行，造成一种“貌似同时”的错觉，简单地说，单核CPU实现的多任务就是并发</p>
<p>并行：同一时刻，多个任务同时执行。多个CPU可以实现并行</p>
<h2 id="线程的基本使用"><a href="#线程的基本使用" class="headerlink" title="线程的基本使用"></a>线程的基本使用</h2><h3 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h3><p>1）继承Thread类，重写run方法</p>
<p>2）实现Runnable接口，实现run方法</p>
<p>​		java是单继承的，在某些情况下一个类可能已经继承了某个父类，这时再用继承Thread类方法来创建线程显然不可能了，需要new Thread()来使用start方法</p>
<p>​		实现Runnable接口方式更加适合多个线程共享一个资源情况，并且避免了单继承的限制，建议使用Runnable</p>
<p>3）线程池创建线程</p>
<h3 id="线程常用方法"><a href="#线程常用方法" class="headerlink" title="线程常用方法"></a>线程常用方法</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220514203110588.png" alt="image-20220514203110588"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220514203153934.png" alt="image-20220514203153934"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220514203305654.png" alt="image-20220514203305654"></p>
<p>用户线程：也叫工作线程，当线程的任务执行完成或通知方式结束</p>
<p>守护线程：一般是为工作线程服务的，当所有的用户线程结束，守护线程自动结束（常见的守护线程：垃圾回收机制）setDaemon()方法</p>
<h2 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h2><p>Thread.State枚举表示了线程的几种状态</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220514204340007.png" alt="image-20220514204340007"></p>
<p><img src="https://uploadfiles.nowcoder.com/images/20180316/8955099_1521189690989_0BB28C2A1ECCC47EC020E89E8A554BBC" alt="img"></p>
<p><strong>TCP客户端：</strong> </p>
<p>1.建立连接套接字，设置Ip和端口监听，socket()</p>
<p>2.建立连接 connect</p>
<p>3.write() 获取网络流对象 发送数据</p>
<p>4.read()获取网络流对象 接收数据</p>
<p>5.关闭套接字</p>
<p><strong>TCP服务器端：</strong></p>
<p>1.建立端口监听 socket()</p>
<p>2.绑定指定端口 bind()</p>
<p>3.listen 进行端口监听</p>
<p>4.accept() 阻塞式 直到有客户端访问</p>
<p>5.read()获取客户端发送数据</p>
<p>6.write()发送返回数据</p>
<p>7.close关闭端口监听</p>
<h2 id="线程的同步"><a href="#线程的同步" class="headerlink" title="线程的同步"></a>线程的同步</h2><h3 id="线程同步机制"><a href="#线程同步机制" class="headerlink" title="线程同步机制"></a>线程同步机制</h3><p> <strong>Synchronized</strong></p>
<p>在多线程编程，一些敏感数据不允许被多个线程同时访问，此时就使用同步访问技术，保证数据在任何同一时刻，最多有一个线程访问，以保证数据的完整性</p>
<p>线程同步：即当有一个线程在内存进行操作时，其他线程都不可以对这个内存地址进行操作，直到该线程完成操作，其他线程才能对该内存地址进行操作</p>
<h3 id="同步具体方法-Synchronized"><a href="#同步具体方法-Synchronized" class="headerlink" title="同步具体方法-Synchronized"></a>同步具体方法-Synchronized</h3><p>1）同步代码块，尽量使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(对象) &#123; <span class="comment">//得到对象的锁，才能操作同步代码块</span></span><br><span class="line">	<span class="comment">//需要被同步代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2）synchronized还可以放在方法声明中，表示整个方法为同步方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">m</span><span class="params">(String name)</span>&#123;</span><br><span class="line">    <span class="comment">//需要被同步的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><p>Java语言中，引入了对象互斥锁的概念，来保证共享数据操作的完整性</p>
<p>每个对象都对应于一个可称为”互斥锁“的标记，这个标记用来保证在任一时刻，只能有一个线程访问该对象</p>
<p>关键字synchronized来与对象的互斥锁联系。当某个对象用synchronized修饰时，表明该对象在任一时刻只能由一个线程访问</p>
<p>同步的局限性：导致程序的执行效率要降低</p>
<p>同步方法(非静态的)的锁可以是this，也可以是其他对象(要求是同一个对象)</p>
<p>同步方法(静态的)的锁为当前类本身</p>
<p>同步方法如果没有使用static修饰：默认锁对象为this，如果使用static修饰，默认锁对象为：当前类.class</p>
<p>要求多个线程的锁对象为同一个即可！</p>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>多个线程都占用了对方的锁资源，但不肯相让，导致了死锁，在编程是一定要避免死锁的发生</p>
<p>释放锁：当前线程的同步方法、同步代码块执行结束</p>
<p>​				当前线程在同步代码块、同步方法中遇到break、return</p>
<p>​				当前线程在同步代码块、同步方法中出现了未处理的Error或Exception，导致异常结束</p>
<p>​				当前线程在同步代码块、同步方法中执行了线程对象的wait()方法，当前线程暂停，并释放锁</p>
<p>不会释放锁：线程执行同步代码块或同步方法时，程序调用Thread.sleep()、Thread.yield()方法暂停当前线程的执行，不会释放锁</p>
<p>​						线程执行同步代码块时，其他线程调用了该线程的suspend()方法将该线程挂起</p>
<h1 id="IO-流"><a href="#IO-流" class="headerlink" title="IO 流"></a>IO 流</h1><h2 id="文件流"><a href="#文件流" class="headerlink" title="文件流"></a>文件流</h2><p>文件在程序中是以流的形式来操作的</p>
<p>流：数据在数据源(文件)和程序(内存)之间经历的路径</p>
<p>输入流：数据从数据源(文件)到程序(内存)的路径</p>
<p>输出流：数据从程序(内存)到数据源(文件)的路径</p>
<h2 id="常见的文件操作"><a href="#常见的文件操作" class="headerlink" title="常见的文件操作"></a>常见的文件操作</h2><p>创建文件相关构造器和方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">File</span>(String pathname)<span class="comment">//根据路径构建一个File对象</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">File</span>(File parent, String child)<span class="comment">//根据父目录文件+子路径构建一个File对象</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">File</span>(String parent, String child)<span class="comment">//根据父目录+子路径构建一个File对象</span></span><br><span class="line">    </span><br><span class="line">creatNewFile <span class="comment">//创建新文件</span></span><br></pre></td></tr></table></figure>

<p>获取文件的相关信息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">getNmae<span class="comment">//文件名字</span></span><br><span class="line">getAbsolutePath<span class="comment">//文件绝对路径</span></span><br><span class="line">getParent<span class="comment">//&quot;文件父级目录</span></span><br><span class="line">length<span class="comment">//文件大小(字节)</span></span><br><span class="line">exists<span class="comment">//文件是否存在</span></span><br><span class="line">isFile<span class="comment">//是不是一个文件</span></span><br><span class="line">isDirectory<span class="comment">//是不是一个目录</span></span><br></pre></td></tr></table></figure>

<p>目录的操作和文件删除</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">makdir<span class="comment">//创建一级目录</span></span><br><span class="line">mkdirs<span class="comment">//创建多级目录</span></span><br><span class="line">delete<span class="comment">//删除空目录或文件</span></span><br></pre></td></tr></table></figure>

<h2 id="IO-流原理及流的分类"><a href="#IO-流原理及流的分类" class="headerlink" title="IO 流原理及流的分类"></a>IO 流原理及流的分类</h2><p><strong>原理</strong></p>
<p>1）I&#x2F;O是Input&#x2F;Output的缩写，I&#x2F;O技术，用于处理数据传输</p>
<p>2）Java程序中，对于数据的输入&#x2F;输出操作以“流(stream)”的方式进行</p>
<p>3）java.io包下提供了各种“流”类和接口，用以获得不同种类的数据，并通过方法输入或输出数据</p>
<p>4）输入input：读取外部数据(磁盘、光盘等存储设备的数据)到程序(内存)中</p>
<p>5）输出output：将程序(内存)数据输出到磁盘、光盘等存储设备中</p>
<p><strong>分类</strong></p>
<p>按操作数据单位不同：字节流(8 bit)二进制文件，字符流(按字符)文本文件</p>
<p>按数据流的流向不同：输入流，输出流</p>
<p>按流的角色不同：节点流，处理流&#x2F;包装流</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220515222537824.png" alt="image-20220515222537824"></p>
<p>1）Java的IO流共涉及40多个类，都是从如上4个抽象基类派生的</p>
<p>2）由这四个类派生出来的子类名称都是以其父类名作为子类名后缀</p>
<h2 id="IO-流体系图"><a href="#IO-流体系图" class="headerlink" title="IO 流体系图"></a>IO 流体系图</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220516122221731.png" alt="image-20220516122221731"></p>
<p><strong>FileOutputSream</strong></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220516142451047.png" alt="image-20220516142451047"></p>
<p> <strong>FileReader 和 FileWriter</strong></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220516142644135.png" alt="image-20220516142644135"></p>
<p><strong>FileReader 相关方法：</strong></p>
<p>new FileReader(File&#x2F;String)</p>
<p>read：每次读取单个字符，返回该字符，如果到文件末尾返回-1</p>
<p>read(Char[])：批量读取多个字符到数组，返回读取到的字符数，如果到文件末尾返回-1</p>
<p>相关API：new String(char[])：将char[]转换成String</p>
<pre><code>             new String(char[], off, len)：将char[]的指定部分转换成String
</code></pre>
<p><strong>FileWriter 相关方法：</strong></p>
<p>new FileWriter(File&#x2F;String)：覆盖模式，相当于流的指针在首端</p>
<p>new FileWriter(File&#x2F;String, true)：追加模式，相当于流的指针在尾端</p>
<p>writer(int)：写入单个字符</p>
<p>writer(char[])：写入指定数组</p>
<p>writer(char[], off, len)：写入指定数组的指定部分</p>
<p>writer(string)：写入整个字符串</p>
<p>writer(string, off, len)：写入字符串的指定部分</p>
<p>FileWriter使用后，必须**关闭(close)或刷新(flush)**，否则写入不到指定文件！</p>
<h2 id="节点流和处理流"><a href="#节点流和处理流" class="headerlink" title="节点流和处理流"></a>节点流和处理流</h2><p>节点流：可以从一个特定的数据源读写数据，如：FileReader、FileWriter</p>
<p>处理流：是连接在已存在的流(节点流或处理流之上)，为程序提供更为强大的读写功能，也更加灵活，如：BufferedReader、BufferedWriter</p>
<p>区别和联系：</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220516145022746.png" alt="image-20220516145022746"></p>
<h2 id="处理流的优点"><a href="#处理流的优点" class="headerlink" title="处理流的优点"></a>处理流的优点</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220516145131925.png" alt="image-20220516145131925"></p>
<h2 id="处理流-BufferedReader和BufferWriter"><a href="#处理流-BufferedReader和BufferWriter" class="headerlink" title="处理流-BufferedReader和BufferWriter"></a>处理流-BufferedReader和BufferWriter</h2><p>属于字符流，是按照字符来读取数据的</p>
<p>关闭时处理流，只需要关闭外层流即可</p>
<h2 id="处理流-BufferedInputStream-和-BufferedOutputStream"><a href="#处理流-BufferedInputStream-和-BufferedOutputStream" class="headerlink" title="处理流-BufferedInputStream 和 BufferedOutputStream"></a>处理流-BufferedInputStream 和 BufferedOutputStream</h2><p>BufferedInputStream 是字节流，在创建 BufferedInputStream 时，会创建一个内部缓冲区数组</p>
<p><strong>BufferedInputStream–&gt;FilterInputStream–&gt;InputStream–&gt;Closeable(接口)</strong></p>
<p><strong>BufferedOutputStream–&gt;FilterOutputStream–&gt;OutputStream–&gt;Closeable和Flushable(接口)</strong></p>
<h2 id="对象流-ObjectInputStream-和-ObjectOutputStrea"><a href="#对象流-ObjectInputStream-和-ObjectOutputStrea" class="headerlink" title="对象流-ObjectInputStream 和 ObjectOutputStrea"></a>对象流-ObjectInputStream 和 ObjectOutputStrea</h2><h3 id="序列和反序列化"><a href="#序列和反序列化" class="headerlink" title="序列和反序列化"></a>序列和反序列化</h3><p>1）序列化就是在保存数据时，保存数据的值和数据类型。</p>
<p>​		将数据结构转换称为二进制数据流或者文本流的过程。序列化后的数据方便在网络上传输和在硬盘上存储。</p>
<p>2）反序列化就是在恢复数据时，恢复数据的值和数据类型</p>
<p>​		与序列化相反，是将二进制数据流或者文本流转换称为易于处理和阅读的数据结构的过程。</p>
<p>3）需要让某个对象支持序列化机制，则必须让其类是可序列化的，为了让某个类是可序列化的，该类必须实现如下两个接口之一：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Serializable <span class="comment">//这是一个标记接口，没有方法</span></span><br><span class="line">   Externalizable <span class="comment">//该接口有方法需要实现，因此一般实现Serializable接口</span></span><br><span class="line">   <span class="comment">//transient关键字的作用，在已实现序列化的类中，有的变量不需要保存在磁盘中，就要transient关键字修饰，如银行卡密码等，</span></span><br><span class="line">   <span class="comment">//就这个作用------在已序列化的类中使变量不序列化，通常一个类实现序列化方式是实现序列化接口 Serializable</span></span><br></pre></td></tr></table></figure>

<p>对象流功能：提供了对基本类型或对象类型的序列化和反序列化的方法 </p>
<p>​						ObjectOutputStream 提供 序列化功能 </p>
<p>​			   		 ObjectInputStream 提供 反序列化功能</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220516201954245.png" alt="image-20220516201954245">			</p>
<p>序列化数据和反序列化恢复数据</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220516201309591.png" alt="image-20220516201309591"></p>
<h2 id="标准输入输出流"><a href="#标准输入输出流" class="headerlink" title="标准输入输出流"></a>标准输入输出流</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220516201438597.png" alt="image-20220516201438597"></p>
<h2 id="转换流-InputStreamReader-和-OutputStreamWriter"><a href="#转换流-InputStreamReader-和-OutputStreamWriter" class="headerlink" title="转换流-InputStreamReader 和 OutputStreamWriter"></a>转换流-InputStreamReader 和 OutputStreamWriter</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220516201634261.png" alt="image-20220516201634261"></p>
<h2 id="打印流-PrintStream-和-PrintWriter"><a href="#打印流-PrintStream-和-PrintWriter" class="headerlink" title="打印流-PrintStream 和 PrintWriter"></a>打印流-PrintStream 和 PrintWriter</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220516201859470.png" alt="image-20220516201859470"></p>
<h1 id="反射-reflection"><a href="#反射-reflection" class="headerlink" title="反射(reflection)"></a>反射(reflection)</h1><p>需求：根据配置文件re.properties指定信息，创建对象并调用方法；即通过外部配置文件，在不修改源码的情况下来控制程序，也符合设计模式的<strong>ocp原则</strong>(<strong>开闭原则</strong>：不修改源码，扩容功能)</p>
<h2 id="反射机制"><a href="#反射机制" class="headerlink" title="反射机制"></a>反射机制</h2><p>1）反射机制允许程序在执行期间借助于Reflection API 获得任何类的内部信息(比如：成员变量、构造器，成员方法等)，并能操作对象的属性及方法。反射在设计模式和框架底层都会用到</p>
<p>2）加载完类之后，在堆中就产生了一个Class类型的对象(一个类只有一个Class对象)，这个对象包含了类的完整结构信息。通过这个对象得到类的结构。</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220517143914000.png" alt="image-20220517143914000"></p>
<p><strong>作用</strong></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220517144131916.png" alt="image-20220517144131916"></p>
<p><strong>反射相关的类</strong></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220517144239805.png" alt="image-20220517144239805"></p>
<h2 id="反射优点和缺点"><a href="#反射优点和缺点" class="headerlink" title="反射优点和缺点"></a>反射优点和缺点</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220517144349140.png" alt="image-20220517144349140"></p>
<h2 id="反射调用优化-关闭访问检查"><a href="#反射调用优化-关闭访问检查" class="headerlink" title="反射调用优化-关闭访问检查"></a>反射调用优化-关闭访问检查</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220517144438188.png" alt="image-20220517144438188"></p>
<h2 id="Class-类"><a href="#Class-类" class="headerlink" title="Class 类"></a>Class 类</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220517144528389.png" alt="image-20220517144528389"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220517144622172.png" alt="image-20220517144622172"></p>
<h3 id="Class-类的常用方法"><a href="#Class-类的常用方法" class="headerlink" title="Class 类的常用方法"></a>Class 类的常用方法</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220517144710973.png" alt="image-20220517144710973"></p>
<h3 id="获取-Class-类对象"><a href="#获取-Class-类对象" class="headerlink" title="获取 Class 类对象"></a>获取 Class 类对象</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220517144936294.png" alt="image-20220517144936294"></p>
<h3 id="哪些类型有-Class-对象"><a href="#哪些类型有-Class-对象" class="headerlink" title="哪些类型有 Class 对象"></a>哪些类型有 Class 对象</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220517145022485.png" alt="image-20220517145022485"></p>
<h2 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220517145152479.png" alt="image-20220517145152479"></p>
<h3 id="类加载时机"><a href="#类加载时机" class="headerlink" title="类加载时机"></a>类加载时机</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220517145228556.png" alt="image-20220517145228556"></p>
<h3 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220517145340270.png" alt="image-20220517145340270"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220517145413669.png" alt="image-20220517145413669"></p>
<h4 id="加载阶段"><a href="#加载阶段" class="headerlink" title="加载阶段"></a>加载阶段</h4><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220517145456333.png" alt="image-20220517145456333"></p>
<h4 id="验证阶段"><a href="#验证阶段" class="headerlink" title="验证阶段"></a>验证阶段</h4><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220517145557852.png" alt="image-20220517145557852"></p>
<h4 id="准备阶段"><a href="#准备阶段" class="headerlink" title="准备阶段"></a>准备阶段</h4><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220517145702581.png" alt="image-20220517145702581"></p>
<h4 id="解析阶段"><a href="#解析阶段" class="headerlink" title="解析阶段"></a>解析阶段</h4><p>虚拟机将常量池中的符号引用替换为直接引用的过程</p>
<h4 id="Initialization（初始化-阶段"><a href="#Initialization（初始化-阶段" class="headerlink" title="Initialization（初始化) 阶段"></a>Initialization（初始化) 阶段</h4><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220517145853355.png" alt="image-20220517145853355"></p>
<h2 id="通过反射获取类的结构信息"><a href="#通过反射获取类的结构信息" class="headerlink" title="通过反射获取类的结构信息"></a>通过反射获取类的结构信息</h2><h3 id="java-lang-Class类"><a href="#java-lang-Class类" class="headerlink" title="java.lang.Class类"></a>java.lang.Class类</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220517150019387.png" alt="image-20220517150019387"></p>
<h3 id="java-lang-reflect-Field-类"><a href="#java-lang-reflect-Field-类" class="headerlink" title="java.lang.reflect.Field 类"></a>java.lang.reflect.Field 类</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220517150106804.png" alt="image-20220517150106804"></p>
<h3 id="java-lang-reflect-Method-类"><a href="#java-lang-reflect-Method-类" class="headerlink" title="java.lang.reflect.Method 类"></a>java.lang.reflect.Method 类</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220517150208171.png" alt="image-20220517150208171"></p>
<h3 id="java-lang-reflect-Constructor-类"><a href="#java-lang-reflect-Constructor-类" class="headerlink" title="java.lang.reflect.Constructor 类"></a>java.lang.reflect.Constructor 类</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220517150233977.png" alt="image-20220517150233977"></p>
<h2 id="通过反射创建对象"><a href="#通过反射创建对象" class="headerlink" title="通过反射创建对象"></a>通过反射创建对象</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220517150326870.png" alt="image-20220517150326870"></p>
<h2 id="通过反射访问类中的成员"><a href="#通过反射访问类中的成员" class="headerlink" title="通过反射访问类中的成员"></a>通过反射访问类中的成员</h2><h3 id="访问属性"><a href="#访问属性" class="headerlink" title="访问属性"></a>访问属性</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220517150407163.png" alt="image-20220517150407163"></p>
<h3 id="访问方法"><a href="#访问方法" class="headerlink" title="访问方法"></a>访问方法</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220517150431898.png" alt="image-20220517150431898"></p>
<h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><p>处理文本的利器，是对字符串执行模式匹配的技术</p>
<p>一个正则表达式，就是用某种模式去匹配字符串的一个公式</p>
<p>注：在Java正则表达式中，两个\\代表其它语言中的一个\</p>
<h2 id="正则表达式底层实现"><a href="#正则表达式底层实现" class="headerlink" title="正则表达式底层实现"></a>正则表达式底层实现</h2><p>1）创建一个<strong>Pattern模式对象</strong>，即正则表达式对象；</p>
<p>2）创建一个<strong>matcher匹配器对象</strong>，按照pattern(模式)，到字符串中去匹配；</p>
<p>3）找到后，将子字符串的开始的索引记录到 matcher 对象的属性 grops[0]，把该子字符串的结束的索引+1 的值记录到 groups[1]；</p>
<p>4）同时记录 oldLast 的值为子字符串的结束的索引 +1 的值即 groups[1]，即下次执行 find 时，就从此开始匹配；</p>
<h3 id="matcher-group-0-分析"><a href="#matcher-group-0-分析" class="headerlink" title="matcher.group(0) 分析"></a>matcher.group(0) 分析</h3><p>根据 groups[0] 和 groups[1] 的记录的位置，从字符串中开始截取子字符串返回，就是 [groups[0], groups[1]) 包含groups[0] 但是不包</p>
<p>含索引为groups[1]的位置</p>
<p><strong>有分组</strong>：将子字符串的开始的索引记录到 matcher 对象的属性 grops[0]，把该子字符串的结束的索引+1 的值记录到 groups[1]</p>
<p>​				记录第一个分组匹配到的字符串 groups[2] ，groups[3]为开始和结束+1的索引值</p>
<pre><code>            记录第二个分组匹配到的字符串 groups[4]，groups[5]为开始和结束+1的索引值
</code></pre>
<p>​				如果有更多的分组以此类推</p>
<p>​				group(0) 表示匹配到的子字符串</p>
<p>​				group(1) 表示匹配到的子字符串的第一组字串 </p>
<p>​				group(2) 表示匹配到的子字符串的第二组字串</p>
<p><strong>matches</strong>方法：用于整体匹配，在验证输入的字符串是否满足条件使用，返回ture或false</p>
<h2 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h2><h3 id="mysql中的模糊查询"><a href="#mysql中的模糊查询" class="headerlink" title="mysql中的模糊查询"></a>mysql中的模糊查询</h3><p><code>%</code>: 匹配0个或者多个任意字符</p>
<p><code>_</code>: 匹配任意一个字符</p>
<h3 id="转义号"><a href="#转义号" class="headerlink" title="转义号"></a>转义号</h3><p>使用正则表达式去检索某些特殊字符的时候，需要用到转移符号</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220518220453765.png" alt="image-20220518220453765"></p>
<h3 id="限定符"><a href="#限定符" class="headerlink" title="限定符"></a>限定符</h3><p>用于指定其前面的字符和组合项连续出现多少次</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220518153708550.png" alt="image-20220518153708550"></p>
<h3 id="选择匹配符"><a href="#选择匹配符" class="headerlink" title="选择匹配符"></a>选择匹配符</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220518153639621.png" alt="image-20220518153639621"></p>
<h3 id="分组组合和反向引用符"><a href="#分组组合和反向引用符" class="headerlink" title="分组组合和反向引用符"></a>分组组合和反向引用符</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220518154036309.png" alt="image-20220518154036309"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220518154102247.png" alt="image-20220518154102247"></p>
<h3 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h3><h3 id="字符匹配符"><a href="#字符匹配符" class="headerlink" title="字符匹配符"></a>字符匹配符</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220518153246607.png" alt="image-20220518153246607"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220518153258920.png" alt="image-20220518153258920"></p>
<p>\s：匹配任何空白字符，包括空格、制表符、换页符等。与[\f\n\r\t\v]等效</p>
<p>\S：匹配任何非空白字符</p>
<h3 id="定位符"><a href="#定位符" class="headerlink" title="定位符"></a>定位符</h3><p>规定要匹配的字符串出现的位置，比如在字符串的开始还是在结束的位置</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220518153948293.png" alt="image-20220518153948293"></p>
<h2 id="常用类-1"><a href="#常用类-1" class="headerlink" title="常用类"></a>常用类</h2><h3 id="Pattern类"><a href="#Pattern类" class="headerlink" title="Pattern类"></a>Pattern类</h3><p>pattern对象是一个正则表达式对象，Pattern类没有公共构造方法，要创建一个Pattern对象，调用其公共静态方法，它返回一个Pattern对象，该方法接收一个正则表达式作为他的第一个参数</p>
<h3 id="Matcher类"><a href="#Matcher类" class="headerlink" title="Matcher类"></a>Matcher类</h3><p>是对输入字符串进行解释和匹配的引擎。与Pattern类一样，Matcher也没有公共构造方法，需要调用Pattern对象的matcher方法获得一个Mather对象</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220519153616879.png" alt="image-20220519153616879"></p>
<h3 id="PatternSyntaxException类"><a href="#PatternSyntaxException类" class="headerlink" title="PatternSyntaxException类"></a>PatternSyntaxException类</h3><p>非强制异常类，表示一个正则表达式模式中的语法错误0</p>
<h2 id="分组、捕获、反向引用"><a href="#分组、捕获、反向引用" class="headerlink" title="分组、捕获、反向引用"></a>分组、捕获、反向引用</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220519154550603.png" alt="image-20220519154550603">	</p>
<h1 id="Lamda-表达式"><a href="#Lamda-表达式" class="headerlink" title="Lamda 表达式"></a>Lamda 表达式</h1><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><p><strong>(args1, args2,…) -&gt; { <a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=express&spm=1001.2101.3001.7020">express</a> block }</strong></p>
<p>lamda表达式由两部分组成：<strong>参数和语句块</strong>，参数可以不写参数类型也可以写参数类型，如果写参数类型，必须与对应方法的参数类型一致，</p>
<p><strong>如果只有一个参数，可以省略小括号()<strong>；语句块中如果只有一条语句，</strong>可以省略大括号{ }和return关键字</strong>。</p>
<p><strong>lamda表达式只支持函数式接口，函数式接口就是只有一个抽象方法的接口</strong>，例如Runnable</p>
<p>避免匿名<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%86%85%E9%83%A8%E7%B1%BB&spm=1001.2101.3001.7020">内部类</a>定义过多</p>
<p>可以让你的代码看起来很简洁</p>
<p>去掉了一堆没有意义的代码，留下核心的逻辑</p>
<p>其实质属于<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B&spm=1001.2101.3001.7020">函数式编程</a>的概念</p>
<h1 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h1><h2 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h2><p>两个区域A和B，初始对象在A，继续存活的对象被转移到B。此为新生代最常用的算法</p>
<h2 id="标记清理算法"><a href="#标记清理算法" class="headerlink" title="标记清理算法"></a>标记清理算法</h2><p>一块区域，标记可达对象（可达性分析），然后回收不可达对象，会出现碎片，那么引出标记-整理算法：多了碎片整理，整理出更大的内存放更大的对象</p>
<p>两个概念：<strong>新生代和年老代</strong></p>
<p>新生代：初始对象，生命周期短的</p>
<p>永久代：长时间存在的对象</p>
<p>整个java的垃圾回收是新生代和年老代的协作，这种叫做分代回收。</p>
<p>Serial New收集器是针对新生代的收集器，采用的是复制算法</p>
<p>Parallel New（并行）收集器，新生代采用复制算法，老年代采用标记整理</p>
<p>Parallel Scavenge（并行）收集器，针对新生代，采用复制收集算法</p>
<p>Serial Old（串行）收集器，新生代采用复制，老年代采用标记整理</p>
<p>Parallel Old（并行）收集器，针对老年代，标记整理</p>
<p>CMS收集器，基于标记清理</p>
<p>G1收集器：整体上是基于标记 整理 ，局部采用复制</p>
<p><strong>综上：新生代基本采用复制算法，老年代采用标记整理算法。cms采用标记清理。</strong></p>
<h1 id="委托事件模型"><a href="#委托事件模型" class="headerlink" title="委托事件模型"></a>委托事件模型</h1><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/cac99c0f172b">https://www.jianshu.com/p/cac99c0f172b</a></p>
<h1 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h1><h2 id="网络的相关概念"><a href="#网络的相关概念" class="headerlink" title="网络的相关概念"></a>网络的相关概念</h2><h3 id="网络通信"><a href="#网络通信" class="headerlink" title="网络通信"></a>网络通信</h3><p>两台设备之间通过网络实现数据传输&#x2F;将数据通过网络从一台设备传输到另一台设备</p>
<p>java.net包下提供了一系列的类或接口，供程序员使用，完成网络通信</p>
<h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><p>两台或多台设备通过一定物理设备连接起来构成了网络</p>
<p>根据网络的覆盖范围进行分类：</p>
<p>1）局域网：覆盖范围小，仅仅覆盖一个教室或一个机房</p>
<p>2）城域网：覆盖范围较大，可以覆盖一个城市</p>
<p>3）广域网：覆盖范围最大，可以覆盖全国，甚至全球，万维网是广域网的代表</p>
<h3 id="ip-地址"><a href="#ip-地址" class="headerlink" title="ip 地址"></a>ip 地址</h3><p>用以标识网络中的每一台主机&#x2F;计算机</p>
<p>查看IP地址：ipconfig</p>
<p>ip地址的表示形式：点分十进制 xx.xx.xx.xx</p>
<p>每一个十进制数的范围：0-255</p>
<p>ip地址的组成：网络地址+主机地址</p>
<p>ipv4的网络地址资源有限，严重制约了互联网的应用和发展，ipv6的使用，不仅能解决网络地址资源数量的问题，而且也解决了多种接入设备连入互联网的障碍</p>
<h3 id="ipv4地址分类"><a href="#ipv4地址分类" class="headerlink" title="ipv4地址分类"></a>ipv4地址分类</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220519170200444.png" alt="image-20220519170200444"></p>
<h3 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h3><p>好处：为了方便记忆，解决记ip的困难</p>
<p>概念：将ip地址映射成域名，HTTP</p>
<p><strong>端口号：</strong>用于标识计算机上某个特定的网络程序</p>
<p>​				以整数形式，端口范围：0-65535[两个字节表示端口]</p>
<p>​				0-1024已经被占用，比如：ssh 22,  ftp 21,  smtp 25,  http 80</p>
<p>​				常见的网络程序端口号：tomcat:8080</p>
<p>​															mysql:3306</p>
<p>​															oracle:1521</p>
<p>​															sqlserver:1433</p>
<h3 id="网络通信协议"><a href="#网络通信协议" class="headerlink" title="网络通信协议"></a>网络通信协议</h3><p>TCP&#x2F;IP：传输控制协议，由网络层的IP协议和传输层的TCP协议组成</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220519172516839.png" alt="image-20220519172516839"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220519172535187.png" alt="image-20220519172535187"></p>
<h2 id="InetAddress-类"><a href="#InetAddress-类" class="headerlink" title="InetAddress 类"></a>InetAddress 类</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220519172610171.png" alt="image-20220519172610171"></p>
<h2 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220519172647626.png" alt="image-20220519172647626"></p>
<h2 id="TCP-网络通信编程"><a href="#TCP-网络通信编程" class="headerlink" title="TCP 网络通信编程"></a>TCP 网络通信编程</h2><p>基于客户端—服务端的网络通信</p>
<p>底层使用的是TCP&#x2F;IP协议</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220519172850090.png" alt="image-20220519172850090"></p>
<h3 id="netstat-指令"><a href="#netstat-指令" class="headerlink" title="netstat 指令"></a>netstat 指令</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220519172954362.png" alt="image-20220519172954362"></p>
<p>-Xms1G -Xmx2G -Xmn500M -XX:MaxPermSize&#x3D;64M -XX:+UseConcMarkSweepGC -XX:SurvivorRatio&#x3D;3,</p>
<p>-Xms：1G ， 就是说初始堆大小为1G<br>-Xmx：2G ， 就是说最大堆大小为2G<br>-Xmn：500M ，就是说年轻代大小是500M（包括一个Eden和两个Survivor）<br>-XX:MaxPermSize：64M ， 就是说设置持久代最大值为64M<br>-XX:+UseConcMarkSweepGC ， 就是说使用使用CMS内存收集算法<br>-XX:SurvivorRatio&#x3D;3 ， 就是说Eden区与Survivor区的大小比值为3：1：1</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-计算机网络：IP服务"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
	
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/08/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%9AIP%E6%9C%8D%E5%8A%A1/"
    >IP服务</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/08/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%9AIP%E6%9C%8D%E5%8A%A1/" class="article-date">
  <time datetime="2022-08-11T13:33:16.000Z" itemprop="datePublished">2022-08-11</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">计算机基础知识</a> / <a class="article-category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="IP基础知识"><a href="#IP基础知识" class="headerlink" title="IP基础知识"></a>IP基础知识</h1><h2 id="IP概念"><a href="#IP概念" class="headerlink" title="IP概念"></a>IP概念</h2><p>IP是英文 Internet Protocol的缩写，意思是<strong>“网络之间互连的协议”</strong>，也就是为计算机网络相互连接进行通信而设计的协议。在因特网中，它是能使连接到网上的所有计算机网络实现相互通信的一套规则，规定了计算机在因特网上进行通信时应当遵守的规则。</p>
<h2 id="IP作用"><a href="#IP作用" class="headerlink" title="IP作用"></a>IP作用</h2><p>IP位于TCP&#x2F;IP参考模型的第三层网络层，实现主机与主机之间的点对点通信，例：</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220811213511120.png" alt="image-20220811213511120"></p>
<h2 id="IP与MAC地址"><a href="#IP与MAC地址" class="headerlink" title="IP与MAC地址"></a>IP与MAC地址</h2><ol>
<li>IP负责在没有直连的两个网络之间进行数据通信</li>
<li>MAC负责实现直连的两个设备之间的通信</li>
</ol>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220811213733503.png" alt="image-20220811213733503"></p>
<p><strong>区别</strong>：</p>
<ol>
<li>MAC地址的长度为48位（6个字节）；而IP地址为32位。</li>
<li>MAC地址应用在OSI第二层，即数据链路层；IP地址应用于OSI第三层，即网络层。</li>
<li>MAC地址的分配是基于制造商；IP地址的分配是基于网络拓朴。</li>
</ol>
<h2 id="IP地址的构成"><a href="#IP地址的构成" class="headerlink" title="IP地址的构成"></a>IP地址的构成</h2><ul>
<li><p>IP地址（IPv4）由<strong>32bit二进制</strong>组成，使用<strong>点分十进制</strong>表示，<strong>8个bit为一组，共4组，使用点分割</strong>，大概支持43亿设备连接，如：</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220811213938970.png" alt="image-20220811213938970"></p>
</li>
<li><p>实际IP地址是以<strong>网卡</strong>为标准进行配置</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220811214028305.png" alt="image-20220811214028305"></p>
</li>
</ul>
<h2 id="IP地址的分类"><a href="#IP地址的分类" class="headerlink" title="IP地址的分类"></a>IP地址的分类</h2><ul>
<li>IP地址 &#x3D; <strong>网络号（网段地址）+主机号（主机地址）</strong></li>
<li>网络号：设备所在区域的唯一标识，网络号相同的设备允许相互通信</li>
<li>主机号：同一网段中不同设备的唯一标识，不允许重复</li>
<li>IP地址共分为5类：A类、B类、C类、D类、E类，如：</li>
</ul>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220811214353778.png" alt="image-20220811214353778"></p>
<p><strong>地址的第一个字段的十进制值</strong></p>
<p><strong>主机数</strong> &#x3D; 2的主机号位数的次方-2（全0和全1）</p>
<ul>
<li>A类：1-126 ，16777214台主机，如：10.1.2.3，A类地址的范围为：<strong>1.0.0.1-126.255.255.254</strong></li>
<li>B类：128-191，65534  台主机，如：144.12.3.77，B类IP地址的范围：<strong>128.0.0.1-191.255.255.254</strong></li>
<li>C类：192-223，254台主机，如：192.168.1.1，C类IP地址的范围：<strong>192.0.0.1-223.255.255.254</strong></li>
</ul>
<h2 id="特殊IP地址"><a href="#特殊IP地址" class="headerlink" title="特殊IP地址"></a>特殊IP地址</h2><h3 id="网络地址"><a href="#网络地址" class="headerlink" title="网络地址"></a>网络地址</h3><p><strong>作用</strong>：标识网络唯一位置及名称</p>
<p><strong>计算</strong>：网络地址 &#x3D; <strong>网络号+0</strong> 组成</p>
<p><strong>例1</strong>：ip&#x3D;192.168.1.125  C类  net：host  3:1  网络地址&#x3D;192.168.1.0</p>
<p><strong>例2</strong>：ip&#x3D;16.1.3.8  A类  net：host  1:3  网络地址&#x3D;16.0.0.0</p>
<p><strong>注意</strong>：网络地址不同的设备不能相互通信</p>
<h3 id="广播地址"><a href="#广播地址" class="headerlink" title="广播地址"></a>广播地址</h3><ol>
<li><strong>本地广播</strong>：用于同一个链路中相互连接的主机之间发送数据包</li>
</ol>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220811220224427.png" alt="image-20220811220224427"></p>
<p>本地广播地址通过 <strong>255.255.255.255</strong> 发送</p>
<ol start="2">
<li><strong>直接广播地址</strong>：在不同网路之间进行的广播，<strong>对方的IP网络号+255</strong>，如：</li>
</ol>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220811220325855.png" alt="image-20220811220325855"></p>
<ol start="3">
<li><strong>多播地址</strong>：将数据包发送给网络中<strong>特定组</strong>的所有主机，如：</li>
</ol>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/wps3.jpg" alt="img"> </p>
<p><strong>多播</strong>使用<strong>D类地址</strong>，从 <strong>224.0.0.0~239.255.255.255</strong> 范围内进行多播，<strong>划分为三类</strong>：</p>
<ul>
<li><p>224.0.0.0~224.0.0.255  预留的组播地址，只能用于局域网LAN中，路由器不转发</p>
</li>
<li><p>224.0.1.0~238.255.255.255  组播地址，用于 internet</p>
</li>
<li><p>239.0.0.0~239.255.255.255  为本地管理组播地址预留，供网络内部使用</p>
</li>
</ul>
<h3 id="回环地址"><a href="#回环地址" class="headerlink" title="回环地址"></a>回环地址</h3><p>同一台计算机内的程序之间进行网络通信时使用的默认地址，使用<strong>127.0.0.1</strong>作为标准默认回环地址，与回环地址具有相同意义的主机名称为 <strong>localhost</strong>，使用该ip及主机名时，数据包不会流向网络</p>
<h3 id="本地IP地址"><a href="#本地IP地址" class="headerlink" title="本地IP地址"></a>本地IP地址</h3><p><strong>作用</strong>：本地LAN内部使用的IP地址</p>
<p><strong>区间</strong>：<strong>192.168.x.x</strong>  或  <strong>10.x.x.x</strong></p>
<h2 id="IP地址的优缺点"><a href="#IP地址的优缺点" class="headerlink" title="IP地址的优缺点"></a>IP地址的优缺点</h2><p><strong>优点</strong>：简单明了，使用方便</p>
<p><strong>缺点</strong>：</p>
<ol>
<li>同一个网络下没有层次划分，缺少灵活性</li>
<li>不能很好的与现实网络匹配</li>
</ol>
<h2 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h2><ul>
<li><p><strong>组成</strong>：与IP地址相同，<strong>32bit</strong>组成，<strong>点分十进制</strong>表示，如：255.255.255.0</p>
</li>
<li><p>子网掩码中<strong>0</strong>映射的IP地址表示<strong>主机</strong>，<strong>1</strong>映射的IP地址表示<strong>网络</strong>：</p>
<p>ip：192.168.1. 234</p>
<p>netmask： 255. 255.255.0</p>
</li>
<li><p><strong>作用</strong></p>
<ol>
<li><p><strong>网络地址与主机地址分离</strong>：<strong>网络地址 &#x3D; IP 地址 AND 子网掩码</strong> ，例：</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220812161326619.png" alt="image-20220812161326619"></p>
<p>​      192.168.129.10  1100 0000    0000 1010</p>
<p>&amp;   255.255.255.0     1111 1111   0000 0000</p>
<p>net：192.168.129.0</p>
</li>
<li><p><strong>子网划分</strong></p>
</li>
</ol>
</li>
<li><p><strong>子网划分</strong></p>
<ol>
<li><p>IP地址 &#x3D; <strong>网络号 + （子网地址 + 子网主机号）</strong></p>
</li>
<li><p>默认子网掩码：<strong>A类 255.0.0.0   B类 255.255.0.0  C类 255.255.255.0</strong></p>
</li>
<li><p>子网划分原则：<strong>子网掩码二进制状态下将表示主机的0更改为1，原来表示主机的数据现在表示子网，</strong>如：</p>
<p>255.255.255.0   1111 1111  1111 1111  1111 1111  00 00 0000</p>
<p>改为：255.255.255.192  1111 1111  1111 1111  1111 1111  11 00 0000</p>
<p>1111 1111  1111 1111  1111 1111表示网络号，11表示子网号，00 0000表示主机号     </p>
</li>
<li><p>例1：有网络地址192.168.1.0 ，子网掩码为255.255.255.192，分析网络构成：</p>
<ul>
<li><p>第一点：划分几个子网：<strong>2的n次方</strong>    n：子网掩码的<strong>0变为1的个数</strong>，当前示例：2的2次方 -&gt; 4 个子网</p>
</li>
<li><p>第二点：每个子网的合法主机数：<strong>2的n次方-2</strong>  n：子网掩码中<strong>剩余0的个数</strong>，当前示例：2的6次方-2 -&gt; 62 台</p>
</li>
<li><p>第三点：每个合法的子网号：</p>
<p>ip：   1111 1111  1111 1111  1111 1111  xx xx xxxx</p>
<p>netmask  1111 1111  1111 1111  1111 1111  11 00 0000   </p>
<p>2个1  则IP地址最后一个字节的可能数据：  </p>
<ol>
<li><strong>00</strong> 00 0000 -&gt;  <strong>0</strong></li>
<li><strong>01</strong> 00 0000 -&gt;  <strong>64</strong></li>
<li><strong>10</strong> 00 0000 -&gt;  <strong>128</strong></li>
<li><strong>11</strong> 00 0000 -&gt;  <strong>192</strong></li>
</ol>
<p><strong>合法的子网号</strong>：</p>
<ol>
<li>192.168.1.0</li>
<li>192.168.1.64</li>
<li>192.168.1.128</li>
<li>192.168.1.192</li>
</ol>
</li>
<li><p>第四点：每个子网的广播地址：<strong>下一子网号-1</strong></p>
<ol>
<li>第一个子网广播地址：192.168.1.63</li>
<li>第二个子网广播地址：192.168.1.127</li>
<li>第三个子网广播地址：192.168.1.191</li>
<li>第四个子网广播地址：192.168.1.255</li>
</ol>
</li>
<li><p>第五点：每个子网合法的主机号范围：掐头去尾</p>
<ol>
<li>第一个子网主机地址：192.168.1.1~192.168.1.62</li>
<li>第二个子网主机地址：192.168.1.65~192.168.1.126</li>
<li>第三个子网主机地址：192.168.1.129~192.168.1.190</li>
<li>第四个子网主机地址：192.168.1.193~192.168.1.254</li>
</ol>
</li>
</ul>
</li>
<li><p>例2：有网络地址192.168.1.0 ， 子网掩码为255.255.255.240，分析网络构成：</p>
<p>子网掩码的二进制表示：1111 1111  1111 1111  1111 1111  1111 0000</p>
<ul>
<li><p>第一点：划分几个子网：<strong>2的n次方</strong>    n：子网掩码的<strong>0变为1的个数</strong>，当前示例：2的4次方 -&gt; 16 个子网</p>
</li>
<li><p>第二点：每个子网的合法主机数：<strong>2的n次方-2</strong>  n：子网掩码中<strong>剩余0的个数</strong>，当前示例：2的4次方-2 -&gt; 14 台</p>
</li>
<li><p>第三点：每个合法的子网号：</p>
<p>ip：   1111 1111  1111 1111  1111 1111  xx xx xxxx</p>
<p>netmask  1111 1111  1111 1111  1111 1111  1111 0000   </p>
<p>2个1  则IP地址最后一个字节的可能数据：  </p>
<ol>
<li><strong>0000</strong> 0000 -&gt;  <strong>0</strong></li>
<li>0001 0000 -&gt;  <strong>16</strong></li>
<li>0010 0000 -&gt;  <strong>32</strong></li>
<li>0011 0000 -&gt;  <strong>48</strong></li>
<li>0100 0000 -&gt;  <strong>64</strong></li>
<li>0101 0000 -&gt;  <strong>80</strong></li>
<li>0110 0000 -&gt;  <strong>96</strong></li>
<li>0111 0000 -&gt;  <strong>112</strong></li>
<li>1000 0000 -&gt;  <strong>128</strong></li>
<li>1001 0000 -&gt;  <strong>144</strong></li>
<li>1010 0000 -&gt;  <strong>160</strong></li>
<li>1011 0000 -&gt;  <strong>176</strong></li>
<li>1100 0000 -&gt;  <strong>192</strong></li>
<li>1101 0000 -&gt;  <strong>208</strong></li>
<li>1110 0000 -&gt;  <strong>224</strong></li>
<li>1111 0000 -&gt;  <strong>240</strong></li>
</ol>
<p><strong>合法的子网号</strong>：</p>
<ol>
<li>192.168.1.0</li>
<li>192.168.1.16</li>
<li>192.168.1.32</li>
<li>192.168.1.48</li>
<li>192.168.1.64</li>
<li>192.168.1.80</li>
<li>192.168.1.96</li>
<li>192.168.1.112</li>
<li>192.168.1.128</li>
<li>192.168.1.144</li>
<li>192.168.1.160</li>
<li>192.168.1.176</li>
<li>192.168.1.192</li>
<li>192.168.1.208</li>
<li>192.168.1.224</li>
<li>192.168.1.240</li>
</ol>
</li>
<li><p>第四点：每个子网的广播地址：<strong>下一子网号-1</strong></p>
<ol>
<li>第一个子网广播地址：192.168.1.15</li>
<li>第二个子网广播地址：192.168.1.31</li>
<li>第三个子网广播地址：192.168.1.47</li>
<li>第四个子网广播地址：192.168.1.63   </li>
<li>第五个子网广播地址：192.168.1.79 </li>
<li>第六个子网广播地址：192.168.1.95  </li>
<li>第七个子网广播地址：192.168.1.111  </li>
<li>第八个子网广播地址：192.168.1.127  </li>
<li>第九个子网广播地址：192.168.1.143 </li>
<li>第十个子网广播地址：192.168.1.159  </li>
<li>第十一个子网广播地址：192.168.1.175  </li>
<li>第十二个子网广播地址：192.168.1.191  </li>
<li>第十三个子网广播地址：192.168.1.207  </li>
<li>第十四个子网广播地址：192.168.1.223 </li>
<li>第十五个子网广播地址：192.168.1.239  </li>
<li>第十六个子网广播地址：192.168.1.255</li>
</ol>
</li>
<li><p>第五点：每个子网合法的主机号范围：掐头去尾</p>
<ol>
<li>第一个子网主机地址：192.168.1.1~192.168.1.14</li>
<li>第二个子网主机地址：192.168.1.17~192.168.1.30</li>
<li>第三个子网主机地址：192.168.1.33~192.168.1.46</li>
<li>第四个子网主机地址：192.168.1.49~192.168.1.62</li>
</ol>
</li>
</ul>
</li>
</ol>
</li>
<li><p>子网掩码精简表示法</p>
<ul>
<li>结构：<strong>IP地址&#x2F;子网掩码二进制中1个数</strong></li>
<li>例：192.168.1.0&#x2F;24   24表示子网掩码有24个1，一共32位，剩余位0，则十进制：255.255.255.0</li>
</ul>
</li>
</ul>
<h2 id="公有IP与私有IP"><a href="#公有IP与私有IP" class="headerlink" title="公有IP与私有IP"></a>公有IP与私有IP</h2><ol>
<li>公有IP地址是由固定组织部门统一分配，互联网范围中必须唯一</li>
<li>私有IP地址是在LAN中自行分配使用，可以重复</li>
<li>公有IP地址是由ICANN（互联网名称与数字地址分配机构）组织下的IANA负责分配互联网的IP地址，按照洲划分，中国是由CNNIC机构管理，如：</li>
</ol>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220812171751467.png" alt="image-20220812171751467"></p>
<h2 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h2><ul>
<li><p>原因：IPv4是32位，提供的地址数量不足</p>
</li>
<li><p>IPv6地址是<strong>128bit二进制</strong>组成，以<strong>16位一组</strong>，每组使用<strong>冒号</strong>分割，若出现连续的0，可以省略并用两个冒号隔开（一个IP地址<strong>只允许出现一次2个连续的冒号</strong>），如： fe80::22da:22ff:fe7a:2a87</p>
</li>
<li><p>特点</p>
<ol>
<li><p>IPV4与IPv6 不能兼容</p>
</li>
<li><p>IPv6可以自动分配IP地址，不需要DHCP服务器支持，实现即插即用</p>
</li>
<li><p>IPv6数据包的包头采用固定的40字节长度，去掉了包头校验等简化了包头结构，减轻了路由器的符合，提高传输速度</p>
</li>
<li><p>IPv6地址：单播地址（一对一）、组播地址（一对多）、任播地址  ，<strong>没有广播地址</strong>，如：</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220812172124299.png" alt="image-20220812172124299"></p>
</li>
</ol>
</li>
</ul>
<h2 id="IP的分片与重组"><a href="#IP的分片与重组" class="headerlink" title="IP的分片与重组"></a>IP的分片与重组</h2><ul>
<li><p>原因：由于数据链路层到达的目的不同，且每种链路最大的传输单元不同，则导致IP数据报发送时需要分片接收时需要重组</p>
</li>
<li><p>MTU：数据链路层的最大传输单元，如图：</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220812172222213.png" alt="image-20220812172222213"></p>
</li>
<li><p>重组：IP数据报在目的主机完成片段重组，可能出现乱序、丢失的现象，路由器不负责重组，如：</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220812172232200.png" alt="image-20220812172232200"></p>
</li>
</ul>
<h2 id="IP地址与路由控制"><a href="#IP地址与路由控制" class="headerlink" title="IP地址与路由控制"></a>IP地址与路由控制</h2><ul>
<li><p>路由转发原理：IP数据报到达路由器时，路由器根据数据报的目的地址来查询<strong>路由表</strong>，根据查询结果将数据报转发给下一投递路径，该过程称为<strong>IP路由</strong></p>
</li>
<li><p>分析：</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220812173524457.png" alt="image-20220812173524457"></p>
<ol>
<li>主机A将IP数据报发送给直连路由器1</li>
<li>路由器1收到后，计算目的地址的网络地址拿到路由表中查询，得到转发结果为：10.1.0.2即路由器2</li>
<li>路由器2收到后，查询路由表找到匹配项，最终转发给目的主机10.1.2.1，结束通信</li>
</ol>
</li>
<li><p>路由表</p>
<ul>
<li><p>路由表记录IP数据报在下一跳应该转发的地址</p>
</li>
<li><p>跳：Hop，它是网络的一个区间，IP数据报在网络中跳跃转发，在每一个区间决定IP数据报的下一条路径即为<strong>路由算法</strong>，图：</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220812174402267.png" alt="image-20220812174402267"></p>
</li>
<li><p>路由表生成方式有两种，一种为手动设置即<strong>静态路由</strong>，另一种为路由器之间通过交换信息自行刷新的称为<strong>动态路由（OSPF）</strong></p>
</li>
</ul>
</li>
</ul>
<h2 id="ARP（Address-Resolution-Protocol）"><a href="#ARP（Address-Resolution-Protocol）" class="headerlink" title="ARP（Address Resolution Protocol）"></a>ARP（Address Resolution Protocol）</h2><ul>
<li><p>作用：将IP地址解析为MAC地址</p>
</li>
<li><p>工作原理：</p>
<ol>
<li><p>ARP请求：主机通过广播发送ARP请求，如：</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220812175018391.png" alt="image-20220812175018391"></p>
</li>
<li><p>ARP响应：当链路中所有设备收到ARP请求后，会拆开ARP请求包，若其中目的IP与自己IP相同则就将本机的MAC地址塞入ARP响应包中返回给发送方主机，图：</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220812175118344.png" alt="image-20220812175118344"></p>
</li>
<li><p>更新ARP缓存表：主机A收到ARP响应包后将主机C的IP地址与MAC地址记录到ARP缓存表中，下次在发送数据时，直接读取缓存信息</p>
</li>
</ol>
</li>
<li><p>查询命令：arp  -a</p>
</li>
<li><p>RARP：将已知MAC地址转为IP地址</p>
</li>
</ul>
<h2 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h2><ul>
<li><p>作用：用来确认网络设备位置的位址</p>
</li>
<li><p>组成：使用<strong>48bit二进制</strong>组成，十六进制表示，使用横杠作为间隔符，两两一组，如：20-da-22 - 7a-2a-87，其中，20-da-22为厂商识别码  7a-2a-87为内部识别码，IP地址的分配基于网络的拓扑结构，而MAC地址的分配基于制造商。</p>
</li>
<li><p>MAC地址直接写入（烧录）在网卡的rom芯片中，只读属性，原则上不可修改，用于LAN中<strong>表示目的设备位置</strong></p>
</li>
</ul>
<h2 id="DNS域名解析"><a href="#DNS域名解析" class="headerlink" title="DNS域名解析"></a>DNS域名解析</h2><ul>
<li><p>作用：</p>
<ol>
<li>域名管理</li>
<li>域名解析：将域名网址转换为IP地址</li>
</ol>
</li>
<li><p><strong>域名管理</strong></p>
<ol>
<li><p>使用<strong>层级关系</strong>管理组织域名系统</p>
</li>
<li><p>地址名称解释： http:&#x2F;&#x2F; www . baidu . com &#x2F; index.html。其中，http:为协议名，www . baidu . com为域名，index.html为目录及文件名+</p>
</li>
<li><p>域名中<strong>越靠右侧的域名级别越高</strong></p>
</li>
<li><p><strong>最右侧为根域</strong>即顶层，使用树状组织关系：如：com 商业组织   gov  政府部门  edu  教育机构  cn  中国  </p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220812195923996.png" alt="image-20220812195923996"></p>
</li>
</ol>
</li>
<li><p><strong>域名解析</strong></p>
</li>
</ul>
<ol>
<li>作用：由于域名对于使用者来说使用方便但计算机设备不识别，IP地址计算机识别但不方便人使用和记忆，则就有一组即独立又协作服务器来<strong>完成域名地址与IP地址的转换</strong></li>
<li>解析方式：<strong>递归解析、反复解析</strong></li>
<li>工作流程<ol>
<li><strong>本地处理</strong>：浏览器<strong>查看缓存</strong>是否有域名与IP映射关系，若没有则向操作系统缓存要，若还没有则检查本机域名hosts文件，若无信息则向DNS服务器提出查询（hosts文件位置：C:\Windows\System32\drivers\etc）</li>
<li><strong>外网查询</strong>：客户端向本地DNS服务器发出DNS请求-&gt;服务器收到请求查询本机缓存，若有则返回，若无此信息则向上级DNS服务器提出请求-&gt;……-&gt;本地DNS将IP地址返回给客户端，客户端与目的建立连接</li>
</ol>
</li>
</ol>
<h2 id="DHCP协议"><a href="#DHCP协议" class="headerlink" title="DHCP协议"></a>DHCP协议</h2><ul>
<li><p>作用：<strong>动态获取IP地址</strong></p>
</li>
<li><p>DHCP客户端使用68号端口，DHCP服务器使用67端口监听</p>
</li>
<li><p>工作原理：四步</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220812200347395.png" alt="image-20220812200347395"></p>
<ol>
<li>客户端发起DHCP请求，由于客户端无IP地址也不知道DHCP服务器的IP地址，则通过UDP广播（255.255.255.255）发送请求</li>
<li>DHCP服务器收到请求后，依然通过广播将相应信息（IP、网关、掩码等）发送给网络</li>
<li>客户端收到后，向服务器发送确认信息，并回显配置参数</li>
<li>最后服务端响应后应答后续参数</li>
</ol>
</li>
<li><p>注意</p>
<ul>
<li>IP地址有租期概念，快到期时会重新发送请求报文，同意则延长租期</li>
<li>DHCP响应时间比自行设置要慢</li>
</ul>
</li>
</ul>
<h2 id="NAT技术"><a href="#NAT技术" class="headerlink" title="NAT技术"></a>NAT技术</h2><ul>
<li><p>原因：IPV4的地址非常紧缺，使用NAT地址转换方法缓解地址耗尽问题</p>
</li>
<li><p>作用：NAT可以将私有地址转换为公有地址，如：</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220812200511805.png" alt="image-20220812200511805"></p>
</li>
<li><p>实际使用中使用IP地址+端口号一起进行转换，NAT变为NAPT（网络地址与端口转换协议），图：</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220812200530221.png" alt="image-20220812200530221"></p>
<ol>
<li>图中两个客户端192.168.1.10 与192.168.1.11同时与服务器183.232.231.172进行通信，两个客户端端口号都是1025</li>
<li>此时，两个私有ip都需要转换为公有IP（120.229.175.121），通过公有地址的不同端口号来区分</li>
<li>路由器生成NAPT转换表，使用同一个公有IP和不同端口号与私有IP进行映射，实现通信</li>
</ol>
</li>
</ul>
<h2 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h2><ul>
<li><p><strong>互联网控制报文协议</strong></p>
</li>
<li><p>作用：<strong>确认IP数据报是否成功到达目的地址、提供错误报告、改善网络设置</strong></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220812200624288.png" alt="image-20220812200624288"></p>
</li>
<li><p>例：</p>
<ol>
<li>主机A向主机B发送数据报，由于某些原因路由器2未发现主机B的存在，此时路由器2会向主机A发送一个ICMP目标不可到达数据报，说明发送未成功</li>
<li>路由器2返回ICMP数据报时会通过路由器1转发，最后到达目的主机A</li>
<li>主机A收到后分解ICMP的首部信息及数据信息已得知发生的具体问题</li>
</ol>
</li>
<li><p>ICMP报文的类型</p>
<ol>
<li><strong>诊断查询类型（查询报文类型）</strong></li>
<li><strong>通知出错原因类型（差错报文类型）</strong></li>
</ol>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220812200710229.png" alt="image-20220812200710229"></p>
</li>
<li><p>ping命令</p>
<ul>
<li><strong>因特网包探索器命令</strong>，用于测试网络连接，ping命令发送一个ICMP请求，判断目的设备能否应答。</li>
<li>格式：  <strong>ping   目的IP地址   或   ping  目的域名</strong></li>
<li>参数：<ol>
<li><strong>TTL</strong>：生存时间，由发送主机设置，不同操作系统数值不同，以防止数据报在网络中永不终止的循环发送，转发一次会减1</li>
<li><strong>time</strong>：一次请求时间，数值越小速度越快</li>
<li><strong>丢包率</strong>：网络负载及健康程度</li>
</ol>
</li>
</ul>
</li>
</ul>
<h1 id="ISO-x2F-OSI网络参考模型"><a href="#ISO-x2F-OSI网络参考模型" class="headerlink" title="ISO&#x2F;OSI网络参考模型"></a>ISO&#x2F;OSI网络参考模型</h1><ul>
<li>网络协议分层模型意义：为了解决通信，由于一次性实现较难，则分步来解决，每一个步骤使用最恰当的技术来实现，所有步骤都完成则通信即可实现</li>
</ul>
<h2 id="OSI协议模型"><a href="#OSI协议模型" class="headerlink" title="OSI协议模型"></a>OSI协议模型</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220812210330169.png" alt="image-20220812210330169"></p>
<ul>
<li><p>一共分为七层</p>
</li>
<li><p>是一种互联、开放、参考模型，是一种框架式的、指南性的协议，具体实现细节并未说明，是指定其它协议的参考</p>
</li>
<li><p>物理层</p>
<ul>
<li>作用：连接不同的物理设备，<strong>传输比特流（二进制）</strong>，为上层协议提供一个传输数据的可靠<strong>物理媒体</strong></li>
<li>设备：<ol>
<li><strong>中继器（repeater）</strong>：放大器，对传输数据信号进行再次放大，延长传输距离，放大次数要受到限制</li>
<li><strong>集线器</strong>：连接局域网中的不同设备（多端口的中继器）</li>
</ol>
</li>
</ul>
</li>
<li><p>数据链路层：</p>
<ul>
<li><p>作用：在物理层基础上提供可靠的数据投递服务，完成<strong>差错控制、流量控制、物理地址寻址</strong>等功能</p>
</li>
<li><p>传输数据的单位：<strong>帧</strong>，如：</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220812212458802.png" alt="image-20220812212458802"></p>
<p>目的和源地址：MAC地址（6B）</p>
<p>类型：标识上层协议（2B）</p>
<p>数据：封装数据内容（1500B）</p>
<p>CRC：循环冗余校验（4B）</p>
</li>
</ul>
</li>
<li><p>网络层</p>
<ul>
<li><p>实现两个端系统之间的数据传输，实现<strong>路由选择、连接建立、释放、终止</strong>等</p>
</li>
<li><p>重要设备：<strong>路由器（router）</strong>，涉及到的协议：</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220812212608163.png" alt="image-20220812212608163"></p>
</li>
</ul>
</li>
<li><p>传输层</p>
</li>
<li><p>提供端到端的连接，透明的传输报文，将数据可靠的传送到相应端口</p>
</li>
<li><p><strong>端口</strong>：使用<strong>2Bi</strong>t对应用程序编号，范围：0-65535，图：HTTP  80  FTP  21  POP3  110</p>
</li>
<li><p>协议：<strong>TCP  UPD</strong></p>
</li>
<li><p>应用层：为操作系统或网络应用程序提供访问接口</p>
</li>
<li><p>各层功能及协议总图</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220812212641335.png" alt="image-20220812212641335"></p>
</li>
</ul>
<h2 id="TCP-x2F-IP协议（四层）"><a href="#TCP-x2F-IP协议（四层）" class="headerlink" title="TCP&#x2F;IP协议（四层）"></a>TCP&#x2F;IP协议（四层）</h2><ul>
<li><p>OSI协议与TCP&#x2F;IP协议的映射关系：</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220812214211573.png" alt="image-20220812214211573"></p>
</li>
<li><p>TCP&#x2F;IP各层包含的子协议：</p>
</li>
</ul>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220812213513243.png" alt="image-20220812213513243"></p>
<ul>
<li><p>网络层IP数据报的结构</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220812214246630.png" alt="image-20220812214246630"></p>
</li>
<li><p>IP数据报功能分析</p>
<ul>
<li><p>版本：占用4b，表示IP的版本号，一般有IPV4 和 IPV6</p>
</li>
<li><p>头部长度：占用4b，表示数据报报头的长度，没有可选项的数据报报头长度为20B</p>
</li>
<li><p>总长度：占16b，表示整个数据报的长度，最大65535B</p>
</li>
<li><p>标识：占16b，用于分片及重组，同一个分片的标识是相同</p>
</li>
<li><p>标志：占3b，表示分片的信息，含义：</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220812213606392.png" alt="image-20220812213606392"></p>
</li>
<li><p>分片偏移：占13b，表示分片在整个数据报的位置，以便于重组</p>
</li>
<li><p>生存时间：占8b，表示数据报可以经过的中转路由器数量，每经过一个路由器TTL会减1，变为0时会丢弃数据报，避免数据报无限传播</p>
</li>
<li><p>协议：占8b，表示上一层所使用的的协议（TCP&#x2F;UDP）</p>
</li>
<li><p>头部校验和：占16b，用来校验数据报的报头是否损坏</p>
</li>
<li><p>源地址：占32b，表示发送端的IP地址</p>
</li>
<li><p>目的地址：占32b，表示接收端的IP地址</p>
</li>
<li><p>可选项：很少使用</p>
</li>
<li><p>填充：若没有可选项，报头长度不是32b的整数倍，则需要向填充字段填充数据，保证为32b的整数倍</p>
</li>
</ul>
</li>
<li><p>TCP报文、IP数据报、数据帧的关系：</p>
</li>
</ul>
<p> <img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220812213659740.png" alt="image-20220812213659740"></p>
<h2 id="TCP协议的三次握手"><a href="#TCP协议的三次握手" class="headerlink" title="TCP协议的三次握手"></a>TCP协议的三次握手</h2><ul>
<li>作用：建立连接</li>
</ul>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220812215450345.png" alt="image-20220812215450345"></p>
<ul>
<li><p>名词解释</p>
<ul>
<li>seq：<strong>序列号</strong>，占4B，标记数据段顺序</li>
<li>SYN：<strong>请求同步序列号</strong>，当SYN&#x3D;1 ， ACK&#x3D;0 时表示建立连接，握手完毕后会清零</li>
<li>ack：<strong>序列确认号</strong>，占4B，表示期望接收到的下一个字节的编号</li>
<li>ACK：<strong>标志确认号</strong>，占1b，仅当ACK&#x3D;1时，ack字段才有效</li>
</ul>
</li>
<li><p>过程</p>
<ol>
<li>第一次握手：<strong>建立连接时客户端向服务器端发送SYN&#x3D;1包，等待服务器确认</strong>（客户端说：我请求建立连接）</li>
<li>第二次握手：<strong>服务器端收到了SYN包，此时再次发送确认信息表明客户端的SYN包已收到</strong>（服务器端说：我收到了你发送建立连接的请求，我可以建立连接）</li>
<li>第三次握手：<strong>客户端收到服务器的SYN确认包，再次向服务器发送ACK确认包，次包发送完毕，两端都进入连接成功状态，开始发送数据</strong>（客户端说：收到了你可以建立连接的消息，那就开始吧）</li>
</ol>
</li>
</ul>
<h2 id="TCP协议的四次挥手"><a href="#TCP协议的四次挥手" class="headerlink" title="TCP协议的四次挥手"></a>TCP协议的四次挥手</h2><ul>
<li>作用：释放连接</li>
</ul>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220812215450345.png"></p>
<ul>
<li>过程<ol>
<li>第一次挥手：<strong>客户端发送释放连接报文，随后客户端进行半关闭状态，停止客户端向服务端方向的信息发送，但任然可以接收服务端传过来的信息</strong>（客户端说：我请求释放连接）</li>
<li>第二次挥手：<strong>服务器端确认客户端的请求已收到，服务器端进半关闭</strong>（服务器端说：收到，你需要释放连接请求我知道了）</li>
<li>第三次挥手：<strong>发送剩余数据，做好服务器端到客户机端方向上的连接释放准备</strong>（服务器端说：剩余数据已发送完毕，可以关闭连接了）</li>
<li>第四次挥手：<strong>客户机确认服务器已做好释放连接准备，客户端等待2MSL后结束</strong>（客户端说：收到，再见）</li>
</ol>
</li>
</ul>
<h2 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h2><ul>
<li><p><strong>用户数据报协议</strong>，是一种<strong>面向无连接、不可靠的数据投递服务</strong>，没有拥塞控制的一种报文传输协议</p>
</li>
<li><p>TCP与UDP应用区别：</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220812215859320.png" alt="image-20220812215859320"></p>
</li>
<li><p>TCP报文格式：</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220812215911344.png" alt="image-20220812215911344"></p>
</li>
<li><p>UDP报文格式：</p>
</li>
</ul>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220812213839865.png" alt="image-20220812213839865"></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-计算机网络：数据链路层"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
	
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/08/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%9A%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"
    >数据链路层</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/08/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%9A%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/" class="article-date">
  <time datetime="2022-08-11T08:21:31.000Z" itemprop="datePublished">2022-08-11</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">计算机基础知识</a> / <a class="article-category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h1><p>数据链路层在物理层提供的基础上向网络层提供服务，主要作用是加强物理层传输原始比特流的功能，将物理层提供的可能出错的物理连接改造为逻辑上无差错的数据链路。</p>
<h2 id="为网络层提供服务"><a href="#为网络层提供服务" class="headerlink" title="为网络层提供服务"></a>为网络层提供服务</h2><ul>
<li>无确认的无连接服务：不建立链路连接，目的机器接收到源机器发送的数据帧后不发回确认。丢失不负责，适用于实时通信或误码率较低的通信通道，如以太网。</li>
<li>有确认的无连接服务：不建立链路连接，目的机器接收到源机器发送的数据帧后发回确认。如果源机器在规定时间内未收到确认信号，重传丢失的帧。适用于误码率较高的通信通道，如无线通信。</li>
<li>有确认的面向连接服务：<strong>建立链路、传输帧、释放数据链路</strong>。每一帧都要给出确认，源机器收到确认后才发送下一帧，可靠性极高，适用于通信要求较高的场合。</li>
</ul>
<h2 id="链路管理"><a href="#链路管理" class="headerlink" title="链路管理"></a>链路管理</h2><p>数据链路层连接的建立、维持和释放过程称为链路管理。</p>
<h2 id="帧定界、帧同步与透明传输"><a href="#帧定界、帧同步与透明传输" class="headerlink" title="帧定界、帧同步与透明传输"></a>帧定界、帧同步与透明传输</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/86b4d5e5d754a09b221add26fab009b7.png" alt=" HDLC标准帧格式"></p>
<h3 id="帧定界"><a href="#帧定界" class="headerlink" title="帧定界"></a>帧定界</h3><p>帧由数据部分加上首部尾部的很多控制信息组成，而首部、尾部的控制信息的重要作用就是<strong>确定帧的界限</strong>。</p>
<h3 id="帧同步"><a href="#帧同步" class="headerlink" title="帧同步"></a>帧同步</h3><p>信号接收方能够从接收到的二进制比特流中区分出帧的<strong>起始与终止</strong>。</p>
<h3 id="透明传输"><a href="#透明传输" class="headerlink" title="透明传输"></a>透明传输</h3><p>如果在数据信息中恰好出现了与标志F相同的比特组合，那么会被误认为传输结束，为了解决这个问题，采取<strong>透明传输</strong>。透明传输就是不管数据是什么比特组合，都应该能在链路上传送。</p>
<h2 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h2><p>流量控制就是限制发送方的数据流量，使其发送速率不超过接收方的接收能力。举个例子，下课去吃饭，楼道口只有这么大，如果学生一股脑往楼道口冲，显然出不去，因此要限制学生出楼道口的速率。</p>
<p>流量控制的过程需要某种反馈机制使发送方能够知道接收方是否能跟上自己，即需要一些规则使发送方知道在什么情况下可以接着发送下一帧。</p>
<h2 id="差错控制"><a href="#差错控制" class="headerlink" title="差错控制"></a>差错控制</h2><p>在帧的传输过程中，由于信道噪声的干扰可能出现错误。使发送方确认接收方是否正确收到数据的方法称为差错控制。</p>
<p>错误可分为两种：<strong>位错</strong>（帧中某些位出现差错）、<strong>帧错</strong>（帧的丢失、重复或失序）。</p>
<h1 id="组帧"><a href="#组帧" class="headerlink" title="组帧"></a>组帧</h1><p>为了在传输出错时<strong>不用重发所有比特数据</strong>，而把比特组合成帧，在出错时只发送错的帧就可。因此发送方必须根据规则把网络层提交的分组封装成帧，这个过程叫<strong>组帧</strong>。</p>
<p>目前最常用的还是<strong>零比特填充法和违规编码法</strong>。</p>
<h3 id="字符计数法"><a href="#字符计数法" class="headerlink" title="字符计数法"></a>字符计数法</h3><p>在帧头部使用一个计数字段来标明帧内字符数，这样目的结点在收到数据时可以根据头部的字符数确定帧结束的位置。</p>
<p>但是显然，如果在传输中计数字段出错，将造成整个数据混乱。</p>
<h3 id="字符填充的首尾定界符法"><a href="#字符填充的首尾定界符法" class="headerlink" title="字符填充的首尾定界符法"></a>字符填充的首尾定界符法</h3><p>字符填充法使用特定字符来界定一帧的开始与结束，如图3.4中，控制字符SOH意味帧的开始，控制字符EOT意味帧的结束。为了防止帧的信息中有结束的特殊字符而被误判为帧结束了，可在特殊字符前面添加转义字符ESC加以区分（转义字符是ASCII码中的控制字符，是一个字符，不是E、S、C三个字符），以实现透明传输。</p>
<h3 id="零比特填充的首尾标识法"><a href="#零比特填充的首尾标识法" class="headerlink" title="零比特填充的首尾标识法"></a>零比特填充的首尾标识法</h3><p>零比特填充法允许数据帧包含任意个数的比特，也允许每个字符的编码包含任意个数的比特。</p>
<p>原理是使用一个特定的比特模式，即01111110来标志一帧的开始和结束。为了不使信息位中出现比特流01111110而被误判帧的首尾标志，发送方的数据链路层在信息位中遇到5个连续的“1”时，将自动在其后面插入一个“0”；而接收方执行逆操作。</p>
<h3 id="违规编码法"><a href="#违规编码法" class="headerlink" title="违规编码法"></a>违规编码法</h3><p>曼彻斯特编码中只有“高-低”电平对表示“1”和“低-高”电平对表示“0”，而没有“高-高”和“低-低”电平对，我们可以借用这种违规作为帧的起始与终止。</p>
<h1 id="差错控制-1"><a href="#差错控制-1" class="headerlink" title="差错控制"></a>差错控制</h1><p>比特在传输过程中可能会出现差错，比特差错是传输差错的一种，本节仅分析比特差错。</p>
<p>编码技术进行差错控制主要有两类：自动重传请求ARQ和前向纠错FEC。</p>
<h2 id="检错编码"><a href="#检错编码" class="headerlink" title="检错编码"></a>检错编码</h2><p>有效数据发送前，先按规则加一定的冗余位，符合某一规则的码字后再发送，接收端根据收到的码字是否仍符合原规则来判断是否出错。</p>
<h3 id="奇偶校验码"><a href="#奇偶校验码" class="headerlink" title="奇偶校验码"></a>奇偶校验码</h3><p>奇偶校验码是奇校验码和偶校验码的统称，是一种最基本的检错码。</p>
<p>原理是：由n-1位信息元和1位校验码组成，如果是奇校验码，那么在附加一个校验元后，码长位n的码字中“1”的个数位奇数，如果是偶校验码，则“1”的个数位偶数。</p>
<p>这种校验方法只能检测奇数位的出错情况，但并不知道哪些位错了，也不能发现偶数位的出错情况。</p>
<h3 id="循环冗余码"><a href="#循环冗余码" class="headerlink" title="循环冗余码"></a>循环冗余码</h3><p>循环冗余码（CRC），又称多项式码，任何一个由二进制位数串组成的代码都可以与一个只含有0和1两个系数的多项式建立一一对应关系。</p>
<p>具体计算过程请查看王道教材P69</p>
<h2 id="纠错编码"><a href="#纠错编码" class="headerlink" title="纠错编码"></a>纠错编码</h2><p>在数据块上附加足够多的冗余信息，能够让接收方推导出实际发送了什么样的比特串，就叫纠错编码（自己能够改正）。</p>
<p>最常见的纠错编码是海明码，实现原理是在有效信息位中加入几个校验位形成海明码，并把海明码的每个二进制位分配到几个奇偶校验组中。</p>
<h1 id="流量控制与可靠传输机制"><a href="#流量控制与可靠传输机制" class="headerlink" title="流量控制与可靠传输机制"></a>流量控制与可靠传输机制</h1><h2 id="流量控制、可靠传输与滑动窗口机制"><a href="#流量控制、可靠传输与滑动窗口机制" class="headerlink" title="流量控制、可靠传输与滑动窗口机制"></a>流量控制、可靠传输与滑动窗口机制</h2><p>流量控制涉及对链路上帧的发送速率的控制，以使接收方由足够的缓冲空间来接收每个帧。</p>
<p>流量控制的基本方法是使接收方控制发送方发送数据的速率，常见的方式有两种：<strong>停止-等待协议和滑动窗口协议</strong>。</p>
<p><strong>1.停止-等待流量控制基本原理</strong></p>
<p>发送方没发送一帧，都要等待接收方的应答信号之后才可以发送下一帧，不然就一直处于等待状态。</p>
<p><strong>2.滑动窗口流量控制基本原理</strong></p>
<p>在任意时刻，发送方都要维持一组连续的允许发送的帧的序号，称为发送窗口；同时接收方也要维持接收窗口。</p>
<p>发送端每收到一个确认帧，发送窗口就会向前滑动一个帧的位置；接收端口收到帧数据后，将窗口向前移一个位置，并发回确认帧。</p>
<p><strong>3.可靠传输机制</strong></p>
<p>可靠传输机制通常由确认和超时重传两种机制完成。</p>
<p>确认是在接收方正确接收了内容后发送一个回复帧，称为捎带确认。</p>
<p>超时重传是发送方发送数据帧后启动计时器，如果没有在规定时间内收到确认帧，则重新发送该数据帧。</p>
<h2 id="单帧滑动窗口与停止-等待协议"><a href="#单帧滑动窗口与停止-等待协议" class="headerlink" title="单帧滑动窗口与停止-等待协议"></a>单帧滑动窗口与停止-等待协议</h2><p>停止等待协议前面讲了，是单帧的发送与确认，相当于发送窗口和接收窗口大小均为1的滑动窗口。</p>
<h2 id="多帧滑动窗口与后退N帧协议（GBN）"><a href="#多帧滑动窗口与后退N帧协议（GBN）" class="headerlink" title="多帧滑动窗口与后退N帧协议（GBN）"></a>多帧滑动窗口与后退N帧协议（GBN）</h2><p>在GBN协议下，发送方无需等待上一帧的确认帧后再发送下一帧，而是可以连续的发送帧，当接收方检测出失序信息帧后，要求发送方重发出错帧后的有所未确认帧。</p>
<h2 id="多帧滑动窗口与选择重传协议（SR）"><a href="#多帧滑动窗口与选择重传协议（SR）" class="headerlink" title="多帧滑动窗口与选择重传协议（SR）"></a>多帧滑动窗口与选择重传协议（SR）</h2><p>选择重传协议可设法只重传出现差错的数据帧或计时器超时的数据帧，但是接收方窗口要加大，以便先收下发送序列不连续但仍处在接收窗口中的那些数据帧。等到所缺的数据帧收到后再一并交给主机。</p>
<h1 id="介质访问控制"><a href="#介质访问控制" class="headerlink" title="介质访问控制"></a>介质访问控制</h1><p>介质访问控制所要完成的主要任务，是为使用介质的每个结点隔离来自同一信道上其他结点所传送的信号，以协调活动结点的传输。</p>
<h2 id="信道划分介质访问控制"><a href="#信道划分介质访问控制" class="headerlink" title="信道划分介质访问控制"></a>信道划分介质访问控制</h2><p>信道划分介质访问控制将使用介质的每个设备与来自同一通信信道上的其他设备的通信隔离开来，把时域和频域资源合理的分配给网络上的设备。</p>
<ol>
<li><p>频分多路复用(FDM)</p>
<p>频分多路复用是一种将多路基带信号调制到不同频率载波上，将物理信道分割成若干个与传输单个信号宽带相同的子信道，每个子信道传输一种信号。</p>
</li>
<li><p>时分多路复用（TDM）</p>
<p>时分多路复用是将一条物理信道按时间分成若干时间片，轮流的分配给多个信号使用。</p>
</li>
<li><p>波分多路复用</p>
</li>
<li><p>码分多路复用（CDM）</p>
<p>码分多路复用采用不同的编码来区分各路原始信号的一种复用方式。与FDM和TDM不同，它既共享信道的频率，又共享时间。</p>
</li>
</ol>
<h2 id="随机访问介质访问控制"><a href="#随机访问介质访问控制" class="headerlink" title="随机访问介质访问控制"></a>随机访问介质访问控制</h2><p>在随机访问协议中，不采用集中控制进行人为划分干预的这种方式，更像是原始社会，所有用户都能随意的发送信息，占用信道全部速率，但是为了解决几个用户发送帧之间的帧冲突，就需要每个用户按照一定的规则反复的重传帧，直到帧无碰撞的通过。</p>
<p>它的核心思想是：胜利者通过争用获得信道，从而获得信息的发送全，因此又叫做争用型协议。</p>
<p>随机介质访问控制实质上是将广播信道转化为点到点信道的行为。</p>
<h3 id="ALOHA协议"><a href="#ALOHA协议" class="headerlink" title="ALOHA协议"></a>ALOHA协议</h3><p>其基本思想是：当网络中有任何一个站点需要发送数据时，可以 不进行任何检测就发送数据。如果在一段时间内未收到确认，那么该站点就认为传输过程中发生了冲突，发送站点需要等待一段随机时间后再发送数据，直至发送成功。</p>
<h3 id="CSMA协议"><a href="#CSMA协议" class="headerlink" title="CSMA协议"></a>CSMA协议</h3><p>因为ALOHA协议每个站点随心所欲的发送数据，因此发送碰撞的概率很大。若每个站点在发送前都先侦听一下公共信道，发现信道空闲后再发送，则就会大大降低冲突的可能，CSMA协议是在ALOHA协议基础上多了一个载波监听装置。</p>
<h3 id="CSMA-x2F-CD协议"><a href="#CSMA-x2F-CD协议" class="headerlink" title="CSMA&#x2F;CD协议"></a>CSMA&#x2F;CD协议</h3><p>载波侦听多路访问&#x2F;碰撞检测协议是CSMA协议的改进，碰撞检测是边发送边侦听，即适配器边发送数据边检测信道上信号电压的变化情况，以便判断自己在发送数据时其他站点是否也在发送数据。</p>
<h2 id="轮询访问介质访问控制：令牌传递协议"><a href="#轮询访问介质访问控制：令牌传递协议" class="headerlink" title="轮询访问介质访问控制：令牌传递协议"></a>轮询访问介质访问控制：令牌传递协议</h2><h1 id="3-6局域网"><a href="#3-6局域网" class="headerlink" title="3.6局域网"></a>3.6局域网</h1><h2 id="局域网的基本概念和体系结构"><a href="#局域网的基本概念和体系结构" class="headerlink" title="局域网的基本概念和体系结构"></a>局域网的基本概念和体系结构</h2><p>局域网是只在一个较小的范围内，将各种计算机、外部设备、数据库系统等连接起来的可以共享信息的互联网络。</p>
<p>局域网的特性主要由拓扑序列、传输介质、介质访问控制方式三个要素决定。</p>
<p>以太网是目前使用范围最广的局域网，基本处于局域网的垄断地位。逻辑拓扑是总线型结构，物理拓扑是星形或拓展星形结构。</p>
<h2 id="以太网与IEEE-802-3"><a href="#以太网与IEEE-802-3" class="headerlink" title="以太网与IEEE 802.3"></a>以太网与IEEE 802.3</h2><p>以太网采用的无连接无确认的方式，发送的数据都使用曼彻斯特编码的信号。</p>
<h2 id="IEEE-802-11"><a href="#IEEE-802-11" class="headerlink" title="IEEE 802.11"></a>IEEE 802.11</h2><h2 id="令牌环网的基本原理"><a href="#令牌环网的基本原理" class="headerlink" title="令牌环网的基本原理"></a>令牌环网的基本原理</h2><h1 id="广域网"><a href="#广域网" class="headerlink" title="广域网"></a>广域网</h1><h2 id="广域网的基本概念"><a href="#广域网的基本概念" class="headerlink" title="广域网的基本概念"></a>广域网的基本概念</h2><p>广域网通常是指覆盖范围广（超过一个城市的范围）的长距离网络。广域网是因特网的核心部分，其任务是长距离运送主机所发送的数据。</p>
<p>广域网由一些结点交换机及连接这些交换机的链路组成，结点交换机的功能是将分组存储并转发。</p>
<p>广域网中一个重要问题是路由选择和分组转发。</p>
<h2 id="PPP协议"><a href="#PPP协议" class="headerlink" title="PPP协议"></a>PPP协议</h2><p>PPP（Point-to-Point Protocol）是使用串行线路通信的面向字节的协议，该协议应用在直接连接两个结点的链路上。</p>
<p>PPP协议有三个组成部分：</p>
<ol>
<li><p>链路控制协议（LCP）。一种扩展链路控制协议，用于建立、配置、测试和管理数据链路。</p>
</li>
<li><p>网络控制协议（NCP）。PPP协议允许同时采用多种网络层协议，每个不同的网络层协议要用一个相应的NCP来配置。</p>
</li>
<li><p>一个将IP数据报封装到串行链路的方法。IP数据报在PPP帧中就是其信息部分。</p>
</li>
</ol>
<h2 id="HDLC协议"><a href="#HDLC协议" class="headerlink" title="HDLC协议"></a>HDLC协议</h2><p>高级数据链路控制（High-level Date Link Control，HDLC）协议是ISO制定的面向比特的数据链路层协议。</p>
<p>所有帧采用CRC检验，对信息帧进行顺序编号，防止漏发重发。</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/4e15924d6dffc79d050cce6f60da1b29.png" alt="HDLC的帧格式"></p>
<h1 id="数据链路层设备"><a href="#数据链路层设备" class="headerlink" title="数据链路层设备"></a>数据链路层设备</h1><h2 id="网桥的概念及其基本原理"><a href="#网桥的概念及其基本原理" class="headerlink" title="网桥的概念及其基本原理"></a>网桥的概念及其基本原理</h2><p>网桥根据MAC帧的目的地址对帧进行转发和过滤。当网桥收到一个帧时，先检查此帧的目的MAC地址，然后确定将该帧转发到哪个接口，或者把他丢弃（过滤）。</p>
<ol>
<li><p>透明网桥</p>
<p>“透明”是只以太网站点不知道所发送的帧经过了哪些网桥，是一种即插即用的设备——自学习</p>
</li>
<li><p>源路由网桥</p>
<p>源路由网桥：在发送帧时，把详细的最佳路由信息放在帧的首部。</p>
<p>方法：源站以广播方式向欲通信的目的站发送一个发现帧。</p>
</li>
</ol>
<h2 id="局域网交换机及其工作原理"><a href="#局域网交换机及其工作原理" class="headerlink" title="局域网交换机及其工作原理"></a>局域网交换机及其工作原理</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82.png" alt="数据链路层"></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-计算机网络：物理层"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
	
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/08/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%9A%E7%89%A9%E7%90%86%E5%B1%82/"
    >物理层</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/08/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%9A%E7%89%A9%E7%90%86%E5%B1%82/" class="article-date">
  <time datetime="2022-08-11T07:37:25.000Z" itemprop="datePublished">2022-08-11</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">计算机基础知识</a> / <a class="article-category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><ul>
<li><p>物理层考虑怎样在连接各台计算机的传输媒体上<strong>传输数据比特流</strong>，而不是指具体的传输媒体。</p>
</li>
<li><p>主要任务：确定与传输媒体<strong>接口</strong>有关的一些特性—&gt;定义标准</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220811154134685.png" alt="image-20220811154134685"></p>
</li>
</ul>
<h1 id="数据通信基础知识"><a href="#数据通信基础知识" class="headerlink" title="数据通信基础知识"></a>数据通信基础知识</h1><h2 id="典型的数据通信模型"><a href="#典型的数据通信模型" class="headerlink" title="典型的数据通信模型"></a>典型的数据通信模型</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220811154401221.png" alt="image-20220811154401221"></p>
<h2 id="数据通信相关术语"><a href="#数据通信相关术语" class="headerlink" title="数据通信相关术语"></a>数据通信相关术语</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220811154447192.png" alt="image-20220811154447192"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/dc3ce8cf56d36f438c1ce4fb11aeaeef.png" alt="通信系统模型"></p>
<blockquote>
<p>信道按传输信号形式不同，可分为模拟信道(传送模拟信号)和数字信道(传送数字信号)。</p>
<p>信道按传输介质不同，可分为无线信道和有线信道。</p>
<p>信道上传输的信号有基带信号(把0和1用不同电压表示，送到数字信道上传输)、宽带信号(在基带信号进行调制后形成模拟信号，送到模拟信道上传输)。</p>
<p>通信方式分为三种：单向通信、半双工通信、全双工通信。</p>
</blockquote>
<ul>
<li><strong>速率</strong>：数据传输速率，单位时间内传输的数据量</li>
<li><strong>码元</strong>：用一个固定时长的信号波形（数字脉冲），代表离散数值的基本波形。当有多个离散状态时，成为M进制码元，一个码元可以携带多个比特的信息</li>
<li><strong>波特</strong>：码元传输速率（波特率）的单位，波特率是单位时间内数字通信系统所传输的码元个数</li>
<li><strong>信号带宽</strong>：信号具有的频带宽度，单位是赫兹(Hz)</li>
<li><strong>信道带宽</strong>：信道能通过的最高频率和最低频率之差</li>
</ul>
<h2 id="奈氏准则"><a href="#奈氏准则" class="headerlink" title="奈氏准则"></a>奈氏准则</h2><h3 id="失真"><a href="#失真" class="headerlink" title="失真"></a>失真</h3><p><strong>影响失真的因素</strong></p>
<ol>
<li>码元传输速率</li>
<li>信号传输距离</li>
<li>噪声干扰</li>
<li>传输媒体质量</li>
</ol>
<p><strong>码间串扰</strong>：接收端收到的信号波形失去了码元之间清晰界限的现象</p>
<h3 id="奈奎斯特定理"><a href="#奈奎斯特定理" class="headerlink" title="奈奎斯特定理"></a>奈奎斯特定理</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220811160033198.png" alt="image-20220811160033198"></p>
<h2 id="香农定理"><a href="#香农定理" class="headerlink" title="香农定理"></a>香农定理</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220811160256941.png" alt="image-20220811160256941"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220811160345390.png" alt="image-20220811160345390"></p>
<h2 id="编码与调制"><a href="#编码与调制" class="headerlink" title="编码与调制"></a>编码与调制</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220811160536551.png" alt="image-20220811160536551"></p>
<ul>
<li>把数据变为模拟信号的过程称为<strong>调制</strong>，把数据变为数字信号的过程称为<strong>编码</strong></li>
</ul>
<p><strong>1. 数字数据编码为数字信号</strong></p>
<p>归零编码、非归零编码、反向非归零编码、曼彻斯特编码、差分曼彻斯特编码</p>
<p><strong>2. 数字数据调制为模拟信号</strong></p>
<p>幅移键控、频移键控、相移键控、正交振幅调制</p>
<p><strong>3. 模拟数据编码为数字信号</strong></p>
<p><strong>4. 模拟数据调制为模拟信号</strong></p>
<h2 id="数据交换"><a href="#数据交换" class="headerlink" title="数据交换"></a>数据交换</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220811160913985.png" alt="image-20220811160913985"></p>
<h3 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h3><ul>
<li>在数据传输前，两个结点之间建立一条专用的物理通信路径，在整个数据传输期间一直被独占，直到通信结束才被释放。电路交换技术分为三个阶段：<strong>连接建立、数据传输、连接释放。</strong></li>
<li>电路交换线路<strong>独占</strong>，导致资源浪费严重</li>
</ul>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220811161206069.png" alt="image-20220811161206069"></p>
<h3 id="报文交换"><a href="#报文交换" class="headerlink" title="报文交换"></a>报文交换</h3><ul>
<li><p>数据交换的单位是报文，报文携带有目标地址、源地址等信息。报文交换<strong>采用存储转发的传输方式</strong>。</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220811161238900.png" alt="image-20220811161238900"></p>
</li>
<li><p>报文交换存储转发会引起<strong>转发时延，对报文的大小没有限制</strong>，要求网络结点需要有较大的缓存空间</p>
</li>
</ul>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220811161258553.png" alt="image-20220811161258553"></p>
<h3 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h3><ul>
<li>分组交换<strong>采用存储转发的方式</strong>，但是解决了报文交换中大报文传输的问题。分组交换限制了每次传送的数据块大小。</li>
</ul>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220811161325768.png" alt="image-20220811161325768"></p>
<h1 id="传输介质"><a href="#传输介质" class="headerlink" title="传输介质"></a>传输介质</h1><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220811161442232.png" alt="image-20220811161442232"></p>
<h1 id="物理层设备"><a href="#物理层设备" class="headerlink" title="物理层设备"></a>物理层设备</h1><h2 id="中继器（RP-repeater）"><a href="#中继器（RP-repeater）" class="headerlink" title="中继器（RP repeater）"></a>中继器（RP repeater）</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220811161637268.png" alt="image-20220811161637268"></p>
<h2 id="集线器（Hub）"><a href="#集线器（Hub）" class="headerlink" title="集线器（Hub）"></a>集线器（Hub）</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220811161712463.png" alt="image-20220811161712463"></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-计算机网络：计算机网络概述"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
	
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/08/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/"
    >计算机网络体系结构</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/08/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/" class="article-date">
  <time datetime="2022-08-10T01:32:59.000Z" itemprop="datePublished">2022-08-10</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">计算机基础知识</a> / <a class="article-category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="计算机网络概述"><a href="#计算机网络概述" class="headerlink" title="计算机网络概述"></a>计算机网络概述</h1><h2 id="计算机网络的概念"><a href="#计算机网络的概念" class="headerlink" title="计算机网络的概念"></a>计算机网络的概念</h2><ul>
<li>计算机网络是一个将分散的、具有独立功能的<strong>计算机系统</strong>，通过<strong>通信设备与线路</strong>连接起来，由功能完善的软件<strong>实现资源共享和信息传递</strong>的系统。</li>
<li>简而言之，计算机网络就是一些<strong>互联的（互联互通）、自治的（无主从关系）</strong>计算机系统的集合。</li>
</ul>
<h2 id="计算机网络的组成"><a href="#计算机网络的组成" class="headerlink" title="计算机网络的组成"></a>计算机网络的组成</h2><ul>
<li>从<strong>组成部分</strong>上看，一个完整的计算机网络主要由<strong>硬件、软件、协议</strong>三大部分组成，缺一不可。</li>
<li>从<strong>工作方式</strong>上看，计算机网络可分为<strong>边缘部分和核心部分</strong>。<ul>
<li>边缘部分：用户直接使用</li>
<li>核心部分：为边缘部分服务</li>
</ul>
</li>
<li>从<strong>功能组成</strong>上看，计算机网络由<strong>通信子网和资源子网</strong>组成。<ul>
<li>通信子网：实现数据通信</li>
<li>资源子网：实现资源共享&#x2F;数据处理</li>
</ul>
</li>
</ul>
<h2 id="计算机网络的功能"><a href="#计算机网络的功能" class="headerlink" title="计算机网络的功能"></a>计算机网络的功能</h2><ol>
<li>数据通信：最基本最重要的功能，能够实现计算机之间的数据传输</li>
<li>资源共享：软件共享、数据共享、硬件共享</li>
<li>分布式处理：提高系统利用率</li>
<li>提高可靠性：一台坏了，可以用同网络下其他计算机代替</li>
<li>负载均衡：将工作任务均衡分配给网络下的计算机</li>
</ol>
<h2 id="计算机网络的分类"><a href="#计算机网络的分类" class="headerlink" title="计算机网络的分类"></a>计算机网络的分类</h2><ul>
<li>按分布范围分类：广域网WAN、城域网MAN、局域网WAN、个人区域网PAN</li>
<li>按传输技术分类：广播式网络、点对点网络</li>
<li>按拓朴结构分类：总线型、星型网络、环型网络、网状型网络</li>
<li>按使用者分类：公用网、专用网</li>
<li>按交换技术分类：电路交换、报文交换、分组交换</li>
</ul>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220811143256460.png" alt="image-20220811143256460"></p>
<h2 id="计算机网络的性能指标"><a href="#计算机网络的性能指标" class="headerlink" title="计算机网络的性能指标"></a>计算机网络的性能指标</h2><h3 id="速率"><a href="#速率" class="headerlink" title="速率"></a>速率</h3><ul>
<li><strong>定义</strong>：连接在计算机网络上的主机在数字信道上传送数据位数的速率</li>
<li><strong>单位</strong>：b&#x2F;s,Kb&#x2F;s,Mb&#x2F;s,Tb&#x2F;s，如果用字节表示，则是B&#x2F;s,KB&#x2F;s,MB&#x2F;s,TB&#x2F;s</li>
<li>1Byte&#x3D;8Bit</li>
</ul>
<h3 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h3><p>网络设备所支持的最高速度，单位同速率，是<strong>理想条件下最高速率</strong></p>
<h3 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h3><p>单位时间内通过某个网络的<strong>数据总量</strong></p>
<h3 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h3><p>数据从网络的一端到另一端所需的时间，也叫<strong>延迟或迟延</strong></p>
<table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">描述</th>
<th align="center">计算公式</th>
</tr>
</thead>
<tbody><tr>
<td align="center">发送时延</td>
<td align="center">数据从主机到信道上所用的时间</td>
<td align="center">发送的数据长度&#x2F;发送速率</td>
</tr>
<tr>
<td align="center">传播时延</td>
<td align="center">数据在信道上传播所花费的时间</td>
<td align="center">信道长度&#x2F;电磁波在信道上传播的速率</td>
</tr>
<tr>
<td align="center">排队时延</td>
<td align="center">数据在路由器前等待前面数据处理的时间</td>
<td align="center">无计算方式</td>
</tr>
<tr>
<td align="center">处理时延</td>
<td align="center">数据在路由器中处理需求的时间</td>
<td align="center">无计算方式</td>
</tr>
</tbody></table>
<p>使用高速链路(提高网速)，只能减小<strong>发送时延</strong>，无法减少其他三个时延</p>
<h3 id="时延带宽积"><a href="#时延带宽积" class="headerlink" title="时延带宽积"></a>时延带宽积</h3><p>公式：时延带宽积&#x3D;传播时延x带宽</p>
<p>以比特为单位的链路长度，意思是链路上有多少比特的数据</p>
<h3 id="往返时延RTT"><a href="#往返时延RTT" class="headerlink" title="往返时延RTT"></a>往返时延RTT</h3><p>从发送端发送数据开始，到发送端收到来自接收端的确认（接收端收到数据后便立即发送确认）</p>
<p>总共经历的时延 RTT&#x3D;传播时延x2+处理时间(有时可能直接忽略)</p>
<h3 id="利用率"><a href="#利用率" class="headerlink" title="利用率"></a>利用率</h3><h4 id="信道利用率"><a href="#信道利用率" class="headerlink" title="信道利用率"></a>信道利用率</h4><p>信道利用率&#x3D;有数据通过时间&#x2F;有+无数据通过时间</p>
<h4 id="网络利用率"><a href="#网络利用率" class="headerlink" title="网络利用率"></a>网络利用率</h4><p>网络利用率&#x3D;所有信道利用率加权求平均值</p>
<h3 id="时延和利用率的关系图"><a href="#时延和利用率的关系图" class="headerlink" title="时延和利用率的关系图"></a>时延和利用率的关系图</h3><p>利用率越高，延迟越大</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/20200626203643244.png" alt="img"></p>
<h1 id="计算机网络体系结构与参考模型"><a href="#计算机网络体系结构与参考模型" class="headerlink" title="计算机网络体系结构与参考模型"></a>计算机网络体系结构与参考模型</h1><h2 id="计算机网络分层结构"><a href="#计算机网络分层结构" class="headerlink" title="计算机网络分层结构"></a>计算机网络分层结构</h2><h3 id="为什么要分层"><a href="#为什么要分层" class="headerlink" title="为什么要分层"></a>为什么要分层</h3><p>为了降低协议设计和调试的复杂性，通常对计算机网络系统结构以分层方式进行建模，每层都实现一种相对独立的功能，降低系统的复杂度。</p>
<ol>
<li>发起通信的计算机必须将数据通信的通路进行激活。</li>
<li>要告诉网络如何识别目的主机。</li>
<li>发起通信的计算机要查明目的主机是否开机，并且与网络连接正常。</li>
<li>发起通信的计算机要弄清楚，对方计算机中文件管理程序是否已经做好准备工作。</li>
<li>确保差错和意外可以解决。</li>
</ol>
<h3 id="分层的基本原则"><a href="#分层的基本原则" class="headerlink" title="分层的基本原则"></a>分层的基本原则</h3><ol>
<li>各层之间相互<strong>独立</strong>，每层只实现一种相对独立的功能</li>
<li>每层之间<strong>界面自然清晰</strong>，易于理解，相互交流尽可能少</li>
<li>结构上下可分隔开。每层都采用<strong>最合适的技术</strong>来实现</li>
<li>保持下层对上层的独立性，<strong>上层单向使用下层提供的服务</strong></li>
<li>整个分层结构应该能促进标准化工作</li>
</ol>
<h2 id="计算机网络协议、接口、服务"><a href="#计算机网络协议、接口、服务" class="headerlink" title="计算机网络协议、接口、服务"></a>计算机网络协议、接口、服务</h2><ul>
<li><strong>协议</strong>：在网络中一种事先约定好的交换数据的规则，这些规则规定了所交换数据的格式及有关的同步问题。</li>
<li><strong>接口</strong>：接口是同一结点内相邻两层间交换信息的连接点，是一个系统的内部的规定。每层只能为紧邻的层次之间定义接口，不能跨层定义接口。</li>
<li><strong>服务</strong>：服务是指下层为紧邻的上层提供的功能调用。上层使用下层的服务时必须与下层交换一些命令：请求、指示、响应、证实。</li>
</ul>
<h3 id=""><a href="#" class="headerlink" title=""></a><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220811145806430.png" alt="image-20220811145806430"></h3><h2 id="参考模型"><a href="#参考模型" class="headerlink" title="参考模型"></a>参考模型</h2><h3 id="7层OSI参考模型"><a href="#7层OSI参考模型" class="headerlink" title="7层OSI参考模型"></a>7层OSI参考模型</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/21ab1b9d916d4b8cae802156ec04aedd.png" alt="img"></p>
<ul>
<li><strong>物理层</strong>：物理层的传输单位是比特，物理层的功能是在物理媒体上为数据端设备透明地<strong>传输原始比特流</strong>。物理层主要定义数据终端设备（DTE）和数据通信设备（DCE）的物理与逻辑连接方法。</li>
<li><strong>数据链路层</strong>：数据链路层的传输单位是帧，任务是将网络层传来的IP数据报组装称帧。数据链路层的功能可以概括为：<strong>物理寻址、成帧、差错控制、流量控制、传输管理。</strong></li>
<li><strong>网络层</strong>：网络层的传输单位是数据报，它的主要任务是把网络层的协议数据单元从源端传到目的端，为分组交换网上的不同主机提供通信服务。</li>
<li><strong>传输层</strong>：传输层的传输单位是报文段（TCP）或用户数据报（UDP），传输层负责主机中两个进程之间的通信，功能是为端到端连接提供可靠的传输服务，为端到端连接提供流量控制、差错控制、服务质量、数据传输管理等服务。ps：数据链路层提供的是点到点（IP到IP）之间的通信，而传输层可以直接实现端到端（不同主机间进程到进程）的通信，更加细致化。</li>
<li><strong>会话层</strong>：会话层允许不同主机上各个进程之间进行会话。会话层利用传输层提供的端到端的服务，向表示层提供它的增值服务。会话层负责管理主机间的会话进程，包括建立、管理及终止进程间的会话。</li>
<li><strong>表示层</strong>：表示层主要处理两个通信系统中交换信息的表示方式。因为不同机器采用的编码和数据结构等不同，所有使用表示层采用抽象的标准方法定义数据结构，并采用标准的编码形式。数据压缩、加密、解密也是表示层可提供的功能。</li>
<li><strong>应用层</strong>：是用户与网络的界面，为特定类型的网络应用提供访问OSI参考模型环境的手段，最复杂，也是协议最多的一层，常用的如FTP、HTTP、SMTP等。</li>
</ul>
<h4 id="通信过程"><a href="#通信过程" class="headerlink" title="通信过程"></a>通信过程</h4><ul>
<li>网络层及以上，每一层都要对上一层发送的数据进行处理（加个头部）</li>
<li>数据链路层不仅需要加头部，还需要加尾部</li>
<li>物理层什么都不加，只管发送数据（比特流）</li>
</ul>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220811151248217.png" alt="image-20220811151248217"></p>
<h3 id="4层TCP-x2F-IP模型"><a href="#4层TCP-x2F-IP模型" class="headerlink" title="4层TCP&#x2F;IP模型"></a>4层TCP&#x2F;IP模型</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/356f1d95e071413180b2e7b6ce4be106.png" alt="img"></p>
<h3 id="TCP-x2F-IP模型与OSI参考模型的比较"><a href="#TCP-x2F-IP模型与OSI参考模型的比较" class="headerlink" title="TCP&#x2F;IP模型与OSI参考模型的比较"></a>TCP&#x2F;IP模型与OSI参考模型的比较</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220811153536158.png" alt="image-20220811153536158"></p>
<p><strong>相同点</strong></p>
<ol>
<li>都分层</li>
<li>基于独立的协议栈的个概念</li>
<li>可以实现异构网络互连</li>
</ol>
<p><strong>不同点</strong></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220811152110530.png" alt="image-20220811152110530"></p>
<h2 id="五层参考模型"><a href="#五层参考模型" class="headerlink" title="五层参考模型"></a>五层参考模型</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/20200626210125977.png" alt="img"></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-计算机网络：计算机网络思维导图"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
	
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/08/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/"
    >计算机网络思维导图</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/08/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/" class="article-date">
  <time datetime="2022-08-10T01:25:23.000Z" itemprop="datePublished">2022-08-10</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">计算机基础知识</a> / <a class="article-category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.png" alt="计算机网络思维导图"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/%E7%89%A9%E7%90%86%E5%B1%82.png" alt="物理层"></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-操作系统：内存管理"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
	
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/08/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"
    >内存管理</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/08/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" class="article-date">
  <time datetime="2022-08-09T08:15:40.000Z" itemprop="datePublished">2022-08-09</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">计算机基础知识</a> / <a class="article-category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="内存的基础知识"><a href="#内存的基础知识" class="headerlink" title="内存的基础知识"></a>内存的基础知识</h1><h2 id="什么是内存？有何作用？"><a href="#什么是内存？有何作用？" class="headerlink" title="什么是内存？有何作用？"></a>什么是内存？有何作用？</h2><p>内存可存放数据。程序执行前<strong>需要先放到内存中才能被CPU处理</strong>——缓和CPU与硬盘之间的速度矛盾</p>
<p><strong>思考</strong>：在多道程序环境下，系统中会有多个程序并发执行，也就是说会有多个程序的数据需要同时放到内存中。那么，如何区分各个程序的数据是放在什么地方的呢？</p>
<p><strong>方案</strong>：给内存的存储单元编地址</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220809162437667.png" alt="image-20220809162437667"></p>
<h2 id="指令的工作原理"><a href="#指令的工作原理" class="headerlink" title="指令的工作原理"></a>指令的工作原理</h2><ul>
<li><strong>指令的工作基于“地址”</strong>。 每个地址对应一个数据的存储单元</li>
<li>我们写的代码要翻译成CPU能识别的指令。这些指令会告诉CPU应该去内存的哪个地址读&#x2F;写数据，这个数据应该做什么样的处理。默认让<strong>进程的相关内容从地址#0开始连续存放</strong>，指令中的地址参数直接给出了变量 x 的实际存放地址（<strong>物理地址</strong>）。</li>
</ul>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220809162945616.png" alt="image-20220809162945616"></p>
<h3 id="装入的三种方式"><a href="#装入的三种方式" class="headerlink" title="装入的三种方式"></a>装入的三种方式</h3><h4 id="绝对装入"><a href="#绝对装入" class="headerlink" title="绝对装入"></a>绝对装入</h4><ul>
<li>在编译时，如果知道程序将放到内存中的哪个位置，编译程序将<strong>产生绝对地址的目标代码</strong>。装入程序按照装入模块中的地址，将程序和数据装入内存。</li>
<li>绝对装入<strong>只适用于单道程序环境</strong>。 </li>
<li>程序中使用的绝对地址，可在编译或汇编时给出，也可由程序员直接赋予。通常情况下都是编译或汇编时再转换为绝对地址。</li>
</ul>
<h4 id="静态重定位"><a href="#静态重定位" class="headerlink" title="静态重定位"></a>静态重定位</h4><ul>
<li>又称<strong>可重定位装入</strong>。编译、链接后的装入模块的地址都是从0开始的，指令中使用的地址、数据存放的地址都是相对于起始地址而言的逻辑地址。可根据内存的当前情况，将装入模块装入到内存的适当位置。装入时对地址进行<strong>“重定位”</strong>，将逻辑地址变换为物理地址（地址变换是在装入时一次完成的）。</li>
<li>静态重定位的<strong>特点</strong>是在一个作业装入内存时，<strong>必须分配其要求的全部内存空间</strong>，如果没有足够的内存，就不能装入该作业。作业一旦进入内存后，<strong>在运行期间就不能再移动</strong>，也不能再申请内存空间。</li>
</ul>
<h4 id="动态重定位"><a href="#动态重定位" class="headerlink" title="动态重定位"></a>动态重定位</h4><ul>
<li>又称<strong>动态运行时装入</strong>。编译、链接后的装入模块的地址都是从0开始的。装入程序把装入模块装入内存后，并不会立即把逻辑地址转换为物理地址，而是<strong>把地址转换推迟到程序真正要执行时才进行</strong>。因此装入内存后所有的地址依然是逻辑地址。这种方式需要一个<strong>重定位寄存器</strong>的支持。</li>
<li><strong>重定位寄存器</strong>： 存放装入模块存放的<strong>起始位置</strong></li>
<li>可将程序分配到不连续的存储区中；在程序运行前只需装入它的部分代码即可投入运行，然后在<strong>程序运行期间，根据需要动态申请分配内存</strong>；便于程序段的共享，可以向用户提供一个比存储空间大得多的地址空间。</li>
<li>采用动态重定位时<strong>允许程序在内存中发生移动</strong>。</li>
</ul>
<h2 id="从写程序到程序运行"><a href="#从写程序到程序运行" class="headerlink" title="从写程序到程序运行"></a>从写程序到程序运行</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220809163445626.png" alt="image-20220809163445626"></p>
<p><strong>编译</strong>：由编译程序将用户源代码编译成若干个目标模块（编译就是<strong>把高级语言翻译为机器语言</strong>） </p>
<p><strong>链接</strong>：由链接程序将编译后形成的一组目标模块，以及所需库函数链接在一起，形成一个完整的装入模块装入（装载）：由装入程序将装入模块装入内存运行</p>
<h3 id="链接的三种方式"><a href="#链接的三种方式" class="headerlink" title="链接的三种方式"></a>链接的三种方式</h3><h4 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h4><p>在程序运行之前，先将各目标模块及它们所需的库函数连接成一个完整的可执行文件（装入模块），之后不再拆开。</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220809163733271.png" alt="image-20220809163733271"></p>
<h4 id="装入时动态链接"><a href="#装入时动态链接" class="headerlink" title="装入时动态链接"></a>装入时动态链接</h4><p>将各目标模块装入内存时，<strong>边装入边链接</strong>的链接方式。</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220809163752585.png" alt="image-20220809163752585"></p>
<h4 id="运行时动态链接"><a href="#运行时动态链接" class="headerlink" title="运行时动态链接"></a>运行时动态链接</h4><p>在程序执行中<strong>需要该目标模块时，才对它进行链接</strong>。其优点是便于修改和更新，便于实现对目标模块的共享。</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220809163816108.png" alt="image-20220809163816108"></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220809163844934.png" alt="image-20220809163844934"></p>
<h1 id="内存管理的概念"><a href="#内存管理的概念" class="headerlink" title="内存管理的概念"></a>内存管理的概念</h1><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220809180115814.png" alt="image-20220809180115814"></p>
<p>操作系统作为系统资源的管理者，当然也需要对内存进行管理，要管些什么呢？</p>
<ol>
<li><p>操作系统负责<strong>内存空间的分配与回收</strong></p>
</li>
<li><p>操作系统需要提供某种技术从逻辑上<strong>对内存空间进行扩充</strong></p>
</li>
<li><p>操作系统需要提供地址转换功能，负责程序的<strong>逻辑地址与物理地址</strong>的转换。为了使编程更方便，程序员写程序时应该只需要关注指令、数据的逻辑地址。而<strong>逻辑地址到物理地址的转换</strong>（这个过程称为<strong>地址重定位</strong>）应该由操作系统负责，这样就保证了程序员写程序时不需要关注物理内存的实际情况。</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220809180228042.png" alt="image-20220809180228042"></p>
</li>
<li><p>操作系统需要提供<strong>内存保护</strong>功能。保证各进程在各自存储空间内运行，互不干扰</p>
<p>内存保护可采取两种方法： </p>
<ul>
<li>方法一：在CPU中<strong>设置一对上、下限寄存器</strong>，存放进程的上、下限地址。进程的指令要访问某个地址时，CPU检查是否越界。</li>
<li>方法二：采用<strong>重定位寄存器</strong>（又称<strong>基址寄存器</strong>）和<strong>界地址寄存器</strong>（又称<strong>限长寄存器</strong>）进行越界检查。重定位寄存器中存放的是进程的<strong>起始物理地址</strong>。界地址寄存器中存放的是进程的<strong>最大逻辑地址</strong>。</li>
</ul>
</li>
</ol>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220809180357930.png" alt="image-20220809180357930"></p>
<h1 id="覆盖与交换"><a href="#覆盖与交换" class="headerlink" title="覆盖与交换"></a>覆盖与交换</h1><h2 id="覆盖技术"><a href="#覆盖技术" class="headerlink" title="覆盖技术"></a>覆盖技术</h2><ul>
<li>早期的计算机内存很小，比如 IBM 推出的第一台PC机最大只支持 1MB 大小的内存。因此经常会出现内存大小不够的情况。后来人们引入了<strong>覆盖技术</strong>，用来<strong>解决“程序大小超过物理内存总和”的问题</strong></li>
<li><strong>覆盖技术的思想</strong>：将<strong>程序分为多个段</strong>（多个模块）。常用的段常驻内存，不常用的段在需要时调入内存。内存中分为<strong>一个“固定区”</strong>和<strong>若干个“覆盖区”</strong>。 需要常驻内存的段放在<strong>“固定区”</strong>中，<strong>调入后就不再调出（除非运行结束）</strong> 不常用的段放在<strong>“覆盖区”</strong>，<strong>需要用到时调入内存，用不到时调出内存</strong></li>
</ul>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220809180820391.png" alt="image-20220809180820391"></p>
<ul>
<li><strong>必须由程序员声明覆盖结构，</strong>操作系统完成自动覆盖。<strong>缺点：对用户不透明，</strong>增加了用户编程负担。覆盖技术只用于早期的操作系统中，现在已成为历史。</li>
</ul>
<h2 id="交换技术"><a href="#交换技术" class="headerlink" title="交换技术"></a>交换技术</h2><ul>
<li>交换（对换）技术的设计思想：内存空间紧张时，系统将内存中某些进程暂时<strong>换出</strong>外存，把外存中某些已具备运行条件的进程<strong>换入</strong>内存（进程在内存与磁盘间动态调度）</li>
</ul>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220809180901488.png" alt="image-20220809180901488"></p>
<ul>
<li><p><strong>中级调度（内存调度）</strong>，就是要决定将哪个处于挂起状态的进程重新调入内存。</p>
</li>
<li><p>暂时换出外存等待的进程状态为<strong>挂起状态（挂起态，suspend）</strong>，挂起态又可以进一步细分为<strong>就绪挂起、阻塞挂起</strong>两种状态</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220809181009332.png" alt="image-20220809181009332"></p>
</li>
</ul>
<blockquote>
<p>问题：应该在外存（磁盘）的什么位置保存被换出的进程？</p>
<p>回答：具有对换功能的操作系统中，通常把<strong>磁盘空间</strong>分为<strong>文件区和对换区</strong>两部分。<strong>文件区</strong>主要用于存放文件，<strong>主要追求存储空间的利用率</strong>，因此对文件区空间的管理采用<strong>离散分配方式</strong>；<strong>对换区</strong>空间只占磁盘空间的小部分，<strong>被换出的进程数据就存放在对换区</strong>。由于对换的速度直接影响到系统的整体速度，因此对换区空间的管理<strong>主要追求换入换出速度</strong>，因此通常对换区采用<strong>连续分配方式</strong>。总之，<strong>对换区的I&#x2F;O速度比文件区的更快</strong>。</p>
<p>问题：什么时候应该交换？</p>
<p>回答：交换通常在许多进程运行且内存吃紧时进行，而系统负荷降低就暂停。例如：在发现许多进程运行时经常发生缺页，就说明内存紧张，此时可以换出一些进程； 如果缺页率明显下降，就可以暂停换出。</p>
<p>问题：应该换出哪些进程？</p>
<p>回答：可优先换出<strong>阻塞进程</strong>；可换出<strong>优先级低的进程</strong>；为了防止优先级低的进程在被调入内存后很快又被换出，有的系统还会考虑进程在内存的驻留时间…</p>
<p><strong>注意</strong>：<strong>PCB 会常驻内存</strong>，不会被换出外存</p>
</blockquote>
<h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220809181330272.png" alt="image-20220809181330272"></p>
<h1 id="连续分配管理方式"><a href="#连续分配管理方式" class="headerlink" title="连续分配管理方式"></a>连续分配管理方式</h1><p><strong>连续分配</strong>：指为用户进程分配的必须是<strong>一个连续的内存空间</strong>。</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220809181426494.png" alt="image-20220809181426494"></p>
<h2 id="单一连续分配"><a href="#单一连续分配" class="headerlink" title="单一连续分配"></a>单一连续分配</h2><ul>
<li>在单一连续分配方式中，内存被分为<strong>系统区和用户区</strong>。系统区通常位于内存的低地址部分，用于存放操作系统相关数据；用户区用于存放用户进程相关数据。 </li>
<li>内存中<strong>只能有一道用户程序</strong>，用户程序独占整个用户区空间。 </li>
<li><strong>优点</strong>：实现简单；<strong>无外部碎片</strong>；可以采用覆盖技术扩充内存；不一定需要采取内存保护（eg：早期的 PC 操作系统 MS-DOS）。 </li>
<li><strong>缺点</strong>：只能用于单用户、单任务的操作系统中；<strong>有内部碎片</strong>(分配给某进程的内存区域中，如果有些部分没有用上，就是“内部碎片”)；存储器利用率极低。</li>
</ul>
<h2 id="固定分区分配"><a href="#固定分区分配" class="headerlink" title="固定分区分配"></a>固定分区分配</h2><ul>
<li>20世纪60年代出现了支持多道程序的系统，为了能在内存中装入多道程序，且这些程序之间又不会相互干扰， 于是将<strong>整个用户空间</strong>划分为<strong>若干个固定大小的分区</strong>，在<strong>每个分区中只装入一道作业</strong>，这样就形成了最早的、最简单的一种可运行多道程序的内存管理方式。</li>
</ul>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220809181738782.png" alt="image-20220809181738782"></p>
<ul>
<li>分区大小相等：缺乏灵活性，但是很<strong>适合用于用一台计算机控制多个相同对象的场合</strong>（比如：钢铁厂有n个相同的炼钢炉，就可把内存分为n个大小相等的区域存放 n个炼钢炉控制程序） </li>
<li>分区大小不等：增加了灵活性，可以满足不同大小的进程需求。根据常在系统中运行的作业大小情况进行划分（比如：划分多个小分区、适量中等分区、少量大分区）</li>
<li>操作系统需要建立一个数据结构——<strong>分区说明表</strong>（用数据结构的数组（或 链表）即可表示这个表 ），来实现各个分区的分配与回收。每个表项对应一个分区，通常按分区大小排列。每个表项包括对应分区的<strong>大小、起始地址、状态</strong>（是否已分配）。 </li>
<li>当某用户程序要装入内存时，由操作系统内核程序根据用户程序大小检索该表，从中找到一个能满足大小的、未分配的分区，将之分配给该程序，然后修改状 态为“已分配”。 </li>
<li><strong>优点</strong>：实现简单，<strong>无外部碎片</strong>。 </li>
<li><strong>缺点</strong>：a. 当用户程序太大时，<strong>可能所有的分区都不能满足需求</strong>，此时不得不采用覆盖技术来解决，但这又会降低性能；b. <strong>会产生内部碎片</strong>，内存利用率低。</li>
</ul>
<h2 id="动态分区分配"><a href="#动态分区分配" class="headerlink" title="动态分区分配"></a>动态分区分配</h2><ul>
<li><p>动态分区分配又称为<strong>可变分区分配</strong>。这种分配方式<strong>不会预先划分内存分区</strong>，而是在进程装入内存时，<strong>根据进程的大小动态地建立分区</strong>，并使分区的大小正好适合进程的需要。因此系统分区的大小和数目是可变的。</p>
</li>
<li><p><strong>系统要用什么样的数据结构记录内存的使用情况？</strong></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220809182136031.png" alt="image-20220809182136031"></p>
<ul>
<li><strong>空闲分区表</strong>：每个空闲分区对应一个表项。表项中包含<strong>分区号、分区大小、分区起始地址</strong>等信息</li>
<li><strong>空闲分区链</strong>：每个分区的起始部分和末尾部分分别设置<strong>前向指针和后向指针</strong>。起始部分处还可记录分区大小等信息</li>
</ul>
</li>
<li><p><strong>当很多个空闲分区都能满足需求时，应该选择哪个分区进行分配？</strong></p>
<ul>
<li>把一个新作业装入内存时，须按照一定的<strong>动态分区分配算法</strong>，从空闲分区表（或空闲分区链）中选出一个分区分配给该作业。由于分配算法算法对系统性能有很大的影响，因此人们对它进行了广泛的研究。 下个小节会介绍<strong>四种动态分区分配算法</strong>…</li>
</ul>
</li>
<li><p><strong>如何进行分区的分配与回收操作？</strong>假设系统采用的数据结构是“空闲分区表”…<strong>如何分配？</strong> </p>
<ul>
<li><p>情况一：回收区的后面有一个相邻的空闲分区</p>
<ul>
<li>两个相邻的空闲分区合并为一个</li>
</ul>
</li>
<li><p>情况二：回收区的前面有一个相邻的空闲分区</p>
<ul>
<li>两个相邻的空闲分区合并为一个</li>
</ul>
</li>
<li><p>情况三：回收区的前、后各有一个相邻的空闲分区</p>
<ul>
<li>三个相邻的空闲分区合并为一个</li>
</ul>
</li>
<li><p>情况四：回收区的前、后都没有相邻的空闲分区</p>
<ul>
<li>新增一个表项。注：各表项的顺序不一定按照地址递增顺序排列，具体的排列方式需要依据动态分区分配算法来确定。</li>
</ul>
</li>
</ul>
</li>
<li><p>动态分区分配<strong>没有内部碎片</strong>，但是<strong>有外部碎片</strong>。<strong>内部碎片，分配给某进程的内存区域中，如果有些部分没有用上。外部碎片，是指内存中的某些空闲分区由于太小而难以利用。</strong> </p>
</li>
<li><p>如果内存中空闲空间的总和本来可以满足某进程的要求，但由于进程需要的是一整块连续的内存空间，因此这些“碎片”不能满足进程的需求。可以通过<strong>紧凑（拼凑，Compaction）</strong>技术来解决外部碎片。<strong>动态重定位装入方式</strong></p>
</li>
</ul>
<h2 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220809182840552.png" alt="image-20220809182840552"></p>
<h1 id="动态分区分配算法"><a href="#动态分区分配算法" class="headerlink" title="动态分区分配算法"></a>动态分区分配算法</h1><p>动态分区分配算法：在动态分区分配方式中， 当很多个空闲分区都能满足需求时，应该选择哪个分区进行分配？</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220809182928123.png" alt="image-20220809182928123"> </p>
<h2 id="首次适应算法"><a href="#首次适应算法" class="headerlink" title="首次适应算法"></a>首次适应算法</h2><p><strong>算法思想</strong>：每次都从低地址开始查找，找到第一个能满足大小的空闲分区。 </p>
<p><strong>实现</strong>：<strong>空闲分区以地址递增的次序排列</strong>。每次分配内存时顺序查找<strong>空闲分区链（或空闲分区表）</strong>，找到大小能满足要求的第一个空闲分区。</p>
<h2 id="最佳适应算法"><a href="#最佳适应算法" class="headerlink" title="最佳适应算法"></a>最佳适应算法</h2><p><strong>算法思想</strong>：由于动态分区分配是一种连续分配方式，为各进程分配的空间必须是连续的一整片区域。因此为了保证当“大进程”到来时能有连续的大片空间，可以尽可能多地留下大片的空闲区，即，<strong>优先使用更小的空闲区</strong>。  </p>
<p><strong>实现</strong>：空闲分区<strong>按容量递增次序链接</strong>。每次分配内存时顺序查找<strong>空闲分区链（或空闲分区表）</strong>，找到大小能满足要求的第一个空闲分区。 </p>
<p><strong>缺点：每次都选最小的分区进行分配，会留下越来越多的、很小的、难以利用的内存块。因此这种方法会产生很多的外部碎片。</strong></p>
<h2 id="最坏适应算法"><a href="#最坏适应算法" class="headerlink" title="最坏适应算法"></a>最坏适应算法</h2><p>又称<strong>最大适应算法（Largest Fit）</strong> </p>
<p><strong>算法思想</strong>：为了解决最佳适应算法的问题——即留下太多难以利用的小碎片，可以在每次分配时优先使用最大的连续空闲区，这样分配后剩余的空闲区就不会太小，更方便使用。 </p>
<p><strong>实现</strong>：空闲分区<strong>按容量递减次序链接</strong>。每次分配内存时顺序查找<strong>空闲分区链（或空闲分区表）</strong>，找到大小能满足要求的第一个空闲分区。 </p>
<p><strong>缺点：每次都选最大的分区进行分配，虽然可以让分配后留下的空闲区更大，更可用，但是这种方式会导致较大的连续空闲区被迅速用完。如果之后有“大进程”到达，就没有内存分区可用了。</strong></p>
<h2 id="邻近适应算法"><a href="#邻近适应算法" class="headerlink" title="邻近适应算法"></a>邻近适应算法</h2><p><strong>算法思想</strong>：首次适应算法每次都从链头开始查找的。这可能会导致低地址部分出现很多小的空闲分区，而每次分配查找时，都要经过这些分区，因此也增加了查找的开销。如果每次都从上次查 找结束的位置开始检索，就能解决上述问题。 </p>
<p><strong>实现</strong>：空闲分区<strong>以地址递增的顺序排列</strong>（可排成一个循环链表）。每次分配内存时<strong>从上次查找结束的位置开始</strong>查找<strong>空闲分区链（或空闲分区表）</strong>，找到大小能满足要求的第一个空闲分区。 </p>
<p>首次适应算法每次都要从头查找，每次都需要检索低地址的小分区。 但是这种规则也决定了当低地址部分有更小的分区可以满足需求时，会更有可能用到低地址部分的小分区，也会更有可能把高地址部分的大分区保留下来(<strong>最佳适应算法的优点</strong>)</p>
<p>邻近适应算法的规则可能会导致无论低地址、高地址部分的空闲分区都有相同的概率被使用，也就导致了高地址部分的大分区更可能被使用，划分为小分区，最后导致无大分区可用(<strong>最大适应法的缺点</strong>)</p>
<p>综合来看，<strong>四种算法中，首次适应算法的效果反而更好</strong></p>
<h2 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220809183507690.png" alt="image-20220809183507690"></p>
<h1 id="非连续分配管理方式"><a href="#非连续分配管理方式" class="headerlink" title="非连续分配管理方式"></a>非连续分配管理方式</h1><ul>
<li>非连续分配：为用户进程分配的可以是一些<strong>分散的内存空间</strong>。</li>
</ul>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220809205655209.png" alt="image-20220809205655209"></p>
<h2 id="基本分页存储管理"><a href="#基本分页存储管理" class="headerlink" title="基本分页存储管理"></a>基本分页存储管理</h2><ul>
<li>将<strong>内存空间</strong>分为一个个<strong>大小相等的分区</strong>（比如：每个分区4KB），每个分区就是一个<strong>“页框”（页框&#x3D;页帧&#x3D;内存块&#x3D;物理块&#x3D;物理页面）</strong>。每个页框有一个编号，即<strong>“页框号”</strong>（<strong>页框号&#x3D;页帧号&#x3D;内存块号&#x3D;物理块号&#x3D;物理页号</strong>），页框号<strong>从0开始</strong>。 </li>
<li>将<strong>进程的逻辑地址空间</strong>也分为<strong>与页框大小相等</strong>的一个个部分，每个部分称为一个<strong>“页”或“页面”</strong> 。每个页面也有一个编号，即<strong>“页号”</strong>，页号也是<strong>从0开始</strong>。</li>
<li>操作系统<strong>以页框为单位为各个进程分配内存空间</strong>。进程的每个页面分别放入一个页框中。也就是说，进程的<strong>页面</strong>与内存的<strong>页框</strong>有<strong>一一对应</strong>的关系。 各个页面不必连续存放，可以放到不相邻的各个页框中。 </li>
<li>注：进程的最后一个页面可能没有一个页框那么大。也就是说，分页存储有可能产生内部碎片，因此<strong>页框不能太大，否则可能产生过大的内部碎片造成浪费</strong></li>
</ul>
<h3 id="如何实现地址的转换"><a href="#如何实现地址的转换" class="headerlink" title="如何实现地址的转换"></a>如何实现地址的转换</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220809212933118.png" alt="image-20220809212933118"></p>
<ul>
<li><strong>页号</strong> &#x3D; 逻辑地址 &#x2F; 页面长度 （取除法的<strong>整数</strong>部分） </li>
<li><strong>页内偏移量</strong> &#x3D; 逻辑地址 % 页面长度（取除法的<strong>余数</strong>部分）</li>
</ul>
<h3 id="逻辑地址结构"><a href="#逻辑地址结构" class="headerlink" title="逻辑地址结构"></a>逻辑地址结构</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220809210643508.png" alt="image-20220809210643508"></p>
<p>地址结构包含两个部分：前一部分为页号，后一部分为页内偏移量 W。在上图所示的例子中，地址长度为 32 位，其中 0<del>11位 为<strong>“页内偏移量”</strong>，或称<strong>“页内地址”</strong>；12</del>31 位为<strong>“页号”</strong>。 </p>
<p><strong>如果有 K 位表示“页内偏移量”，则说明该系统中一个页面的大小是 2的 K 次方个内存单元</strong> </p>
<p><strong>如果有 M 位表示“页号”，则说明在该系统中，一个进程最多允许有 2的 M 次方个页面</strong></p>
<blockquote>
<p>Tips：有些奇葩题目中页面大小有可能不是2的整数次幂，这种情况还是得用最原始的方法计算： </p>
<p><strong>页号</strong> &#x3D; 逻辑地址 &#x2F; 页面长度 （取除法的<strong>整数</strong>部分） </p>
<p><strong>页内偏移量</strong> &#x3D; 逻辑地址 % 页面长度（取除法的<strong>余数</strong>部分）</p>
</blockquote>
<h3 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h3><ul>
<li><p>为了能知道进程的每个页面在内存中存放的位置，操作系统要为每个进程建立一张<strong>页表</strong>。 </p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220809213423340.png" alt="image-20220809213423340"></p>
<ol>
<li><p>一个进程对应一张页表</p>
</li>
<li><p>进程的每个页面对应一个页表项</p>
</li>
<li><p>每个<strong>页表项</strong>由“页号”和“块号”组成</p>
</li>
<li><p>页表记录进程<strong>页面</strong>和实际存放的<strong>内存块</strong>之间的<strong>映射关系</strong></p>
</li>
<li><p>每个页表项的长度是相同的</p>
</li>
</ol>
</li>
<li><p>注：页表通常存在PCB（进程控制块）中</p>
</li>
</ul>
<blockquote>
<p><strong>问题二：如何实现地址的转换</strong></p>
<p>回答：重定位寄存器：指明了进程在内存中的起始位置</p>
<p><strong>子问题：为何页面大小要取2的整数幂？</strong></p>
<p>回答：如果每个页面大小为<strong>2的k次方B</strong>，用二进制数表示逻辑地址，则末尾K位即为<strong>页内偏移量</strong>，其余部分就是<strong>页号</strong>。因此，<strong>如果让每个页面的大小为2的整数幂</strong>，计算机就可以很方便地得出一个逻辑地址对应的页号和页内偏移量。</p>
</blockquote>
<h3 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220809210850194.png" alt="image-20220809210850194"></p>
<h2 id="基本分段存储管理"><a href="#基本分段存储管理" class="headerlink" title="基本分段存储管理"></a>基本分段存储管理</h2><h3 id="分段"><a href="#分段" class="headerlink" title="分段"></a>分段</h3><ul>
<li>进程的地址空间：按照程序<strong>自身的逻辑关系划分为若干个段</strong>，每个段都有一个段名（在低级语言中，程序员使用段名来编程），<strong>每段从0开始编址</strong> </li>
<li>内存分配规则：以段为单位进行分配，<strong>每个段在内存中占据连续空间</strong>，但<strong>各段之间可以不相邻</strong>。</li>
</ul>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220809214702751.png" alt="image-20220809214702751"></p>
<ul>
<li>由于是按逻辑功能模块划分，<strong>用户编程更方便，程序的可读性更高</strong></li>
</ul>
<h3 id="逻辑地址结构-1"><a href="#逻辑地址结构-1" class="headerlink" title="逻辑地址结构"></a>逻辑地址结构</h3><ul>
<li><p>分段系统的逻辑地址结构由<strong>段号（段名）和段内地址（段内偏移量）</strong>所组成。如：</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220809211051480.png" alt="image-20220809211051480"></p>
<p><strong>段号的位数决定了每个进程最多可以分几个段</strong> </p>
<p><strong>段内地址位数决定了每个段的最大长度是多少</strong></p>
</li>
</ul>
<h3 id="段表"><a href="#段表" class="headerlink" title="段表"></a>段表</h3><p>问题：程序分多个段，各段离散地装入内存，为了保证程序能正常运行，就必须能从物理内存中找到各个逻辑段的存放位置。为此，需为每个进程建立一张段映射表，简称<strong>“段表”</strong>。</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220809211545223.png" alt="image-20220809211545223"></p>
<ol>
<li><p>每个段对应一个段表项，其中记录了该段在内存中的起始位置（又称 “基址”）和段的长度。</p>
</li>
<li><p>各个段表项的长度是相同的。例如：某系统按字节寻址，采用分段存储管理，逻辑地址结构为（段号16位, 段内地址16位），因此用16位 即可表示最大段长。物理内存大小为4GB（可用32位表示整个物理内存地址空间）。因此，可以让每个段表项占 16+32 &#x3D; 48位，即6B。由于段表项长度相同，因此<strong>段号可以是隐含的，不占存储空间。</strong>若段表存放的起始地址为 M，则 K号段对应的段表项存放的地址为 M + K*6</p>
</li>
</ol>
<h3 id="分段、分页管理的对比"><a href="#分段、分页管理的对比" class="headerlink" title="分段、分页管理的对比"></a>分段、分页管理的对比</h3><ul>
<li><strong>页是信息的物理单位</strong>。分页的主要目的是为了实现离散分配，提高内存利用率。分页仅仅是系统管理上的需要，完全是系统行为，<strong>对用户是不可见的</strong>。 </li>
<li><strong>段是信息的逻辑单位</strong>。分段的主要目的是更好地满足用户需求。一个段通常包含着一组属于一个逻辑模块的信息。<strong>分段对用户是可见的</strong>，用户编程时需要显式地给出段名。 </li>
<li>页的大小固定且由系统决定。段的长度却不固定，决定于用户编写的程序。 </li>
<li><strong>分页的用户进程地址空间是一维的</strong>，程序员只需给出一个记忆符即可表示一个地址。 </li>
<li><strong>分段的用户进程地址空间是二维的</strong>，程序员在标识一个地址时，既要给出段名，也要给出段内地址。</li>
<li><strong>分段比分页更容易实现信息的共享和保护</strong>。</li>
<li>不能被修改的代码称为<strong>纯代码或可重入代码</strong>（不属于临界资源），这样的代码是可以共享的。可修改的代码是不能共享的</li>
<li>访问一个逻辑地址需要几次访存？ <ul>
<li><strong>分页（单级页表）</strong>：第一次访存——查内存中的页表，第二次访存——访问目标内存单元。总共<strong>两次访存</strong></li>
<li><strong>分段</strong>：第一次访存——查内存中的段表，第二次访存——访问目标内存单元。总共<strong>两次访存</strong></li>
</ul>
</li>
<li>与分页系统类似，分段系统中也可以引入<strong>快表</strong>机构，将近期访问过的段表项放到快表中，这样<strong>可以少一次访问</strong>，加快地址变换速度。</li>
</ul>
<h3 id="小结-5"><a href="#小结-5" class="headerlink" title="小结"></a>小结</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220809215708744.png" alt="image-20220809215708744"></p>
<h2 id="段页式管理方式"><a href="#段页式管理方式" class="headerlink" title="段页式管理方式"></a>段页式管理方式</h2><h3 id="分页、分段的优缺点"><a href="#分页、分段的优缺点" class="headerlink" title="分页、分段的优缺点"></a>分页、分段的优缺点<img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220809215945638.png" alt="image-20220809215945638"></h3><p>分段管理中产生的外部碎片也可以用“紧凑”来解决，只是需要付出较大的时间代价</p>
<h3 id="逻辑地址结构-2"><a href="#逻辑地址结构-2" class="headerlink" title="逻辑地址结构"></a>逻辑地址结构</h3><p>段页式系统的逻辑地址结构由段号、页号、页内地址（页内偏移量）组成。如:</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220809220208624.png" alt="image-20220809220208624"></p>
<ul>
<li><p><strong>段号的位数决定了每个进程最多可以分几个段</strong></p>
</li>
<li><p><strong>页号位数决定了每个段最大有多少页</strong></p>
</li>
<li><p><strong>页内偏移量决定了页面大小、内存块大小是多少</strong></p>
</li>
<li><p><strong>“分段”对用户是可见的</strong>，程序员编程时需要显式地给出段号、段内地址。而将各段“分页”对用户是不可见的。系统会根据段内地址自动划分页号和页内偏移量。因此<strong>段页式管理的地址结构是二维的</strong>。</p>
</li>
</ul>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220809220543860.png" alt="image-20220809220543860"></p>
<h3 id="小结-6"><a href="#小结-6" class="headerlink" title="小结"></a>小结</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220809220753418.png" alt="image-20220809220753418"></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-操作系统：死锁"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
	
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/08/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%9A%E6%AD%BB%E9%94%81/"
    >死锁</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/08/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%9A%E6%AD%BB%E9%94%81/" class="article-date">
  <time datetime="2022-08-09T06:29:54.000Z" itemprop="datePublished">2022-08-09</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">计算机基础知识</a> / <a class="article-category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="死锁的概念"><a href="#死锁的概念" class="headerlink" title="死锁的概念"></a>死锁的概念</h1><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220809145814467.png" alt="image-20220809145814467"></p>
<h2 id="死锁、饥饿、死循环的区别"><a href="#死锁、饥饿、死循环的区别" class="headerlink" title="死锁、饥饿、死循环的区别"></a>死锁、饥饿、死循环的区别</h2><ul>
<li><strong>死锁</strong>：在并发环境下，各进程因竞争资源而造成的一种互相等待对方手里的资源，导致各进程都阻塞，都无法向前推进的现象，就是“死锁”发生后若无外力干涉,这些进程都将无法向前推进。</li>
<li><strong>饥饿</strong>：长期得不到想要的资源，某进程无法向前推进</li>
<li><strong>死循环</strong>：某进程执行过程中一直跳不出某个循环</li>
</ul>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220809150235076.png" alt="image-20220809150235076"></p>
<h2 id="死锁产生的必要条件"><a href="#死锁产生的必要条件" class="headerlink" title="死锁产生的必要条件"></a>死锁产生的必要条件</h2><p>产生死锁必须同时满足以下四个条件，若有一个不满足，死锁就不会发生</p>
<ol>
<li><strong>互斥条件</strong>：对互斥使用的资源的争夺才会导致死锁</li>
<li><strong>不剥夺条件</strong>：进程获得的资源在未使用完之前，<strong>不能由其他进程强行夺走，只能主动释放</strong></li>
<li><strong>请求和保持条件</strong>：进程<strong>已经保持了至少一个资源</strong>，但又提出了新的资源<strong>请求</strong>，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源<strong>保持</strong>不放</li>
<li><strong>循环等待条件</strong>：存在一种进程<strong>资源的循环等待链</strong>，链中的每一个进程已获得的资源同时被下一个进程所请求</li>
</ol>
<p><strong>注意</strong>：<strong>发生死锁时一定有循环等待，但是发生循环等待时未必死锁</strong>（循环等待是死锁的必要不充分条件)</p>
<p>如果同类资源数大于1，则即使有循环等待，也未必发生死锁。但如果系统中每类资源都只有一个，那循环等待就是死锁的充分必要条件了。</p>
<p><strong>什么时候会发生死锁？</strong></p>
<ol>
<li><strong>对系统资源的竞争</strong>。各进程对不可剥夺的资源（如打印机）的竞争可能引起死锁，对可剥夺的资源（CPU）的竞争是不会引起死锁的。</li>
<li><strong>进程推进顺序非法</strong>。请求和释放资源的顺序不当，也同样会导致死锁。例如，并发执行的进程P1、P2分别申请并占有了资源R1、R2，之后进程P1又紧接着申请资源R2，而进程P2又申请资源R1，两者会因为申请的资源被对方占有而阻塞，从而发生死锁。</li>
<li><strong>信号量的使用不当也会造成死锁</strong>。如生产者-消费者问题中，如果实现互斥的P操作在实现同步的P操作之前，就有可能导致死锁。(可以把互斥信号量、同步信号量也看做是一种抽象的系统资源)</li>
</ol>
<p>总之，<strong>对不可剥夺资源的不合理分配，可能导致死锁</strong>。</p>
<h2 id="死锁的处理策略"><a href="#死锁的处理策略" class="headerlink" title="死锁的处理策略"></a>死锁的处理策略</h2><ol>
<li><strong>预防死锁</strong>：破坏死锁产生的四个必要条件中的一个或几个</li>
<li><strong>避免死锁</strong>：用某种方法防止系统进入不安全状态，从而避免死锁</li>
<li><strong>死锁的检测和解除</strong>：允许死锁的发生，操作系统检测出死锁后，会采取措施解除死锁</li>
</ol>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220809151314255.png" alt="image-20220809151314255"></p>
<h1 id="死锁的处理策略-1"><a href="#死锁的处理策略-1" class="headerlink" title="死锁的处理策略"></a>死锁的处理策略</h1><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220809151439640.png" alt="image-20220809151439640"></p>
<h2 id="预防死锁"><a href="#预防死锁" class="headerlink" title="预防死锁"></a>预防死锁</h2><h3 id="破坏互斥条件"><a href="#破坏互斥条件" class="headerlink" title="破坏互斥条件"></a>破坏互斥条件</h3><p><strong>互斥条件</strong>：只有对必须互斥使用的资源的争抢才会导致死锁。 </p>
<p><strong>方案</strong>：如果把只能互斥使用的资源改造为允许共享使用，则系统不会进入死锁状态。比如: SPOOLing技术。 操作系统可以采用 SPOOLing 技术把独占设备在逻辑上改造成共享设备。比如，用SPOOLing技术将打印机改造为共享设备</p>
<p><strong>缺点</strong>：并不是所有的资源都可以改造成可共享使用的资源。并且为了系统安全，很多地方还必须保护这种互斥性。因此，<strong>很多时候都无法破坏互斥条件</strong>。</p>
<h3 id="破坏不剥夺条件"><a href="#破坏不剥夺条件" class="headerlink" title="破坏不剥夺条件"></a>破坏不剥夺条件</h3><p><strong>不剥夺条件</strong>：进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放。 </p>
<p><strong>方案一</strong>：当某个进程请求新的资源得不到满足时，它必须立即释放保持的所有资源，待以后需要时再重新申请。也就是说，即使某些资源尚未使用完，也需要主动释放，从而破坏了不可剥夺条件。 </p>
<p><strong>方案二</strong>：当某个进程需要的资源被其他进程所占有的时候，可以由操作系统协助，<strong>将想要的资源强行剥夺</strong>。这种方式一般需要考虑各进程的<strong>优先级</strong>（比如：剥夺调度方式，就是将处理机资源强行剥夺给优先级更高的进程使用） </p>
<p><strong>缺点</strong>：</p>
<ol>
<li><p>实现起来比较复杂。</p>
</li>
<li><p>释放已获得的资源可能造成前一阶段工作的失效。因此这种方法一般<strong>只适用于易保存和恢复状态的资源，如CPU</strong>。</p>
</li>
<li><p>反复地申请和释放资源会增加系统开销，降低系统吞吐量。 </p>
</li>
<li><p>若采用方案一，意味着只要暂时得不到某个资源，之前获得的那些资源就都需要放弃，以后再重新申请。如果一直发生这样的情况，就会导致进程饥饿。</p>
</li>
</ol>
<h3 id="破坏请求和保持条件"><a href="#破坏请求和保持条件" class="headerlink" title="破坏请求和保持条件"></a>破坏请求和保持条件</h3><p><strong>请求和保持条件</strong>：进程<strong>已经保持了至少一个资源</strong>，但又提出了新的资源<strong>请求</strong>，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源<strong>保持</strong>不放。 </p>
<p><strong>方案</strong>：可以采用<strong>静态分配方法</strong>，即进程在运行前一次申请完它所需要的全部资源，在它的资源未满足前，不让它投入运行。一旦投入运行后，这些资源就一直归它所有，该进程就不会再请求别的任何资源了。</p>
<p>该策略实现起来简单，但也有明显的<strong>缺点</strong>： 有些资源可能只需要用很短的时间，因此如果进程的整个运行期间都一直保持着所有资源，就会造 成严重的资源浪费，<strong>资源利用率极低</strong>。另外，该策略也有可能导致某些<strong>进程饥饿</strong>。 </p>
<h3 id="破坏循环等待条件"><a href="#破坏循环等待条件" class="headerlink" title="破坏循环等待条件"></a>破坏循环等待条件</h3><p><strong>循环等待条件</strong>：存在一种进程<strong>资源的循环等待链</strong>，链中的每一个进程已获得的资源同时被下一个进程所请求。 </p>
<p><strong>方案</strong>：可采用<strong>顺序资源分配法</strong>。首先给系统中的资源编号，规定每个进程<strong>必须按编号递增的顺序请求资源</strong>，同类资源（即编号相同的资源）一次申请完。 </p>
<p><strong>原理分析</strong>：一个进程只有已占有小编号的资源时，才有资格申请更大编号的资源。按此规则，已持有大编号资源的进程不可能逆向地回来申请小编号的资源，从而就不会产生循环等待的现象。 </p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220809152933700.png" alt="image-20220809152933700"></p>
<p><strong>缺点</strong>：</p>
<ol>
<li><p>不方便增加新的设备，因为可能需要重新分配所有的编号；</p>
</li>
<li><p>进程实际使用资源的顺序可能和编号递增顺序不一致，会导致资源浪费；</p>
</li>
<li><p>必须按规定次序申请资源，用户编程麻烦。</p>
</li>
</ol>
<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220809153056996.png" alt="image-20220809153056996"></p>
<h2 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220809153714085.png" alt="image-20220809153714085"></p>
<p><strong>安全序列、不安全状态、死锁的联系</strong></p>
<ul>
<li>所谓<strong>安全序列</strong>，就是指如果系统按照这种序列分配资源，则每个进程都能顺利完成。只要能找出一个安全序列，系统就是<strong>安全状态</strong>。当然，<strong>安全序列可能有多个。</strong> </li>
<li>如果分配了资源之后，系统中找不出任何一个安全序列，系统就进入了<strong>不安全状态</strong>。这就意味着之后<strong>可能</strong>所有进程都无法顺利的执行下去。当然，如果有进程提前归还了一些资源，那<strong>系统也有可能重新回到安全状态</strong>，不过我们在分配资源之前总是要考虑到最坏的情况。</li>
<li>如果系统处于<strong>安全状态</strong>，就<strong>一定不会发生死锁</strong>。如果系统进入<strong>不安全状态</strong>，就<strong>可能发生死锁</strong>（处于不安全状态未必就是发生了死锁，但发生死锁时一定是在不安全状态） </li>
<li>因此可以<strong>在资源分配之前预先判断这次分配是否会导致系统进入不安全状态</strong>，以此决定是否答应资分配请求。这也是<strong>“银行家算法”</strong>的核心思想。</li>
</ul>
<h3 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h3><p><strong>核心思想</strong>：在进程提出资源申请时，先预判此次分配是否会导致系统进入不安全状态。如果会进入不安全状态，就暂时不答应这次请求，让该进程先阻塞等待。 </p>
<p><strong>数据结构</strong>： </p>
<ul>
<li>长度为 m 的一维数组 Available 表示还有多少可用资源 </li>
<li>n*m 矩阵 Max 表示各进程对资源的最大需求数 </li>
<li>n*m 矩阵 Allocation 表示已经给各进程分配了多少资源</li>
<li>Max – Allocation &#x3D; Need 矩阵表示各进程最多还需要多少资源 </li>
<li>用长度为 m 的一位数组 Request 表示进程此次申请的各种资源数</li>
</ul>
<p><strong>银行家算法步骤</strong>： </p>
<ol>
<li>检查此次申请是否超过了之前声明的最大需求数 </li>
<li>检查此时系统剩余的可用资源是否还能满足这次请求 </li>
<li>试探着分配，更改各数据结构 </li>
<li>用<strong>安全性算法检查</strong>此次分配是否会导致系统进入不安全状态</li>
</ol>
<p><strong>安全性算法步骤</strong>： </p>
<ul>
<li>检查当前的剩余可用资源是否能满足某个进程的最大需求，如果可以，就把该进程加入安全序列， 并把该进程持有的资源全部回收。 不断重复上述过程，看最终是否能让所有进程都加入安全序列。</li>
</ul>
<p>系统处于不安全状态未必死锁，但死锁时一定处于不安全状态。系统处于安全状态一定不会死锁。</p>
<h2 id="死锁的检测与解除"><a href="#死锁的检测与解除" class="headerlink" title="死锁的检测与解除"></a>死锁的检测与解除</h2><p>如果系统中既不采取预防死锁的措施，也不采取避免死锁的措施，系统就很可能发生死锁。在这种情况下，系统应当提供两个算法： </p>
<ol>
<li><strong>死锁检测算法</strong>：用于检测系统状态，以确定系统中是否发生了死锁。 </li>
<li><strong>死锁解除算法</strong>：当认定系统中已经发生了死锁，利用该算法可将系统从死锁状态中解脱出来。</li>
</ol>
<h3 id="死锁的检测"><a href="#死锁的检测" class="headerlink" title="死锁的检测"></a>死锁的检测</h3><p>为了能对系统是否已发生了死锁进行检测，必须： </p>
<ol>
<li>用<strong>某种数据结构</strong>来保存资源的请求和分配信息； </li>
<li>提供<strong>一种算法</strong>，利用上述信息来检测系统是否已进入死锁状态。</li>
</ol>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220809160100602.png" alt="image-20220809160100602"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220809160154793.png" alt="image-20220809160154793"></p>
<p><strong>原理</strong></p>
<ol>
<li><p>如果系统中剩余的可用资源数足够满足进程的需求，那么这个进程暂时是不会阻塞的，可以顺利地执行下去。 </p>
</li>
<li><p>如果这个进程执行结束了把资源归还系统，就可能使某些正在等待资源的进程被激活，并顺利地执行下去。 </p>
</li>
<li><p>相应的，这些被激活的进程执行完了之后又会归还一些资源，这样可能又会激活另外一些阻塞的进程… </p>
</li>
<li><p>如果按上述过程分析，<strong>最终能消除所有边</strong>，就称这个图是<strong>可完全简化的</strong>。此时一定<strong>没有发生死锁</strong>（相当于能找到一个安全序列） </p>
</li>
<li><p>如果<strong>最终不能消除所有边</strong>，那么此时就是发生了<strong>死锁</strong> </p>
</li>
<li><p><strong>最终还连着边的那些进程就是处于死锁状态的进程。</strong></p>
</li>
</ol>
<p><strong>检测死锁的算法</strong></p>
<ol>
<li>在资源分配图中，找出<strong>既不阻塞又不是孤点</strong>的进程 Pi（即找出一条有向边与它相连，且该有向边对应资源的申请数量小于等于系统中已有空闲资源数量。如下图中，R1没有空闲资源，R2有 一个空闲资源。若所有的连接该进程的边均满足上述条件，则这个进程能继续运行直至完成，然 后释放它所占有的所有资源）。消去它所有的请求边和分配变，使之称为孤立的结点。在上图中，P1 是满足这一条件的进程结点，于是将P1的所有边消去。 </li>
<li>进程 Pi 所释放的资源，可以唤醒某些因等待这些资源而阻塞的进程，原来的阻塞进程可能变为非阻塞进程。在下图中，P2 就满足这样的条件。根据 1）中的方法进行一系列简化后，若能消去途中所有的边，则称该图是<strong>可完全简化的</strong>。</li>
</ol>
<p><strong>死锁定理</strong>：如果某时刻系统的资源分配图是<strong>不可完全简化</strong>的，那么此时系统<strong>死锁</strong></p>
<h3 id="死锁的解除"><a href="#死锁的解除" class="headerlink" title="死锁的解除"></a>死锁的解除</h3><p>一旦检测出死锁的发生，就应该立即解除死锁。 </p>
<p>补充：并不是系统中所有的进程都是死锁状态，用死锁检测算法<strong>化简资源分配图后，还连着边的那些进程就是死锁进程</strong> </p>
<p>解除死锁的主要方法有：</p>
<ol>
<li><p><strong>资源剥夺法</strong>。挂起（暂时放到外存上）某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。但是应防止被挂起的进程长时间得不到资源而饥饿。</p>
</li>
<li><p><strong>撤销进程法</strong>（或称<strong>终止进程法</strong>）。强制撤销部分、甚至全部死锁进程，并剥夺这些进程的资 源。这种方式的优点是实现简单，但所付出的代价可能会很大。因为有些进程可能已经运行了很长时间，已经接近结束了，一旦被终止可谓功亏一篑，以后还得从头再来。</p>
</li>
<li><p><strong>进程回退法</strong>。让一个或多个死锁进程回退到足以避免死锁的地步。这就要求系统要记录进程的历史信息，设置还原点。</p>
</li>
</ol>
<p><strong>如何决定“对谁动手”</strong></p>
<ol>
<li>进程优先级</li>
<li>已执行多长时间</li>
<li>还要多久能完成</li>
<li>进程已经使用了多少资源</li>
<li>进程是交互式的还是批处理式的</li>
</ol>
<h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220809161056512.png" alt="image-20220809161056512"></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-操作系统：进程同步、互斥"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
	
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/08/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%9A%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E3%80%81%E4%BA%92%E6%96%A5/"
    >进程同步、互斥</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/08/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%9A%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E3%80%81%E4%BA%92%E6%96%A5/" class="article-date">
  <time datetime="2022-08-08T12:11:49.000Z" itemprop="datePublished">2022-08-08</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">计算机基础知识</a> / <a class="article-category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="进程同步、互斥"><a href="#进程同步、互斥" class="headerlink" title="进程同步、互斥"></a>进程同步、互斥</h1><h2 id="进程异步"><a href="#进程异步" class="headerlink" title="进程异步"></a>进程异步</h2><p>各并发执行的进程以各自独立的、不可预知的速度向前推进</p>
<h2 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h2><ul>
<li><p>协调多个并发执行进程的工作先后次序</p>
</li>
<li><p>例如：进程通信中的管道通信</p>
<ul>
<li>读进程和写进程并发地运行，由于并发必然导致异步性，因此“写数据”和“读数据”两个操作执行的先后顺序是不确定的。而实际应用中，又必须按照“<strong>写数据→读数据</strong>”的顺序来执行的。</li>
<li>如何解决这种<strong>异步</strong>问题，就是“<strong>进程同步</strong>”所讨论的内容。</li>
</ul>
</li>
<li><p>同步亦称<strong>直接制约关系</strong>，它是指为完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上<strong>协调</strong>它们的<strong>工作次序</strong>而产生的制约关系。进程间的直接制约关系就是源于它们之间的相互合作。</p>
</li>
</ul>
<h2 id="进程互斥"><a href="#进程互斥" class="headerlink" title="进程互斥"></a>进程互斥</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220808202305888.png" alt="image-20220808202305888"></p>
<ul>
<li>我们把<strong>一个时间段内只允许一个进程使用的资源称为临界资源</strong>。许多物理设备（比如摄像头、打印机）都属于临界资源。此外还有许多变量、数据、内存缓冲区等都属于临界资源。</li>
<li>对临界资源的访问，必须<strong>互斥</strong>地进行。互斥，亦称<strong>间接制约关系</strong></li>
<li><strong>进程互斥</strong>指当一个进程访问某临界资源时，另一个想要访问该临界资源的进程必须等待。当前访问临界资源的进程访问结束，释放该资源之后，另一个进程才能去访问临界资源。</li>
</ul>
<h2 id="访问临界资源"><a href="#访问临界资源" class="headerlink" title="访问临界资源"></a>访问临界资源</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220808202529431.png" alt="image-20220808202529431"></p>
<ul>
<li><strong>临界区</strong>是进程中<strong>访问临界资源</strong>的代码</li>
<li><strong>进入区</strong>和<strong>退出区</strong>是<strong>负责实现互斥</strong>的代码段</li>
<li>临界区也可称为”临界段“</li>
</ul>
<p> <strong>访问临界资源（进程互斥）需要遵循的原则</strong></p>
<ol>
<li><p><strong>空闲让进</strong></p>
<p>临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区</p>
</li>
<li><p><strong>忙则等待</strong></p>
<p>当已有进程进入临界区时，其他试图进入临界区的进程必须等待</p>
</li>
<li><p><strong>有限等待</strong></p>
<p>对请求访问的进程，应保证能在有限时间内进入临界区 (保证不会饥饿)</p>
</li>
<li><p><strong>让权等待</strong></p>
<p>当进程不能进入临界区，应当立即释放处理机，防止进程忙等待 (不应该让他占用处理机 一直执行循环无法前进，应当得知无法进入临界区时不执行循环，直接切换进程)</p>
</li>
</ol>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220808203126849.png" alt="image-20220808203126849"></p>
<h1 id="进程互斥的软件实现方法"><a href="#进程互斥的软件实现方法" class="headerlink" title="进程互斥的软件实现方法"></a>进程互斥的软件实现方法</h1><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220808203349709.png" alt="image-20220808203349709"></p>
<h2 id="单标志法"><a href="#单标志法" class="headerlink" title="单标志法"></a>单标志法</h2><h3 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h3><p>一个进程<strong>访问完临界区后</strong>会把使用临界区的权限交给另一个进程，即<strong>每个进程进入临界区的权限只能被另一个进程赋予</strong></p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220808204043347.png" alt="image-20220808204043347"></p>
<ol>
<li>turn的初值为0，即刚开始只允许0号进程进入临界区。</li>
<li>若P1先上处理机运行，则会一直卡在⑤。直到P1的时间片用完，发生调度，切换P0上处理机运行。代码①不会卡住P0，P0可以正常访问临界区，在P0访问临界区期间即使切换回p1，P1依然会卡在⑤，只有P0在退出区将turn改为1后，P1才能进入临界区。</li>
<li>因此，该算法<code>可以实现”同一时刻最多只允许一个进程访问临界区“</code></li>
<li>如果此时允许进入临界区的进程是P0，而P0一直不访问临界区，那么此时虽然临界区空闲，但一直不允许P1访问，因此，单标志法存在的问题是：<strong>违背空闲让进原则</strong></li>
</ol>
<h2 id="双标志先检查"><a href="#双标志先检查" class="headerlink" title="双标志先检查"></a>双标志先检查</h2><h3 id="思想-1"><a href="#思想-1" class="headerlink" title="思想"></a>思想</h3><p>设置一个布尔数组flag[]，数组中各元素<strong>标记各进程是否想进入临界区</strong>，true表示想进入， false表示不想进入；每个进程在进入临界区之前先检查当前有没有别的进程想进入临界 区，如果没有，把自身对应的标志flag[i]改为true，之后开始访问临界区</p>
<h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220808204701062.png" alt="image-20220808204701062"></p>
<p>存在的问题：P0进程进入之后，在修改P0为true之前，切换到P1，P1检查无别的进程想进入临界区，故会将P1改为true，导致两个进程都为true，会同时访问临界区，<strong>违反了”忙则等待“原则</strong></p>
<p>原因：<strong>进入区</strong>的检查和上锁两个处理<strong>不是一气呵成的</strong>。检查后，上锁前可能发生进程切换</p>
<h2 id="双标志后检查"><a href="#双标志后检查" class="headerlink" title="双标志后检查"></a>双标志后检查</h2><h3 id="思想-2"><a href="#思想-2" class="headerlink" title="思想"></a>思想</h3><p>双标志先检查法的改版，<strong>先上锁后检查</strong>，谁想进谁直接将自身改为true，不关心其他进 程，改为true之后，再检查有没有其他进程想访问</p>
<h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220808205216016.png" alt="image-20220808205216016"></p>
<p>存在的问题：P0想进入，P0改为true，在检查之前切换到P1，P1想进入，改为true，导致两个进程都为true，违背了<strong>“空闲让进”和有限等待”</strong>，谁都无法访问临界区，<strong>产生饥饿现象</strong></p>
<p>原因：进入区的检查和上锁不是一气呵成的</p>
<h2 id="Peterson算法"><a href="#Peterson算法" class="headerlink" title="Peterson算法"></a>Peterson算法</h2><h3 id="思想-3"><a href="#思想-3" class="headerlink" title="思想"></a>思想</h3><p>双标志后检查法的改版，若两个进程都想进入临界区，可以<strong>主动让对方优先访问临界区</strong></p>
<h3 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220808205512859.png" alt="image-20220808205512859"></p>
<p>进入区做了三件事：1. 主动争取 2. 主动谦让 3. 检查对方</p>
<p>Peterson算法解决了空闲让进，忙则等待，有限等待三个原则，但<strong>未遵循让权等待原则</strong></p>
<h1 id="进程互斥的硬件实现方法"><a href="#进程互斥的硬件实现方法" class="headerlink" title="进程互斥的硬件实现方法"></a>进程互斥的硬件实现方法</h1><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220808210328910.png" alt="image-20220808210328910"></p>
<h2 id="中断屏蔽方法"><a href="#中断屏蔽方法" class="headerlink" title="中断屏蔽方法"></a>中断屏蔽方法</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>利用“开&#x2F;关中断指令”实现（与原语的实现思想相同，即在某进程开始访问临界区到结束访问为止都不允许被中断，也就不能发生进程切换，因此也不可能发生两个同时访问临界区的情况）</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220808210615415.png" alt="image-20220808210615415"></p>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：简单、高效 </p>
<p>缺点：<strong>不适用于多处理机</strong>；只适用于操作系统内核进程，<strong>不适用于用户进程</strong>（因为开&#x2F;关中断指令只能运行在内核态，这组指令如果能让用户随意使用会很危险）</p>
<h2 id="TestAndSet指令-TS指令"><a href="#TestAndSet指令-TS指令" class="headerlink" title="TestAndSet指令(TS指令)"></a>TestAndSet指令(TS指令)</h2><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>TSL 指令是用硬件实现的，执行的过程不允许被中断，只能一气呵成。</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220808210815379.png" alt="image-20220808210815379"></p>
<p>若刚开始 lock 是 false，则 TSL 返回的 old 值为 false，while 循环条件不满足，直接跳过循环，进入临界区。</p>
<p>若刚开始 lock 是 true，则执行 TLS 后 old 返回的值为 true，while 循环条件满足，会一直循环，直到当前访问临界区的进程在退出区进行“解锁”。 </p>
<h3 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h3><p>相比软件实现方法，TSL 指令把“上锁”和“检查”操作用硬件的方式变成了一气呵成的原子操作。 </p>
<p>优点：实现简单，无需像软件实现方法那样严格检查是否会有逻辑漏洞；适用于多处理机环境 </p>
<p>缺点：<strong>不满足“让权等待”原则</strong>，暂时无法进入临界区的进程会占用CPU并循环执行TSL指令，从而导致“忙等”。</p>
<h2 id="Swap指令"><a href="#Swap指令" class="headerlink" title="Swap指令"></a>Swap指令</h2><h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><p>Swap 指令是用硬件实现的，执行的过程不允许被中断，只能一气呵成。</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220808211326054.png" alt="image-20220808211326054"></p>
<p>逻辑上来看 Swap 和 TSL 并无太大区别，都是先记录下此时临界区是否已经被上锁（记录在 old 变量上），再将上锁标记 lock 设置为 true，最后检查 old，如果 old 为 false 则说明之前没有别的进程对临界区上锁，则可跳出循环，进入临界区。</p>
<h3 id="优缺点-2"><a href="#优缺点-2" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：实现简单，无需像软件实现方法那样严格检查是否会有逻辑漏洞；适用于多处理机环境 </p>
<p>缺点：<strong>不满足“让权等待”原则</strong>，暂时无法进入临界区的进程会占用CPU并循环执行TSL指令，从而导致“忙等”。</p>
<h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220808211841332.png" alt="image-20220808211841332"></p>
<h1 id="信号量机制"><a href="#信号量机制" class="headerlink" title="信号量机制"></a>信号量机制</h1><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220808212101299.png" alt="image-20220808212101299"></p>
<h2 id="出现原因"><a href="#出现原因" class="headerlink" title="出现原因"></a>出现原因</h2><p>进程互斥的四种软件实现方式（单标志法、双标志先检查、双标志后检查、Peterson算法） </p>
<p>进程互斥的三种硬件实现方式（中断屏蔽方法、TS&#x2F;TSL指令、Swap&#x2F;XCHG指令）</p>
<ol>
<li><p>在双标志先检查法中，<strong>进入区的“检查”、“上锁” 操作无法一气呵成</strong>，从而导致了两个进程有可能<strong>同时进入临界区</strong>的问题；</p>
</li>
<li><p>所有的解决方案<strong>都无法实现“让权等待”</strong></p>
</li>
</ol>
<p>1965年，荷兰学者Dijkstra提出了一种卓有成效的实现<strong>进程互斥、同步</strong>的方法——<strong>信号量机制</strong></p>
<h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><ul>
<li>用户进程可以通过使用操作系统提供的<strong>一对原语</strong>来对<strong>信号量</strong>进行操作，从而很方便的实现了进程互斥、进程同步。 </li>
<li><strong>信号量</strong>其实就是一个变量 ，可以用一个信号量来<strong>表示系统中某种资源的数量</strong>，比如：系统中只有一台打印机，就可以设置一个初值为 1 的信号量。 </li>
<li><strong>原语</strong>是一种特殊的程序段，其<strong>执行只能一气呵成，不可被中断</strong>。原语是由<strong>关中断&#x2F;开中断</strong>指令实现的。软件解决方案的主要问题是由“进入区的各种操作无法一气呵成”，因此如果能把进入区、退出区的操作都用“原语”实现，使这些操作能“一气呵成”就能避免问题。</li>
<li><strong>一对原语</strong>：<strong>wait(S)</strong> 原语和 <strong>signal(S)</strong> 原语，可以把原语理解为我们自己写的函数，函数名分别为 wait 和 signal，括号里的<strong>信号量 S</strong> 其实就是函数调用时传入的一个参数。</li>
<li>wait、signal 原语常<strong>简称为 P、V操作</strong>（来自荷兰语 proberen 和 verhogen）。</li>
</ul>
<h2 id="整型信号量"><a href="#整型信号量" class="headerlink" title="整型信号量"></a>整型信号量</h2><ul>
<li>用一个<strong>整数型的变量</strong>作为信号量，用来<strong>表示系统中某种资源的数量</strong>。</li>
<li>与普通整数变量的区别： 对信号量的操作只有三种， 即 <strong>初始化、P操作、V操作</strong></li>
</ul>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220808213217836.png" alt="image-20220808213217836"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220808213254429.png" alt="image-20220808213254429"></p>
<h2 id="记录型信号量"><a href="#记录型信号量" class="headerlink" title="记录型信号量"></a>记录型信号量</h2><p>整型信号量的缺陷是<strong>存在“忙等”问题</strong>，因此人们又提出了“记录型信号量”，即用记录型数据结构表示的信号量。</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220808213446149.png" alt="image-20220808213446149"><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220808213930158.png" alt="image-20220808213930158"></p>
<ul>
<li>中 wait(S)、signal(S) 也可以记为 P(S)、V(S)，这对原语可用于<strong>实现系统资源的“申请”和“释放”。</strong></li>
<li><strong>S.value 的初值</strong>表示<strong>系统中某种资源的数目</strong>。 </li>
<li>对信号量 S 的<strong>一次 P 操作</strong>意味着进程<strong>请求一个单位的该类资源</strong>，因此需要执行 S.value–，表示资源数减1，当 S.value &lt; 0 时表示该类资源已分配完毕，因此进程应<strong>调用 block 原语进行自我阻塞<strong>（当前运行的进程从</strong>运行态—&gt;阻塞态</strong>），主动放弃处理机，并插入该类资源的等待队列 S.L 中。可见，该机制<strong>遵循了“让权等待”原则</strong>，不会出现“忙等”现象。 </li>
<li>对信号量 S 的<strong>一次 V 操作</strong>意味着进程<strong>释放一个单位的该类资源</strong>，因此需要执行 S.value++，表示资源数加1，若加1后仍是 S.value &lt;&#x3D; 0，表示依然有进程在等待该类资源，因此应<strong>调用 wakeup 原语唤醒等待队列中的第一个进程<strong>（被唤醒进程从</strong>阻塞态—&gt;就绪态</strong>）。</li>
</ul>
<h2 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220808214501300.png" alt="image-20220808214501300"></p>
<h1 id="用信号量实现进程互斥、同步、前驱关系"><a href="#用信号量实现进程互斥、同步、前驱关系" class="headerlink" title="用信号量实现进程互斥、同步、前驱关系"></a>用信号量实现进程互斥、同步、前驱关系</h1><ul>
<li><strong>一个信号量对应一种资源</strong> </li>
<li>信号量的值 &#x3D; 这种资源的剩余数量（信号量的值如果小于0，说明此时有进程在等待这种资源）</li>
<li>P( S ) —— 申请一个资源S，<strong>如果资源不够就阻塞等待</strong></li>
<li>V( S ) —— 释放一个资源S，<strong>如果有进程在等待该资源，则唤醒一个进程</strong></li>
</ul>
<h2 id="进程互斥实现"><a href="#进程互斥实现" class="headerlink" title="进程互斥实现"></a>进程互斥实现</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220808214838619.png" alt="image-20220808214838619"></p>
<h2 id="进程同步实现"><a href="#进程同步实现" class="headerlink" title="进程同步实现"></a>进程同步实现</h2><p>进程同步：要让各并发进程按要求有序地推进。</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220808215133294.png" alt="image-20220808215133294"></p>
<h2 id="前驱关系实现"><a href="#前驱关系实现" class="headerlink" title="前驱关系实现"></a>前驱关系实现</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220808215509765.png" alt="image-20220808215509765"></p>
<h2 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220808215643943.png" alt="image-20220808215643943"></p>
<h1 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h1><h2 id="为什么要引入管程"><a href="#为什么要引入管程" class="headerlink" title="为什么要引入管程"></a>为什么要引入管程</h2><ul>
<li>信号量机制存在的问题：编写程序困难、易出错</li>
<li>能不能设计一种机制，让程序员写程序时不需要再关注复杂的PV操作，让写代码更轻松呢？</li>
<li>1973年，Brinch Hansen 首次在程序设计语言 (Pascal)中引入了<strong>“管程”</strong>成分——一种高级同步机制</li>
</ul>
<h2 id="管程的定义和基本特征"><a href="#管程的定义和基本特征" class="headerlink" title="管程的定义和基本特征"></a>管程的定义和基本特征</h2><p><strong>管程是一种特殊的软件模块，有这些部分组成：</strong></p>
<ol>
<li><p>局部于管程的<strong>共享数据结构说明</strong>；</p>
</li>
<li><p>对该数据结构进行操作的<strong>一组过程</strong>；“过程”其实就是“函数” </p>
</li>
<li><p>对局部于管程的共享数据设置初始值的语句；</p>
</li>
<li><p>管程有一个名字。</p>
</li>
</ol>
<p><strong>管程的基本特征：</strong></p>
<ol>
<li><p>局部于管程的数据只能被局部于管程的过程所访问；</p>
</li>
<li><p>一个进程只有通过调用管程内的过程才能进入管程访问共享数据；</p>
</li>
<li><p><strong>每次仅允许一个进程在管程内执行某个内部过程。</strong></p>
</li>
</ol>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220809141641757.png" alt="image-20220809141641757"></p>
<ul>
<li><p>由编译器负责实现各进程互斥地进入管程中的过程</p>
</li>
<li><p>管程中设置条件变量和等待&#x2F;唤醒操作， 以解决同步问题</p>
</li>
<li><p>每次仅允许一个进程在管程内执行某个内部过程。 </p>
<ul>
<li><p>例1：两个生产者进程并发执行，依次调用了insert 过程… </p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220809142034952.png" alt="image-20220809142034952"></p>
</li>
<li><p>例2：两个消费者进程先执行，生产者进程后执行…</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220809142056699.png" alt="image-20220809142056699"></p>
</li>
</ul>
</li>
<li><p>引入管程的目的无非就是要更方便地实现进程互斥和同步。</p>
<ol>
<li><p>需要在管程中定义共享数据（如生产者消费者问题的缓冲区）</p>
</li>
<li><p>需要在管程中定义用于访问这些共享数据的“入口”——其实就是一些函数（如生产者消费者问题中，可以定义一个函数用于将产品放入缓冲区，再定义一个函数用于从缓冲区取出产品）</p>
</li>
<li><p>只有<strong>通过这些特定的“入口”才能访问共享数据</strong></p>
</li>
<li><p>管程中有很多“入口”，但是<strong>每次只能开放其中一个“入口”</strong>，并且<strong>只能让一个进程或线程进入</strong>（如生产者消费者问题中，各进程需要互斥地访问共享缓冲区。管程的这种特性即可保证一个时间段内最多只会有一个进程在访问缓冲区。注意：这种<strong>互斥特性是由编译器负责实现</strong>的，程序员不用关心）</p>
</li>
<li><p>可在管程中设置<strong>条件变量及等待&#x2F;唤醒操作</strong>以解决同步问题。可以让一个进程或线程在条件变量上等待（<strong>此时，该进程应先释放管程的使用权，也就是让出“入口”</strong>）；可以通过唤醒操作将等待在条件变量上的进程或线程唤醒。</p>
</li>
</ol>
</li>
<li><p>程序员可以用某种特殊的语法定义一个管程（比如: monitor ProducerConsumer …… end monitor;），之后其他程序员就可以使用这个管程提供的特定“入口”很方便地使用实现进程同步&#x2F;互斥了。（封装思想）</p>
</li>
</ul>
<h2 id="Java-中类似于管程的机制"><a href="#Java-中类似于管程的机制" class="headerlink" title="Java 中类似于管程的机制"></a>Java 中类似于管程的机制</h2><p>Java 中，如果用关键字 synchronized 来᧿ 述一个函数，那么这个函数同一时间段内只能被一个线程调用</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220809142530862.png" alt="image-20220809142530862"></p>
<ul>
<li>每次只能有一个线程进入insert 函数，如果多个线程 同时调用 insert 函数，则后来者需要排队等待</li>
</ul>
<h2 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220809142625250.png" alt="image-20220809142625250"></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-操作系统：处理机调度"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
	
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/08/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%9A%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6/"
    >处理机调度</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/08/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%9A%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6/" class="article-date">
  <time datetime="2022-08-08T07:10:15.000Z" itemprop="datePublished">2022-08-08</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">计算机基础知识</a> / <a class="article-category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="处理机调度的概念、层次"><a href="#处理机调度的概念、层次" class="headerlink" title="处理机调度的概念、层次"></a>处理机调度的概念、层次</h1><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220808151236283.png" alt="image-20220808151236283"></p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul>
<li>当有一堆任务要处理，但由于资源有限，这些事情没法同时处理。这就需要确定<strong>某种规则</strong>来<strong>决定</strong>处理这些任务的<strong>顺序</strong>，这就是“调度”研究的问题。 </li>
<li>在多道程序系统中，进程的数量往往是多于处理机的个数的，这样不可能同时并行地处理各个进程。<strong>处理机调度</strong>，就是从就绪队列中按照一定的算法选择一个进程并将处理机分配给它运行，以实现进程的并发执行。</li>
</ul>
<h2 id="处理机调度的三个层次"><a href="#处理机调度的三个层次" class="headerlink" title="处理机调度的三个层次"></a>处理机调度的三个层次</h2><h3 id="高级调度（作业调度）"><a href="#高级调度（作业调度）" class="headerlink" title="高级调度（作业调度）"></a>高级调度（作业调度）</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220808192157610.png" alt="image-20220808192157610"></p>
<ul>
<li>由于内存空间有限，有时无法将用户提交的作业全部放入内存，因此就需要确定某种规则来决定将作业调入内存的顺序。 </li>
<li><strong>高级调度（作业调度）</strong>。按一定的原则从外存上处于后备队列的作业中挑选一个（或多个）作业，给他们分配内存等必要资源，<strong>并建立相应的进程（建立PCB）</strong>，以使它（们）<strong>获得竞争处理机的权利</strong>。</li>
<li>高级调度是辅存（外存）与内存之间的调度。每个作业只调入一次，调出一次。<strong>作业调入时会建立相应的PCB，作业调出时才撤销PCB</strong>。高级调度主要是指调入的问题，因为只有调入的时机需要操作系统来确定，但调出的时机必然是作业运行结束才调出。</li>
</ul>
<h3 id="中级调度（内存调度）"><a href="#中级调度（内存调度）" class="headerlink" title="中级调度（内存调度）"></a>中级调度（内存调度）</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220808192322620.png" alt="image-20220808192322620"></p>
<ul>
<li>引入了虚拟存储技术之后，可将暂时不能运行的进程调至外存等待。等它重新具备了运行条件且内存又稍有空闲时，再重新调入内存。 </li>
<li>这么做的目的是为了<strong>提高内存利用率和系统吞吐量</strong>。 </li>
<li>暂时调到外存等待的进程状态为<strong>挂起状态</strong>。值得注意的是，<strong>PCB并不会一起调到外存，而是会常驻内存</strong>。PCB中会记录进程数据在外存中的存放位置，进程状态等信息，操作系统通过内存中的PCB来保持对各个进程的监控、管理。<strong>被挂起的进程PCB会被放到的挂起队列中</strong>。 </li>
<li><strong>中级调度（内存调度），就是要决定将哪个处于挂起状态的进程重新调入内存。</strong></li>
<li>一个进程可能会被多次调出、调入内存，因此<strong>中级调度发生的频率要比高级调度更高</strong>。</li>
</ul>
<h4 id="进程的挂起态与七状态模型"><a href="#进程的挂起态与七状态模型" class="headerlink" title="进程的挂起态与七状态模型"></a>进程的挂起态与七状态模型</h4><ul>
<li><p>暂时调到外存等待的进程状态为<strong>挂起状态</strong>（挂起态，suspend） </p>
</li>
<li><p>挂起态又可以进一步细分为<strong>就绪挂起、阻塞挂起</strong>两种状态</p>
</li>
<li><p>五状态模型—&gt;七状态模型</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220808192621967.png" alt="image-20220808192621967"></p>
<p><strong>注意</strong>：“挂起”和“阻塞”的区别，两种状态都是暂时不能获得CPU的服务，但挂起态是将进程映像调到外存去了，而阻塞态下进程映像还在内存中。 有的操作系统会把就绪挂起、阻塞挂起分为两个挂起队列，甚至会根据阻塞原因不同再把阻塞挂起进程进一步细分为多个队列。</p>
</li>
</ul>
<h3 id="低级调度（进程调度）"><a href="#低级调度（进程调度）" class="headerlink" title="低级调度（进程调度）"></a>低级调度（进程调度）</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220808192731046.png" alt="image-20220808192731046"></p>
<ul>
<li><strong>低级调度（进程调度）</strong>，其主要任务是按照某种方法和策略<strong>从就绪队列中选取一个进程</strong>，将处理机分配给它。 </li>
<li>进程调度是操作系统中<strong>最基本的一种调度</strong>，在一般的操作系统中都必须配置进程调度。 </li>
<li>进程调度的<strong>频率很高</strong>，一般几十毫秒一次。</li>
</ul>
<h3 id="三种调度的对比"><a href="#三种调度的对比" class="headerlink" title="三种调度的对比"></a>三种调度的对比</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220808192919564.png" alt="image-20220808192919564"></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220808164047195.png" alt="image-20220808164047195"></p>
<h1 id="进程调度的时机与调度方式"><a href="#进程调度的时机与调度方式" class="headerlink" title="进程调度的时机与调度方式"></a>进程调度的时机与调度方式</h1><h2 id="进程调度的时机"><a href="#进程调度的时机" class="headerlink" title="进程调度的时机"></a>进程调度的时机</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220808193037768.png" alt="image-20220808193037768"></p>
<blockquote>
<p><strong>临界资源</strong>：一个时间段内只允许一个进程使用的资源。各进程需要互斥地访问临界资源。 </p>
<p><strong>临界区</strong>：访问临界资源的那段代码。</p>
<p><strong>内核程序临界区</strong>一般是用来访问某种内核数据结构的，比如进程的就绪队列（由各就绪进程的PCB组成）</p>
<p>进程在操作系统内核程序临界区中不能进行调度与切换（√）</p>
<p>解析：内核程序临界区访问的临界资源如果不尽快释放的话，极有可能影响到操作系统内核的其他管理工作。因此在访问内核程序临界区期间不能进行调度与切换</p>
<p>进程处于临界区时不能进行处理机调度（×）</p>
<p>解析：普通临界区访问的临界资源不会直接影响操作系统内核的管理工作。因此在访问普通临界区时可以进行调度与切换。</p>
</blockquote>
<h2 id="进程调度的方式"><a href="#进程调度的方式" class="headerlink" title="进程调度的方式"></a>进程调度的方式</h2><h3 id="非剥夺调度方式"><a href="#非剥夺调度方式" class="headerlink" title="非剥夺调度方式"></a>非剥夺调度方式</h3><ul>
<li>又称<strong>非抢占方式</strong>。即，只<strong>允许进程主动放弃处理机</strong>。在运行过程中即便有更紧迫的任务到达，当前进程依然会继续使用处理机，直到该进程终止或主动要求进入阻塞态。</li>
<li>实现简单，系统开销小但是无法及时处理紧急任务，适合于早期的批处理系统</li>
</ul>
<h3 id="剥夺调度方式"><a href="#剥夺调度方式" class="headerlink" title="剥夺调度方式"></a>剥夺调度方式</h3><ul>
<li>又称<strong>抢占方式</strong>。当一个进程正在处理机上执行时，如果有一个<strong>更重要或更紧迫的进程需要使用处理机，则立即暂停正在执行的进程</strong>，将处理机分配给更重要紧迫的那个进程。</li>
<li>可以优先处理更紧急的进程，也可实现让各进程按时间片轮流执行的功能（通过时钟中断）。适合于分时操作系统、实时操作系统</li>
</ul>
<h2 id="进程的切换与过程"><a href="#进程的切换与过程" class="headerlink" title="进程的切换与过程"></a>进程的切换与过程</h2><p>“狭义的进程调度”与“进程切换”的区别： </p>
<ul>
<li><p><strong>狭义的进程调度</strong>指的是<strong>从就绪队列中选中一个要运行的进程</strong>。（这个进程可以是<strong>刚刚被暂停执行的进程</strong>，也可能是<strong>另一个进程</strong>，后一种情况就需要进程切换） </p>
</li>
<li><p><strong>进程切换</strong>是指一个进程让出处理机，由另一个进程占用处理机的过程。 </p>
</li>
<li><p><strong>广义的进程调度</strong>包含了选择一个进程和进程切换两个步骤。</p>
</li>
</ul>
<p>进程切换的过程主要完成了：</p>
<ol>
<li><p>对原来运行进程各种数据的保存</p>
</li>
<li><p>对新的进程各种数据的恢复（如：程序计数器、程序状态字、各种数据寄存器等处理机现场信息，这些信息一般保存在进程控制块）</p>
</li>
</ol>
<p>注意：<strong>进程切换是有代价的</strong>，因此如果<strong>过于频繁</strong>的进行进程<strong>调度、切换</strong>，必然会使<strong>整个系统的效率降低</strong>，使系统大部分时间都花在了进程切换上，而真正用于执行进程的时间减少。</p>
<h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220808182459003.png" alt="image-20220808182459003"></p>
<h1 id="调度算法的评价指标"><a href="#调度算法的评价指标" class="headerlink" title="调度算法的评价指标"></a>调度算法的评价指标</h1><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220808183003135.png" alt="image-20220808183003135"></p>
<h1 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h1><h2 id="先来先服务（FCFS-First-Come-First-Serve）"><a href="#先来先服务（FCFS-First-Come-First-Serve）" class="headerlink" title="先来先服务（FCFS, First Come First Serve）"></a>先来先服务（FCFS, First Come First Serve）</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220808194810823.png" alt="image-20220808194810823"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220808194840929.png" alt="image-20220808194840929"></p>
<h2 id="短作业优先（SJF-Shortest-Job-First）"><a href="#短作业优先（SJF-Shortest-Job-First）" class="headerlink" title="短作业优先（SJF, Shortest Job First）"></a>短作业优先（SJF, Shortest Job First）</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220808194954027.png" alt="image-20220808194954027"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220808195217511.png" alt="image-20220808195217511"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220808195323448.png" alt="image-20220808195323448"></p>
<p><strong>注意</strong>：</p>
<ul>
<li><strong>默认是非抢占式的</strong></li>
</ul>
<h2 id="高响应比优先（HRRN-Highest-Response-Ratio-Next）"><a href="#高响应比优先（HRRN-Highest-Response-Ratio-Next）" class="headerlink" title="高响应比优先（HRRN, Highest Response Ratio Next）"></a>高响应比优先（HRRN, Highest Response Ratio Next）</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220808195623462.png" alt="image-20220808195623462"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220808195639635.png" alt="image-20220808195639635"></p>
<h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220808195730956.png" alt="image-20220808195730956"></p>
<p><strong>注</strong>：这几种算法主要关心对用户的公平性、平均周转时间、平均等待时间等评价系统整体性能的指标，但是<strong>不关心“响应时间”</strong>，也并<strong>不区分任务的紧急程度</strong>，因此对于用户来说，交互性很糟糕。因此这三种算法一般适合用于<strong>早期的批处理系统</strong>，当然，FCFS算法也常结合其他的算法使用，在现在也扮演着很重要的角色。</p>
<h2 id="时间片轮转（RR）"><a href="#时间片轮转（RR）" class="headerlink" title="时间片轮转（RR）"></a>时间片轮转（RR）</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220808185854769.png" alt="image-20220808185854769"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220808185438210.png" alt="image-20220808185438210"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220808185506621.png" alt="image-20220808185506621"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220808185525659.png" alt="image-20220808185525659"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220808185942892.png" alt="image-20220808185942892"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220808185616448.png" alt="image-20220808185616448"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220808185701771.png" alt="image-20220808185701771"></p>
<p><strong>注意</strong></p>
<ul>
<li><p>每次选择上的处理机的进程都是排在就绪队列队头的进程</p>
</li>
<li><p>一个进程执行完会移动到就绪队列的尾部</p>
</li>
<li><p>一个进程时间片到，刚下处理机要移至就绪队列的尾部的同时有一个新进程到达就绪队列，则新进程先到达就绪队列的尾部</p>
</li>
<li><p>如果时间片太大，使得每个进程都可以在一个时间片内就完成，则时间斤轮转调度昇宏退化八尤木先服务调度算法，并且会增大进程响应时间。因此时间片不能太大。</p>
</li>
<li><p>另一方面，进程调度、切换是有时间代价的（保存、恢复运行坯境)，因此如果时间片太小，过于致进程切换过于频繁，系统会花大量的时间来处理进程切换，从导致头际用于进在执行的时间比例减少。可见时间片也不能太小。</p>
</li>
</ul>
<h2 id="优先级调度"><a href="#优先级调度" class="headerlink" title="优先级调度"></a>优先级调度</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220808190928540.png" alt="image-20220808190928540"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220808190253225.png" alt="image-20220808190253225"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220808190410056.png" alt="image-20220808190410056"></p>
<p><strong>补充</strong>:</p>
<ul>
<li>就绪队列未必只有一个，可以按照不同优先级来组织。另外，也可以把优先级高的进程排在更靠近队头的位置</li>
<li>根据优先级是否可以动态改变，可将优先级分为<strong>静态优先级和动态优先级</strong>两种</li>
<li><strong>静态优先级</strong>：创建进程时确定，之后一直不变。</li>
<li><strong>动态优先级</strong>：创建进程时有一个初始值，之后会根据情况动态地调整优先级。</li>
</ul>
<p><strong>如何合理地设置各类进程的优先级?</strong></p>
<p>通常:</p>
<ul>
<li>系统进程优先级<strong>高于</strong>用户进程</li>
<li>前台进程优先级<strong>高于</strong>后台进程</li>
<li>操作系统更<strong>偏好l&#x2F;O型进程（或称l&#x2F;O繁忙型进程)</strong><ul>
<li>I&#x2F;O设备和CPU可以并行工作。如果优先计I&#x2F;O繁忙型进程优先运行的话，则越有可能让l&#x2F;O设备尽早地投入工作，则资源利用率、系统吞吐量都会得到提升</li>
</ul>
</li>
</ul>
<p>注：与I&#x2F;O型进程相对的是计算型进程（或称CPU繁忙型进程)</p>
<p><strong>如果采用的是动态优先级，什么时候应该调整?</strong></p>
<ul>
<li>可以从追求公平、提升资源利用率等角度考虑</li>
<li>如果某进程在就绪队列中等待了很长时间，则可以适当提开其优先级</li>
<li>如果某进程占用处理机运行了很长时间，则可适当降低其优先级</li>
<li>如果发现一个进程频繁地进行l&#x2F;O操作，则可适当提升其优先级</li>
</ul>
<h2 id="多级反馈队列调度"><a href="#多级反馈队列调度" class="headerlink" title="多级反馈队列调度"></a>多级反馈队列调度</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220808191644049.png" alt="image-20220808191644049"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220808191458029.png" alt="image-20220808191458029"></p>
<h2 id="对比-1"><a href="#对比-1" class="headerlink" title="对比"></a>对比</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220808191742245.png" alt="image-20220808191742245"></p>
<p><strong>注</strong>：比起早期的批处理操作系统来说，由于计算机造价大幅降低，因此之后出现的交互式操作系统（包括分时操作系统、实时操作系统等）更注重系统的响应时间、公平性、平衡性等指标。而这几种算法恰好也能较好地满足<strong>交互式系统</strong>的需求。因此这三种算法适合用于交互式系统。(比如UNIX使用的就是多级反馈队列调度算法)</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
  </article>
  

  
  <nav class="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2022
        <i class="ri-heart-fill heart_icon"></i> Yang Shiyu
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="Healer"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>