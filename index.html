<!DOCTYPE html>


<html lang="en">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title> Healer</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    <link rel="alternate" href="/atom.xml" title="Healer" type="application/atom+xml">
</head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      
<section class="cover">
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover1.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">Healer</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.staticfile.org/typed.js/2.0.12/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['面朝大海，春暖花开', '愿你一生努力，一生被爱', '想要的都拥有，得不到的都释怀'],
        startDelay: 0,
        typeSpeed: 200,
        loop: true,
        backSpeed: 100,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  
  
  

<div class="notice" style="margin-top:50px">
    <i class="ri-heart-fill"></i>
    <div class="notice-content" id="broad"></div>
</div>
<script type="text/javascript">
    fetch('https://v1.hitokoto.cn')
        .then(response => response.json())
        .then(data => {
            document.getElementById("broad").innerHTML = data.hitokoto;
        })
        .catch(console.error)
</script>

<style>
    .notice {
        padding: 20px;
        border: 1px dashed #e6e6e6;
        color: #969696;
        position: relative;
        display: inline-block;
        width: 100%;
        background: #fbfbfb50;
        border-radius: 10px;
    }

    .notice i {
        float: left;
        color: #999;
        font-size: 16px;
        padding-right: 10px;
        vertical-align: middle;
        margin-top: -2px;
    }

    .notice-content {
        display: initial;
        vertical-align: middle;
    }
</style>
  
  <article class="articles">
    
    
    
    
    <article
  id="post-JavaSE"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
	
		置顶
	
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/06/28/JavaSE/"
    >JavaSE
  <i class="article-topping">Sticky</i>
</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/06/28/JavaSE/" class="article-date">
  <time datetime="2022-06-28T05:58:06.000Z" itemprop="datePublished">2022-06-28</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/JavaSE/">JavaSE</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="Java-概述"><a href="#Java-概述" class="headerlink" title="Java 概述"></a>Java 概述</h1><h2 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h2><p>计算机执行某些操作或解决某个问题而编写的一系列有序指令的集合</p>
<h2 id="Java-重要特点"><a href="#Java-重要特点" class="headerlink" title="Java 重要特点"></a>Java 重要特点</h2><ol>
<li><p>Java 语言是<strong>面向对象</strong>的(oop)</p>
</li>
<li><p>Java 语言是<strong>健壮</strong>的。Java 的强类型机制、异常处理、垃圾的自动收集等是 Java 程序健壮性的重要保证 </p>
</li>
<li><p>Java 语言是<strong>跨平台性</strong>的。[即: 一个编译好的.class 文件可以在多个系统下运行，这种特性称为跨平台]</p>
</li>
<li><p>Java 语言是<strong>解释型</strong>的。</p>
</li>
</ol>
<p>​		<strong>解释性语言：javascript,PHP, java</strong> </p>
<p>​		<strong>编译性语言: c &#x2F; c++</strong> </p>
<p>​		区别是：解释性语言，编译后的代码，不能直接被机器执行,需要解释器来执行, 编译性语言, 编译后的代码, 可以直接被机器执行, c &#x2F;c+</p>
<h2 id="JDK，JRE介绍"><a href="#JDK，JRE介绍" class="headerlink" title="JDK，JRE介绍"></a>JDK，JRE介绍</h2><p>1）JDK 的全称(Java Development Kit Java 开发工具包)</p>
<pre><code>     **JDK = JRE + java 开发工具集 **   [java, javac,javadoc,javap,java编译工具等] 
</code></pre>
<p>​		JDK 是提供给 Java 开发人员使用的，其中包含了 java 的开发工具，也包括了 JRE。所以安装了 JDK，就不用在单独安装 JRE了</p>
<p>2）JRE(Java Runtime Environment Java 运行环境)</p>
<p>​		 <strong>JRE &#x3D; JVM + Java 的核心类库[类]</strong> </p>
<p>​		包括 Java 虚拟机(JVM Java Virtual Machine)和 Java 程序所需的核心类库等，如果想要运行一个开发好的 Java 程序， 计算机中只需要安装 JRE 即可。</p>
<h2 id="Java虚拟机-JVM"><a href="#Java虚拟机-JVM" class="headerlink" title="Java虚拟机-JVM"></a>Java虚拟机-JVM</h2><ol>
<li><p>JVM 是一个虚拟的计算机，具有指令集并使用不同的存储区域。负责执行指令，管理数据、内存、寄存器，<strong>包含在 JDK 中</strong>. </p>
</li>
<li><p>对于不同的平台，有不同的虚拟机。 </p>
</li>
<li><p>Java 虚拟机机制屏蔽了底层运行平台的差别，实现了“<strong>一次编译，到处运行”</strong></p>
</li>
</ol>
<h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><p>私有:java虚拟机栈，程序计数器，本地方法栈 共享:java堆，方法区</p>
<ol>
<li><p>栈： 一般存放基本数据类型(局部变量) </p>
</li>
<li><p>堆： 存放对象(Cat cat , 数组等) </p>
</li>
<li><p>方法区：常量池(常量，比如字符串)， 类加载信息</p>
</li>
</ol>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220511221502453.png" alt="image-20220511221502453"></p>
<h2 id="Java-转义字符"><a href="#Java-转义字符" class="headerlink" title="Java 转义字符"></a>Java 转义字符</h2><p>在控制台使用 <strong>tab</strong> 可补全命令</p>
<p>\t ：一个制表位，实现对齐的功能 </p>
<p>\n ：换行符 </p>
<p>\ \：一个\</p>
<p>\ &quot; :一个”</p>
<p>\ &#39; ：一个’ </p>
<p>\r :一个回车</p>
<p>\0:空字符</p>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>用于注解说明解释程序的文字，提高了代码的阅读性(可读性)</p>
<p>被注释的文字，不会被 JVM（java 虚拟机）解释执行</p>
<p> 多行注释里面不允许有多行注释嵌套</p>
<p>文档注释：javadoc -d 文件名 -author -version xx.java</p>
<h2 id="常用dos命令"><a href="#常用dos命令" class="headerlink" title="常用dos命令"></a>常用dos命令</h2><ol>
<li><p>查看当前目录是有什么内容：dir </p>
</li>
<li><p>切换到其他盘下：盘符号 + ：</p>
</li>
<li><p>切换到上一级：cd .. </p>
</li>
<li><p>切换到根目录：cd \ </p>
</li>
<li><p>查看指定的目录下所有的子级目录：tree</p>
</li>
<li><p>清屏：cls </p>
</li>
<li><p>退出：exit</p>
</li>
</ol>
<h2 id="成员方法传参机制"><a href="#成员方法传参机制" class="headerlink" title="成员方法传参机制"></a>成员方法传参机制</h2><p><strong>实参定义</strong></p>
<p>实参全称为实际参数，是在调用时传递给函数的参数。实参可以是常量、变量、表达式、函数等，无论实参是何种类型的量，在进行函数调用时，它们都必须具有确定的值，以便把这些值 传送给形参因此应预先用赋值，输入等办法使实参获得确定值。</p>
<p><strong>形参定义</strong></p>
<p>形参全称为形式参数，由于它不是实际存在变量，所以又称虚拟变量。是在定义函数名和函数体的时候使用的参数,目的是用来接收调用该函数时传入的参数.在调用函数时，实参将赋值给形参。因而，必须注意实参的个数，类型应与形参-一对应， 并且实参必须要有确定的值。</p>
<ol>
<li><p>基本数据类型，传递的是值（值拷贝），形参的改变不影响实参</p>
</li>
<li><p>引用数据类型,，传递的是地址（传递也是值，但是值是地址），可以通过形参影响实参</p>
</li>
</ol>
<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220517173202743.png" alt="image-20220517173202743"></p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220517173304401.png" alt="image-20220517173304401"></p>
<h3 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h3><p>默认int</p>
<p>计算机底层存储的都是<strong>补码</strong>，并以补码进行数据运算，显示的是原码</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220517173405866.png"></p>
<h3 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a>浮点类型</h3><p>默认float</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220517175012934.png" alt="image-20220517175012934"></p>
<ol>
<li><p>关于浮点数在机器中存放形式的简单说明，浮点数&#x3D;符号位+指数位+尾数位 </p>
</li>
<li><p>尾数部分可能丢失，造成精度损失(小数都是近似值)</p>
</li>
</ol>
<h3 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h3><p>字符类型可以表示单个字符,字符类型是 char，char 是两个字节(可以存放汉字)，多个字符用字符串 String</p>
<p>字符型存储到计算机中，是对应的ASCII码值</p>
<h3 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h3><p>只允许取值true和false，无null，占一个字节</p>
<h2 id="基本数据类型转换"><a href="#基本数据类型转换" class="headerlink" title="基本数据类型转换"></a>基本数据类型转换</h2><p>自动类型转换：进行赋值或运算时，精度小的类型自动转换为精度大的数据类型(byte–&gt;short–&gt;int–&gt;long–&gt;float–&gt;double)(char–&gt;int–&gt;long–&gt;float–&gt;double)</p>
<p>​							byte, short 和 char 之间不会相互自动转换，但可以计算，在计算时首先转换成int类型</p>
<p>强制类型转换：将容量大的数据类型转换成容量小的数据类型</p>
<p>​							使用时要加上强制转换符()，但可能造成精度降低或溢出</p>
<p>基本数据类型和String类型的转换：基本–&gt;String：将基本数据类型的值+””</p>
<p>​															 String–&gt;基本：通过基本类型的包装类调用parseXXX方法</p>
<h2 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220517191425976.png" alt="image-20220517191425976"></p>
<p>Unicode：将世界上所有的符号都纳入其中，每个符号都给予一个独一无二的编码，使用Unicode没有乱码问题</p>
<h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220517193700932.png" alt="image-20220517193700932"></p>
<h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><p>1）基本赋值运算符   int a &#x3D; 10;</p>
<p>2）复合赋值运算符 +&#x3D; ，-&#x3D; ，*&#x3D; ， &#x2F;&#x3D; ，%&#x3D; 等</p>
<p>复合赋值运算符会进行类型转换。例如：b +&#x3D; 2; &#x2F;&#x2F; 等价 b &#x3D; (byte)(b+2)</p>
<h2 id="关系运算符-比较运算符"><a href="#关系运算符-比较运算符" class="headerlink" title="关系运算符(比较运算符)"></a>关系运算符(比较运算符)</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220517193743927.png" alt="image-20220517193743927"></p>
<h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><ol>
<li><p>短路与 &amp;&amp; ， 短路或 ||，取反 ! </p>
</li>
<li><p>逻辑与 &amp;，逻辑或 |，^ 逻辑异或</p>
</li>
</ol>
<h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220517195010581.png" alt="image-20220517195010581"></p>
<ol>
<li><p>算术右移 &gt;&gt;：低位溢出,符号位不变,并用符号位补溢出的高位 int a&#x3D;1&gt;&gt;2; &#x2F;&#x2F;1 &#x3D;&gt; 00000001 &#x3D;&gt; 00000000 本质 1&#x2F;2&#x2F;2&#x3D;0</p>
</li>
<li><p>算术左移 &lt;&lt;: 符号位不变,低位补 0 int c&#x3D;1&lt;&lt;2; &#x2F;&#x2F;1 &#x3D;&gt; 00000001 &#x3D;&gt; 00000100 本质 1 * 2 * 2 &#x3D; 4</p>
</li>
<li><blockquote>
<blockquote>
<blockquote>
<p> 逻辑右移也叫无符号右移,运算规则是: 低位溢出，高位补 0</p>
</blockquote>
</blockquote>
</blockquote>
</li>
</ol>
<h2 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h2><p>条件表达式 ? 表达式 1: 表达式 2; </p>
<p>运算规则：1）如果条件表达式为 true，运算后的结果是表达式 1； </p>
<p>​					2）如果条件表达式为 false，运算后的结果是表达式 2；</p>
<h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><p>1）由26个英文字母大小写，0-9，_或$组成</p>
<p>2）数字不能开头</p>
<p>3）不可以使用关键字和保留字，但能包含关键字和保留字</p>
<p>4）不能包含空格</p>
<h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><p><strong>都小写</strong></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220517194602552.png" alt="image-20220517194602552"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220517194633358.png" alt="image-20220517194633358"></p>
<p><strong>volatile与synchronized的区别：</strong></p>
<p>volatile本质是在告诉jvm当前变量在寄存器中的值是不确定的,需要从主存中读取,synchronized则是锁定当前变量,只有当前线程可以访问该变量,其他线程被阻塞住</p>
<p>volatile仅能使用在变量级别,synchronized则可以使用在变量,方法.</p>
<p>volatile仅能实现变量的修改可见性,但不具备原子特性,而synchronized则可以保证变量的修改可见性和原子性.</p>
<p>volatile不会造成线程的阻塞,而synchronized可能会造成线程的阻塞.</p>
<p>volatile标记的变量不会被编译器优化,而synchronized标记的变量可以被编译器优化.</p>
<p>synchronized很强大，既可以保证可见性，又可以保证原子性，而volatile不能保证原子性！</p>
<h2 id="保留字"><a href="#保留字" class="headerlink" title="保留字"></a>保留字</h2><p>Java 保留字：现有 Java 版本尚未使用，但以后版本可能会作为关键字使用。自己命名标识符时要避免使用这些保留字 byValue、cast、future、 generic、inner、 operator、 outer、 rest、 var 、 goto</p>
<h2 id="原码、反码、补码"><a href="#原码、反码、补码" class="headerlink" title="原码、反码、补码"></a>原码、反码、补码</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220517194927173.png" alt="image-20220517194927173"></p>
<h1 id="程序控制结构"><a href="#程序控制结构" class="headerlink" title="程序控制结构"></a>程序控制结构</h1><p>switch(表达式)中表达式的返回值必须是：byte, short, int, char, enum, String</p>
<p>break 语句用于终止某个语句块的执行，一般使用在 switch 或者循环[for, while, do-while]中</p>
<p>continue 语句用于结束本次循环，继续执行下一次循环，出现在多层嵌套的循环语句体中时，可以通过标签指明要跳过的是哪一层循环 </p>
<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>存放多个同一类型的数据，是一种<strong>引用类型</strong>数据</p>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>动态初始化：数据类型 数组名[] &#x3D; new  数据类型[大小] 例：int a[] &#x3D; new int[5]</p>
<p>​						数据类型 数组名[]；数组名 &#x3D; new  数据类型[大小] </p>
<p>​						数据类型 数组名[[]][[][] &#x3D; new  数据类型[大小] [大小]</p>
<p>​						数据类型 数组名[[]][[][] &#x3D; new  数据类型[大小] []</p>
<p>静态初始化：数据类型 数组名[] &#x3D; {元素值，元素值, … }</p>
<h2 id="数组细节"><a href="#数组细节" class="headerlink" title="数组细节"></a>数组细节</h2><p>1）数组是多个相同类型数据的组合</p>
<p>2）数组创建后，如果没有赋值，有默认值</p>
<p>​		int 0，short 0, byte 0, long 0, float 0.0,double 0.0，char \u0000，boolean false，String null</p>
<p>3）数组属于引用类型，数组型数据是对象(Object)</p>
<h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>1）区分相同名字的类</p>
<p>2）当类很多时，可以更好的管理类</p>
<p>3）控制访问范围</p>
<h3 id="常用的包"><a href="#常用的包" class="headerlink" title="常用的包"></a>常用的包</h3><ol>
<li><p>java.lang.* &#x2F;&#x2F;lang 包是基本包，默认引入，不需要再引入. </p>
</li>
<li><p>java.util.* &#x2F;&#x2F;util 包，系统提供的工具包, 工具类，使用 Scanner </p>
</li>
<li><p>java.net.* &#x2F;&#x2F;网络包，网络开发 </p>
</li>
<li><p>java.awt.* &#x2F;&#x2F;是做 java的界面开发，GUI</p>
</li>
</ol>
<h2 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h2><p>java 提供四种访问控制修饰符号，用于控制方法和属性(成员变量)的访问权限（范围）</p>
<ol>
<li><p>公开级别:用 <strong>public</strong> 修饰,对外公开 </p>
</li>
<li><p>受保护级别:用 <strong>protected</strong> 修饰,对子类和同一个包中的类公开</p>
</li>
<li><p>默认级别:没有修饰符号,向同一个包的类公开</p>
</li>
<li><p>私有级别:用 <strong>private</strong> 修饰,只有类本身可以访问,不对外公开</p>
</li>
</ol>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>修饰符可以修饰类中的属性，成员方法以及类</p>
<p>只有默认的和public才能修饰类</p>
<h1 id="OOP"><a href="#OOP" class="headerlink" title="OOP"></a>OOP</h1><h2 id="面向对象编程三大特征"><a href="#面向对象编程三大特征" class="headerlink" title="面向对象编程三大特征"></a>面向对象编程三大特征</h2><p>封装、继承和多态</p>
<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>把抽象出的数据[属性]和对数据的操作[方法]封装在一起，数据被保护在内部，程序的其他部分只能通过被授权的操作[方法]，才能对数据进行操作</p>
<ol>
<li><p>将属性进行私有化private</p>
</li>
<li><p>提供一个公共的set方法，用户对数据进行赋值</p>
</li>
<li><p>提供一个公共的get方法，用于获取属性的值</p>
</li>
</ol>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>继承可以解决代码复用,让我们的编程更加靠近人类思维.当多个类存在相同的属性(变量)和方法时,可以从这些类中抽象出父类,在父类中定义这些相同的属性和方法，所有的子类不需要重新定义这些属性和方法，只需要通过 extends 来声明继承父类即可。</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220503220735855.png" alt="image-20220503220735855"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220503220812342.png" alt="image-20220503220812342"></p>
<p>继承的深入讨论&#x2F;细节问题</p>
<ol>
<li><p>子类继承了所有的属性和方法，非私有的属性和方法可以在子类直接访问, 但是私有属性和方法不能在子类直接访 问，要通过父类提供公共的方法去访问</p>
</li>
<li><p>子类必须调用父类的构造器， 完成父类的初始化 </p>
</li>
<li><p>当创建子类对象时，不管使用子类的哪个构造器，默认情况下总会去调用父类的无参构造器，如果父类没有提供无参构造器，则必须在子类的构造器中用super</p>
<p>  去指定使用父类的哪个构造器完成对父类的初始化工作，否则，编译不会通过</p>
</li>
<li><p>如果希望指定去调用父类的某个构造器，则显式的调用一下 : super(参数列表)</p>
</li>
<li><p>super 在使用时，必须放在构造器第一行(super只能在构造器中使用) </p>
</li>
<li><p>super() 和 this() 都只能放在构造器第一行，因此这两个方法不能共存在一个构造器</p>
</li>
<li><p>java 所有类都是 Object 类的子类, Object 是所有类的基类. </p>
</li>
<li><p>父类构造器的调用不限于直接父类！将一直往上追溯直到 Object 类(顶级父类) </p>
</li>
<li><p>子类最多只能继承一个父类(指直接继承)，即 java 中是单继承机制。 思考：如何让 A 类继承 B 类和 C 类？ 【A 继承 B， B 继承 C】 </p>
</li>
<li><p>不能滥用继承，子类和父类之间必须满足 <strong>is-a</strong> 的逻辑</p>
</li>
</ol>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>方法或对象具有多种形态。是面向对象的第三大特征，多态是建立在封装和继承基础之上的。</p>
<ol>
<li>方法的多态：重写和重载就体现多态</li>
</ol>
<p>2）<strong>对象的多态</strong></p>
<p>a.一个对象的编译类型和运行类型可以不一致</p>
<p>b.编译类型在定义对象时就确定了，不能改变</p>
<p>c.运行类型可以改变</p>
<p><strong>d.编译看左，运行看右</strong></p>
<h4 id="多态的注意事项"><a href="#多态的注意事项" class="headerlink" title="多态的注意事项"></a>多态的注意事项</h4><p>多态的<strong>前提</strong>是：两个对象(类)存在继承关系</p>
<p><strong>多态的向上转型</strong></p>
<p>​		本质：父类引用指向子类对象</p>
<p>​		语法：父类类型 引用名 &#x3D; new 子类类型()；</p>
<p>​		特点：<strong>编译看左，运行看右</strong></p>
<p>​					可以调用父类中的所有成员</p>
<p>​					不能调用子类中的特有成员</p>
<p>​					最终运行效果看子类的具体实现</p>
<p><strong>多态的向下转型</strong></p>
<p>​		语法：子类类型 引用名 &#x3D; (子类类型) 父类引用；</p>
<p>​		特点：只能强转父类的引用，不能强转父类的对象</p>
<p>​					要求父类的引用必须指向的是当前目标类型的对象</p>
<p>​					向下转型后可以调用子类类型中的所有成员</p>
<p><strong>instanceOf</strong> 比较操作符，用于判断对象的运行类型是否为 XX 类型或 XX 类型的子类型</p>
<h4 id="java-的动态绑定机制"><a href="#java-的动态绑定机制" class="headerlink" title="java 的动态绑定机制"></a>java 的动态绑定机制</h4><p>1）当调用对象方法的时候，该方法会与该对象的内存地址&#x2F;运行类型绑定</p>
<p>2）当调用对象属性的时候，没有动态绑定机制，哪里声明，哪里使用</p>
<h2 id="super-关键字"><a href="#super-关键字" class="headerlink" title="super 关键字"></a>super 关键字</h2><p>super代表父类的引用，用于访问父类的属性、方法、构造器。</p>
<h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>1）访问父类的属性，但不能访问父类的private属性  例：super.属性名</p>
<p>2）访问父类的方法，但不能访问父类的private方法  例：super.方法名(参数列表)</p>
<p>3）访问父类的构造器 例：super(参数列表) 只能放在构造器的第一句，只能出现一句</p>
<h3 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h3><p>1）调用父类的构造器（分工明确，父类属性由父类初始化，子类属性由子类初始化）</p>
<p>2）当子类中有和父类中的成员（属性和方法）重名时，为了访问父类的成员，必须通过super</p>
<p>3）super的访问不限于直接父类，如果爷爷类有和本类中有同名的成员，也可以使用super去访问爷爷类的成员；</p>
<p>​		如果多个基类中都有相同的成员，则super访问遵循就近原则</p>
<h3 id="super与this的比较"><a href="#super与this的比较" class="headerlink" title="super与this的比较"></a>super与this的比较</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220505145216027.png" alt="image-20220505145216027"></p>
<h2 id="方法重写-x2F-覆盖-override"><a href="#方法重写-x2F-覆盖-override" class="headerlink" title="方法重写&#x2F;覆盖(override)"></a>方法重写&#x2F;覆盖(override)</h2><p>子类中有一个方法，和父类的某个方法的名称、返回值类型、参数一样</p>
<h3 id="重写与重载的区别"><a href="#重写与重载的区别" class="headerlink" title="重写与重载的区别"></a>重写与重载的区别</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220505145536052.png" alt="image-20220505145536052"></p>
<h2 id="Object-类"><a href="#Object-类" class="headerlink" title="Object 类"></a>Object 类</h2><p><img src="https://uploadfiles.nowcoder.com/images/20200717/257056865_1594996230591_77654A637F366FC03F9C293582926971" alt="img"></p>
<p><img src="https://uploadfiles.nowcoder.com/images/20190412/242025553_1555068065653_1F768A0737B2E9FBB49649C7465CBFCE" alt="img"></p>
<h3 id="equals方法"><a href="#equals方法" class="headerlink" title="equals方法"></a>equals方法</h3><h4 id="x3D-x3D-和-equals比较"><a href="#x3D-x3D-和-equals比较" class="headerlink" title="&#x3D;&#x3D;和 equals比较"></a>&#x3D;&#x3D;和 equals比较</h4><p>&#x3D;&#x3D;是一个比较运算符</p>
<p>1）&#x3D;&#x3D;：既可以判断基本类型，又可以判断引用类型</p>
<p>2）&#x3D;&#x3D;：如果判断基本类型，判断的是<strong>值</strong>是否相等</p>
<p>3）&#x3D;&#x3D;：如果判断引用类型，判断的是**地址值 **是否相等</p>
<p>4）equals：是Object类中的方法，只能判断引用类型，默认判断的是地址值是否相等，子类中往往重写该方法，用于判断<strong>内容</strong>是否相等（例：Integer, String）</p>
<h3 id="hashCode方法"><a href="#hashCode方法" class="headerlink" title="hashCode方法"></a>hashCode方法</h3><ol>
<li><p>返回对象的哈希码值，提高具有哈希结构的容器的效率！ </p>
</li>
<li><p>两个引用，如果指向的是同一个对象，则哈希值肯定是一样的！ </p>
</li>
<li><p>两个引用，如果指向的是不同对象，则哈希值是不一样的 </p>
</li>
<li><p>哈希值主要根据地址号来的！不能完全将哈希值等价于地址</p>
</li>
</ol>
<h3 id="toString-方法"><a href="#toString-方法" class="headerlink" title="toString 方法"></a>toString 方法</h3><ol>
<li>基本介绍</li>
</ol>
<p>​	默认返回：全类名+@+哈希值的十六进制</p>
<p>​	子类往往重写 toString 方法，用于返回对象的属性信息 </p>
<ol start="2">
<li><p>重写 toString 方法，打印对象或拼接对象时，都会自动调用该对象的 toString 形式</p>
</li>
<li><p>当直接输出一个对象时，toString 方法会被默认的调用</p>
</li>
</ol>
<h3 id="finalize-方法"><a href="#finalize-方法" class="headerlink" title="finalize 方法"></a>finalize 方法</h3><ol>
<li><p>当对象被回收时，系统自动调用该对象的 finalize 方法。子类可以重写该方法，做一些释放资源的操作</p>
</li>
<li><p>什么时候被回收：当某个对象没有任何引用时，则 jvm 就认为这个对象是一个垃圾对象，就会使用垃圾回收机制来销毁该对象，在销</p>
</li>
</ol>
<p>​		毁该对象前，会先调用finalize 方法。 </p>
<ol start="3">
<li>垃圾回收机制的调用，是由系统来决定(即有自己的 GC 算法), 也可以通过 System.gc() 主动触发垃圾回收机制</li>
</ol>
<h2 id="类变量和类方法（静态变量和静态方法）"><a href="#类变量和类方法（静态变量和静态方法）" class="headerlink" title="类变量和类方法（静态变量和静态方法）"></a>类变量和类方法（静态变量和静态方法）</h2><h3 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h3><p>​	特点：会被本类的所有的对象实例共享，随着类的加载而创建，可以直接通过类名调用</p>
<p>​	<strong>内存布局</strong>：在堆的永久生成区域中</p>
<p>​	定义：访问修饰符 static 数据类型 变量名；</p>
<p>​	访问：类名.变量名[前提：满足访问修饰符的访问权限和范围]</p>
<p>​	生命周期：随类的加载开始，随类的消亡而销毁</p>
<h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>​	特点：不创建实例，也可以调用，可通过类名调用；不允许使用与对象有关的关键字，<strong>this、super</strong></p>
<p>​	定义：访问修饰符 static 数据返回类型 方法名(){}</p>
<p><strong>静态方法，只能访问静态的成员，非静态方法，可以访问静态成员和非静态成员</strong></p>
<h2 id="main方法"><a href="#main方法" class="headerlink" title="main方法"></a>main方法</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220505162645471.png" alt="image-20220505162645471"></p>
<p>在main方法中，可以直接调用main方法所在类的静态方法或静态属性</p>
<p>但是，不能直接访问该类中的非静态成员，必须创建该类的一个实例对象后，才能通过这个对象去访问类中的非静态成员</p>
<h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><p>又称初始化块，属于类中的成员，类似于方法，将逻辑语句封装在方法体中，通过{}包围起来</p>
<p>但和方法不同，没有方法名，没有返回，没有参数，只有方法体，而且不能通过对象或类显示调用，而是加载类时，或创建对象时隐式调用</p>
<p>两类：静态代码块和普通&#x2F;非静态代码块</p>
<p>相当于另一种形式的构造器，可以做初始化操作</p>
<h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><p>1）静态代码块随着类的加载而执行，并且只会执行一次</p>
<p>2）<strong>类加载时间</strong></p>
<p>​		a.创建对象实例时(new)</p>
<p>​		b.创建子类对象实例，父类也会被加载</p>
<p>​		c.使用类的静态成员时</p>
<p>3）普通代码块，在创建对象实例时，会被隐式的调用</p>
<p>​		<strong>创建一次，调用一次</strong></p>
<p>4）创建对象时，类的调用顺序</p>
<p>​		a.调用静态代码块和静态属性初始化(优先级一样，按定义顺序调用)</p>
<p>​		b.调用普通代码块和普通属性初始化(优先级一样，按定义顺序调用)</p>
<p>​		c.调用构造方法</p>
<p>5）子父类的调用顺序</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220505172401550.png" alt="image-20220505172401550"></p>
<h2 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h2><p>设计模式是在大量的实践中总结和理论化之后优化的代码结构、编程风格、以及解决问题的思考方式。</p>
<p>单例设计模式：采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法</p>
<p>方式：1）饿汉式；2）懒汉式</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220506133052141.png" alt="image-20220506133052141"></p>
<ol>
<li>将构造器私有化</li>
<li>在类的内部直接创建对象(该对象是 static) </li>
<li>提供一个公共的 static 方法，返回对象</li>
</ol>
<h2 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h2><p><strong>可以修饰类、属性、方法和局部变量，不能修饰构造器</strong></p>
<p>1）被final修饰的类，不能被继承，但可以实例化</p>
<p>2）被final修饰的方法，不能被子类重写</p>
<p>3）被final修饰的局部变量或类中的某个属性，又叫常量，不能被修改</p>
<p>4）final修饰的属性在定义时，<strong>必须赋初值</strong>，赋值可以在以下位置：</p>
<p>​		a.定义时 b.在构造器中 c.在代码块中</p>
<p>5）如果final修饰的属性是静态的，则初始化的位置只能是a.定义时 b.在静态代码块中，不能在构造器中赋值</p>
<p>6）如果一个类已经是final类，就没有必要再将方法修饰成final方法</p>
<p>7）final和static往往搭配使用，效率更高，<strong>不会导致类加载</strong>，底层编译器做了优化处理</p>
<p>8）包装类，String类都是final类</p>
<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>当父类的一些方法不能确定时，可以用abstract关键字来修饰该方法，这个方法就是抽象方法，用abstract来修饰该类就是抽象类</p>
<p>1）抽象类不能被实例化</p>
<p>2）abstract只能修饰类和方法，不能修饰属性和其它的</p>
<p>3）抽象类的本质还是类，可以有任意成员，例如：非抽象方法、构造器、静态属性等</p>
<p>4）抽象方法不能有主体，即不能实现</p>
<p>5）一个类继承了抽象类，则它必须实现抽象类的所有抽象方法</p>
<p>6）<strong>抽象方法不能使用private、final和static来修饰，因为这些关键字都是和重写相违背的</strong></p>
<p>关于抽象类</p>
<p><strong>JDK 1.8以前</strong>，抽象类的方法默认访问权限为<strong>protected</strong></p>
<p><strong>JDK 1.8时</strong>，抽象类的方法默认访问权限变为<strong>default</strong></p>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>给出一些没有实现的方法，封装在一起，到某个类要使用的时候，再根据具体情况把这些方法写出来</p>
<p>接口体现了程序设计的多态和高内聚低耦合的设计思想</p>
<p>JDK7.0中接口是更加抽象的抽象类，抽象类里的方法可以有方法体，接口里的方法都没有方法体</p>
<p>JDK8.0后接口类可以有静态方法、默认方法，也就是说接口中可以有方法的具体实现</p>
<p><strong>接口中的属性，只能是final的，而且是public static final修饰符，必须初始化</strong></p>
<p>接口不能继承其他的类，但是可以继承多个接口</p>
<p><strong>接口的修饰符只能是public和默认，这点和类的修饰符一样</strong></p>
<p><strong>like-a</strong>的关系</p>
<p>关于接口</p>
<p><strong>JDK 1.8以前</strong>，接口中的方法必须是<strong>public</strong>的</p>
<p><strong>JDK 1.8时</strong>，接口中的方法可以是<strong>public</strong>的，也可以是<strong>default</strong>的</p>
<p><strong>JDK 1.9时</strong>，接口中的方法可以是<strong>private</strong>的</p>
<p><strong>高内聚低耦合</strong>，是<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/25279">软件工程</a>中的概念，是判断软件设计好坏的标准，主要用于程序的<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/2262089">面向对象</a>的设计，主要看类的内聚性是否高，<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E8%80%A6%E5%90%88%E5%BA%A6/2603938">耦合度</a>是否低。目的是使程序模块的可重用性、移植性大大增强。通常程序结构中各模块的内聚程度越高，模块间的耦合程度就越低。内聚是从功能角度来度量模块内的联系，一个好的内聚模块应当恰好做一件事，它描述的是模块内的功能联系；耦合是软件结构中各模块之间相互连接的一种<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%BA%A6%E9%87%8F/34036">度量</a>，耦合强弱取决于模块间接口的复杂程度、进入或访问一个模块的点以及通过接口的数据。</p>
<h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><p>类的五大成员：<strong>属性、方法、构造器、代码块、内部类</strong></p>
<p>类在局部位置(方法中&#x2F;代码块)：<strong>局部内部类、匿名内部类</strong></p>
<p>类在成员位置：<strong>成员内部类、静态内部类</strong></p>
<p>特点：可以直接访问私有属性，并且可以体现类与类之间的包含关系</p>
<h3 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220506150105202.png" alt="image-20220506150105202"></p>
<h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220506150255497.png" alt="image-20220506150255497"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220506150420023.png" alt="image-20220506150420023"></p>
<h3 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220506150551210.png" alt="image-20220506150551210"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220506150620993.png" alt="image-20220506150620993"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220506150656265.png" alt="image-20220506150656265"></p>
<h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220506150811300.png" alt="image-20220506150811300"></p>
<h2 id="枚举-enum"><a href="#枚举-enum" class="headerlink" title="枚举(enum)"></a>枚举(enum)</h2><p>枚举是一组常量的集合</p>
<p>枚举是一种特殊的类，里面包含一组有限的特定的对象</p>
<h3 id="自定义类实现枚举"><a href="#自定义类实现枚举" class="headerlink" title="自定义类实现枚举"></a>自定义类实现枚举</h3><p>可以提供getXxx方法，不需要提供setXxx方法，防止属性被修改，因为枚举对象通常为只读</p>
<p>对枚举对象&#x2F;属性使用final+static共同修饰，实现底层优化</p>
<p>枚举对象名全部大写</p>
<p>将构造器私有化，目的防止直接 new</p>
<p>本类内部创建一组对象</p>
<p>对外暴露对象（通过为对象添加 public final static修饰符）</p>
<h3 id="enum-关键字实现枚举"><a href="#enum-关键字实现枚举" class="headerlink" title="enum 关键字实现枚举"></a>enum 关键字实现枚举</h3><p>使用关键字 enum 替代 class</p>
<p> enum 关键字开发一个枚举类时，默认会<strong>继承 Enum 类</strong>, 而且是一个 final 类</p>
<p>public static final Season SPRING &#x3D; new Season(“春天”, “温暖”) 直接使用  SPRING(“春天”, “温暖”)    解读：<strong>常量名(实参列表)</strong></p>
<p>如果有多个常量(对象)， 使用<strong>逗号</strong>间隔，<strong>分号</strong>结尾</p>
<p>enum 来实现枚举，要求将定义常量对象，写在前面</p>
<p>如果使用无参构造器创建 枚举对象，则实参列表和小括号都可以省略</p>
<h3 id="Enum-类"><a href="#Enum-类" class="headerlink" title="Enum 类"></a>Enum 类</h3><ol>
<li><p>toString：Enum 类已经重写过了，返回的是当前对象名,子类可以重写该方法，用于返回对象的属性信息 </p>
</li>
<li><p>name：返回当前对象名（常量名），子类中不能重写 </p>
</li>
<li><p>ordinal：返回当前对象的位置号，默认从 0 开始 </p>
</li>
<li><p>values：返回当前枚举类中所有的常量</p>
</li>
<li><p>valueOf：将字符串转换成枚举对象，要求字符串必须为已有的常量名，否则报异常！</p>
</li>
<li><p>compareTo：比较两个枚举常量，比较的就是编号！</p>
</li>
</ol>
<h3 id="enum-实现接口"><a href="#enum-实现接口" class="headerlink" title="enum 实现接口"></a>enum 实现接口</h3><ol>
<li><p>使用 enum 关键字后，就不能再继承其它类了，因为 enum 会隐式继承 Enum，而 Java 是单继承机制。</p>
</li>
<li><p>枚举类和普通类一样，可以实现接口，如下形式。 enum 类名 implements 接口 1，接口 2{}</p>
</li>
</ol>
<h2 id="注解-Annotation"><a href="#注解-Annotation" class="headerlink" title="注解(Annotation)"></a>注解(Annotation)</h2><ol>
<li><p>注解(Annotation)也被称为元数据(Metadata)，用于修饰解释包、类、方法、属性、构造器、局部变量等数据信息。 </p>
</li>
<li><p>和注释一样，注解不影响程序逻辑，但注解可以被编译或运行，相当于嵌入在代码中的补充信息。 </p>
</li>
<li><p>在 JavaSE 中，注解的使用目的比较简单，例如标记过时的功能，忽略警告等。在 JavaEE 中注解占据了更重要的角 色，例如用来配置应用程序的任何切面，代	替 java EE 旧版中所遗留的繁冗代码和 XML 配置等</p>
</li>
</ol>
<p>使用 Annotation 时要在其前面增加 @ 符号, 并把该 Annotation 当成一个修饰符使用。用于修饰它支持的程序元素</p>
<p>三个基本的 Annotation: </p>
<ol>
<li>@Override: 限定某个方法，是重写父类方法, 该注解只能用于方法</li>
</ol>
<p>​	如果写了@Override 注解，编译器就会去检查该方法是否真的重写了父类的 方法，如果的确重写了，则编译通过，如果没有构成重写，则编译错误</p>
<p>​	 @Override注解源码：@Target(ElementType.METHOD)，说明只能修饰方法，不能修饰其它类、包、和属性等</p>
<ol start="2">
<li>@Deprecated: 用于表示某个程序元素(类, 方法等)已过时，即不在推荐使用，但是仍然可以使用</li>
</ol>
<p>​	@Deprecated 注解类的源码：@Target(value&#x3D;{CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE}，说明可以修饰方法，</p>
<p>​	类，字段, 包, 参数等等</p>
<p>​	@Deprecated 可以做版本升级过渡使用</p>
<ol start="3">
<li>@SuppressWarnings: 抑制编译器警告，在{“”} 中，可以写入你希望抑制(不显示)警告信息</li>
</ol>
<p>​	@SuppressWarnings 源码：@Target({TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE})，通常我们可以放置具体的语句, 方法, 类</p>
<p>​	可以指定的警告类型有 </p>
<p>​	&#x2F;&#x2F;all，抑制所有警告</p>
<p>​	&#x2F;&#x2F;boxing，抑制与封装&#x2F;拆装作业相关的警告</p>
<p>​	&#x2F;&#x2F;cast，抑制与强制转型作业相关的警告 </p>
<p>​	&#x2F;&#x2F;dep-ann，抑制与淘汰注释相关的警告</p>
<p>​	&#x2F;&#x2F;deprecation，抑制与淘汰的相关警告</p>
<p>​	&#x2F;&#x2F;fallthrough，抑制与 switch 陈述式中遗漏 break 相关的警告</p>
<p>​	&#x2F;&#x2F;finally，抑制与未传回 finally 区块相关的警告 </p>
<p>​	hiding，抑制与隐藏变数的区域变数相关的警告</p>
<p>​	&#x2F;&#x2F;incomplete-switch，抑制与 switch 陈述式(enum case)中遗漏项目相关的警告  </p>
<p>​	&#x2F;&#x2F;javadoc，抑制与 javadoc 相关的警告</p>
<p>​	&#x2F;&#x2F;nls，抑制与非 nls 字串文字相关的警告</p>
<p>​	&#x2F;&#x2F;null，抑制与空值分析相关的警告 </p>
<p>​	&#x2F;&#x2F;rawtypes，抑制与使用 raw 类型相关的警告</p>
<p>​	&#x2F;&#x2F;resource，抑制与使用 Closeable 类型的资源相关的警告 </p>
<p>​	&#x2F;&#x2F;restriction，抑制与使用不建议或禁止参照相关的警告  </p>
<p>​	&#x2F;&#x2F;serial，抑制与可序列化的类别遗漏 serialVersionUID 栏位相关的警告 </p>
<p>​	&#x2F;&#x2F;static-access，抑制与静态存取不正确相关的警告</p>
<p>​	&#x2F;&#x2F;static-method，抑制与可能宣告为 static 的方法相关的警告</p>
<p>​	&#x2F;&#x2F;super，抑制与置换方法相关但不含 super 呼叫的警告</p>
<p>​	&#x2F;&#x2F;synthetic-access，抑制与内部类别的存取未最佳化相关的警告</p>
<p>​	&#x2F;&#x2F;sync-override，抑制因为置换同步方法而遗漏同步化的警告</p>
<p>​	&#x2F;&#x2F;unchecked，抑制与未检查的作业相关的警告</p>
<p>​	&#x2F;&#x2F;unqualified-field-access，抑制与栏位存取不合格相关的警告 </p>
<p>​	&#x2F;&#x2F;unused，抑制与未用的程式码及停用的程式码相关的警告</p>
<h2 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h2><p>JDK 的元 Annotation 用于修饰其他 Annotation</p>
<p>元注解的种类：</p>
<ol>
<li>Retention &#x2F;&#x2F;指定注解的作用范围，三种 SOURCE,CLASS,RUNTIME</li>
</ol>
<p>​	只能用于修饰一个 Annotation 定义, 用于指定该 Annotation 可以保留多长时间, @Rentention 包含一个 RetentionPolicy 类型的成员变量, 使用 @Rentention 	时必须为该 value</p>
<p>@Retention 的三种值 </p>
<p>a. RetentionPolicy.SOURCE: 编译器使用后，直接丢弃这种策略的注释 </p>
<p>b. RetentionPolicy.CLASS: 编译器将把注解记录在 class 文件中. 	当运行 Java 程序时, JVM 不会保留注解。 这是默认值</p>
<p>c. RetentionPolicy.RUNTIME:编译器将把注解记录在 class 文件中. 当运行 Java 程序时, JVM 会保留注解. 程序可以 通过反射获取该注解</p>
<ol start="2">
<li><p>Target &#x2F;&#x2F; 指定注解可以在哪些地方使用 </p>
</li>
<li><p>Documented &#x2F;&#x2F;指定该注解是否会在 javadoc 体现</p>
</li>
<li><p>Inherited &#x2F;&#x2F;子类会继承父类注解</p>
</li>
</ol>
<h2 id="异常-Exception"><a href="#异常-Exception" class="headerlink" title="异常-Exception"></a>异常-Exception</h2><p>java语言中，将程序执行中发生的不正常情况称为“异常”(开发过程中的语法错误和逻辑错误不是异常)</p>
<p>两类：Error—Java虚拟机无法解决的严重问题，如：JVM系统内部错误、资源耗尽等情况</p>
<p>​			Exception—其他因编程错误或偶然的外在因素导致的一般性问题，可以使用针对性的代码进行处理。例如：空指针访问、试图读取不存在的文件、网络连接中断等，分为：运行时异常(可以不做处理，默认就是throws的方式处理，若全处理可能会对程序的可读性和运行效率产生影响)和编译时异常(必须处置，否则代码不能通过编译)。</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220506214357718.png" alt="image-20220506214357718"></p>
<h3 id="常见的运行时异常"><a href="#常见的运行时异常" class="headerlink" title="常见的运行时异常"></a>常见的运行时异常</h3><ol>
<li>NullPointerException 空指针异常</li>
</ol>
<p>​	当应用程序试图在需要对象的地方使用 null 时，抛出该异常</p>
<ol start="2">
<li>ArithmeticException 数学运算异常</li>
</ol>
<p>​	当出现异常的运算条件时，抛出此异常。例如，一个整数“除以零”时，抛出此类的一个实例</p>
<ol start="3">
<li>ArrayIndexOutOfBoundsException 数组下标越界异常</li>
</ol>
<p>​	用非法索引访问数组时抛出的异常。如果索引为负或大于等于数组大小，则该索引为非法索引</p>
<ol start="4">
<li>ClassCastException 类型转换异常</li>
</ol>
<p>​	当试图将对象强制转换为不是实例的子类时，抛出该异常。</p>
<ol start="5">
<li>NumberFormatException 数字格式不正确异常</li>
</ol>
<p>​	当应用程序试图将字符串转换成一种数值类型，但该字符串不能转换为适当格式时，抛出该异常 &#x3D;&gt; 使用异常我们 可以确保输入是满足条件数字</p>
<h3 id="常见的编译时异常"><a href="#常见的编译时异常" class="headerlink" title="常见的编译时异常"></a>常见的编译时异常</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220506215045615.png" alt="image-20220506215045615"></p>
<h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220506215331954.png" alt="image-20220506215331954"></p>
<h4 id="try-catch-finally"><a href="#try-catch-finally" class="headerlink" title="try-catch-finally"></a>try-catch-finally</h4><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220506215507298.png" alt="image-20220506215507298"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220506215617489.png" alt="image-20220506215617489"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220506220317153.png" alt="image-20220506220317153"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220506215812627.png" alt="image-20220506215812627"></p>
<h4 id="throws"><a href="#throws" class="headerlink" title="throws"></a>throws</h4><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220506220018705.png" alt="image-20220506220018705"></p>
<h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><p>当程序中出现了某些错误，但该错误信息并没有在Throwable子类中描述处理，则可以自己设计异常类，用于描述该错误信息。</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220506220807103.png" alt="image-20220506220807103"></p>
<h3 id="throw-和-throws-的区别"><a href="#throw-和-throws-的区别" class="headerlink" title="throw 和 throws 的区别"></a>throw 和 throws 的区别</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220506221123112.png" alt="image-20220506221123112"></p>
<h1 id="常用类"><a href="#常用类" class="headerlink" title="常用类"></a>常用类</h1><h2 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h2><ol>
<li><p>针对八种基本数据类型相应的引用类型—包装类 </p>
</li>
<li><p>有了类的特点，就可以调用类中的方法。</p>
</li>
</ol>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220507143234839.png" alt="image-20220507143234839"></p>
<h3 id="装箱与拆箱"><a href="#装箱与拆箱" class="headerlink" title="装箱与拆箱"></a>装箱与拆箱</h3><p>包装类与基本数据类型之间的相互转换</p>
<p>JDK5.0以后(含5.0)有自动拆装箱</p>
<p>自动拆装箱底层调用的是<strong>valueOf方法</strong>，例如：Integer.valueOf();</p>
<h3 id="Integer-类和-Character-类的常用方法"><a href="#Integer-类和-Character-类的常用方法" class="headerlink" title="Integer 类和 Character 类的常用方法"></a>Integer 类和 Character 类的常用方法</h3><p>(Integer.MIN_VALUE); &#x2F;&#x2F;返回最小值</p>
<p>(Integer.MAX_VALUE);&#x2F;&#x2F;返回最大值</p>
<p>(Character.isDigit(‘a’));&#x2F;&#x2F;判断是不是数字</p>
<p>(Character.isLetter(‘a’));&#x2F;&#x2F;判断是不是字母 </p>
<p>(Character.isUpperCase(‘a’));&#x2F;&#x2F;判断是不是大写 </p>
<p>(Character.isLowerCase(‘a’));&#x2F;&#x2F;判断是不是小写 </p>
<p>(Character.isWhitespace(‘a’));&#x2F;&#x2F;判断是不是空格 </p>
<p>(Character.toUpperCase(‘a’));&#x2F;&#x2F;转成大写 </p>
<p>(Character.toLowerCase(‘A’));&#x2F;&#x2F;转成小写</p>
<h2 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h2><p>1）String对象用于保存字符串，也就是一组字符序列</p>
<p>2）字符串常量对象是用双引号括起的字符序列</p>
<p>3）字符串的字符使用的是Unicode字符编码，一个字符(不区分字母还是汉字)占两个字节</p>
<p>4）String 类实现了接口 Serializable【String 可以串行化:可以在网络传输】  接口 Comparable [String 对象可以比较大小]</p>
<p>5）String 是 final 类，不能被其他的类继承，代表不可变的字符序列</p>
<p>6）String 有属性 private final char value[]： 用于存放字符串内容 </p>
<p>7）一定要注意：value 是一个 final 类型， 不可以修改(需要功力)：即 value 不能指向新的地址，但是单个字符内容是可以变化</p>
<p>8）字符串是不可变的。一个字符串对象一旦被分配，其内容是不可变的</p>
<p>9）intern方法：最终返回的是常量池的地址(对象)</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220507145402726.png" alt="image-20220507145402726"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220507145435192.png" alt="image-20220507145435192"></p>
<p>10）String类是保存字符串常量的。每次更新都需要重新开辟空间，效率极低，因此Java设计者还提供了StringBuilder和StringBuffer来增强String的功能</p>
<h3 id="String类常用方法"><a href="#String类常用方法" class="headerlink" title="String类常用方法"></a>String类常用方法</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220507155349012.png" alt="image-20220507155349012"></p>
<p>1）toUpperCase 转换成大写</p>
<p>2）toLowerCase 转换成小写</p>
<p>3）concat 拼接字符串</p>
<p>4）replace 替换字符串中的字符</p>
<p>5）split 分割字符串, 对于某些分割字符，我们需要转义比如 | \\等</p>
<p>6）toCharArray 转换成字符数组</p>
<p>7）compareTo 比较两个字符串的大小，如果前者大，则返回正数，后者大，则返回负数，如果相等，返回 0</p>
<p>8）format 格式字符串(占位符有:%s 字符串 %c 字符 %d 整型 %.2f 浮点)</p>
<h2 id="StringBuffer类"><a href="#StringBuffer类" class="headerlink" title="StringBuffer类"></a>StringBuffer类</h2><p><strong>可变的字符序列</strong>，可以对字符串内容进行增删(**线程安全)**。</p>
<p>很多方法与String相同，但StringBuffer是可变长度的。</p>
<p>StringBuffer是一个<strong>容器</strong>。</p>
<p>StringBuffer 的直接父类 是 AbstractStringBuilder</p>
<p>StringBuffer 实现了 Serializable, 即 StringBuffer 的对象可以串行化</p>
<p>在父类中 AbstractStringBuilder 有属性 char[] value,不是 fina，该 value 数组存放字符串内容，引出存放在堆中的</p>
<p>StringBuffer 是一个 final 类，不能被继承</p>
<p>因为 StringBuffer 字符内容是存在 char[] value, 在变化(增加&#x2F;删除)时，不用每次都更换地址(即不是每次创建新对象)， 所以效率高于 String</p>
<h3 id="String与StringBuffer的转换"><a href="#String与StringBuffer的转换" class="headerlink" title="String与StringBuffer的转换"></a>String与StringBuffer的转换</h3><h4 id="String—-gt-StringBuffer"><a href="#String—-gt-StringBuffer" class="headerlink" title="String—&gt;StringBuffer"></a>String—&gt;StringBuffer</h4><p>1）使用构造器：StringBuffer stringBuffer &#x3D; new StringBuffer(str)</p>
<p>2）使用的是 append 方法：StringBuffer stringBuffer &#x3D; new StringBuffer(); stringBuffer &#x3D; stringBuffer.append(str)</p>
<h4 id="StringBuffer—-gt-String"><a href="#StringBuffer—-gt-String" class="headerlink" title="StringBuffer—&gt;String"></a>StringBuffer—&gt;String</h4><p>StringBuffer stringBuffer &#x3D; new StringBuffer(“韩顺平教育”);</p>
<p>1）使用 StringBuffer 提供的 toString 方法：String s &#x3D; stringBuffer.toString()</p>
<p>2）使用构造器：String s &#x3D; new String(stringBuffer)</p>
<h3 id="StringBuffer类常用方法"><a href="#StringBuffer类常用方法" class="headerlink" title="StringBuffer类常用方法"></a>StringBuffer类常用方法</h3><p>1）增：append</p>
<p>2）删：delete</p>
<p>3）改：replace</p>
<p>4）查：indexOf</p>
<p>5）插：insert</p>
<p>6）长度：length</p>
<h2 id="StringBuilder-类"><a href="#StringBuilder-类" class="headerlink" title="StringBuilder 类"></a>StringBuilder 类</h2><p>一个可变的字符序列。此类提供一个与StringBuffer兼容的API，但不保证同步(<strong>线程不安全</strong>)。</p>
<p>StringBuilder 的方法，没有做互斥的处理,即没有 synchronized 关键字,因此在单线程的情况下使用</p>
<p>该类用在字符串缓冲区被单个线程使用的时候，<strong>比StringBuffer要快</strong>。</p>
<p>在StringBuilder上的主要操作是append和insert方法，可重载这些方法，已接受任意类型的数据</p>
<p>StringBuilder 接父类 是 AbstractStringBuilder</p>
<p>StringBuilder 实现了 Serializable, 即 StringBuilder 的对象可以串行化</p>
<p>在父类中 AbstractStringBuilder 有属性 char[] value,不是 fina，该 value 数组存放字符串内容，引出存放在堆中的</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220507164322409.png" alt="image-20220507164322409"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220507164338156.png" alt="image-20220507164338156"></p>
<h3 id="String、StringBuffer-和-StringBuilder-的选择"><a href="#String、StringBuffer-和-StringBuilder-的选择" class="headerlink" title="String、StringBuffer 和 StringBuilder 的选择"></a>String、StringBuffer 和 StringBuilder 的选择</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220507164449875.png" alt="image-20220507164449875"></p>
<h2 id="Math-类"><a href="#Math-类" class="headerlink" title="Math 类"></a>Math 类</h2><p>Math 类包含用于执行基本数学运算的方法，如初等指数、对数、平方根和三角函数。均为静态方法</p>
<p>abs 绝对值</p>
<p>pow 求幂</p>
<p>ceil 向上取整，返回&gt;&#x3D;该参数的最小整数(转成 double)</p>
<p>floor 向下取整，返回&lt;&#x3D;该参数的最大整数(转成 double)</p>
<p>round 四舍五入</p>
<p>sqrt 求开方</p>
<p>random 求随机数  返回的是 0 &lt;&#x3D; x &lt; 1 之间的一个随机小数</p>
<h2 id="Arrays-类"><a href="#Arrays-类" class="headerlink" title="Arrays 类"></a>Arrays 类</h2><p>Arrays里面包含了一系列静态方法，用于管理或操作数组(例如排序和搜素)</p>
<p>1）toString 返回数组的字符串形式</p>
<p>2）sort 排序</p>
<p>3）binarySearch 通过二分搜索法进行查找，要求必须排好序</p>
<p>4）copyOf 数组元素的复制</p>
<p>5）fill 数组元素的填充</p>
<p>6）equals 比较两个数组元素内容是否完全一致</p>
<p>7）asList 将一组值转换成List</p>
<h2 id="System-类"><a href="#System-类" class="headerlink" title="System 类"></a>System 类</h2><p>1）exit 退出当前程序</p>
<p>2）arraycopy 复制数组元素，比较适合底层调用，一般使用Arrays.copyOf完成复制数组</p>
<p>3）currentTimeMillens 返回当前时间距离1970-1-1的毫秒数</p>
<p>4）gc 运行垃圾回收机制</p>
<p>5）fill 数组元素的填充</p>
<p>6）equals 比较两个数组元素内容是否完全一致</p>
<p>7）asList 将一组值转换成List</p>
<h2 id="BigInteger-和-BigDecimal-类"><a href="#BigInteger-和-BigDecimal-类" class="headerlink" title="BigInteger 和 BigDecimal 类"></a>BigInteger 和 BigDecimal 类</h2><p>BigInteger 适合保存比较大的整型</p>
<p>BigDecimal适合保存精度更高的浮点型</p>
<h3 id="常见方法"><a href="#常见方法" class="headerlink" title="常见方法"></a>常见方法</h3><p>1）add 加</p>
<p>2）subtract 减</p>
<p>3）multiply 乘</p>
<p>4）divide 除</p>
<h2 id="日期类"><a href="#日期类" class="headerlink" title="日期类"></a>日期类</h2><h3 id="第一代日期类"><a href="#第一代日期类" class="headerlink" title="第一代日期类"></a>第一代日期类</h3><p>1.Date：精确到毫秒，代表特定的瞬间</p>
<p>2.SimpleDateFormat：格式和解析日期的类</p>
<h3 id="第二代日期类"><a href="#第二代日期类" class="headerlink" title="第二代日期类"></a>第二代日期类</h3><p>Calendar类：抽象类，他为特定瞬间与一组诸如YEAR、MONTH、DAY_OF_MONTH、HOUR等日历字段之间的转换提供了一些方法，并为操作日历字段提供了一</p>
<p>些方法。</p>
<h3 id="第三代日期类"><a href="#第三代日期类" class="headerlink" title="第三代日期类"></a>第三代日期类</h3><p>LocalDate：只包含日期，可以获得日期字段</p>
<p>LocalTime：只包含时间，可以获得时间字段</p>
<p>LocalDateTime：包含日期+时间，可以获取日期和时间字段</p>
<h3 id="DateTimeFormatter-格式日期类"><a href="#DateTimeFormatter-格式日期类" class="headerlink" title="DateTimeFormatter 格式日期类"></a>DateTimeFormatter 格式日期类</h3><h3 id="Instant-时间戳"><a href="#Instant-时间戳" class="headerlink" title="Instant 时间戳"></a>Instant 时间戳</h3><h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><p>数组缺点：长度开始时必须指定，而且一旦指定，不能更改</p>
<p>​					保存的必须为同一类型的元素</p>
<p>​					使用数组进行增删改查比较麻烦</p>
<p>集合：可以<strong>动态保存</strong>任意多个对象</p>
<p>​			提供了一系列方便的操作对象的方法：add、remove、set、get等</p>
<p>​			使用集合添加、删除新元素简单</p>
<p>Java的集合类主要分为两大类</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220510195334921.png" alt="image-20220510195334921"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220510195351280.png" alt="image-20220510195351280"></p>
<p><img src="http://uploadfiles.nowcoder.com/images/20151109/403938_1447079573733_4F723777B74785B7A07A73C9792B8F6F" alt="img"></p>
<p>集合主要是两组(单列集合，双列集合)</p>
<p>Collection接口有两个重要的子接口List Set，他们的实现子类都是单列集合</p>
<p>Map接口的实现子类是双列集合，存放的是K-V</p>
<h2 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a>Collection接口</h2><p>Collection实现子类可以存放多个元素，每个元素可以是Object</p>
<p>有些实现子类可以存放重复元素，有些不可以</p>
<p>有些实现子类是有序的(List)，有些是无序的(Set)</p>
<p>Collection接口没有直接的实现子类，是通过他的子接口Set和List来实现的</p>
<h3 id="Collection-接口常用方法"><a href="#Collection-接口常用方法" class="headerlink" title="Collection 接口常用方法"></a>Collection 接口常用方法</h3><p>add:添加单个元素</p>
<p>remove:删除指定元素</p>
<p>contains:查找元素是否存在</p>
<p>size:获取元素个数</p>
<p>isEmpty:判断是否为空</p>
<p>clear:清空</p>
<p>addAll:添加多个元素</p>
<p>containsAll:查找多个元素是否都存在</p>
<p>removeAll：删除多个元素</p>
<h3 id="Collection-接口遍历元素"><a href="#Collection-接口遍历元素" class="headerlink" title="Collection 接口遍历元素"></a>Collection 接口遍历元素</h3><h4 id="Iterator-迭代器"><a href="#Iterator-迭代器" class="headerlink" title="Iterator(迭代器)"></a>Iterator(迭代器)</h4><p>所有实现了Collection接口的集合类都有一个iterator()方法，用以返回一个实现了Iterator接口的对象，即可以返回一个迭代器</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220510200811204.png" alt="image-20220510200811204"></p>
<h4 id="for-循环增强"><a href="#for-循环增强" class="headerlink" title="for 循环增强"></a>for 循环增强</h4><p>语法：for(元素类型 元素名：集合名或数组名){</p>
<p>​						访问元素</p>
<p>​			}</p>
<h2 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a>List接口</h2><p>Collection接口的子接口</p>
<p>List集合类中<strong>元素有序</strong>(添加顺序与取出顺序一致)、<strong>可重复</strong></p>
<p>List集合中的每个元素都有其对应的顺序索引，即支持索引</p>
<p>List容器中的元素都对应一个整数型的序号记载其在容器中的位置，可以根据序号存取容器中的元素</p>
<h3 id="List的遍历"><a href="#List的遍历" class="headerlink" title="List的遍历"></a>List的遍历</h3><p>使用iterator</p>
<p>增强for</p>
<p>普通for</p>
<h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><p>由数组实现数据存储</p>
<p>可以加入<strong>null</strong>，并且<strong>多个</strong></p>
<p>基本等同于<strong>Vector</strong>，除了**ArrayList是线程不安全的(执行效率高)**，多线程情况下，不建议使用ArrayList</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220510203244326.png" alt="image-20220510203244326"></p>
<h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h3><p>线程同步，即<strong>线程安全</strong>，Vector类的操作方法带有<strong>synchronized</strong></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220510204207739.png" alt="image-20220510204207739"></p>
<h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><p>底层实现了双向链表和双端队列的特点</p>
<p>可以添加任意元素(元素可以重复)，包括null</p>
<p>线程不安全，没有实现同步</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220510204439516.png" alt="image-20220510204439516"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220510204620749.png" alt="image-20220510204620749"></p>
<h2 id="Set接口"><a href="#Set接口" class="headerlink" title="Set接口"></a>Set接口</h2><p><strong>无序</strong>(添加和取出的顺序不一致)，没有索引</p>
<p><strong>不允许重复元素</strong>，最多只能包含一个null</p>
<h3 id="Set的遍历"><a href="#Set的遍历" class="headerlink" title="Set的遍历"></a>Set的遍历</h3><p>使用迭代器</p>
<p>增强for</p>
<p>不能使用索引的方式来获取</p>
<h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><p>底层是HashMap，HashMap的底层是数组+链表+红黑树</p>
<p>可以存放null值，但是只能有一个</p>
<p>不能有重复元素</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220510205506684.png" alt="image-20220510205506684"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220510205702116.png" alt="image-20220510205702116"></p>
<h3 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h3><p>HashSet的子类</p>
<p>底层是LinkedHashMap，底层维护了一个数组+双向链表</p>
<p>根据元素的hashCode值来决定元素的存储位置，同时使用链表维护元素的次序，这使元素看起来是以插入顺序保存的</p>
<p>不允许添加重复元素</p>
<h2 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h2><p><strong>Map与Collection并列存在</strong>，用于保存具有映射关系的数据：Key-Value</p>
<p>Key和Value可以是任何引用类型的数据，会封装到HashMap$Node对象中</p>
<p><strong>Key不允许重复</strong>，原因和HashSet一样</p>
<p><strong>Value可以重复</strong></p>
<p><strong>Key与Value可为null</strong></p>
<p>常用String类作为Map的Key</p>
<p>Key与Value存在<strong>单向一对一</strong>关系，即通过指定的Key总能找到对应的value</p>
<p>一对K-V是存放在一个HashMap$Node中的，Node实现了Entry接口，故也可说，一对k-v就是一个Entry</p>
<h3 id="Map接口常用方法"><a href="#Map接口常用方法" class="headerlink" title="Map接口常用方法"></a>Map接口常用方法</h3><p>put：添加数据，若key相等，则替换key对应的value值</p>
<p>remove：根据键删除映射关系</p>
<p>get：根据键获取值</p>
<p>size：获取元素个数</p>
<p>isEmpty：判断个数是否为 0</p>
<p>clear：清除 k-v</p>
<p>containsKey：查找键是否存在</p>
<h3 id="Map的遍历"><a href="#Map的遍历" class="headerlink" title="Map的遍历"></a>Map的遍历</h3><p>1）containsKey：查找键是否存在</p>
<p>2）KeySet：获取所有的键</p>
<p>3）entrySet：获取所有关系</p>
<p>4）values：获取所有的值</p>
<h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p>是Map接口使用频率最高的实现类</p>
<p>以<strong>key-value</strong>对的方式来存储数据(HashMap$Node类型)</p>
<p>key不能重复，但是值可以，允许使用null键和null值</p>
<p>如果添加相同的key，则会覆盖原来的key-value，等同于修改</p>
<p><strong>无序</strong>，与HashSet一样，不保证映射的顺序，因为底层是以hash表的方式来存储的</p>
<p>Hash没有实现同步，因此是<strong>线程不安全</strong>的，方法没有做同步互斥的操作，没有synchronized</p>
<p>扩容机制</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220512151107133.png" alt="image-20220512151107133"></p>
<h3 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h3><p>存放的元素是键值对：k-v</p>
<p>hashTable的键和值都<strong>不能为null</strong>，否则会抛出NullPointerException</p>
<p>hashTable使用方法基本与hashMap一样</p>
<p>**线程安全(synchronized)**，hashMap线程不安全</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220512151637502.png" alt="image-20220512151637502"></p>
<h3 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h3><p>继承HashTable类，并实现了Map接口，也是使用一种键值对的形式来保存数据</p>
<p>使用特点和HashTable类似</p>
<p>可用于从xxx.properties文件中，加载数据到Properties类对象，并进行读取和修改</p>
<p>专门用于读写配置文件的集合类，配置文件的格式：键&#x3D;值，键值对不需要有空格，值不需要用引号一起来，默认类型是String</p>
<p>常见方法：</p>
<p>1）load：加载配置文件的键值对到Properties对象</p>
<p>2）list：将数据显示到指定设备</p>
<p>3）getProperty(key)：根据键获取值</p>
<p>4）setProperty(key, value)：设置键值对到Properties对象</p>
<p>5）store：将Properties中的键值对存储到配置文件，在idea中，保存信息到配置文件，如果含有中文，会存储为unicode码</p>
<h2 id="集合实现类的选取"><a href="#集合实现类的选取" class="headerlink" title="集合实现类的选取"></a>集合实现类的选取</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220512152145730.png" alt="image-20220512152145730"></p>
<h2 id="Collections-工具类"><a href="#Collections-工具类" class="headerlink" title="Collections 工具类"></a>Collections 工具类</h2><p>操作Set、List、和Map等集合的工具类</p>
<p>提供了一系列<strong>静态方法</strong>对集合元素进行排序、查询和修改等操作</p>
<h3 id="排序操作"><a href="#排序操作" class="headerlink" title="排序操作"></a>排序操作</h3><p>reverse(List)：反转 List 中元素的顺序</p>
<p>shuffle(List)：对 List 集合元素进行随机排序</p>
<p>sort(List)：根据元素的自然顺序对指定 List 集合元素按升序排序</p>
<p>sort(List，Comparator)：根据指定的 Comparator 产生的顺序对 List 集合元素进行排序</p>
<p>swap(List，int， int)：将指定 list 集合中的 i 处元素和 j 处元素进行交换</p>
<h3 id="查找、替换"><a href="#查找、替换" class="headerlink" title="查找、替换"></a>查找、替换</h3><p>Object max(Collection)：根据元素的自然顺序，返回给定集合中的最大元素</p>
<p>Object max(Collection，Comparator)：根据 Comparator 指定的顺序，返回给定集合中的最大元素</p>
<p>int frequency(Collection，Object)：返回指定集合中指定元素的出现次数</p>
<p>void copy(List dest,List src)：将 src 中的内容复制到 dest 中</p>
<p>boolean replaceAll(List list，Object oldVal，Object newVal)：使用新值替换 List 对象的所有旧值</p>
<h1 id="泛型E"><a href="#泛型E" class="headerlink" title="泛型E"></a>泛型E</h1><p>传统方法不能对加入到集合中的数据类型进行约束(不安全)</p>
<p>遍历的时候需要进行类型转换，如果集合中的数据量较大，对效率有影响</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220512160747944.png" alt="image-20220512160747944"></p>
<p>作用：可以在类声明时通过一个标识表示类中某个属性的类型，或者是某个方法的返回值的类型，或者是参数类型。</p>
<p>泛型的声明：interface 接口<T>{}和class 类&lt;K,V&gt;{}</p>
<p>​						T、K、V不代表值，而是表示类型，只能是<strong>引用类型</strong></p>
<p>泛型的实例化：要在类名后面指定类型参数的值(类型)</p>
<p>在给泛型指定具体类型后，可以传入该类型或者子类类型</p>
<h2 id="自定义泛型类"><a href="#自定义泛型类" class="headerlink" title="自定义泛型类"></a>自定义泛型类</h2><p>class 类名&lt;T, R…&gt;{</p>
<p>​		成员</p>
<p>}</p>
<p>普通成员可以使用泛型，静态不可以</p>
<p>使用泛型的数组，不能初始化</p>
<p>静态方法中不能使用类的泛型</p>
<p>泛型类的类型，是在创建对象的时候确定的(因为创建对象时，需要指定确定类型</p>
<p>如果在创建对象时，没有指定类型，默认为Object</p>
<h2 id="自定义泛型接口"><a href="#自定义泛型接口" class="headerlink" title="自定义泛型接口"></a>自定义泛型接口</h2><p>interface 接口名&lt;T,R…&gt;{}</p>
<p>接口中，静态成员也不能使用泛型</p>
<p>泛型接口的类型，在继承接口或者实现接口时确定</p>
<p>没有指定类型，默认为Object</p>
<h2 id="自定义泛型方法"><a href="#自定义泛型方法" class="headerlink" title="自定义泛型方法"></a>自定义泛型方法</h2><p>修饰符 &lt;T,R&gt;返回类型 方法名(参数列表){}</p>
<p>泛型方法，可以定义在普通类中，也可以定义在泛型类中</p>
<p>泛型方法被调用时，类型会确定</p>
<h2 id="泛型的继承和通配符"><a href="#泛型的继承和通配符" class="headerlink" title="泛型的继承和通配符"></a>泛型的继承和通配符</h2><p>泛型不具备继承性</p>
<p>&lt; ? &gt;：支持任意泛型类型</p>
<p>&lt; ? extends A &gt;：支持A类以及A类的子类，规定了泛型的上限</p>
<p>&lt; ? super A &gt;：支持A类以及A类的父类，不限于直接父类，规定了泛型的下限</p>
<h2 id="JUnit"><a href="#JUnit" class="headerlink" title="JUnit"></a>JUnit</h2><p>一个类有很多功能代码需要测试，为了测试，就需要写入到main方法中，如果有多个功能代码测试，就需要来回注销，切换很麻烦</p>
<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>进程是指运行中的程序，比如我们使用QQ，就启动了一个进程，操作系统就会为该进程分配内存空间。当我们使用迅雷，又启动了一个进程，操作系统将为迅雷分配性的内存空间。</p>
<p>进程是程序的一次执行过程，或是正在运行的一个程序。是动态过程：有他自身的产生、存在和消亡的过程。</p>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>由进程创建，是进程的一个实体</p>
<p>一个进程可以拥有多个线程</p>
<p>单线程：同一时刻，只允许执行一个线程</p>
<p>多线程：同一时刻，可以执行多个线程，比如：一个QQ进程，可以同时打开多个聊天窗口，一个迅雷进程，可以同时下载多个文件</p>
<p>并发：同一时刻，多个任务交替执行，造成一种“貌似同时”的错觉，简单地说，单核CPU实现的多任务就是并发</p>
<p>并行：同一时刻，多个任务同时执行。多个CPU可以实现并行</p>
<h2 id="线程的基本使用"><a href="#线程的基本使用" class="headerlink" title="线程的基本使用"></a>线程的基本使用</h2><h3 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h3><p>1）继承Thread类，重写run方法</p>
<p>2）实现Runnable接口，实现run方法</p>
<p>​		java是单继承的，在某些情况下一个类可能已经继承了某个父类，这时再用继承Thread类方法来创建线程显然不可能了，需要new Thread()来使用start方法</p>
<p>​		实现Runnable接口方式更加适合多个线程共享一个资源情况，并且避免了单继承的限制，建议使用Runnable</p>
<p>3）线程池创建线程</p>
<h3 id="线程常用方法"><a href="#线程常用方法" class="headerlink" title="线程常用方法"></a>线程常用方法</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220514203110588.png" alt="image-20220514203110588"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220514203153934.png" alt="image-20220514203153934"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220514203305654.png" alt="image-20220514203305654"></p>
<p>用户线程：也叫工作线程，当线程的任务执行完成或通知方式结束</p>
<p>守护线程：一般是为工作线程服务的，当所有的用户线程结束，守护线程自动结束（常见的守护线程：垃圾回收机制）setDaemon()方法</p>
<h2 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h2><p>Thread.State枚举表示了线程的几种状态</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220514204340007.png" alt="image-20220514204340007"></p>
<p><img src="https://uploadfiles.nowcoder.com/images/20180316/8955099_1521189690989_0BB28C2A1ECCC47EC020E89E8A554BBC" alt="img"></p>
<p><strong>TCP客户端：</strong> </p>
<p>1.建立连接套接字，设置Ip和端口监听，socket()</p>
<p>2.建立连接 connect</p>
<p>3.write() 获取网络流对象 发送数据</p>
<p>4.read()获取网络流对象 接收数据</p>
<p>5.关闭套接字</p>
<p><strong>TCP服务器端：</strong></p>
<p>1.建立端口监听 socket()</p>
<p>2.绑定指定端口 bind()</p>
<p>3.listen 进行端口监听</p>
<p>4.accept() 阻塞式 直到有客户端访问</p>
<p>5.read()获取客户端发送数据</p>
<p>6.write()发送返回数据</p>
<p>7.close关闭端口监听</p>
<h2 id="线程的同步"><a href="#线程的同步" class="headerlink" title="线程的同步"></a>线程的同步</h2><h3 id="线程同步机制"><a href="#线程同步机制" class="headerlink" title="线程同步机制"></a>线程同步机制</h3><p> <strong>Synchronized</strong></p>
<p>在多线程编程，一些敏感数据不允许被多个线程同时访问，此时就使用同步访问技术，保证数据在任何同一时刻，最多有一个线程访问，以保证数据的完整性</p>
<p>线程同步：即当有一个线程在内存进行操作时，其他线程都不可以对这个内存地址进行操作，直到该线程完成操作，其他线程才能对该内存地址进行操作</p>
<h3 id="同步具体方法-Synchronized"><a href="#同步具体方法-Synchronized" class="headerlink" title="同步具体方法-Synchronized"></a>同步具体方法-Synchronized</h3><p>1）同步代码块，尽量使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(对象) &#123; <span class="comment">//得到对象的锁，才能操作同步代码块</span></span><br><span class="line">	<span class="comment">//需要被同步代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2）synchronized还可以放在方法声明中，表示整个方法为同步方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">m</span><span class="params">(String name)</span>&#123;</span><br><span class="line">    <span class="comment">//需要被同步的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><p>Java语言中，引入了对象互斥锁的概念，来保证共享数据操作的完整性</p>
<p>每个对象都对应于一个可称为”互斥锁“的标记，这个标记用来保证在任一时刻，只能有一个线程访问该对象</p>
<p>关键字synchronized来与对象的互斥锁联系。当某个对象用synchronized修饰时，表明该对象在任一时刻只能由一个线程访问</p>
<p>同步的局限性：导致程序的执行效率要降低</p>
<p>同步方法(非静态的)的锁可以是this，也可以是其他对象(要求是同一个对象)</p>
<p>同步方法(静态的)的锁为当前类本身</p>
<p>同步方法如果没有使用static修饰：默认锁对象为this，如果使用static修饰，默认锁对象为：当前类.class</p>
<p>要求多个线程的锁对象为同一个即可！</p>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>多个线程都占用了对方的锁资源，但不肯相让，导致了死锁，在编程是一定要避免死锁的发生</p>
<p>释放锁：当前线程的同步方法、同步代码块执行结束</p>
<p>​				当前线程在同步代码块、同步方法中遇到break、return</p>
<p>​				当前线程在同步代码块、同步方法中出现了未处理的Error或Exception，导致异常结束</p>
<p>​				当前线程在同步代码块、同步方法中执行了线程对象的wait()方法，当前线程暂停，并释放锁</p>
<p>不会释放锁：线程执行同步代码块或同步方法时，程序调用Thread.sleep()、Thread.yield()方法暂停当前线程的执行，不会释放锁</p>
<p>​						线程执行同步代码块时，其他线程调用了该线程的suspend()方法将该线程挂起</p>
<h1 id="IO-流"><a href="#IO-流" class="headerlink" title="IO 流"></a>IO 流</h1><h2 id="文件流"><a href="#文件流" class="headerlink" title="文件流"></a>文件流</h2><p>文件在程序中是以流的形式来操作的</p>
<p>流：数据在数据源(文件)和程序(内存)之间经历的路径</p>
<p>输入流：数据从数据源(文件)到程序(内存)的路径</p>
<p>输出流：数据从程序(内存)到数据源(文件)的路径</p>
<h2 id="常见的文件操作"><a href="#常见的文件操作" class="headerlink" title="常见的文件操作"></a>常见的文件操作</h2><p>创建文件相关构造器和方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">File</span>(String pathname)<span class="comment">//根据路径构建一个File对象</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">File</span>(File parent, String child)<span class="comment">//根据父目录文件+子路径构建一个File对象</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">File</span>(String parent, String child)<span class="comment">//根据父目录+子路径构建一个File对象</span></span><br><span class="line">    </span><br><span class="line">creatNewFile <span class="comment">//创建新文件</span></span><br></pre></td></tr></table></figure>

<p>获取文件的相关信息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">getNmae<span class="comment">//文件名字</span></span><br><span class="line">getAbsolutePath<span class="comment">//文件绝对路径</span></span><br><span class="line">getParent<span class="comment">//&quot;文件父级目录</span></span><br><span class="line">length<span class="comment">//文件大小(字节)</span></span><br><span class="line">exists<span class="comment">//文件是否存在</span></span><br><span class="line">isFile<span class="comment">//是不是一个文件</span></span><br><span class="line">isDirectory<span class="comment">//是不是一个目录</span></span><br></pre></td></tr></table></figure>

<p>目录的操作和文件删除</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">makdir<span class="comment">//创建一级目录</span></span><br><span class="line">mkdirs<span class="comment">//创建多级目录</span></span><br><span class="line">delete<span class="comment">//删除空目录或文件</span></span><br></pre></td></tr></table></figure>

<h2 id="IO-流原理及流的分类"><a href="#IO-流原理及流的分类" class="headerlink" title="IO 流原理及流的分类"></a>IO 流原理及流的分类</h2><p><strong>原理</strong></p>
<p>1）I&#x2F;O是Input&#x2F;Output的缩写，I&#x2F;O技术，用于处理数据传输</p>
<p>2）Java程序中，对于数据的输入&#x2F;输出操作以“流(stream)”的方式进行</p>
<p>3）java.io包下提供了各种“流”类和接口，用以获得不同种类的数据，并通过方法输入或输出数据</p>
<p>4）输入input：读取外部数据(磁盘、光盘等存储设备的数据)到程序(内存)中</p>
<p>5）输出output：将程序(内存)数据输出到磁盘、光盘等存储设备中</p>
<p><strong>分类</strong></p>
<p>按操作数据单位不同：字节流(8 bit)二进制文件，字符流(按字符)文本文件</p>
<p>按数据流的流向不同：输入流，输出流</p>
<p>按流的角色不同：节点流，处理流&#x2F;包装流</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220515222537824.png" alt="image-20220515222537824"></p>
<p>1）Java的IO流共涉及40多个类，都是从如上4个抽象基类派生的</p>
<p>2）由这四个类派生出来的子类名称都是以其父类名作为子类名后缀</p>
<h2 id="IO-流体系图"><a href="#IO-流体系图" class="headerlink" title="IO 流体系图"></a>IO 流体系图</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220516122221731.png" alt="image-20220516122221731"></p>
<p><strong>FileOutputSream</strong></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220516142451047.png" alt="image-20220516142451047"></p>
<p> <strong>FileReader 和 FileWriter</strong></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220516142644135.png" alt="image-20220516142644135"></p>
<p><strong>FileReader 相关方法：</strong></p>
<p>new FileReader(File&#x2F;String)</p>
<p>read：每次读取单个字符，返回该字符，如果到文件末尾返回-1</p>
<p>read(Char[])：批量读取多个字符到数组，返回读取到的字符数，如果到文件末尾返回-1</p>
<p>相关API：new String(char[])：将char[]转换成String</p>
<pre><code>             new String(char[], off, len)：将char[]的指定部分转换成String
</code></pre>
<p><strong>FileWriter 相关方法：</strong></p>
<p>new FileWriter(File&#x2F;String)：覆盖模式，相当于流的指针在首端</p>
<p>new FileWriter(File&#x2F;String, true)：追加模式，相当于流的指针在尾端</p>
<p>writer(int)：写入单个字符</p>
<p>writer(char[])：写入指定数组</p>
<p>writer(char[], off, len)：写入指定数组的指定部分</p>
<p>writer(string)：写入整个字符串</p>
<p>writer(string, off, len)：写入字符串的指定部分</p>
<p>FileWriter使用后，必须**关闭(close)或刷新(flush)**，否则写入不到指定文件！</p>
<h2 id="节点流和处理流"><a href="#节点流和处理流" class="headerlink" title="节点流和处理流"></a>节点流和处理流</h2><p>节点流：可以从一个特定的数据源读写数据，如：FileReader、FileWriter</p>
<p>处理流：是连接在已存在的流(节点流或处理流之上)，为程序提供更为强大的读写功能，也更加灵活，如：BufferedReader、BufferedWriter</p>
<p>区别和联系：</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220516145022746.png" alt="image-20220516145022746"></p>
<h2 id="处理流的优点"><a href="#处理流的优点" class="headerlink" title="处理流的优点"></a>处理流的优点</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220516145131925.png" alt="image-20220516145131925"></p>
<h2 id="处理流-BufferedReader和BufferWriter"><a href="#处理流-BufferedReader和BufferWriter" class="headerlink" title="处理流-BufferedReader和BufferWriter"></a>处理流-BufferedReader和BufferWriter</h2><p>属于字符流，是按照字符来读取数据的</p>
<p>关闭时处理流，只需要关闭外层流即可</p>
<h2 id="处理流-BufferedInputStream-和-BufferedOutputStream"><a href="#处理流-BufferedInputStream-和-BufferedOutputStream" class="headerlink" title="处理流-BufferedInputStream 和 BufferedOutputStream"></a>处理流-BufferedInputStream 和 BufferedOutputStream</h2><p>BufferedInputStream 是字节流，在创建 BufferedInputStream 时，会创建一个内部缓冲区数组</p>
<p><strong>BufferedInputStream–&gt;FilterInputStream–&gt;InputStream–&gt;Closeable(接口)</strong></p>
<p><strong>BufferedOutputStream–&gt;FilterOutputStream–&gt;OutputStream–&gt;Closeable和Flushable(接口)</strong></p>
<h2 id="对象流-ObjectInputStream-和-ObjectOutputStrea"><a href="#对象流-ObjectInputStream-和-ObjectOutputStrea" class="headerlink" title="对象流-ObjectInputStream 和 ObjectOutputStrea"></a>对象流-ObjectInputStream 和 ObjectOutputStrea</h2><h3 id="序列和反序列化"><a href="#序列和反序列化" class="headerlink" title="序列和反序列化"></a>序列和反序列化</h3><p>1）序列化就是在保存数据时，保存数据的值和数据类型。</p>
<p>​		将数据结构转换称为二进制数据流或者文本流的过程。序列化后的数据方便在网络上传输和在硬盘上存储。</p>
<p>2）反序列化就是在恢复数据时，恢复数据的值和数据类型</p>
<p>​		与序列化相反，是将二进制数据流或者文本流转换称为易于处理和阅读的数据结构的过程。</p>
<p>3）需要让某个对象支持序列化机制，则必须让其类是可序列化的，为了让某个类是可序列化的，该类必须实现如下两个接口之一：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Serializable <span class="comment">//这是一个标记接口，没有方法</span></span><br><span class="line">   Externalizable <span class="comment">//该接口有方法需要实现，因此一般实现Serializable接口</span></span><br><span class="line">   <span class="comment">//transient关键字的作用，在已实现序列化的类中，有的变量不需要保存在磁盘中，就要transient关键字修饰，如银行卡密码等，</span></span><br><span class="line">   <span class="comment">//就这个作用------在已序列化的类中使变量不序列化，通常一个类实现序列化方式是实现序列化接口 Serializable</span></span><br></pre></td></tr></table></figure>

<p>对象流功能：提供了对基本类型或对象类型的序列化和反序列化的方法 </p>
<p>​						ObjectOutputStream 提供 序列化功能 </p>
<p>​			   		 ObjectInputStream 提供 反序列化功能</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220516201954245.png" alt="image-20220516201954245">			</p>
<p>序列化数据和反序列化恢复数据</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220516201309591.png" alt="image-20220516201309591"></p>
<h2 id="标准输入输出流"><a href="#标准输入输出流" class="headerlink" title="标准输入输出流"></a>标准输入输出流</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220516201438597.png" alt="image-20220516201438597"></p>
<h2 id="转换流-InputStreamReader-和-OutputStreamWriter"><a href="#转换流-InputStreamReader-和-OutputStreamWriter" class="headerlink" title="转换流-InputStreamReader 和 OutputStreamWriter"></a>转换流-InputStreamReader 和 OutputStreamWriter</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220516201634261.png" alt="image-20220516201634261"></p>
<h2 id="打印流-PrintStream-和-PrintWriter"><a href="#打印流-PrintStream-和-PrintWriter" class="headerlink" title="打印流-PrintStream 和 PrintWriter"></a>打印流-PrintStream 和 PrintWriter</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220516201859470.png" alt="image-20220516201859470"></p>
<h1 id="反射-reflection"><a href="#反射-reflection" class="headerlink" title="反射(reflection)"></a>反射(reflection)</h1><p>需求：根据配置文件re.properties指定信息，创建对象并调用方法；即通过外部配置文件，在不修改源码的情况下来控制程序，也符合设计模式的<strong>ocp原则</strong>(<strong>开闭原则</strong>：不修改源码，扩容功能)</p>
<h2 id="反射机制"><a href="#反射机制" class="headerlink" title="反射机制"></a>反射机制</h2><p>1）反射机制允许程序在执行期间借助于Reflection API 获得任何类的内部信息(比如：成员变量、构造器，成员方法等)，并能操作对象的属性及方法。反射在设计模式和框架底层都会用到</p>
<p>2）加载完类之后，在堆中就产生了一个Class类型的对象(一个类只有一个Class对象)，这个对象包含了类的完整结构信息。通过这个对象得到类的结构。</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220517143914000.png" alt="image-20220517143914000"></p>
<p><strong>作用</strong></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220517144131916.png" alt="image-20220517144131916"></p>
<p><strong>反射相关的类</strong></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220517144239805.png" alt="image-20220517144239805"></p>
<h2 id="反射优点和缺点"><a href="#反射优点和缺点" class="headerlink" title="反射优点和缺点"></a>反射优点和缺点</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220517144349140.png" alt="image-20220517144349140"></p>
<h2 id="反射调用优化-关闭访问检查"><a href="#反射调用优化-关闭访问检查" class="headerlink" title="反射调用优化-关闭访问检查"></a>反射调用优化-关闭访问检查</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220517144438188.png" alt="image-20220517144438188"></p>
<h2 id="Class-类"><a href="#Class-类" class="headerlink" title="Class 类"></a>Class 类</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220517144528389.png" alt="image-20220517144528389"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220517144622172.png" alt="image-20220517144622172"></p>
<h3 id="Class-类的常用方法"><a href="#Class-类的常用方法" class="headerlink" title="Class 类的常用方法"></a>Class 类的常用方法</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220517144710973.png" alt="image-20220517144710973"></p>
<h3 id="获取-Class-类对象"><a href="#获取-Class-类对象" class="headerlink" title="获取 Class 类对象"></a>获取 Class 类对象</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220517144936294.png" alt="image-20220517144936294"></p>
<h3 id="哪些类型有-Class-对象"><a href="#哪些类型有-Class-对象" class="headerlink" title="哪些类型有 Class 对象"></a>哪些类型有 Class 对象</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220517145022485.png" alt="image-20220517145022485"></p>
<h2 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220517145152479.png" alt="image-20220517145152479"></p>
<h3 id="类加载时机"><a href="#类加载时机" class="headerlink" title="类加载时机"></a>类加载时机</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220517145228556.png" alt="image-20220517145228556"></p>
<h3 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220517145340270.png" alt="image-20220517145340270"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220517145413669.png" alt="image-20220517145413669"></p>
<h4 id="加载阶段"><a href="#加载阶段" class="headerlink" title="加载阶段"></a>加载阶段</h4><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220517145456333.png" alt="image-20220517145456333"></p>
<h4 id="验证阶段"><a href="#验证阶段" class="headerlink" title="验证阶段"></a>验证阶段</h4><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220517145557852.png" alt="image-20220517145557852"></p>
<h4 id="准备阶段"><a href="#准备阶段" class="headerlink" title="准备阶段"></a>准备阶段</h4><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220517145702581.png" alt="image-20220517145702581"></p>
<h4 id="解析阶段"><a href="#解析阶段" class="headerlink" title="解析阶段"></a>解析阶段</h4><p>虚拟机将常量池中的符号引用替换为直接引用的过程</p>
<h4 id="Initialization（初始化-阶段"><a href="#Initialization（初始化-阶段" class="headerlink" title="Initialization（初始化) 阶段"></a>Initialization（初始化) 阶段</h4><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220517145853355.png" alt="image-20220517145853355"></p>
<h2 id="通过反射获取类的结构信息"><a href="#通过反射获取类的结构信息" class="headerlink" title="通过反射获取类的结构信息"></a>通过反射获取类的结构信息</h2><h3 id="java-lang-Class类"><a href="#java-lang-Class类" class="headerlink" title="java.lang.Class类"></a>java.lang.Class类</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220517150019387.png" alt="image-20220517150019387"></p>
<h3 id="java-lang-reflect-Field-类"><a href="#java-lang-reflect-Field-类" class="headerlink" title="java.lang.reflect.Field 类"></a>java.lang.reflect.Field 类</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220517150106804.png" alt="image-20220517150106804"></p>
<h3 id="java-lang-reflect-Method-类"><a href="#java-lang-reflect-Method-类" class="headerlink" title="java.lang.reflect.Method 类"></a>java.lang.reflect.Method 类</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220517150208171.png" alt="image-20220517150208171"></p>
<h3 id="java-lang-reflect-Constructor-类"><a href="#java-lang-reflect-Constructor-类" class="headerlink" title="java.lang.reflect.Constructor 类"></a>java.lang.reflect.Constructor 类</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220517150233977.png" alt="image-20220517150233977"></p>
<h2 id="通过反射创建对象"><a href="#通过反射创建对象" class="headerlink" title="通过反射创建对象"></a>通过反射创建对象</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220517150326870.png" alt="image-20220517150326870"></p>
<h2 id="通过反射访问类中的成员"><a href="#通过反射访问类中的成员" class="headerlink" title="通过反射访问类中的成员"></a>通过反射访问类中的成员</h2><h3 id="访问属性"><a href="#访问属性" class="headerlink" title="访问属性"></a>访问属性</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220517150407163.png" alt="image-20220517150407163"></p>
<h3 id="访问方法"><a href="#访问方法" class="headerlink" title="访问方法"></a>访问方法</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220517150431898.png" alt="image-20220517150431898"></p>
<h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><p>处理文本的利器，是对字符串执行模式匹配的技术</p>
<p>一个正则表达式，就是用某种模式去匹配字符串的一个公式</p>
<p>注：在Java正则表达式中，两个\\代表其它语言中的一个\</p>
<h2 id="正则表达式底层实现"><a href="#正则表达式底层实现" class="headerlink" title="正则表达式底层实现"></a>正则表达式底层实现</h2><p>1）创建一个<strong>Pattern模式对象</strong>，即正则表达式对象；</p>
<p>2）创建一个<strong>matcher匹配器对象</strong>，按照pattern(模式)，到字符串中去匹配；</p>
<p>3）找到后，将子字符串的开始的索引记录到 matcher 对象的属性 grops[0]，把该子字符串的结束的索引+1 的值记录到 groups[1]；</p>
<p>4）同时记录 oldLast 的值为子字符串的结束的索引 +1 的值即 groups[1]，即下次执行 find 时，就从此开始匹配；</p>
<h3 id="matcher-group-0-分析"><a href="#matcher-group-0-分析" class="headerlink" title="matcher.group(0) 分析"></a>matcher.group(0) 分析</h3><p>根据 groups[0] 和 groups[1] 的记录的位置，从字符串中开始截取子字符串返回，就是 [groups[0], groups[1]) 包含groups[0] 但是不包</p>
<p>含索引为groups[1]的位置</p>
<p><strong>有分组</strong>：将子字符串的开始的索引记录到 matcher 对象的属性 grops[0]，把该子字符串的结束的索引+1 的值记录到 groups[1]</p>
<p>​				记录第一个分组匹配到的字符串 groups[2] ，groups[3]为开始和结束+1的索引值</p>
<pre><code>            记录第二个分组匹配到的字符串 groups[4]，groups[5]为开始和结束+1的索引值
</code></pre>
<p>​				如果有更多的分组以此类推</p>
<p>​				group(0) 表示匹配到的子字符串</p>
<p>​				group(1) 表示匹配到的子字符串的第一组字串 </p>
<p>​				group(2) 表示匹配到的子字符串的第二组字串</p>
<p><strong>matches</strong>方法：用于整体匹配，在验证输入的字符串是否满足条件使用，返回ture或false</p>
<h2 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h2><h3 id="mysql中的模糊查询"><a href="#mysql中的模糊查询" class="headerlink" title="mysql中的模糊查询"></a>mysql中的模糊查询</h3><p><code>%</code>: 匹配0个或者多个任意字符</p>
<p><code>_</code>: 匹配任意一个字符</p>
<h3 id="转义号"><a href="#转义号" class="headerlink" title="转义号"></a>转义号</h3><p>使用正则表达式去检索某些特殊字符的时候，需要用到转移符号</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220518220453765.png" alt="image-20220518220453765"></p>
<h3 id="限定符"><a href="#限定符" class="headerlink" title="限定符"></a>限定符</h3><p>用于指定其前面的字符和组合项连续出现多少次</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220518153708550.png" alt="image-20220518153708550"></p>
<h3 id="选择匹配符"><a href="#选择匹配符" class="headerlink" title="选择匹配符"></a>选择匹配符</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220518153639621.png" alt="image-20220518153639621"></p>
<h3 id="分组组合和反向引用符"><a href="#分组组合和反向引用符" class="headerlink" title="分组组合和反向引用符"></a>分组组合和反向引用符</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220518154036309.png" alt="image-20220518154036309"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220518154102247.png" alt="image-20220518154102247"></p>
<h3 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h3><h3 id="字符匹配符"><a href="#字符匹配符" class="headerlink" title="字符匹配符"></a>字符匹配符</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220518153246607.png" alt="image-20220518153246607"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220518153258920.png" alt="image-20220518153258920"></p>
<p>\s：匹配任何空白字符，包括空格、制表符、换页符等。与[\f\n\r\t\v]等效</p>
<p>\S：匹配任何非空白字符</p>
<h3 id="定位符"><a href="#定位符" class="headerlink" title="定位符"></a>定位符</h3><p>规定要匹配的字符串出现的位置，比如在字符串的开始还是在结束的位置</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220518153948293.png" alt="image-20220518153948293"></p>
<h2 id="常用类-1"><a href="#常用类-1" class="headerlink" title="常用类"></a>常用类</h2><h3 id="Pattern类"><a href="#Pattern类" class="headerlink" title="Pattern类"></a>Pattern类</h3><p>pattern对象是一个正则表达式对象，Pattern类没有公共构造方法，要创建一个Pattern对象，调用其公共静态方法，它返回一个Pattern对象，该方法接收一个正则表达式作为他的第一个参数</p>
<h3 id="Matcher类"><a href="#Matcher类" class="headerlink" title="Matcher类"></a>Matcher类</h3><p>是对输入字符串进行解释和匹配的引擎。与Pattern类一样，Matcher也没有公共构造方法，需要调用Pattern对象的matcher方法获得一个Mather对象</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220519153616879.png" alt="image-20220519153616879"></p>
<h3 id="PatternSyntaxException类"><a href="#PatternSyntaxException类" class="headerlink" title="PatternSyntaxException类"></a>PatternSyntaxException类</h3><p>非强制异常类，表示一个正则表达式模式中的语法错误0</p>
<h2 id="分组、捕获、反向引用"><a href="#分组、捕获、反向引用" class="headerlink" title="分组、捕获、反向引用"></a>分组、捕获、反向引用</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220519154550603.png" alt="image-20220519154550603">	</p>
<h1 id="Lamda-表达式"><a href="#Lamda-表达式" class="headerlink" title="Lamda 表达式"></a>Lamda 表达式</h1><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><p><strong>(args1, args2,…) -&gt; { <a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=express&spm=1001.2101.3001.7020">express</a> block }</strong></p>
<p>lamda表达式由两部分组成：<strong>参数和语句块</strong>，参数可以不写参数类型也可以写参数类型，如果写参数类型，必须与对应方法的参数类型一致，</p>
<p><strong>如果只有一个参数，可以省略小括号()<strong>；语句块中如果只有一条语句，</strong>可以省略大括号{ }和return关键字</strong>。</p>
<p><strong>lamda表达式只支持函数式接口，函数式接口就是只有一个抽象方法的接口</strong>，例如Runnable</p>
<p>避免匿名<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%86%85%E9%83%A8%E7%B1%BB&spm=1001.2101.3001.7020">内部类</a>定义过多</p>
<p>可以让你的代码看起来很简洁</p>
<p>去掉了一堆没有意义的代码，留下核心的逻辑</p>
<p>其实质属于<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B&spm=1001.2101.3001.7020">函数式编程</a>的概念</p>
<h1 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h1><h2 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h2><p>两个区域A和B，初始对象在A，继续存活的对象被转移到B。此为新生代最常用的算法</p>
<h2 id="标记清理算法"><a href="#标记清理算法" class="headerlink" title="标记清理算法"></a>标记清理算法</h2><p>一块区域，标记可达对象（可达性分析），然后回收不可达对象，会出现碎片，那么引出标记-整理算法：多了碎片整理，整理出更大的内存放更大的对象</p>
<p>两个概念：<strong>新生代和年老代</strong></p>
<p>新生代：初始对象，生命周期短的</p>
<p>永久代：长时间存在的对象</p>
<p>整个java的垃圾回收是新生代和年老代的协作，这种叫做分代回收。</p>
<p>Serial New收集器是针对新生代的收集器，采用的是复制算法</p>
<p>Parallel New（并行）收集器，新生代采用复制算法，老年代采用标记整理</p>
<p>Parallel Scavenge（并行）收集器，针对新生代，采用复制收集算法</p>
<p>Serial Old（串行）收集器，新生代采用复制，老年代采用标记整理</p>
<p>Parallel Old（并行）收集器，针对老年代，标记整理</p>
<p>CMS收集器，基于标记清理</p>
<p>G1收集器：整体上是基于标记 整理 ，局部采用复制</p>
<p><strong>综上：新生代基本采用复制算法，老年代采用标记整理算法。cms采用标记清理。</strong></p>
<h1 id="委托事件模型"><a href="#委托事件模型" class="headerlink" title="委托事件模型"></a>委托事件模型</h1><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/cac99c0f172b">https://www.jianshu.com/p/cac99c0f172b</a></p>
<h1 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h1><h2 id="网络的相关概念"><a href="#网络的相关概念" class="headerlink" title="网络的相关概念"></a>网络的相关概念</h2><h3 id="网络通信"><a href="#网络通信" class="headerlink" title="网络通信"></a>网络通信</h3><p>两台设备之间通过网络实现数据传输&#x2F;将数据通过网络从一台设备传输到另一台设备</p>
<p>java.net包下提供了一系列的类或接口，供程序员使用，完成网络通信</p>
<h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><p>两台或多台设备通过一定物理设备连接起来构成了网络</p>
<p>根据网络的覆盖范围进行分类：</p>
<p>1）局域网：覆盖范围小，仅仅覆盖一个教室或一个机房</p>
<p>2）城域网：覆盖范围较大，可以覆盖一个城市</p>
<p>3）广域网：覆盖范围最大，可以覆盖全国，甚至全球，万维网是广域网的代表</p>
<h3 id="ip-地址"><a href="#ip-地址" class="headerlink" title="ip 地址"></a>ip 地址</h3><p>用以标识网络中的每一台主机&#x2F;计算机</p>
<p>查看IP地址：ipconfig</p>
<p>ip地址的表示形式：点分十进制 xx.xx.xx.xx</p>
<p>每一个十进制数的范围：0-255</p>
<p>ip地址的组成：网络地址+主机地址</p>
<p>ipv4的网络地址资源有限，严重制约了互联网的应用和发展，ipv6的使用，不仅能解决网络地址资源数量的问题，而且也解决了多种接入设备连入互联网的障碍</p>
<h3 id="ipv4地址分类"><a href="#ipv4地址分类" class="headerlink" title="ipv4地址分类"></a>ipv4地址分类</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220519170200444.png" alt="image-20220519170200444"></p>
<h3 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h3><p>好处：为了方便记忆，解决记ip的困难</p>
<p>概念：将ip地址映射成域名，HTTP</p>
<p><strong>端口号：</strong>用于标识计算机上某个特定的网络程序</p>
<p>​				以整数形式，端口范围：0-65535[两个字节表示端口]</p>
<p>​				0-1024已经被占用，比如：ssh 22,  ftp 21,  smtp 25,  http 80</p>
<p>​				常见的网络程序端口号：tomcat:8080</p>
<p>​															mysql:3306</p>
<p>​															oracle:1521</p>
<p>​															sqlserver:1433</p>
<h3 id="网络通信协议"><a href="#网络通信协议" class="headerlink" title="网络通信协议"></a>网络通信协议</h3><p>TCP&#x2F;IP：传输控制协议，由网络层的IP协议和传输层的TCP协议组成</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220519172516839.png" alt="image-20220519172516839"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220519172535187.png" alt="image-20220519172535187"></p>
<h2 id="InetAddress-类"><a href="#InetAddress-类" class="headerlink" title="InetAddress 类"></a>InetAddress 类</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220519172610171.png" alt="image-20220519172610171"></p>
<h2 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220519172647626.png" alt="image-20220519172647626"></p>
<h2 id="TCP-网络通信编程"><a href="#TCP-网络通信编程" class="headerlink" title="TCP 网络通信编程"></a>TCP 网络通信编程</h2><p>基于客户端—服务端的网络通信</p>
<p>底层使用的是TCP&#x2F;IP协议</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220519172850090.png" alt="image-20220519172850090"></p>
<h3 id="netstat-指令"><a href="#netstat-指令" class="headerlink" title="netstat 指令"></a>netstat 指令</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220519172954362.png" alt="image-20220519172954362"></p>
<p>-Xms1G -Xmx2G -Xmn500M -XX:MaxPermSize&#x3D;64M -XX:+UseConcMarkSweepGC -XX:SurvivorRatio&#x3D;3,</p>
<p>-Xms：1G ， 就是说初始堆大小为1G<br>-Xmx：2G ， 就是说最大堆大小为2G<br>-Xmn：500M ，就是说年轻代大小是500M（包括一个Eden和两个Survivor）<br>-XX:MaxPermSize：64M ， 就是说设置持久代最大值为64M<br>-XX:+UseConcMarkSweepGC ， 就是说使用使用CMS内存收集算法<br>-XX:SurvivorRatio&#x3D;3 ， 就是说Eden区与Survivor区的大小比值为3：1：1</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-操作系统：概念"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
	
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/08/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%9A%E6%A6%82%E5%BF%B5/"
    >概念</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/08/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%9A%E6%A6%82%E5%BF%B5/" class="article-date">
  <time datetime="2022-08-06T08:11:57.000Z" itemprop="datePublished">2022-08-06</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">计算机基础知识</a> / <a class="article-category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="操作系统的概念、功能"><a href="#操作系统的概念、功能" class="headerlink" title="操作系统的概念、功能"></a>操作系统的概念、功能</h1><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220806161631109.png" alt="image-20220806161631109"></p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul>
<li><p>系统资源的管理者：控制和<strong>管理</strong>整个计算机系统的<strong>硬件和软件</strong>资源，并合理地组织调度计算机的工作和资源的分配</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220806161651753.png" alt="image-20220806161651753"></p>
</li>
<li><p>向上层提供简便易用的服务：<strong>提供给用户和其他软件方便的接口和环境</strong></p>
</li>
<li><p>最接近硬件的一层软件：是计算机系统中最基本的<strong>系统软件</strong></p>
</li>
</ul>
<h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><ul>
<li><p>系统资源的管理者</p>
<p>执行一个程序之前<strong>需要将该程序放到内存中</strong>才能被CPU处理</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220806161816691.png" alt="image-20220806161816691"></p>
</li>
<li><p>向上层提供简便易用的服务</p>
<ul>
<li><p><strong>封装思想</strong>：操作系统把硬件封装成简便易用的服务，使得用户无需关心底层硬件的原理， 只需要对操作系统发出指令即可使用计算机</p>
</li>
<li><p><strong>GUI</strong>：图形化用户接口（Graphical	User	Interface） ，用户可以使用形象的图形界面进行操作，而不再需要记忆复杂的命令、参数。</p>
</li>
<li><p><strong>联机命令接口</strong>：交互式命令接口，用户说一句， 系统跟着做一句</p>
</li>
<li><p><strong>脱机命令接口</strong>：批处理命令接口，用户说一堆， 系统跟着做一堆</p>
</li>
<li><p><strong>程序接口</strong>：可以在程序中进行系统调用使用程序接口，普通用户不能直接使用程序接口，只能通过程序代码间接使用，比如：</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220806162535866.png" alt="程序接口"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220806162656997.png" alt="向上层提供方便易用的服务"></p>
</li>
</ul>
</li>
<li><p>最接近硬件的一层软件：</p>
<p>操作系统对硬件机器的扩展：将CPU、内存、硬盘等硬件合理的组织起来，让各种硬件能 够相互配合，实现更多复杂的功能</p>
</li>
</ul>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220806162912117.png" alt="操作系统概念、功能"></p>
<h1 id="操作系统的特征"><a href="#操作系统的特征" class="headerlink" title="操作系统的特征"></a>操作系统的特征</h1><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220806163048558.png" alt="操作系统的特征"></p>
<h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><p>指多个事件在<strong>同一时间间隔内发生</strong>，这些事件在宏观上是同时发生的，在微观上是交替发生的</p>
<p>操作系统的并发性指计算机系统中“同时”运行着多个程序，这些程序宏观上看是同时运行着的，而微观上看是交替运行的。 操作系统就是伴随着“多道程序技术”而出现的。因此，操作系统和程序并发是一起诞生的</p>
<p><strong>注意</strong>：</p>
<ol>
<li>与并行区分，<strong>并行</strong>指的是多个事件在<strong>同一时刻同时发生</strong></li>
<li><strong>单核CPU</strong>同一时刻只能执行<strong>一个程序</strong>，各个程序只能<strong>并发</strong>执行</li>
<li><strong>多核CPU</strong>同一时刻可以同时执行<strong>多个程序</strong>，多个程序可以<strong>并行</strong>执行</li>
</ol>
<h2 id="共享"><a href="#共享" class="headerlink" title="共享"></a>共享</h2><p>共享即资源共享，是指系统中的资源可供内存中多个并发执行的进程共同使用。</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220806163519018.png" alt="资源共享方式"></p>
<p>所谓的“同时”往往是宏观上的，而在微观上，这些进程可能是交替地对该资源进行访问的（即分时共享） </p>
<p><strong>生活实例</strong> </p>
<p>互斥共享方式：使用QQ和微信视频。同一时间段内摄像头只能分配给其中一个进程。 </p>
<p>同时共享方式：使用QQ发送文件A，同时使用微信发送文件B。宏观上看，两边都在同时读取并发送文件， </p>
<p>说明两个进程都在访问硬盘资源，从中读取数据。微观上看，两个进程是交替着访问硬盘的。</p>
<h3 id="并发与共享的关系"><a href="#并发与共享的关系" class="headerlink" title="并发与共享的关系"></a>并发与共享的关系</h3><p><strong>并发性</strong>指计算机系统中同时存在着多个运行着的程序。 </p>
<p><strong>共享性</strong>是指系统中的资源可供内存中多个并发执行的进程共同使用。</p>
<p><strong>实例</strong></p>
<p>使用QQ发送文件A，同时使用微信发送文件B。</p>
<ol>
<li>两个进程正在并发执行（并发性），如果失去并发性，则系统中只有一个程序正在运行，则共享性失去存在的意义</li>
<li>需要共享地访问硬盘资源（共享性），如果失去共享性，则QQ和微信不能同时访问硬盘资源，就无法实现同时发送文件，也就无法并发</li>
</ol>
<h2 id="虚拟"><a href="#虚拟" class="headerlink" title="虚拟"></a>虚拟</h2><p>虚拟是指把一个物理上的实体变为若干个逻辑上的对应物。物理实体（前者）是实际存在的，而逻辑上对应物（后者）是用户感受到的。</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220806164003431.png" alt="虚拟技术"></p>
<p>虚拟存储器技术：用户只有4G运行内存，但可以运行总内存大于4G的多个软件</p>
<p>虚拟处理器技术：单核CPU可以同时运行多个程序 (微观上交替)</p>
<p>显然，如果失去了并发性，则一个时间段内系统中只需运行一道程序，那么就失去了实现虚拟性的意义了。因此，<strong>没有并发性，就谈不上虚拟性</strong></p>
<h2 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h2><ul>
<li>异步是指，在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底的， 而是走走停停，以不可预知的速度向前推进，这就是进程的异步性。</li>
<li>如果失去了并发性，即系统只能串行地运行各个程序，那么每个程序的执行会 一贯到底。<strong>只有系统拥有并发性，才有可能导致异步性。</strong></li>
</ul>
<h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220806164258243.png" alt="操作系统的特征"></p>
<h1 id="操作系统的发展与分类"><a href="#操作系统的发展与分类" class="headerlink" title="操作系统的发展与分类"></a>操作系统的发展与分类</h1><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220806164402757.png" alt="操作系统的发展与分类"></p>
<h2 id="手工操作阶段"><a href="#手工操作阶段" class="headerlink" title="手工操作阶段"></a>手工操作阶段</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220806164557530.png" alt="image-20220806164557530"></p>
<p>主要缺点：用户独占全机、人机速度矛盾导致资源利用率极低</p>
<h2 id="单道批处理系统"><a href="#单道批处理系统" class="headerlink" title="单道批处理系统"></a>单道批处理系统</h2><p>引入脱机输入&#x2F;输出技术（用外围机+磁带完成），并由监督程序负责控制作业的输入、输出</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220806164632429.png" alt="image-20220806164632429"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220806164706687.png" alt="image-20220806164706687"></p>
<p>主要优点：缓解了一定程度的人机速度矛盾，资源利用率有所提升。 </p>
<p>主要缺点：<strong>内存中仅能有一道程序运行</strong>，只有 该程序运行结束之后才能调入下一道程序。<strong>CPU有大量的时间是在空闲等待I&#x2F;O完成</strong>。资源 利用率依然很低。</p>
<h2 id="多道批处理系统"><a href="#多道批处理系统" class="headerlink" title="多道批处理系统"></a>多道批处理系统</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220806164919195.png" alt="image-20220806164919195"></p>
<p>主要优点：多道程序<strong>并发</strong>执行，<strong>共享</strong>计算机资源。<strong>资源利用率大幅提升</strong>，CPU和其他资源更能保持“忙碌”状态，系统吞吐量增大。 </p>
<p>主要缺点：用户响应时间长，<strong>没有人机交互功能</strong>（用户提交自己的作业之后就只能等待计算机处理完成，中间不能控制自己的作业 </p>
<p>执行。eg：无法调试程序&#x2F;无法在程序运行过 程中输入一些参数）</p>
<h2 id="分时操作系统"><a href="#分时操作系统" class="headerlink" title="分时操作系统"></a>分时操作系统</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220806165023577.png" alt="image-20220806165023577"></p>
<p>分时操作系统：计算机以<strong>时间片</strong>为单位<strong>轮流为各个用户&#x2F;作业服务</strong>，各个用户可通过终端与计算机进行交互。 </p>
<p>主要优点：用户请求可以被即时响应，<strong>解决了人机交互问题</strong>。允许多个用户同时使用一台计算机，并且用户对计算机的操作相互独立，感受不到别人的存在。 </p>
<p>主要缺点：<strong>不能优先处理一些紧急任务</strong>。操作系统对各个用户&#x2F;作业都是完全公平的，循环地为每个用户&#x2F; 作业服务一个时间片，不区分任务的紧急性。</p>
<h2 id="实时操作系统"><a href="#实时操作系统" class="headerlink" title="实时操作系统"></a>实时操作系统</h2><p>主要优点：能够优先响应一些紧急任务，某些紧急任务不需时间片排队。 </p>
<p>在实时操作系统的控制下，计算机系统接收到外部信号后及时进行处理，并且<strong>要在严格的时限内处理完事件</strong>。实时操作系统的主要特点是<strong>及时性和可靠性</strong></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220806165216654.png" alt="image-20220806165216654"></p>
<h2 id="其他几种操作系统"><a href="#其他几种操作系统" class="headerlink" title="其他几种操作系统"></a>其他几种操作系统</h2><ul>
<li><strong>网络操作系统</strong>：是伴随着计算机网络的发展而诞生的，能把网络中各个计算机有机地结合起来，实现数据传送等功能，<strong>实现网络中各种资源的共享（如文件共享）和各台计算机之间的通信。</strong>（如：Windows NT 就是一种典型的网络操作系统，网站服务器就可以使用） </li>
<li><strong>分布式操作系统</strong>：主要特点是<strong>分布性和并行性</strong>。系统中的各台计算机地位相同，<strong>任何工作都可以分布在这些计算机上，由它们并行、协同完成这个任务。</strong> </li>
<li><strong>个人计算机操作系统</strong>：如 Windows XP、MacOS，方便个人使用。</li>
</ul>
<h2 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220806165424426.png" alt="image-20220806165424426"></p>
<h1 id="操作系统的运行机制、体系结构"><a href="#操作系统的运行机制、体系结构" class="headerlink" title="操作系统的运行机制、体系结构"></a>操作系统的运行机制、体系结构</h1><ul>
<li><p>指令：指的是处理器(CPU)能识别、执行的最基本命令</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/20200913123618988.png" alt="img"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/2020091312362421.png" alt="两种指令"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/2020091312364170.png" alt="两种处理器状态"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/2020091312364927.png" alt="两种程序"></p>
</li>
</ul>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220806171845507.png" alt="image-20220806171845507"></p>
<ul>
<li><p>内核：内核是计算机上的底层软件，是操作系统最基本、最核心的部分。实现内核功能的程序是<strong>内核程序</strong></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220806171143805.png" alt="image-20220806171143805"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220806171218224.png" alt="image-20220806171218224"></p>
<p><strong>注意：</strong> </p>
<p><strong>操作系统内核需要运行在内核态</strong> </p>
<p><strong>操作系统的非内核功能运行在用户态</strong></p>
</li>
</ul>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220806171637306.png" alt="image-20220806171637306"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220806172249338.png" alt="image-20220806172249338"></p>
<h1 id="中断和异常"><a href="#中断和异常" class="headerlink" title="中断和异常"></a>中断和异常</h1><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220806172332250.png" alt="image-20220806172332250"></p>
<ul>
<li>CPU 上会运行两种程序，一种是<strong>操作系统内核程序</strong>，一种是<strong>应用程序</strong>。在合适的情况下，操作系统内核会把CPU的使用权主动让给应用程序，“中断”是<strong>让操作系统内核夺回CPU使用权的唯一途径</strong></li>
<li>“中断”会使CPU由用户态变为内核态，使操作系统重新夺回对CPU的控制权</li>
<li><strong>内核态—&gt;用户态</strong>：执行一条<strong>特权指令</strong>——<strong>修改PSW</strong>的标志位为“用户态”，这个动作意味着操作系统将主动让出CPU使用权 </li>
<li><strong>用户态—&gt;内核态</strong>：由<strong>“中断”</strong>引发，<strong>硬件自动完成变态过程</strong>，触发中断信号意味着操作系统将强行夺回CPU的使用权</li>
</ul>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220806172705391.png" alt="image-20220806172705391"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220806172755699.png" alt="image-20220806172755699"></p>
<ul>
<li><p><strong>不同的中断信号，需要用不同的中断处理程序来处理。</strong>当CPU检测到中断信号后，会根据中断信号的类型去查询“<strong>中断向量表</strong>”，以此来找到相应的中断处理程序在内存中的存放位置。</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220806173055778.png" alt="image-20220806173055778"></p>
</li>
</ul>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/Snipaste_2022-08-06_16-10-28.png" alt="Snipaste_2022-08-06_16-10-28"></p>
<h1 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h1><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220806174228278.png" alt="image-20220806174228278"></p>
<ul>
<li><p>操作系统作为用户和计算机硬件之间的接口，需要向上提供一些简单易用的服务。主要包括命令接口和程序接口。其中，程序接口由一组<strong>系统调用</strong>组成。</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220806174344900.png" alt="image-20220806174344900"></p>
</li>
<li><p>“系统调用”是操作系统提供给应用程序（程序员&#x2F;编程人员）使用的接口，可以理解为一种可供应用程序调用的特殊函数，<strong>应用程序可以通过系统调用来请求获得操作系统内核的服务</strong></p>
</li>
</ul>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220806174446993.png" alt="image-20220806174446993"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220806174507152.png" alt="image-20220806174507152"></p>
<ul>
<li>应用程序通过<strong>系统调用</strong>请求操作系统的服务。而系统中的各种共享资源都由操作系统内核统一掌管，因此<strong>凡是与共享资源有关的操作（如存储分配、I&#x2F;O操作、文件管理等），都必须通过系统调用的方式向操作系统内核提出服务请求</strong>，由操作系统内核代为完成。这样<strong>可以保证系统的稳定性和安全性</strong>，防止用户进行非法操作。</li>
</ul>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220806174609798.png" alt="image-20220806174609798"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220806173929506.png" alt="image-20220806173929506"></p>
<ul>
<li>传递系统调用参数—&gt;执行陷入指令（<strong>用户态</strong>）—&gt;执行相应的内请求核程序处理系统调用（<strong>核心态</strong>）—&gt;返回应用程序 </li>
<li>注意<ol>
<li><strong>陷入指令</strong>是在<strong>用户态</strong>执行的，执行陷入指令之后立即引发一个<strong>内中断</strong>，使CPU<strong>进入核心态</strong></li>
<li><strong>发出系统调用请求</strong>是在<strong>用户态</strong>，而<strong>对系统调用的相应处理在核心态</strong>下进行</li>
</ol>
</li>
</ul>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220806174206287.png" alt="image-20220806174206287"></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-数据库：mysql索引"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
	
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/08/05/%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%9Amysql%E7%B4%A2%E5%BC%95/"
    >mysql索引</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/08/05/%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%9Amysql%E7%B4%A2%E5%BC%95/" class="article-date">
  <time datetime="2022-08-05T10:53:26.000Z" itemprop="datePublished">2022-08-05</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a> / <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/">mysql</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h1><h2 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h2><p>程序和数据的访问都有聚集成群的倾向，在一个时间段内，仅使用其中一小部分，称为<strong>空间局部性</strong></p>
<p>最经访问过的程序代码和数据，很快又被访问的可能性很大，称为<strong>时间局部性</strong></p>
<h2 id="磁盘预读"><a href="#磁盘预读" class="headerlink" title="磁盘预读"></a>磁盘预读</h2><ul>
<li>预读的长度一般为页（page）的整数倍</li>
<li>页是存储器的逻辑块，操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，页大小通常为4K），主存和磁盘以页为单位交换数据</li>
<li>考虑到磁盘IO是非常高昂的操作，计算机操作系统做了一些优化，<strong>当一次IO时，不光把当前磁盘地址的数据，而是把相邻的数据也都读取到内存缓冲区内</strong>，因为局部预读性原理告诉我们，当计算机访问一个地址的数据的时候，与其相邻的数据也会很快被访问到。每一次IO读取的数据我们称之为一页(page)。具体一页有多大数据跟操作系统有关，一般为4k或8k，也就是我们读取一页内的数据时候，实际上才发生了一次IO，这个理论对于索引的数据结构设计非常有帮助。</li>
</ul>
<h1 id="索引概述"><a href="#索引概述" class="headerlink" title="索引概述"></a>索引概述</h1><ul>
<li><p>MySql官方对索引的定义为：<strong>索引是帮助MySql高效获取数据的数据结构</strong>。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用数据，这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引。</p>
</li>
<li><p>索引存储在文件系统中</p>
</li>
<li><p>索引的文件存储形式与存储引擎有关</p>
</li>
<li><p>索引文件的结构：B+树</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/mysql%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%80%89%E6%8B%A9.jpg" alt="mysql数据结构选择"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/mysql%E7%B4%A2%E5%BC%95%E7%B3%BB%E7%BB%9F.jpg" alt="mysql索引系统"></p>
</li>
</ul>
<h1 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a>索引的分类</h1><p>通过给字段添加索引可以提高数据的读取速度，提高项目的并发能力和抗压能力</p>
<ul>
<li><p>普通索引</p>
<ul>
<li><p>基本的索引类型，值可以为空，没有唯一性的限制</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-- 创建索引的第一种方式</span><br><span class="line">CREATE INDEX idx_nickname ON account(nickname); </span><br><span class="line"></span><br><span class="line">-- 创建索引的第二种方式(不常用)</span><br><span class="line">ALTER TABLE account ADD INDEX idx_nickname1(nickname);</span><br><span class="line"></span><br><span class="line">-- 创建索引的第三种方式</span><br><span class="line">CREATE TABLE u1(nickname VARCHAR(64),age TINYINT UNSIGNED,KEY idx_nickname(nickname));</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>主键索引</p>
<ul>
<li><p>一种唯一性索引，但它必须指定为PRIMARY KEY，每个表只能有一个主键</p>
</li>
<li><p>主键索引的列的数据非空,唯一的</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 声明为主键的列就是自动添加主键索引</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> u1(id <span class="type">INT</span> ,nickname <span class="type">VARCHAR</span>(<span class="number">64</span>),age TINYINT UNSIGNED,<span class="keyword">PRIMARY</span> KEY(id));</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>唯一索引</p>
<ul>
<li><p>索引列的值都只能出现一次，即值必须唯一，值可以为空</p>
</li>
<li><p>如果一列被约束为<code>UNIQUE</code>,则在这一列默认添加唯一索引</p>
</li>
<li><p>添加唯一索引的列可以为<code>NULL</code>值,这也是和主键索引,不同的地方</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建索引的第一种方式</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> INDEX uk_nickname <span class="keyword">ON</span> u1(nickname); </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建表时创建唯一索引</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> u1 (</span><br><span class="line">  id <span class="type">INT</span>,</span><br><span class="line">  nickname <span class="type">VARCHAR</span> (<span class="number">64</span>) ,</span><br><span class="line">  age TINYINT UNSIGNED,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (id),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY uk_nickname(nickname) </span><br><span class="line">) ;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>全文索引</p>
<blockquote>
<p>全文索引,通过建立<code>倒排索引</code>,可以提高数据的检索效率,解决判断字段中 <code>是否包含</code> 的问题;</p>
</blockquote>
<ul>
<li><p>索引类型为FULLTEXT。全文索引在varchar、char、text类型的列上创建</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 我们已经给nickname字段添加了普通索引</span></span><br><span class="line"><span class="comment">-- 会使用索引</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> account <span class="keyword">WHERE</span> nickname<span class="operator">=</span><span class="string">&#x27;小明&#x27;</span>;</span><br><span class="line"><span class="comment">-- 会使用索引</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> account <span class="keyword">WHERE</span> nickname <span class="keyword">LIKE</span> <span class="string">&#x27;小明%&#x27;</span>;</span><br><span class="line"><span class="comment">-- 不会使用索引</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> account <span class="keyword">WHERE</span> nickname <span class="keyword">LIKE</span> <span class="string">&#x27;%小明%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>不使用到索引我们如果进行大规模数据检索时,效率会大大的降低,所以前面我们说过 <code>我们只在简单业务或者数据量小的时候才考虑使用like关键字</code>;</p>
<blockquote>
<p>全文索引注意的地方:</p>
</blockquote>
<ul>
<li><p>mysql5.6以前,只有<code>MYISAM</code>存储引擎支持全文索引</p>
</li>
<li><p>在5.6中<code>INNODB</code>存储引擎加入了对全文索引的支持,<strong>但是只支持英文的全文索引,不支持中文的全文索引</strong></p>
</li>
<li><p><strong>在5.7.6中,mysql内置了<code>ngram</code>分词器,用来支持中文;</strong></p>
</li>
</ul>
<blockquote>
<p>配置ngram分词的最小长度:      </p>
</blockquote>
<p>默认长度为2,当然我们也可以设置成1,但是设置成1的话就会浪费大量的空间,不是很好,<code>mysql建议我们配置为2</code>;</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">ngram分词器对分词最小长度(也就是说分词器,分词的时候最小也是两个词一分)</span></span><br><span class="line">[mysqld]</span><br><span class="line">ft_min_word_len=2</span><br></pre></td></tr></table></figure>

<blockquote>
<p>创建全文索引</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建索引的第一种方式</span></span><br><span class="line"><span class="keyword">CREATE</span> FULLTEXT INDEX ft_nickname <span class="keyword">ON</span> account(nickname) <span class="keyword">WITH</span> PARSER ngram ; </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建索引的第二种方式(不常用)</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> account <span class="keyword">ADD</span> FULLTEXT INDEX ft_nickname(nickname) <span class="keyword">WITH</span> PARSER ngram;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建索引的第三种方式</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> u1(nickname <span class="type">VARCHAR</span>(<span class="number">64</span>),age TINYINT UNSIGNED,FULLTEXT KEY ft_nickname(nickname) <span class="keyword">WITH</span> PARSER ngram );</span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用全文索引</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> account <span class="keyword">WHERE</span> <span class="keyword">MATCH</span>(nickname) AGAINST(&quot;你觉得华为笔记本合小米手机哪个好&quot;);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>match</code>中的字段和创建全文建索引时的字段<strong>必须一致</strong>;</li>
</ul>
<blockquote>
<p>全文索引的检索流程</p>
</blockquote>
<p>用户输入词—&gt;sql执行引擎—&gt;<code>ngram</code>分词器对用户输入的词进行分词(配置了最小的分词个数)—&gt;把分词器分的词依次的去倒排索引中去查找,找出相应的记录返回;</p>
</li>
</ul>
</li>
<li><p>组合索引</p>
<ul>
<li><p>多列值组成一个索引，专门用于组合搜索</p>
</li>
<li><p><strong>包含多个字段的索引</strong>称为组合索引;</p>
<blockquote>
<p>组合索引包含</p>
</blockquote>
<ul>
<li>组合普通索引</li>
<li>组合主键索引</li>
<li>组合唯一索引</li>
<li>组合全文索引</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建复合索引时必须指定索引的名称,不能省略</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX mu_title_content <span class="keyword">ON</span> article(title,content,publish_time);</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> article <span class="keyword">WHERE</span> title <span class="keyword">LIKE</span> <span class="string">&#x27;小米%&#x27;</span>; <span class="comment">-- 使用到索引</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> article <span class="keyword">WHERE</span> title <span class="keyword">LIKE</span> <span class="string">&#x27;小米%&#x27;</span> <span class="keyword">AND</span> content <span class="keyword">LIKE</span> <span class="string">&#x27;小米%&#x27;</span>; <span class="comment">-- 使用了索引</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> article <span class="keyword">WHERE</span>  content <span class="keyword">LIKE</span> <span class="string">&#x27;小米%&#x27;</span>; <span class="comment">-- 没有索引</span></span><br></pre></td></tr></table></figure>

<p><strong>建议多列索引的列不要超过2个列</strong></p>
<ul>
<li><p>以上这个复合索引相当于建立了这3个索引</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(title),(title,content),(title,content,publish_time)</span><br></pre></td></tr></table></figure>
</li>
<li><p>多列索引遵循<strong>最左前缀</strong>的原则</p>
</li>
<li><p>多列索引在创建的时候,如果其中有字段时<code>TEXT</code>或<code>BLOB</code>类型,就必须指定索引的长度;</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="MySQL存储引擎"><a href="#MySQL存储引擎" class="headerlink" title="MySQL存储引擎"></a>MySQL存储引擎</h1><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">MyISAM</th>
<th align="center">InnoDB</th>
</tr>
</thead>
<tbody><tr>
<td align="center">索引类型</td>
<td align="center">非聚簇索引</td>
<td align="center">聚簇索引</td>
</tr>
<tr>
<td align="center">支持事务</td>
<td align="center">否</td>
<td align="center">是</td>
</tr>
<tr>
<td align="center">支持表锁</td>
<td align="center">是</td>
<td align="center">是</td>
</tr>
<tr>
<td align="center">支持行锁</td>
<td align="center">否</td>
<td align="center">是</td>
</tr>
<tr>
<td align="center">支持外键</td>
<td align="center">否</td>
<td align="center">是</td>
</tr>
<tr>
<td align="center">支持全文索引</td>
<td align="center">是</td>
<td align="center">是</td>
</tr>
<tr>
<td align="center">适合操作类型</td>
<td align="center">大量select</td>
<td align="center">大量insert、delete、updata</td>
</tr>
</tbody></table>
<h1 id="索引优化-基本知识"><a href="#索引优化-基本知识" class="headerlink" title="索引优化-基本知识"></a>索引优化-基本知识</h1><p><strong>原因</strong>：</p>
<ul>
<li>索引在MySQL中也叫做“键”，是存储引擎用于快速找到记录的一种数据结构。索引对于良好的性能非常关键，尤其是当表中的数据量越来越大时，索引对于性能的影响愈发重要。索引优化应该是对查询性能优化最有效的手段了。索引能够轻易将查询性能提高好几个数量级。索引相当于字典的音序表，如果要查某个字，如果不使用音序表，则需要从几百页中逐页去查。</li>
</ul>
<p><strong>优点</strong>：</p>
<ul>
<li>使用主键索引或者唯一索引,可以保证数据库中的表的数据是唯一</li>
<li><strong>通过建立索引可以大大的提高数据检索的效率,减少表扫描的行数(避免进行全表扫描)</strong></li>
<li>我们在进行多表连接的时候,可以使用索引加速表之间的连接</li>
</ul>
<hr>
<p><strong>缺点</strong>：</p>
<ul>
<li>在创建索引和维护索引时都需要耗费时间;</li>
<li>索引文件会占用物理存储空间,除了表的数据占用一部分空间,索引文件也会占用一部分空间;</li>
<li><strong>设置为<code>text</code>和<code>blob</code>类型的字段强烈不建议添加索引</strong></li>
</ul>
<h1 id="索引优化-联合索引"><a href="#索引优化-联合索引" class="headerlink" title="索引优化-联合索引"></a>索引优化-联合索引</h1><p><strong>回表</strong>：</p>
<ul>
<li>在InnoDB存储引擎下，二级索引查询到的索引列，如果需要查找所有列的数据，则需要到主键索引里面去取出数据。这个过程就称为回表。因为行的数据都是存在主键B+tree的叶子节点里面，二级索引的B+树叶子节点都是存放的(索引列,主键)。</li>
</ul>
<p><strong>覆盖索引</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">select * from s1 where id=123;</span><br><span class="line">该sql命中了索引，但未覆盖索引。</span><br><span class="line">利用id=123到索引的数据结构中定位到该id在硬盘中的位置，或者说再数据表中的位置。</span><br><span class="line">但是我们select的字段为*，除了id以外还需要其他字段，这就意味着，我们通过索引结构取到id还不够，</span><br><span class="line">还需要利用该id再去找到该id所在行的其他字段值，这是需要时间的，很明显，如果我们只select id，</span><br><span class="line">就减去了这份苦恼，如下</span><br><span class="line">select id from s1 where id=123;</span><br><span class="line">这条就是覆盖索引了，命中索引，且从索引的数据结构直接就取到了id在硬盘的地址，速度很快</span><br></pre></td></tr></table></figure>

<p><strong>最左匹配</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">create index ix_name_email on s1(name,email,)</span><br><span class="line">- 最左前缀匹配：必须按照从左到右的顺序匹配</span><br><span class="line">select * from s1 where name=&#x27;egon&#x27;; #可以</span><br><span class="line">select * from s1 where name=&#x27;egon&#x27; and email=&#x27;asdf&#x27;; #可以</span><br><span class="line">select * from s1 where email=&#x27;alex@oldboy.com&#x27;; #不可以</span><br><span class="line">select * from s1 where email=&#x27;asdf&#x27; and  name=&#x27;egon&#x27;; #可以</span><br><span class="line">mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，</span><br><span class="line">比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，</span><br><span class="line">d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。</span><br></pre></td></tr></table></figure>

<p><strong>索引下推</strong>：</p>
<ul>
<li><p>索引条件下推(Index Condition Pushdown),简称ICP。MySQL5.6新添加，用于优化数据的查询。</p>
</li>
<li><p>当你不使用ICP,通过使用非主键索引（普通索引or二级索引）进行查询，存储引擎通过索引检索数据，然后返回给MySQL服务器，服务器再判断是否符合条件。</p>
</li>
<li><p>使用ICP，当存在索引的列做为判断条件时，MySQL服务器将这一部分判断条件传递给存储引擎，然后存储引擎通过判断索引是否符合MySQL服务器传递的条件，只有当索引符合条件时才会将数据检索出来返回给MySQL服务器。</p>
</li>
<li><p>示例</p>
<ul>
<li><p>当我们创建一个用户表(userinfo),其中有字段：id,name,age,addr。我们将name,age建立联合索引。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当我们执行：select * from userinfo where name like &quot;ming%&quot; and age=20;</span><br></pre></td></tr></table></figure>
</li>
<li><p>对于MySQL5.6之前：我们在索引内部首先通过name进行查找，在联合索引name,，age树形查询结果可能存在多个，然后再拿着id值去回表查询，整个过程需要回表多次。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi8xMC8xNmVlZDY2N2YzOGZkM2Vl?x-oss-process=image/format,png" alt="img"></p>
</li>
<li><p>对于MySQL5.6之后：我们是在索引内部就判断age是否等于20，对于不等于20跳过。因此在联合索引name,age索引树只匹配一个记录，此时拿着这个id去主键索引树种回表查询全部数据，整个过程就回一次表。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi8xMC8xNmVlZDY2YWUwZDI2OThh?x-oss-process=image/format,png" alt="img"></p>
</li>
<li><p>如下：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/53e290c6646dca211a8f214e11bfe7b5.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当Extra值为：Using index condition.表示使用索引下推。</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过索引下推对于非主键索引进行优化，<strong>可有效减少回表次数</strong>，从而提高效率。</p>
</li>
<li><p>关闭索引下推命令</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> optimizer_switch=<span class="string">&#x27;index_condition_pushdown=off&#x27;</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h1 id="索引优化-聚簇索引与非聚簇索引"><a href="#索引优化-聚簇索引与非聚簇索引" class="headerlink" title="索引优化-聚簇索引与非聚簇索引"></a>索引优化-聚簇索引与非聚簇索引</h1><ul>
<li><p>聚簇(集)索引的叶子节点就是数据节点。</p>
</li>
<li><p>非聚簇(集)索引的叶子节点仍然是索引节点，只不过有指向对应数据块的指针。非聚簇(集)索引在innodb引擎中，又叫做二级索引，辅助索引等。</p>
</li>
<li><p>聚簇索引并不是一种单独的索引类型，而是一种数据存储方式。术语‘聚簇’表示数据行和相邻的键值聚簇的存储在一起。如下图，左侧的索引就是聚簇索引，因为数据行在磁盘的排列和索引排序保持一致。、</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/20210509163323414.png" alt="img"></p>
</li>
</ul>
<p><strong>聚集索引（聚簇索引）</strong></p>
<p>以 InnoDB 作为存储引擎的表，表中的数据都会有一个主键，即使你不创建主键，系统也会帮你创建一个隐式的主键。</p>
<p>这是因为 InnoDB 是把数据存放在 B+ 树中的，而 B+ 树的键值就是主键，在 B+ 树的叶子节点中，存储了表中所有的数据。</p>
<p>这种以主键作为 B+ 树索引的键值而构建的 B+ 树索引，我们称之为聚集索引。</p>
<p><strong>非聚集索引（非聚簇索引）</strong></p>
<p>以主键以外的列值作为键值构建的 B+树索引，我们称之为非聚集索引。</p>
<p><strong>非聚集索引与聚集索引的区别在于</strong></p>
<p>非聚集索引的叶子节点不存储表中的数据，而是存储该列对应的主键，想要查找数据我们还需要根据主键再去聚集索引中进行查找，这个再根据聚集索引查找数据的过程，我们称为回表。</p>
<p>明白了聚集索引和非聚集索引的定义，我们应该明白这样一句话：<strong>数据即索引，索引即数据</strong>。</p>
<p><strong>聚簇索引的好处</strong>：</p>
<p>按照聚簇索引排列顺序，查询显示一定范围数据的时候，由于数据都是紧密相连，数据库不用从多个数据块中提取数据，所以节省了大量的io操作。</p>
<p><strong>聚簇索引的限制</strong>：</p>
<p>对于mysql 数据库目前只有innodb 数据引擎支持聚簇索引，而Myisam 并不支持聚簇索引。由于数据物理存储排序方式只能有一种，所以每个Mysql 的表只能有一个聚簇索引。一般情况下就是该表的主键。</p>
<p>为了充分利用聚簇索引的聚簇的特性，所以innodb 表的主键列尽量选用有序的顺序id，而不建议用无序的id，比如uuid 这种。</p>
<h1 id="优化细节"><a href="#优化细节" class="headerlink" title="优化细节"></a>优化细节</h1><ol>
<li><p>对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。</p>
</li>
<li><p>应尽量避免在 where 子句中使用!&#x3D;或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描。</p>
</li>
<li><p>应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id from t where num is null </span><br></pre></td></tr></table></figure>

<p>可以在num上设置默认值0，确保表中num列没有null值，然后这样查询：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id from t where num=0 </span><br></pre></td></tr></table></figure>
</li>
<li><p>应尽量避免在 where 子句中使用 or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id from t where num=10 or num=20 </span><br></pre></td></tr></table></figure>

<p> 可以这样查询：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select id from t where num=10 </span><br><span class="line">union all </span><br><span class="line">select id from t where num=20 </span><br></pre></td></tr></table></figure>
</li>
<li><p>下面的查询也将导致全表扫描：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id from t where name like &#x27;%abc%&#x27; </span><br></pre></td></tr></table></figure>

<p>  若要提高效率，可以考虑全文检索。</p>
</li>
<li><p>in 和 not in 也要慎用，否则会导致全表扫描，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id from t where num in(1,2,3) </span><br></pre></td></tr></table></figure>

<p>对于连续的数值，能用 between 就不要用 in 了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id from t where num between 1 and 3 </span><br></pre></td></tr></table></figure>
</li>
<li><p>如果在 where 子句中使用参数，也会导致全表扫描。因为SQL只有在运行时才会解析局部变量，但优化程序不能将访问计划的选择推迟到运行时；它必须在编译时进行选择。然而，如果在编译时建立访问计划，变量的值还是未知的，因而无法作为索引选择的输入项。如下面语句将进行全表扫描：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id from t where num=@num </span><br></pre></td></tr></table></figure>

<p> 可以改为强制查询使用索引：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id from t with(index(索引名)) where num=@num </span><br></pre></td></tr></table></figure>
</li>
<li><p>应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id from t where num/2=100 </span><br></pre></td></tr></table></figure>

<p>应改为:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id from t where num=100*2 </span><br></pre></td></tr></table></figure>
</li>
<li><p>应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select id from t where substring(name,1,3)=&#x27;abc&#x27;--name以abc开头的id </span><br><span class="line">select id from t where datediff(day,createdate,&#x27;2005-11-30&#x27;)=0--&#x27;2005-11-30&#x27;生成的id </span><br></pre></td></tr></table></figure>

<p>应改为:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select id from t where name like &#x27;abc%&#x27; </span><br><span class="line">select id from t where createdate&gt;=&#x27;2005-11-30&#x27; and createdate&lt;&#x27;2005-12-1&#x27; </span><br></pre></td></tr></table></figure>
</li>
<li><p>不要在 where 子句中的“&#x3D;”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。</p>
</li>
<li><p>在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使用，并且应尽可能的让字段顺序与索引顺序相一致。</p>
</li>
<li><p>不要写一些没有意义的查询，如需要生成一个空表结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select col1,col2 into #t from t where 1=0 </span><br></pre></td></tr></table></figure>

<p>这类代码不会返回任何结果集，但是会消耗系统资源的，应改成这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create table #t(...) </span><br></pre></td></tr></table></figure>
</li>
<li><p>很多时候用 exists 代替 in 是一个好的选择：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select num from a where num in(select num from b) </span><br></pre></td></tr></table></figure>

<p>用下面的语句替换：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select num from a where exists(select 1 from b where num=a.num) </span><br></pre></td></tr></table></figure>
</li>
<li><p>并不是所有索引对查询都有效，SQL是根据表中数据来进行查询优化的，当索引列有大量数据重复时，SQL查询可能不会去利用索引，如一表中有字段sex，male、female几乎各一半，那么即使在sex上建了索引也对查询效率起不了作用。</p>
</li>
<li><p>索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有必要。</p>
</li>
<li><p>应尽可能的避免更新 clustered 索引数据列，因为 clustered 索引数据列的顺序就是表记录的物理存储顺序，一旦该列值改变将导致整个表记录的顺序的调整，会耗费相当大的资源。若应用系统需要频繁更新 clustered 索引数据列，那么需要考虑是否应将该索引建为 clustered 索引。</p>
</li>
<li><p>尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。这是因为引擎在处理查询和连接时会逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。</p>
</li>
<li><p>尽可能的使用 varchar&#x2F;nvarchar 代替 char&#x2F;nchar ，因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。</p>
</li>
<li><p>任何地方都不要使用 select * from t ，用具体的字段列表代替“*”，不要返回用不到的任何字段。</p>
</li>
<li><p>尽量使用表变量来代替临时表。如果表变量包含大量数据，请注意索引非常有限（只有主键索引）。</p>
</li>
<li><p>避免频繁创建和删除临时表，以减少系统表资源的消耗。</p>
</li>
<li><p>临时表并不是不可使用，适当地使用它们可以使某些例程更有效，例如，当需要重复引用大型表或常用表中的某个数据集时。但是，对于一次性事件，最好使用导出表。</p>
</li>
<li><p>在新建临时表时，如果一次性插入数据量很大，那么可以使用 select into 代替 create table，避免造成大量 log ，以提高速度；如果数据量不大，为了缓和系统表的资源，应先create table，然后insert。</p>
</li>
<li><p>如果使用到了临时表，在存储过程的最后务必将所有的临时表显式删除，先 truncate table ，然后 drop table ，这样可以避免系统表的较长时间锁定。</p>
</li>
<li><p>尽量避免使用游标，因为游标的效率较差，如果游标操作的数据超过1万行，那么就应该考虑改写。</p>
</li>
<li><p>使用基于游标的方法或临时表方法之前，应先寻找基于集的解决方案来解决问题，基于集的方法通常更有效。</p>
</li>
<li><p>与临时表一样，游标并不是不可使用。对小型数据集使用 FAST_FORWARD 游标通常要优于其他逐行处理方法，尤其是在必须引用几个表才能获得所需的数据时。在结果集中包括“合计”的例程通常要比使用游标执行的速度快。如果开发时间允许，基于游标的方法和基于集的方法都可以尝试一下，看哪一种方法的效果更好。</p>
</li>
<li><p>在所有的存储过程和触发器的开始处设置 SET NOCOUNT ON ，在结束时设置 SET NOCOUNT OFF 。无需在执行存储过程和触发器的每个语句后向客户端发送 DONE_IN_PROC 消息。</p>
</li>
<li><p>尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理。</p>
</li>
<li><p>尽量避免大事务操作，提高系统并发能力。</p>
</li>
</ol>
<h1 id="B-树添加和删除数据"><a href="#B-树添加和删除数据" class="headerlink" title="B+树添加和删除数据"></a>B+树添加和删除数据</h1><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/%E6%A0%91%E6%B7%BB%E5%8A%A0%E5%92%8C%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE%E5%9B%BE%E8%A7%A3.png" alt="B+树添加和删除数据图解"></p>
<h1 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h1><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/%E7%BA%A2%E9%BB%91%E6%A0%91%20(1).jpg" alt="红黑树"></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-数据库：mysql锁"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
	
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/08/05/%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%9Amysql%E9%94%81/"
    >mysql锁</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/08/05/%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%9Amysql%E9%94%81/" class="article-date">
  <time datetime="2022-08-05T07:55:12.000Z" itemprop="datePublished">2022-08-05</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a> / <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/">mysql</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="锁机制"><a href="#锁机制" class="headerlink" title="锁机制"></a>锁机制</h1><ul>
<li>事务与锁是不同的。事务具有ACID( 原子性、一致性、隔离性和持久性)，锁是用于<strong>解决隔离级别</strong>的一种机制。事务的隔离级别通过锁的机制来实现。</li>
<li>为了保证数据并发访问时的<strong>一致性和有效性</strong>，任何一个数据库都存在锁机制。锁机制的优劣直接影响到数据库的并发处理能力和系统性能，所以锁机制也就成为了各种数据库的核心技术之一。</li>
<li>锁机制是为了解决数据库的并发控制问题而产生的。如在同一时刻，客户端对同一个表做更新或查询操作，为了保证数据的一致性，必须对并发操作进行控制。同时，锁机制也为实现 MySQL 的各个隔离级别提供了保证。</li>
<li>可以将锁机制理解为使各种资源在被并发访问时变得有序所设计的一种规则。</li>
<li>如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。从这个角度来说，锁对数据库显得尤其重要，也更加复杂。</li>
</ul>
<h1 id="锁分类"><a href="#锁分类" class="headerlink" title="锁分类"></a>锁分类</h1><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/7d4abdeb78b66d9ba4110d54beec4855.png" alt="img"></p>
<ol>
<li>按照锁的粒度划分：<strong>行锁、表锁、页锁</strong></li>
<li>按照锁的使用方式划分：<strong>共享锁、排它锁</strong>（悲观锁的一种实现）</li>
<li>还有两种思想上的锁：<strong>悲观锁、乐观锁</strong>。</li>
<li>InnoDB中有几种行级锁类型：Record Lock、Gap Lock、Next-key Lock</li>
<li>按<strong>锁级别分类，可分为共享锁、排他锁和意向锁。</strong></li>
</ol>
<p>MySQL的锁机制最显著的特点是不同的存储引擎支持不同的锁机制。比如，MyISAM和MEMORY存储引擎采用的是表级锁，<strong>不支持行锁</strong>；BDB存储引擎采用的是页面锁，但也支持表级锁；InnoDB存储引擎既支持行级锁，也支持表级锁，但默认情况下是采用<strong>行级锁</strong>。不支持行锁意味着并发控制只能使用表锁，对于这种引擎的表，同 一张表上任何时刻只能有一个更新在执行，这就会影响到业务并发度。<strong>InnoDB是支持行锁的， 这也是MyISAM被InnoDB替代的重要原因之一。</strong></p>
<h1 id="行锁（row-level-locking）"><a href="#行锁（row-level-locking）" class="headerlink" title="行锁（row-level locking）"></a>行锁（row-level locking）</h1><ul>
<li>行级锁的锁定颗粒度在 MySQL 中是最小的，<strong>只针对操作的当前行进行加锁</strong>，所以<strong>行级锁发生锁定资源争用的概率也最小</strong>。</li>
<li>行级锁能够给予应用程序尽可能大的并发处理能力，从而提高需要高并发应用系统的整体性能。虽然行级锁在并发处理能力上面有较大的优势，但也因此带来了不少弊端。</li>
<li><strong>由于锁定资源的颗粒度很小，所以每次获取锁和释放锁需要做的事情也就更多，带来的消耗自然也就更大。</strong>此外，<strong>行级锁也最容易发生死锁</strong>。所以说<strong>行级锁最大程度地支持并发处理的同时，也带来了最大的锁开销</strong>。</li>
<li>行级锁主要应用于 <strong>InnoDB 存储引擎</strong>。</li>
<li><strong>随着锁定资源颗粒度的减小，锁定相同数据量的数据所需要消耗的内存数量也越来越多，实现算法也会越来越复杂。不过，随着锁定资源颗粒度的减小，应用程序的访问请求遇到锁等待的可能性也会随之降低，系统整体并发度也会随之提升。</strong></li>
<li><strong>行级锁按照使用方式分为共享锁和排他锁。</strong></li>
</ul>
<h1 id="表锁（table-level-locking）"><a href="#表锁（table-level-locking）" class="headerlink" title="表锁（table-level locking）"></a>表锁（table-level locking）</h1><ul>
<li>表级锁为表级别的锁定，会锁定整张表，<strong>可以很好的避免死锁</strong>，是 MySQL 中最大颗粒度的锁定机制。</li>
<li>一个用户在对表进行写操作(插入、删除、更新等)时，需要先获得写锁(也叫排斥锁)，这会阻塞其它用户对该表的所有读写操作。没有写锁时，其它读取的用户才能获得读锁，读锁之间是不相互阻塞的。</li>
<li>表级锁最大的特点就是<strong>实现逻辑非常简单，带来的系统负面影响最小</strong>。所以获取锁和释放锁的速度很快。当然，锁定颗粒度大带来最大的负面影响就是<strong>出现锁定资源争用的概率会很高</strong>，致使并发度大打折扣。</li>
<li>不过在某些特定的场景中，表级锁也可以有良好的性能。例如，READ LOCAL 表级锁支持某些类型的并发写操作。另外，写锁也比读锁有更高的优先级，因此一个写锁请求可能会被插入到读锁队列的前面(写锁可以插入到锁队列中读锁的前面，反之读锁则不能插入到写锁的前面)。</li>
<li>使用表级锁的主要是 MyISAM，MEMORY，CSV 等一些非事务性存储引擎。</li>
<li>尽管存储引擎可以管理自己的锁，MySQL 本身还是会使用各种有效的表级锁来实现不同的目的。例如，服务器会为诸如 ALTER TABLE 之类的语句使用表级锁，而忽略存储引擎的锁机制。</li>
</ul>
<h1 id="页锁（page-level-locking）"><a href="#页锁（page-level-locking）" class="headerlink" title="页锁（page-level locking）"></a>页锁（page-level locking）</h1><ul>
<li>页级锁是 MySQL 中比较独特的一种锁定级别，在其他数据库管理软件中并不常见。</li>
<li>页级锁的颗粒度<strong>介于行级锁与表级锁之间</strong>，所以获取锁定所需要的资源开销，以及所能提供的并发处理能力同样也是介于上面二者之间。另外，页级锁和行级锁一样，会发生死锁。</li>
<li>页级锁主要应用于 BDB 存储引擎。</li>
</ul>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/78c7b27c7fd257f074da21aef869b491.png" alt="img"></p>
<h1 id="共享锁（Shared-Lock）"><a href="#共享锁（Shared-Lock）" class="headerlink" title="共享锁（Shared Lock）"></a>共享锁（Shared Lock）</h1><ul>
<li><p>共享锁的代号是 <code>S</code>，是 <code>Share</code> 的缩写，也可称为<strong>读锁</strong>。是一种<strong>可以查看但无法修改和删除的数据锁</strong>。</p>
</li>
<li><p><strong>共享锁的锁粒度是行或者元组(多个行)<strong>。</strong>一个事务获取了共享锁之后，可以对锁定范围内的数据执行读操作。会阻止其它事务获得相同数据集的排他锁。</strong></p>
</li>
<li><p><strong>加锁方式</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 行级读锁</span><br><span class="line">select * from T where id=1 lock in share mode;</span><br><span class="line">-- 表级读锁</span><br><span class="line">lock table user_info read;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>释放方式</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">commit、rollback;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="排他锁（EXclusive-Lock）"><a href="#排他锁（EXclusive-Lock）" class="headerlink" title="排他锁（EXclusive Lock）"></a>排他锁（EXclusive Lock）</h1><ul>
<li><p>排他锁的代号是<code>X</code>，是 <code>eXclusive</code> 的缩写，也可称为<strong>写锁</strong>，是基本的锁类型。</p>
</li>
<li><p>排他锁的粒度与共享锁相同，也是行或者元组。<strong>一个事务获取了排他锁之后，可以对锁定范围内的数据执行写操作。允许获得排他锁的事务更新数据，阻止其它事务取得相同数据集的共享锁和排他锁。</strong></p>
</li>
<li><p>当有事务对数据加写锁后，其他事务不能再对锁定的数据加任何锁，又因为InnoDB对select语句默认不加锁，所以其他事务<strong>除了不能写操作外，照样是允许读的（尽管不允许加读锁）</strong>。</p>
</li>
<li><p><strong>主要为了在事务进行写操作时，不允许其他事务修改。</strong></p>
</li>
<li><p><strong>加锁方式</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 行级写锁</span><br><span class="line">自动：DML语句默认加写锁</span><br><span class="line">手动：select * from T where id=1 for update;</span><br><span class="line">-- 表级写锁</span><br><span class="line">lock table user_info write;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>释放方式</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">commit、rollback;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="意向锁（Intention-Lock）"><a href="#意向锁（Intention-Lock）" class="headerlink" title="意向锁（Intention Lock）"></a>意向锁（Intention Lock）</h1><ul>
<li><p>又称<strong>I锁</strong>。针对<strong>表锁</strong>。</p>
</li>
<li><p>为了允许行锁和表锁共存，实现多粒度锁机制，InnoDB 还有两种内部使用的意向锁。</p>
</li>
<li><p>意向锁是一种表锁，锁定的粒度是整张表，分为意向**共享锁(IS)和意向排他锁(IX)**两类。</p>
</li>
<li><p>意向共享锁表示一个事务有意对数据上共享锁或者排他锁。“有意”表示事务想执行操作但还没有真正执行。</p>
</li>
<li><p>当有事务给表的数据行加了共享锁或排他锁，同时会给表设置一个标识，代表已经有行锁了，其他事务要想对表加表锁时，就不必逐行判断有没有行锁可能跟表锁冲突了，直接读这个标识就可以确定自己该不该加表锁。特别是表中的记录很多时，逐行判断加表锁的方式效率很低。而<strong>这个标识就是意向锁</strong>。</p>
<ul>
<li>意向共享锁，IS锁，对整个表加共享锁之前，需要先获取到意向共享锁。</li>
<li>意向排他锁，IX锁，对整个表加排他锁之前，需要先获取到意向排他锁。</li>
<li>主要是为了提高加表锁的效率。</li>
</ul>
</li>
<li><p>加锁方式：</p>
<p>无法手动创建。</p>
</li>
</ul>
<p>锁和锁之间的关系，要么是相容的，要么是互斥的。</p>
<ul>
<li>锁 a 和锁 b 相容是指：操作同样一组数据时，如果事务 t1 获取了锁 a，另一个事务 t2 还可以获取锁 b；</li>
<li>锁 a 和锁 b 互斥是指：操作同样一组数据时，如果事务 t1 获取了锁 a，另一个事务 t2 在 t1 释放锁 a 之前无法释放锁 b</li>
</ul>
<p>其中<strong>共享锁</strong>、<strong>排他锁</strong>、<strong>意向共享锁、意向排他锁</strong>相互之间的兼容&#x2F;互斥关系如下表所示，其中 Y 表示相容，N 表示互斥。</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/24c690732b2a23eaaf35d230f986d830.png" alt="image-20220303132033771"></p>
<p><strong>如果一个事务请求的锁模式与当前的锁兼容，InnoDB 就将请求的锁授予该事务；反之，如果两者不兼容，该事务就要等待锁释放。</strong></p>
<p><strong>为了尽可能提高数据库的并发量，需每次锁定的数据范围越小越好，越小的锁其耗费的系统资源越多，系统性能下降。为在高并发响应和系统性能两方面进行平衡，这样就产生了“锁粒度”的概念。</strong></p>
<h1 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h1><ul>
<li><p>当程序中可能出现并发的情况时，就需要保证在并发情况下数据的准确性，以此确保当前用户和其他用户一起操作时，所得到的结果和他单独操作时的结果是一样的。这就叫做并发控制。并发控制的目的是保证一个用户的工作不会对另一个用户的工作产生不合理的影响。</p>
</li>
<li><p><strong>没有做好并发控制，就可能导致脏读、幻读和不可重复读等问题。</strong></p>
</li>
</ul>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/16b34e4c9b6784337b498623ea0dd849.png" alt="img"></p>
<p>常说的并发控制，一般都和数据库管理系统(DBMS)有关。在 DBMS 中并发控制的任务，是确保多个事务同时增删改查同一数据时，不破坏事务的隔离性、一致性和数据库的统一性。</p>
<p><code>实现并发控制的主要手段分为乐观并发控制和悲观并发控制两种。</code></p>
<p>无论是悲观锁还是乐观锁，都是人们定义出来的概念，<strong>可以认为是一种思想</strong>。其实不仅仅是关系型数据库系统中有乐观锁和悲观锁的概念，像 hibernate、tair、memcache 等都有类似的概念。所以，不应该拿乐观锁、悲观锁和其他的数据库锁等进行对比。<strong>乐观锁比较适用于读多写少的情况(多读场景)，悲观锁比较适用于写多读少的情况(多写场景)。</strong></p>
<h1 id="悲观锁（Pessimistic-Lock）"><a href="#悲观锁（Pessimistic-Lock）" class="headerlink" title="悲观锁（Pessimistic Lock）"></a>悲观锁（Pessimistic Lock）</h1><ul>
<li><p>在关系数据库管理系统里，悲观并发控制（又名“悲观锁”，Pessimistic Concurrency Control，缩写“PCC”）是一种并发控制的方法。它可以阻止一个事务以影响其他用户的方式来修改数据。<strong>如果一个事务执行的操作对某行数据应用了锁，那只有当这个事务把锁释放，其他事务才能够执行与该锁冲突的操作</strong>。悲观并发控制主要用于数据争用激烈的环境，以及发生并发冲突时使用锁保护数据的成本要低于回滚事务的成本的环境中。</p>
</li>
<li><p>悲观锁，具有强烈的独占和排他特性，正如其名，它指的是对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度(悲观)，因此，<strong>在整个数据处理过程中，将数据处于锁定状态</strong>。 <code>悲观锁的实现，往往依靠数据库提供的锁机制 （也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据）</code></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/e0a7bb67259e9c0de800ae7913bf0fd2.png" alt="img"></p>
</li>
<li><p>之所以叫做悲观锁，是因为这是一种对数据的修改持有悲观态度的并发控制方式。总是假设最坏的情况，每次读取数据的时候都默认其他线程会更改数据，因此需要进行加锁操作，当其他线程想要访问数据时，都需要阻塞挂起。</p>
</li>
<li><p>悲观锁的实现：</p>
<ol>
<li>传统的关系型数据库使用这种锁机制，比如行锁、表锁、读锁、写锁等，都是在操作之前先上锁。</li>
<li>Java 里面的同步<code>synchronized</code>关键字的实现。</li>
</ol>
</li>
<li><p>悲观锁主要分为<strong>共享锁和排他锁</strong></p>
</li>
<li><p>mysql中实现悲观锁的具体流程：</p>
<ol>
<li>在对任意记录进行修改前，先尝试为该记录加上排他锁（exclusive locking）</li>
<li>如果加锁失败，说明该记录正在被修改，那么当前查询可能要等待或者抛出异常。 具体响应方式由开发者根据实际需要决定。</li>
<li>如果成功加锁，那么就可以对记录做修改，事务完成后就会解锁了。</li>
<li>期间如果有其他对该记录做修改或加排他锁的操作，都会等待我们解锁或直接抛出异常。</li>
<li><strong>总而言之就是一句话：mysql中悲观锁的实现是通过排他锁来实现的</strong></li>
</ol>
</li>
</ul>
<p><strong>在mysql（InnoDB）中使用悲观锁：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.开始事务</span><br><span class="line">begin;/begin work;/start transaction; (三者选一就可以)</span><br><span class="line">2.查询出商品信息</span><br><span class="line">select ... for update;(这里是使用的行锁的排他锁)</span><br><span class="line">4.提交事务</span><br><span class="line">commit;/commit work;</span><br></pre></td></tr></table></figure>

<p>通过下面的例子来说明：</p>
<p><strong>1. 当你手动加上排它锁，但是并没有关闭mysql中的autocommit。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1.这里先给user表所有的行加上行锁的排他锁</span><br><span class="line">mysql&gt; select * from user for update;</span><br><span class="line">+----+------+--------+</span><br><span class="line">| id | name | psword |</span><br><span class="line">+----+------+--------+</span><br><span class="line">|  1 | a    | 1      |</span><br><span class="line">|  2 | b    | 2      |</span><br><span class="line">|  3 | c    | 3      |</span><br><span class="line">+----+------+--------+</span><br><span class="line">3 rows in set</span><br><span class="line"></span><br><span class="line">2.再对加了排他锁的行更改数据时，这里他会一直提示Unknown</span><br><span class="line">mysql&gt; update user set name=aa where id=1;</span><br><span class="line">1054 - Unknown column &#x27;aa&#x27; in &#x27;field list&#x27;</span><br><span class="line">mysql&gt; insert into user values(4,d,4);</span><br><span class="line">1054 - Unknown column &#x27;d&#x27; in &#x27;field list&#x27;</span><br></pre></td></tr></table></figure>

<p><strong>2. 关闭mysql中的autocommit后的正常流程</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">窗口1：</span><br><span class="line">mysql&gt; set autocommit=0;（先关闭mysql中的autocommit）</span><br><span class="line">Query OK, 0 rows affected</span><br><span class="line">我这里锁的是表中的所有行</span><br><span class="line">mysql&gt; select * from user for update;</span><br><span class="line">+----+-------+</span><br><span class="line">| id | price |</span><br><span class="line">+----+-------+</span><br><span class="line">|  1 |   500 |</span><br><span class="line">|  2 |   800 |</span><br><span class="line">+----+-------+</span><br><span class="line">2 rows in set</span><br><span class="line"></span><br><span class="line">窗口2：</span><br><span class="line">mysql&gt; update user set price=price-100 where id=1;</span><br><span class="line">执行上面操作的时候，会显示等待状态，一直到窗口1执行commit提交事务才会出现下面的显示结果</span><br><span class="line">Database changed</span><br><span class="line">Rows matched: 1  Changed: 1  Warnings: 0</span><br><span class="line"></span><br><span class="line">窗口1：执行commit手动提交事务</span><br><span class="line">mysql&gt; commit;</span><br><span class="line">Query OK, 0 rows affected</span><br><span class="line">再查询一下user表，发现已经执行了窗口2的更新操作</span><br><span class="line">mysql&gt; select * from user;</span><br><span class="line">+----+-------+</span><br><span class="line">| id | price |</span><br><span class="line">+----+-------+</span><br><span class="line">|  1 |   400 |</span><br><span class="line">|  2 |   800 |</span><br><span class="line">+----+-------+</span><br><span class="line">2 rows in set</span><br></pre></td></tr></table></figure>

<p>上面的例子展示了排它锁的原理：一个锁在某一时刻只能被一个线程占有，其它线程必须等待锁被释放之后才可能获取到锁或者进行数据的操作。</p>
<ul>
<li><p><strong>悲观锁的优点和不足</strong></p>
<p>悲观锁实际上是采取了“先取锁在访问”的策略，为数据的处理安全提供了保证，但是在效率方面，由于额外的加锁机制产生了额外的开销，并且<strong>增加了死锁的机会</strong>。并且降低了并发性；当一个事务加锁一行数据的时候，其他事务必须等待该事务提交之后，才能操作这行数据。</p>
</li>
</ul>
<h1 id="乐观锁（Optimistic-Locking）"><a href="#乐观锁（Optimistic-Locking）" class="headerlink" title="乐观锁（Optimistic Locking）"></a>乐观锁（Optimistic Locking）</h1><ul>
<li><p>在关系数据库管理系统里，乐观并发控制（又名“乐观锁”，Optimistic Concurrency Control，缩写“OCC”）是一种并发控制的方法。它假设多用户并发的事务在处理时不会彼此互相影响，各事务能够在不产生锁的情况下处理各自影响的那部分数据。在提交数据更新之前，每个事务会先检查在该事务读取数据后，有没有其他事务又修改了该数据。如果其他事务有更新的话，正在提交的事务会进行回滚。</p>
</li>
<li><p>乐观锁（ Optimistic Locking ） 相对悲观锁而言，乐观锁假设认为数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则让返回用户错误的信息，让用户决定如何去做。</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/569ff4e1a29633f4039ff83c0438346d.png" alt="img"></p>
</li>
<li><p>相对于悲观锁，在对数据库进行处理的时候，乐观锁并不会使用数据库提供的锁机制。</p>
</li>
<li><p>mysql实现乐观锁一般来说有3种方式：</p>
<ol>
<li>使用<strong>数据版本（Version）记录机制</strong>实现，这是乐观锁最常用的一种实现方式。一般是通过为数据库表增加一个数字类型的 “version” 字段，表示数据被修改的次数。当读取数据时，将version字段的值一同读出，数据每更新一次，对此version值加一。<br>当提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的version值进行比对，如果数据库表当前版本号与第一次取出来的version值相等，就进行更新操作，否则认为是过期数据，正在提交的事务会进行回滚。</li>
<li>第二种实现方式和第一种差不多，同样是在需要乐观锁控制的table中增加一个字段，名称无所谓，字段类型使用<strong>时间戳</strong>（timestamp）, 和上面的version类似，也是在更新提交的时候检查当前数据库中数据的时间戳和自己更新前取到的时间戳进行对比，如果一致就更新，否则就是版本冲突。</li>
<li>CAS 实现：Java 中java.util.concurrent.atomic包下面的原子变量使用了乐观锁的一种 CAS 实现方式</li>
</ol>
</li>
<li><p>乐观锁的优点和不足</p>
<p>乐观并发控制相信事务之间的数据竞争(data race)的概率是比较小的，因此尽可能直接做下去，直到提交的时候才去锁定，所以<strong>不会产生任何锁和死锁</strong>。但如果直接简单这么做，还是有可能会遇到不可预期的结果，例如两个事务都读取了数据库的某一行，经过修改以后写回数据库，这时就遇到了问题。</p>
</li>
<li><p>具体流程</p>
<ul>
<li>主要就是两个步骤：<strong>冲突检测和数据更新</strong>。比较典型的就是 CAS (Compare and Swap)。</li>
<li><strong>CAS 即比较并交换</strong>。是解决多线程并行情况下使用锁造成性能损耗的一种机制，CAS 操作包含三个操作数——<strong>内存位置(V)、预期原值(A)和新值(B)<strong>。如果内存位置的值(V)与预期原值(A)相匹配，那么处理器会自动将该位置值更新为新值(B)。否则，处理器不做任何操作。无论哪种情况，它都会在 CAS 指令之前返回该位置的值。CAS 有效地说明了“我认为位置(V)应该包含值(A)。如果包含该值，则将新值(B)放到这个位置；否则，不要更改该位置，只告诉我这个位置现在的值即可”。Java 中，</strong>sun.misc.Unsafe</strong> 类提供了硬件级别的原子操作来实现这个 CAS。<strong>java.util.concurrent</strong>包下大量的类都使用了这个 Unsafe.java 类的 CAS 操作。</li>
<li>当多个线程尝试使用 CAS 同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。比如前面的扣减库存问题，</li>
</ul>
</li>
<li><p>通过乐观锁可以实现如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">查出商品库存信息，quantity=3</span><br><span class="line">select quantity from items where id=1;</span><br><span class="line">修改商品库存为2</span><br><span class="line">update items set quantity=2 where id=1 and quantity = 3;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>在更新之前，先查询一下库存表中当前库存数(quantity)，然后在做 update 的时候，以库存数作为一个修改条件。当提交更新的时候，判断数据库表对应记录的当前库存数与第一次取出来的库存数进行比对，如果数据库表当前库存数与第一次取出来的库存数相等，则予以更新，否则认为是过期数据。</p>
</li>
<li><p>以上更新语句存在一个比较严重的问题，即<strong>ABA问题</strong>：</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/b67b363facf7760af75bfbad53b4e593.png" alt="img"></p>
<ol>
<li>比如说线程一从数据库中取出库存数 3，这时候线程二也从数据库中取出库存数 3，并且线程二进行了一些操作变成了 2。</li>
<li>然后线程二又将库存数变成 3，这时候线程一进行 CAS 操作发现数据库中仍然是 3，然后线程一操作成功。</li>
<li>尽管线程一的 CAS 操作成功，但是不代表这个过程就是没有问题的。</li>
</ol>
</li>
<li><p>一个比较好的解决办法，就是通过一个单独的可以顺序递增的 version 字段。优化如下：</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/d5de6b18dd097c35937d73caa0b6db1b.png" alt="img"></p>
<ul>
<li><p>乐观锁每次在执行数据修改操作时，都会带上一个版本号，一旦版本号和数据的版本号一致就可以执行修改操作并对版本号执行 +1 操作，否则就执行失败。因为每次操作的版本号都会随之增加，所以不会出现 ABA 问题。除了 version 以外，还可以使用时间戳，因为时间戳天然具有顺序递增性。</p>
</li>
<li><p>以上 SQL 其实还是有一定的问题的，就是一旦遇上高并发的时候，就只有一个线程可以修改成功，那么就会存在大量的失败。对于像淘宝这样的电商网站，高并发是常有的事，总让用户感知到失败显然是不合理的。所以，还是要想办法<strong>减少乐观锁的粒度</strong>。一个比较好的建议，就是<strong>减小乐观锁力度，最大程度的提升吞吐率，提高并发能力</strong>！如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">修改商品库存</span><br><span class="line">update item set quantity=quantity-1 where id=1 and quantity-1 &gt; 0;</span><br></pre></td></tr></table></figure>

<ul>
<li>以上 SQL 语句中，如果用户下单数为 1，则通过<code>quantity - 1 &gt; 0</code>的方式进行乐观锁控制。在执行过程中，会在一次原子操作中查询一遍 quantity 的值，并将其扣减掉 1。</li>
<li>高并发环境下锁粒度把控是一门重要的学问。选择一个好的锁，在保证数据安全的情况下，可以大大提升吞吐率，进而提升性能。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="理解-CAS-底层"><a href="#理解-CAS-底层" class="headerlink" title="理解 CAS 底层"></a>理解 CAS 底层</h1><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/885eeb9d953fac34d4fdc53b31215b78.png" alt="img"></p>
<p>假如说有 3 个线程并发的要修改一个AtomicInteger的值，底层机制如下：</p>
<ol>
<li>首先，每个线程都会先获取当前的值，接着走一个原子的 CAS 操作。原子的意思就是这个 CAS 操作一定是自己完整执行完的，不会被别人打断。</li>
<li>然后 CAS 操作里，会比较一下，现在的值是不是刚才获取到的那个值。如果是，说明没人改过这个值，然后设置成累加 1 之后的一个值。</li>
<li>同理，如果有人在执行 CAS 的时候，发现之前获取的值跟当前的值不一样，会导致 CAS 失败。失败之后，进入一个无限循环，再次获取值，接着执行 CAS 操作。</li>
</ol>
<h1 id="CAS-典型应用"><a href="#CAS-典型应用" class="headerlink" title="CAS 典型应用"></a>CAS 典型应用</h1><p>java.util.concurrent.atomic包下的类大多是使用 CAS 操作来实现的，比如 AtomicInteger、AtomicBoolean、AtomicLong。一般在竞争不是特别激烈的时候，使用该包下的原子操作性能比使用 synchronized关键字的方式高效的多(查看 getAndSet()，可知如果资源竞争十分激烈的话，这个 for 循环可能会持续很久都不能成功跳出。不过这种情况可能需要考虑降低资源竞争才是)。</p>
<p>在较多的场景都可能会使用到这些原子类操作。一个典型应用就是计数了，在多线程的情况下需要考虑线程安全问题。</p>
<ol>
<li>支持计数功能 Demo 实现</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Increment</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在并发环境下对 count 进行自增运算是不安全的，为什么不安全以及如何解决这个问题呢？</p>
<ol start="2">
<li>为什么并发环境下的 count 自增操作不安全？因为 count++ 不是原子操作，而是三个原子操作的组合：<ol>
<li>读取内存中的 count 值赋值给局部变量 temp；</li>
<li>执行 temp+1 操作；</li>
<li>将 temp 赋值给 count。</li>
</ol>
</li>
</ol>
<p>所以如果两个线程同时执行 count++ 的话，不能保证线程一按顺序执行完上述三步后线程二才开始执行。</p>
<ol start="3">
<li>并发环境下 count++ 不安全问题的解决方案</li>
</ol>
<p>方案①：<strong>synchronized加锁</strong>。同一时间只有一个线程能加锁，其他线程需要等待锁，这样就不会出现 count 计数不准确的问题了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Increment</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是引入 synchronized 会造成多个线程排队的问题，相当于让各个线程串行化了，一个接一个的排队、加锁、处理数据、释放锁，下一个再进来。同一时间只有一个线程执行，这样的锁有点“重量级”了。这类似于悲观锁的实现，需要获取这个资源，就给它加锁，别的线程都无法访问该资源，直到操作完后释放对该资源的锁。虽然随着 Java 版本更新，也对 synchronized 做了很多优化，但是处理这种简单的累加操作，仍然显得“太重了”。</p>
<p>方案②：<strong>Atomic 原子类</strong>。对于 count++ 的操作，完全可以换一种做法，Java 并发包下面提供了一系列的 Atomic 原子类，比如说 AtomicInteger：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//import java.util.concurrent.atomic.AtomicInteger;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">AtomicInteger</span> <span class="variable">count</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">increase</span><span class="params">()</span> &#123;</span><br><span class="line">        count.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>多个线程可以并发的执行 AtomicInteger 的 incrementAndGet()，意思就是把 count 的值累加 1，接着返回累加后最新的值。实际上，Atomic 原子类底层用的不是传统意义的锁机制，而是无锁化的 CAS 机制，通过 CAS 机制保证多线程修改一个数值的安全性。</p>
<h1 id="CAS-性能优化"><a href="#CAS-性能优化" class="headerlink" title="CAS 性能优化"></a>CAS 性能优化</h1><p>从流程图可以看出来，大量的线程同时并发修改一个 AtomicInteger，可能有很多线程会不停的自旋，进入一个无限重复的循环中。这些线程不停地获取值，然后发起 CAS 操作，但是发现这个值被别人改过了，于是再次进入下一个循环，获取值，发起 CAS 操作又失败了，再次进入下一个循环。在大量线程高并发更新 AtomicInteger 的时候，这种问题可能会比较明显，导致大量线程空循环，自旋转，性能和效率都不是特别好。那么如何优化呢？</p>
<p>Java8 有一个新的类，LongAdder，它就是尝试使用分段 CAS 以及自动分段迁移的方式来大幅度提升多线程高并发执行 CAS 操作的性能，这个类具体是如何优化性能的呢？如图：</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/7abe51c80744d2eab1495895ec3fe11e.png" alt="img"></p>
<p><strong>LongAdder</strong></p>
<p>LongAdder 核心思想就是热点分离，这一点和 ConcurrentHashMap 的设计思想相似。就是将 value 值分离成一个数组，当多线程访问时，通过 hash 算法映射到其中的一个数字进行计数。而最终的结果，就是这些数组的求和累加。这样一来，就减小了锁的粒度。</p>
<p>LongAddr 的兄弟类如下：</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/60ca62457379f485d4482cc848269fb5.png" alt="img"></p>
<p>LongAdder兄弟类</p>
<h1 id="如何选择"><a href="#如何选择" class="headerlink" title="如何选择"></a>如何选择</h1><p>在乐观锁与悲观锁的选择上面，主要看下两者的区别以及适用场景就可以了。</p>
<ol>
<li><strong>响应效率</strong>：如果需要非常高的响应速度，建议采用乐观锁方案，成功就执行，不成功就失败，不需要等待其他并发去释放锁。乐观锁并未真正加锁，效率高。一旦锁的粒度掌握不好，更新失败的概率就会比较高，容易发生业务失败。</li>
<li><strong>冲突频率</strong>：如果冲突频率非常高，建议采用悲观锁，保证成功率。冲突频率大，选择乐观锁会需要多次重试才能成功，代价比较大。</li>
<li><strong>重试代价</strong>：如果重试代价大，建议采用悲观锁。悲观锁依赖数据库锁，效率低。更新失败的概率比较低。</li>
<li>乐观锁如果有人在你之前更新了，你的更新应当是被拒绝的，可以让用户从新操作。悲观锁则会等待前一个更新完成。这也是区别。</li>
</ol>
<p>随着互联网**三高架构(高并发、高性能、高可用)**的提出，悲观锁已经越来越少的被应用到生产环境中了，尤其是并发量比较大的业务场景。</p>
<h1 id="乐观锁和MVCC的区别？"><a href="#乐观锁和MVCC的区别？" class="headerlink" title="乐观锁和MVCC的区别？"></a>乐观锁和MVCC的区别？</h1><p>在数据库中，并发控制是指在多个用户&#x2F;进程&#x2F;线程同时对数据库进行操作时，如何保证事务的一致性和隔离性的，同时最大程度地并发。</p>
<p>当多个用户&#x2F;进程&#x2F;线程同时对数据库进行操作时，会出现3种冲突情形：</p>
<ol>
<li>读-读，不存在任何问题</li>
<li>读-写，有隔离性问题，可能遇到脏读（会读到未提交的数据） ，幻影读等。</li>
<li>写-写，可能丢失更新</li>
</ol>
<p><strong>要解决冲突，一种办法是是锁，即基于锁的并发控制，比如2PL两阶段锁协议，这种方式开销比较高，而且无法避免死锁。而基于无锁的并发控制有两种方式：就是MVCC多版本并发控制和OCC乐观并发控制，这两种方式分别解决上面的第2,3种情况。</strong></p>
<p><strong>多版本并发控制（MVCC）是一种用来解决读-写冲突的无锁并发控制</strong>，也就是为事务分配单向增长的时间戳，为每个修改保存一个版本，版本与事务时间戳关联，读操作只读该事务开始前的数据库的快照。 这样在读操作不用阻塞写操作，写操作不用阻塞读操作的同时，避免了脏读和不可重复读</p>
<p><strong>乐观并发控制（OCC）是一种用来解决写-写冲突的无锁并发控制</strong>，认为事务间争用没有那么多，所以先进行修改，在提交事务前，检查一下事务开始后，有没有新提交改变，如果没有就提交，如果有就放弃并重试。乐观并发控制类似自旋锁。乐观并发控制适用于低数据争用，写冲突比较少的环境。</p>
<p><strong>多版本并发控制可以结合基于锁的并发控制来解决写-写冲突</strong>，即MVCC+2PL，也可以结合乐观并发控制来解决写-写冲突。</p>
<h1 id="InnoDB锁的特性"><a href="#InnoDB锁的特性" class="headerlink" title="InnoDB锁的特性"></a>InnoDB锁的特性</h1><ol>
<li><p>在不通过索引条件查询的时候，InnoDB使用的确实是表锁（锁的是整张表）！</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">price属性并没有加索引，因此这时候虽然是用的行锁，锁的却是整张表</span><br><span class="line">窗口1：</span><br><span class="line">mysql&gt; select * from product where price=88 for update;</span><br><span class="line">+----+------+-------+-----+</span><br><span class="line">| id | name | price | num |</span><br><span class="line">+----+------+-------+-----+</span><br><span class="line">|  2 | 蒙牛 |    88 |   1 |</span><br><span class="line">+----+------+-------+-----+</span><br><span class="line"></span><br><span class="line">窗口2：</span><br><span class="line">mysql&gt; update product set price=price-100 where id=6;</span><br><span class="line">这里会等待，直到窗口1 commit后显示下面结果！</span><br><span class="line">Query OK, 1 row affected</span><br><span class="line">Rows matched: 1  Changed: 1  Warnings: 0</span><br></pre></td></tr></table></figure>
</li>
<li><p>由于 MySQL 的行锁是<strong>针对索引加的锁</strong>,不是针对记录加的锁,所以虽然是访问不同行的记录,但是如果是使用相同的索引键,是会出现锁冲突的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">这里的num属性 加上了普通索引，price属性并没有索引</span><br><span class="line">窗口1：</span><br><span class="line">mysql&gt; set autocommit=0;</span><br><span class="line">Query OK, 0 rows affected</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from product where num=1 and price=68 for update;</span><br><span class="line">+----+------+-------+-----+</span><br><span class="line">| id | name | price | num |</span><br><span class="line">+----+------+-------+-----+</span><br><span class="line">|  1 | 伊利 |    68 |   1 |</span><br><span class="line">+----+------+-------+-----+</span><br><span class="line"></span><br><span class="line">窗口2：</span><br><span class="line">mysql&gt; update product set price=price+100 where num=1 and price=88;</span><br><span class="line">这里会发生等待，直到窗口1 commit 显示下面结果</span><br><span class="line">Query OK, 1 row affected</span><br><span class="line">Rows matched: 1  Changed: 1  Warnings: 0</span><br><span class="line">mysql&gt; select * from product;</span><br><span class="line">+----+----------+-------+-----+</span><br><span class="line">| id | name     | price | num |</span><br><span class="line">+----+----------+-------+-----+</span><br><span class="line">|  1 | 伊利     |    68 |   1 |</span><br><span class="line">|  2 | 蒙牛     |   188 |   1 |</span><br><span class="line">+----+----------+-------+-----+</span><br></pre></td></tr></table></figure>
</li>
<li><p>当表有多个索引的时候,不同的事务可以使用不同的索引锁定不同的行,另外,不论是使用主键索引、唯一索引或普通索引,InnoDB都会使用行锁来对数据加锁。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">锁一行数据，DML操作其他行并没有影响</span><br><span class="line">窗口1：</span><br><span class="line">mysql&gt; select * from user where id=1 for update;</span><br><span class="line">+----+-------+</span><br><span class="line">| id | price |</span><br><span class="line">+----+-------+</span><br><span class="line">|  1 |   400 |</span><br><span class="line">+----+-------+</span><br><span class="line"></span><br><span class="line">窗口2：</span><br><span class="line">mysql&gt; update user set price=price+100 where id=2;</span><br><span class="line">无需等待窗口1 commit</span><br><span class="line">Database changed</span><br><span class="line">Rows matched: 1  Changed: 1  Warnings: 0</span><br></pre></td></tr></table></figure>
</li>
<li><p>即便在条件中使用了索引字段,但是否使用索引来检索数据是由 MySQL 通过判断不同 执行计划的代价来决定的,如果 MySQL 认为全表扫效率更高,比如对一些很小的表,它 就不会使用索引,这种情况下 InnoDB 将使用表锁,而不是行锁。因此,在分析锁冲突时, 别忘了检查SQL 的执行计划（explain查看）,以确认是否真正使用了索引。</p>
</li>
</ol>
<h1 id="死锁的原理及分析"><a href="#死锁的原理及分析" class="headerlink" title="死锁的原理及分析"></a>死锁的原理及分析</h1><h2 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h2><p>MySQL InnoDB存储引擎，实现的是基于多版本并发控制协议—MVCC(Multi-Version Concurrency Control) MVCC最大的好处，相信也是耳熟能详：<strong>读不加锁，读写不冲突</strong>。在读多写少的OLTP应用中，读写不冲突是非常重要的，极大的增加了系统的并发性能，这也是为什么现阶段，几乎所有的RDBMS，都支持了MVCC。</p>
<h2 id="PL：Two-Phase-Locking"><a href="#PL：Two-Phase-Locking" class="headerlink" title="PL：Two-Phase Locking"></a>PL：Two-Phase Locking</h2><p>传统RDBMS（关系数据库管理系统）加锁的一个原则，就是2PL (二阶段锁)：Two-Phase Locking。相对而言，2PL比较容易理解，说的是锁操作分为两个阶段：<strong>加锁阶段与解锁阶段</strong>，并且保证加锁阶段与解锁阶段不相交。下面，仍旧以MySQL为例，来简单看看2PL在MySQL中的实现。</p>
<table>
<thead>
<tr>
<th align="center">transaction</th>
<th align="center">mysql</th>
</tr>
</thead>
<tbody><tr>
<td align="center">begin;</td>
<td align="center">加锁阶段</td>
</tr>
<tr>
<td align="center">insert into</td>
<td align="center">加insert对应的锁</td>
</tr>
<tr>
<td align="center">update table</td>
<td align="center">加update对应的锁</td>
</tr>
<tr>
<td align="center">delete from</td>
<td align="center">加delete对应的锁</td>
</tr>
<tr>
<td align="center">commit</td>
<td align="center">解锁阶段</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">将insert、update、delete的锁全部解开</td>
</tr>
</tbody></table>
<p>上面的例子可以看出2PL就是将加锁、解锁分为两个阶段，并且互相不干扰。加锁阶段只加锁，解锁阶段只解锁。</p>
<h2 id="为什么会发生死锁"><a href="#为什么会发生死锁" class="headerlink" title="为什么会发生死锁"></a>为什么会发生死锁</h2><p>MyISAM中是不会产生死锁的，因为MyISAM总是一次性获得所需的全部锁，要么全部满足，要么全部等待。而在InnoDB中，锁是逐步获得的，就造成了死锁的可能。（不过现在一般都是InnoDB引擎，关于MyISAM不做考虑）</p>
<p>在InnoDB中，行级锁并不是直接锁记录，而是锁索引。索引分为主键索引和非主键索引两种，如果一条sql语句操作了主键索引，MySQL就会锁定这条主键索引；如果一条语句操作了非主键索引，MySQL会先锁定该非主键索引，再锁定相关的主键索引。</p>
<p>当两个事务同时执行，一个锁住了主键索引，在等待其他相关索引。另一个锁定了非主键索引，在等待主键索引。这样就会发生死锁。</p>
<p>通过两个SQL死锁的例子来说明</p>
<ol>
<li><strong>两个session的两条语句</strong></li>
</ol>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/20190406184514611.jpg" alt="img"></p>
<p>这种情况很好理解，首先session1获得 id&#x3D;1的锁 session2获得id&#x3D;5的锁，然后session想要获取id&#x3D;5的锁 等待，session2想要获取id&#x3D;1的锁 ，也等待！</p>
<ol start="2">
<li><strong>两个session的一条语句</strong></li>
</ol>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/20190406184524757.jpg" alt="img"></p>
<p>这种情况需要我们了解<strong>数据的索引的检索顺序</strong>原理简单说下：<strong>普通索引上面保存了主键索引，当我们使用普通索引检索数据时，如果所需的信息不够，那么会继续遍历主键索引。</strong></p>
<p>假设默认情况是RR隔离级别，针对session 1 从name索引出发，检索到的是（hdc,1）（hdc,6）不仅会加name索引上的记录X锁，而且会加聚簇索引上的记录X锁，加锁顺序为先[1,hdc,100]，后[6,hdc,10] 这个顺序是因为B+树结构的有序性。而Session 2，从pubtime索引出发，[10,6],[100,1]均满足过滤条件，同样也会加聚簇索引上的记录X锁，加锁顺序为[6,hdc,10]，后[1,hdc,100]。发现没有，跟Session 1的加锁顺序正好相反，如果两个Session恰好都持有了第一把锁，请求加第二把锁，死锁就发生了。</p>
<p><strong>避免死锁，这里只介绍常见的三种</strong></p>
<ol>
<li>如果不同程序会并发存取多个表，尽量约定以相同的顺序访问表，可以大大降低死锁机会。</li>
<li>在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁产生概率；</li>
<li>对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过表级锁定来减少死锁产生的概率；</li>
</ol>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-数据库：mysql基础"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
	
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/08/02/%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%9Amysql%E5%9F%BA%E7%A1%80/"
    >mysql基础</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/08/02/%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%9Amysql%E5%9F%BA%E7%A1%80/" class="article-date">
  <time datetime="2022-08-02T08:05:11.000Z" itemprop="datePublished">2022-08-02</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a> / <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/">mysql</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="1-mysql简介"><a href="#1-mysql简介" class="headerlink" title="1. mysql简介"></a>1. mysql简介</h1><ul>
<li><p>MySQL是一个<strong>关系型数据库管理系统</strong></p>
</li>
<li><p>由瑞典MySQL AB 公司开发，属于 <a target="_blank" rel="noopener" href="https://baike.baidu.com/item/Oracle">Oracle</a> 旗下产品</p>
</li>
<li><p>Mysql是一个<strong>开源免费的</strong>关系型数据库管理系统</p>
</li>
<li><p>mysql分为社区办和企业版</p>
</li>
<li><p>我们学习的是社区版</p>
</li>
</ul>
<hr>
<h1 id="2-关系型数据库"><a href="#2-关系型数据库" class="headerlink" title="2. 关系型数据库"></a>2. 关系型数据库</h1><p>建立在关系模型基础上的数据库,借助数学中的集合代数等一些数学概念和方法,处理关系型数据库中的数据</p>
<hr>
<h1 id="3-Mysql的安装"><a href="#3-Mysql的安装" class="headerlink" title="3. Mysql的安装"></a>3. Mysql的安装</h1><ul>
<li>windows的安装</li>
<li>Linux的安装</li>
</ul>
<hr>
<h1 id="4-Mysql默认的字符集的配置-了解"><a href="#4-Mysql默认的字符集的配置-了解" class="headerlink" title="4. Mysql默认的字符集的配置(了解)"></a>4. Mysql默认的字符集的配置(了解)</h1><p>以windows中的mysql的配置为例:</p>
<ul>
<li><p>找到mysql的存放配置文件的地方 <code>C:\ProgramData\MySQL\MySQL Server 5.6/my.ini</code></p>
</li>
<li><p>修改</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">character-set-server=utf8</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>但是: <strong>我们完全不建议这样修改</strong>,因为我们每个项目系统使用的数据库编码完全有可能不一样;</p>
</blockquote>
<hr>
<h1 id="5-启动和停止mysql的服务"><a href="#5-启动和停止mysql的服务" class="headerlink" title="5. 启动和停止mysql的服务"></a>5. 启动和停止mysql的服务</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net start mysql</span><br><span class="line">net stop mysql</span><br></pre></td></tr></table></figure>

<p>注意: 如果命令显式不可用代表操作系统的版本不支持(家庭版)</p>
<hr>
<h1 id="6-mysql的登录命令"><a href="#6-mysql的登录命令" class="headerlink" title="6. mysql的登录命令"></a>6. mysql的登录命令</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql <span class="operator">-</span>u用户名  <span class="operator">-</span>p密码 </span><br><span class="line">	<span class="operator">-</span>h: 默认为localhost</span><br><span class="line">	<span class="operator">-</span>P: 默认<span class="number">3306</span></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="7-mysql常用的系统命令"><a href="#7-mysql常用的系统命令" class="headerlink" title="7. mysql常用的系统命令"></a>7. mysql常用的系统命令</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看mysql的版本</span></span><br><span class="line">SELECT VERSION();</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看mysql当前登录的用户</span></span><br><span class="line">select user();</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看mysql的当前日期</span></span><br><span class="line">select now();</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看当前所在的数据库</span></span><br><span class="line">select database();</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="8-mysql的语句规范"><a href="#8-mysql的语句规范" class="headerlink" title="8. mysql的语句规范"></a>8. mysql的语句规范</h1><ul>
<li>关键字和函数名建议大写</li>
<li>数据库的名称,表的名称,字段的名称建议小写</li>
<li>数据库 表名 字段名建议加上&#96;&#96;</li>
<li>sql语句的<strong>定界符</strong>默认以; 结尾</li>
</ul>
<hr>
<h1 id="9-数据库的操作SQL类型-了解"><a href="#9-数据库的操作SQL类型-了解" class="headerlink" title="9. 数据库的操作SQL类型(了解)"></a>9. 数据库的操作SQL类型(了解)</h1><ul>
<li><p><strong>DDL</strong>(数据定义语言)(Data Defination Language)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE/VIEW/INDEX;</span><br><span class="line">DROP DATABASE;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>DML</strong>(数据操纵语言)(Data Manipulation Language)</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>) 插入：<span class="keyword">INSERT</span></span><br><span class="line"><span class="number">2</span>) 更新：<span class="keyword">UPDATE</span></span><br><span class="line"><span class="number">3</span>) 删除：<span class="keyword">DELETE</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>DQL</strong>(数据查询语言)(Data Query Language)</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DQL基本结构是由<span class="keyword">SELECT</span>子句，<span class="keyword">FROM</span>子句，<span class="keyword">WHERE</span></span><br><span class="line">子句组成的查询块：</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">&lt;</span>字段名表<span class="operator">&gt;</span></span><br><span class="line">	<span class="keyword">FROM</span> <span class="operator">&lt;</span>表或视图名<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="operator">&lt;</span>查询条件<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
</li>
<li><p><strong>DCL</strong>(数据控制语言)(Data Control Language) </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">用来定义安全级别和访问权限的</span><br><span class="line">常用的关键字：grant   revoke </span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="10-mysql中的概念"><a href="#10-mysql中的概念" class="headerlink" title="10. mysql中的概念"></a>10. mysql中的概念</h1><ul>
<li>数据库管理系统: 管理数据库的系统</li>
<li>数据库: 数组库是用来存放和组织<code>表</code>的</li>
<li>表:是存储数据的<strong>容器</strong>  </li>
<li>记录: 一行的数据</li>
<li>属性: 一列属性值</li>
</ul>
<hr>
<h1 id="11-数据库的操作-必会"><a href="#11-数据库的操作-必会" class="headerlink" title="11. 数据库的操作(必会)"></a>11. 数据库的操作(必会)</h1><ul>
<li>创建数据库</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE `db2`; #最简单的方式创建一个数据库</span><br></pre></td></tr></table></figure>

<p>注意: 数据库的名称可以加 &#96;&#96; ,也可以不加,默认mysql会给你自动加上</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE db2;  #可以省略``</span><br></pre></td></tr></table></figure>

<ul>
<li>带判断的创建数据库</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `db1`; #如果不存在db1这个数据库则创建db1数据库,如果存在则不会创建但是也不会报错</span><br></pre></td></tr></table></figure>

<ul>
<li>创建数据库并且指定字符集</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#mysql默认的字符集是latin1,latin1不支持中文</span><br><span class="line"><span class="keyword">CREATE</span> DATABASE IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `db3` <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>UTF8MB4;</span><br></pre></td></tr></table></figure>

<ul>
<li>删除数据库</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#删除数据库,如果数据库不存在则会报错</span><br><span class="line"><span class="keyword">DROP</span> DATABASE `db1`;</span><br><span class="line">#带判断的删除数据库</span><br><span class="line"><span class="keyword">DROP</span> DATABASE IF <span class="keyword">EXISTS</span> `db1`</span><br></pre></td></tr></table></figure>

<ul>
<li>查询数据库</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#查询数据库的创建信息</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> DATABASE `db3`;</span><br><span class="line">#查询当前RDBMS中有哪些数据库</span><br><span class="line"><span class="keyword">SHOW</span> DATABASES;</span><br><span class="line">#查询当前所在的数据库</span><br><span class="line"><span class="keyword">SELECT</span> DATABASE();</span><br></pre></td></tr></table></figure>

<ul>
<li>进入数据库</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">USE <span class="string">&#x27;db1&#x27;</span>;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="12-mysql中的数据类型"><a href="#12-mysql中的数据类型" class="headerlink" title="12. mysql中的数据类型"></a>12. mysql中的数据类型</h1><h2 id="12-1-整型"><a href="#12-1-整型" class="headerlink" title="12.1 整型"></a>12.1 整型</h2><table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">范围</th>
<th align="center">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>tinyint</strong></td>
<td align="center"><strong>1个字节 范围(-128<del>127)||0</del>255(无符号)</strong></td>
<td align="center"><strong>与java中的byte类型对应</strong></td>
</tr>
<tr>
<td align="center"><strong>smallint</strong></td>
<td align="center"><strong>2个字节 范围(-32768~32767|| 0 ~ 65535(无符号))</strong></td>
<td align="center"><strong>与java中的short对应</strong></td>
</tr>
<tr>
<td align="center">mediumint</td>
<td align="center">3 个字节, -8388608 to 8388607||0 to 16777215(无符号)</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><strong>int:Integer</strong></td>
<td align="center">4 个字节, -2147483648 to 2147483647||0 to 4294967295(无符号)</td>
<td align="center">与Java中的int类型对应</td>
</tr>
<tr>
<td align="center"><strong>bigint</strong></td>
<td align="center">8 个字节, -9223372036854775808 to 922337203685477580||0 to 18446744073709551615(无符号)</td>
<td align="center"><strong>与java中的long对应</strong></td>
</tr>
</tbody></table>
<hr>
<h2 id="12-2-浮点型"><a href="#12-2-浮点型" class="headerlink" title="12.2 浮点型"></a>12.2 浮点型</h2><table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">范围</th>
<th align="center">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="center">float(m,d)</td>
<td align="center">单精度浮点型  8位精度(4字节)   m总个数，d小数位</td>
<td align="center">与java的float对应</td>
</tr>
<tr>
<td align="center">double(m,d)</td>
<td align="center">双精度浮点型  16位精度(8字节)   m总个数，d小数位</td>
<td align="center">与java的double对应</td>
</tr>
</tbody></table>
<p>注意: 在实际开发过程中设计数据库时&#x3D;&#x3D;一定一定一定&#x3D;&#x3D;,<strong>涉及到小数的不要使用FLOAT和DOUBLE类型</strong></p>
<hr>
<h2 id="12-3-定点"><a href="#12-3-定点" class="headerlink" title="12.3 定点"></a>12.3 定点</h2><p>浮点型在数据库中存放的是近似值，而定点类型在数据库中存放的是精确值</p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">范围</th>
<th align="center">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>decimal(m,d)</strong></td>
<td align="center">参数m&lt;65 是总个数，d&lt;30且 d&lt;m 是小数位</td>
<td align="center">表示金额等精确值</td>
</tr>
</tbody></table>
<p>注意: Decimal这个类型如果Insert的数据比我们预设的d的长度大,也会进行四舍五入;  一般存储小数都会使用DECIMAL类型,<strong>不会丢失精度</strong></p>
<hr>
<h2 id="12-4-字符串"><a href="#12-4-字符串" class="headerlink" title="12.4 字符串"></a>12.4 字符串</h2><table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">范围</th>
<th align="center">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>char(n)</strong></td>
<td align="center"><strong>固定长度，最多255个</strong></td>
<td align="center">定长字符串,n 范围(0,255)， 如果不是定长的数据，n&lt;&#x3D;4 时才使用</td>
</tr>
<tr>
<td align="center"><strong>varchar(n)</strong></td>
<td align="center"><strong>变长字符串，最多65532个字符</strong></td>
<td align="center">变长字符串，65532&gt;n&gt;4, 注意，n 是字符数，而不是字节数</td>
</tr>
<tr>
<td align="center">tinytext</td>
<td align="center">存储 L+1 个字节，其中 L &lt; 2^8</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><strong>text</strong></td>
<td align="center">存储 L+2 个字节，其中 L &lt; 2^16</td>
<td align="center">存储文本的</td>
</tr>
<tr>
<td align="center">mediumtext</td>
<td align="center">存储 L+3 个字节，其中 L &lt; 2^24</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">longtext</td>
<td align="center">存储 L+4 个字节，其中 L &lt; 2^32</td>
<td align="center"></td>
</tr>
</tbody></table>
<h2 id="12-5-Blob二进制类型"><a href="#12-5-Blob二进制类型" class="headerlink" title="12.5 Blob二进制类型"></a>12.5 Blob二进制类型</h2><ul>
<li><p>BLOB和text存储方式不同，TEXT以文本方式存储，英文存储区分大小写，而Blob是以二进制方式存储，不分大小写。</p>
</li>
<li><p>BLOB存储的数据只能整体读出。 </p>
</li>
<li><p>TEXT可以指定字符集，BLOB不用指定字符集。</p>
</li>
</ul>
<hr>
<h2 id="12-6-日期时间类型"><a href="#12-6-日期时间类型" class="headerlink" title="12.6 日期时间类型"></a>12.6 日期时间类型</h2><table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="center">date</td>
<td align="center">日期 ‘2008-12-2’</td>
</tr>
<tr>
<td align="center">time</td>
<td align="center">时间 ‘12:25:36’</td>
</tr>
<tr>
<td align="center">datetime</td>
<td align="center">日期时间 ‘2008-12-2 22:06:44’</td>
</tr>
<tr>
<td align="center">timestamp</td>
<td align="center">自动存储记录修改时间</td>
</tr>
</tbody></table>
<hr>
<h1 id="13-mysql中数据类型属性-约束-CONSTRAINT"><a href="#13-mysql中数据类型属性-约束-CONSTRAINT" class="headerlink" title="13. mysql中数据类型属性(约束-CONSTRAINT)"></a>13. mysql中数据类型属性(约束-CONSTRAINT)</h1><table>
<thead>
<tr>
<th align="center">MySQL关键字</th>
<th align="center">含义</th>
<th align="center">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>NULL</strong></td>
<td align="center">数据列可包含NULL值</td>
<td align="center">mysql默认不指定约束,字段也不添加值,默认为NULL</td>
</tr>
<tr>
<td align="center"><strong>NOT NULL</strong></td>
<td align="center">数据列不允许包含NULL值</td>
<td align="center">非空约束</td>
</tr>
<tr>
<td align="center"><strong>DEFAULT</strong></td>
<td align="center">默认值</td>
<td align="center">默认值约束</td>
</tr>
<tr>
<td align="center"><strong>PRIMARY KEY</strong></td>
<td align="center">主键</td>
<td align="center">主键约束 &#x3D; 非空约束+唯一约束</td>
</tr>
<tr>
<td align="center"><strong>AUTO_INCREMENT</strong></td>
<td align="center">自动递增，适用于整数类型</td>
<td align="center">自增(一般和<strong>数值类型的主键</strong>联合使用)</td>
</tr>
<tr>
<td align="center"><strong>UNSIGNED</strong></td>
<td align="center">无符号</td>
<td align="center">保留正数部分</td>
</tr>
<tr>
<td align="center"><strong>UNIQUE</strong></td>
<td align="center">唯一约束</td>
<td align="center">此字段的值不能重复</td>
</tr>
</tbody></table>
<hr>
<ul>
<li><p>作用</p>
<ul>
<li>保证用户输入的数据存储到数据库中是正确的，准确的。</li>
<li>可以防止一些可能的输入错误。</li>
<li>如何使用<strong>完整性</strong>来保证存储到数据库中的数据是正确的准确的，需要在创建表的时候给表添加约束</li>
</ul>
</li>
<li><p>分类</p>
<ul>
<li>实体完整性</li>
<li>域完整性</li>
<li>引用完整性</li>
</ul>
</li>
</ul>
<h1 id="14-表的操作"><a href="#14-表的操作" class="headerlink" title="14. 表的操作"></a>14. 表的操作</h1><p>数据表是数据库的最重要的组成部分之一,是其他对象的基础;</p>
<h2 id="14-1-查看数据库中的所有的表"><a href="#14-1-查看数据库中的所有的表" class="headerlink" title="14.1 查看数据库中的所有的表"></a>14.1 查看数据库中的所有的表</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW TABLES;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="14-2-创建表"><a href="#14-2-创建表" class="headerlink" title="14.2 创建表"></a>14.2 创建表</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `<span class="keyword">user</span>`(id <span class="type">int</span>,name <span class="type">char</span>(<span class="number">32</span>),age tinyint);</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 带条件的创建表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `<span class="keyword">user</span>`(id <span class="type">int</span>,name <span class="type">char</span>(<span class="number">32</span>),age tinyint);</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建表时指定字符集,如果不指定默认使用的是数据库的字符集</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `<span class="keyword">user</span>`(id <span class="type">int</span>,name <span class="type">char</span>(<span class="number">32</span>),age tinyint) <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>UTF8;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看表结构</span></span><br><span class="line"><span class="keyword">DESCRIBE</span> `<span class="keyword">user</span>`;</span><br><span class="line"><span class="keyword">DESC</span> `<span class="keyword">user</span>`;  #简写</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="14-3-删除表"><a href="#14-3-删除表" class="headerlink" title="14.3 删除表"></a>14.3 删除表</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 删除表</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> `<span class="keyword">user</span>`;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 带判断的删除</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `<span class="keyword">user</span>`;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="14-4-修改表结构"><a href="#14-4-修改表结构" class="headerlink" title="14.4 修改表结构"></a>14.4 修改表结构</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 添加列</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> `<span class="keyword">member</span>` <span class="keyword">ADD</span> <span class="keyword">COLUMN</span> sex <span class="type">CHAR</span>(<span class="number">1</span>);</span><br><span class="line"><span class="comment">-- COLUMN关键字可以省略</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> `<span class="keyword">member</span>` <span class="keyword">ADD</span>  sex <span class="type">CHAR</span>(<span class="number">1</span>);  </span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 删除列	</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="keyword">member</span> <span class="keyword">DROP</span> <span class="keyword">COLUMN</span>  city;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="keyword">member</span> <span class="keyword">DROP</span>  city;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询列</span></span><br><span class="line"><span class="keyword">DESC</span> <span class="keyword">member</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- MODIFY只能修改列的属性 不能修改名字</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="keyword">member</span> MODIFY age <span class="type">SMALLINT</span>;</span><br><span class="line"><span class="comment">-- CHANGE 既能修改列的名称也能修改列的属性</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="keyword">member</span> CHANGE sex sex1 <span class="type">VARCHAR</span>(<span class="number">10</span>)</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="15-记录-数据-的操作"><a href="#15-记录-数据-的操作" class="headerlink" title="15. 记录(数据)的操作"></a>15. 记录(数据)的操作</h1><h2 id="15-1-添加数据"><a href="#15-1-添加数据" class="headerlink" title="15.1 添加数据"></a>15.1 添加数据</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 给表插入一条数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">member</span>(id,nick_name,age,sex) <span class="keyword">VALUES</span>(<span class="number">1</span>,<span class="string">&#x27;小明&#x27;</span>,<span class="number">12</span>,<span class="string">&#x27;男&#x27;</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 批量插入数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">member</span>(id,nick_name,age,sex) <span class="keyword">VALUES</span>(<span class="number">4</span>,&quot;小短腿&quot;,<span class="number">10</span>,<span class="string">&#x27;男&#x27;</span>),(<span class="number">5</span>,<span class="string">&#x27;大胖&#x27;</span>,<span class="number">30</span>,<span class="string">&#x27;男&#x27;</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 骚操作(不指定字段全量插入)----&gt;一般不建议使用全量插入数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">member</span> <span class="keyword">VALUES</span>(<span class="keyword">NULL</span>,<span class="string">&#x27;小明&#x27;</span>,<span class="number">20</span>);</span><br><span class="line">或者</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">member</span> <span class="keyword">VALUES</span>(<span class="keyword">DEFAULT</span>,<span class="string">&#x27;小明&#x27;</span>,<span class="number">20</span>);</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="15-2-查询数据-简单查询"><a href="#15-2-查询数据-简单查询" class="headerlink" title="15.2 查询数据(简单查询)"></a>15.2 查询数据(简单查询)</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 最简单的查询语句</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">member</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询指定的字段</span></span><br><span class="line"><span class="keyword">SELECT</span> nick_name <span class="keyword">FROM</span> <span class="keyword">member</span>;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="15-3-修改数据"><a href="#15-3-修改数据" class="headerlink" title="15.3 修改数据"></a>15.3 修改数据</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 修改数据</span></span><br><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">member</span> <span class="keyword">SET</span> nick_name<span class="operator">=</span><span class="string">&#x27;小胖子&#x27;</span> <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="15-4-删除数据"><a href="#15-4-删除数据" class="headerlink" title="15.4 删除数据"></a>15.4 删除数据</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 删除数据</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> <span class="keyword">member</span> <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">2</span>;                               </span><br></pre></td></tr></table></figure>

<hr>
<h1 id="16-表和表之间关系"><a href="#16-表和表之间关系" class="headerlink" title="16. 表和表之间关系"></a>16. 表和表之间关系</h1><h2 id="16-1-一对一的关系"><a href="#16-1-一对一的关系" class="headerlink" title="16.1 一对一的关系"></a>16.1 一对一的关系</h2><p>例如: 一个会员表中的一条记录只对应我们身份证表中的一条记录</p>
<ul>
<li><p>我们如果设计数据库时出现了一对一的表应该尽量避免;我们只需要给字段多的一方的表<strong>添加额外的字段即可</strong></p>
</li>
<li><p>如果我们设计的时候**无法避免(考虑的优化为题)**一对一的设计,我们需要让两个表的主键进行对应</p>
</li>
<li><p>如果一个表中的字段的个数超过16个,<strong>强烈建议</strong>使用一对一的表的设计</p>
</li>
</ul>
<hr>
<h2 id="16-2-一对多的关系"><a href="#16-2-一对多的关系" class="headerlink" title="16.2 一对多的关系"></a>16.2 一对多的关系</h2><p>例如: 一个会员对应多个订单,而一个订单只对应一个会员(会员表和订单表)</p>
<ul>
<li><p><strong>子表</strong>：订单表</p>
</li>
<li><p>在多的一方的表(订单表)加一个字段<strong>对应一的一方的表中的主键</strong>,数据类型要保持一致</p>
</li>
<li><p>而且我们根据墨菲定律,还可以为其加一个约束条件(<strong>外键(FOREIGN KEY)</strong>)</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 在表创建之后添加外键</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 在多的一方的表中添加了一个字段</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> orders <span class="keyword">ADD</span> <span class="keyword">COLUMN</span> m_id <span class="type">INT</span> ;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 添加外键约束</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> orders <span class="keyword">ADD</span> <span class="keyword">FOREIGN</span> KEY orders(m_id)  <span class="keyword">REFERENCES</span> <span class="keyword">member</span>(id);</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> orders <span class="keyword">ADD</span> <span class="keyword">FOREIGN</span> KEY(m_id)  <span class="keyword">REFERENCES</span> <span class="keyword">member</span>(id);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 可以指定外键的名称</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> orders <span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> ifbk_orders_mid_merber <span class="keyword">FOREIGN</span> KEY(m_id)  <span class="keyword">REFERENCES</span> <span class="keyword">member</span>(id);</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建表的时候直接添加外键</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> orders(</span><br><span class="line">	id <span class="type">INT</span>  AUTO_INCREMENT COMMENT <span class="string">&#x27;订单ID&#x27;</span>,</span><br><span class="line">	number <span class="type">VARCHAR</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;订单编号&#x27;</span>,</span><br><span class="line">	address <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;订单的发货地址&#x27;</span>,</span><br><span class="line">	m_id <span class="type">INT</span>,	</span><br><span class="line">	<span class="keyword">PRIMARY</span> KEY(id),</span><br><span class="line">	<span class="keyword">FOREIGN</span> KEY(m_id) <span class="keyword">REFERENCES</span> <span class="keyword">member</span>(id)</span><br><span class="line">) COMMENT <span class="string">&#x27;订单表&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>注意:</strong></p>
<ul>
<li>创建一对多的表的时候,首先要创建一方对应的那个表</li>
<li><code>REFERENCES</code>：<strong>指定外键依赖的表及对应的列</strong>，并且该列为该表的主键</li>
<li>我们为了数据的安全性,我们会把<strong>多方中的参照的字段设置为外键,而且类型要和一方中的主键保持一致</strong></li>
<li><strong>一般我们在商业项目中,尽量不要使用外键(等会解释)</strong></li>
</ul>
<hr>
<h2 id="16-3-多对多的关系"><a href="#16-3-多对多的关系" class="headerlink" title="16.3 多对多的关系"></a>16.3 多对多的关系</h2><blockquote>
<p>思想: 借助一个额外的表,实现多对多关系</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建商品表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> shop(</span><br><span class="line">	id <span class="type">INT</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;主键&#x27;</span>,</span><br><span class="line">	shop_name <span class="type">VARCHAR</span>(<span class="number">255</span>) COMMENT <span class="string">&#x27;商品名称&#x27;</span>,</span><br><span class="line">	stock <span class="type">INT</span> UNSIGNED COMMENT <span class="string">&#x27;商品库存&#x27;</span>,</span><br><span class="line">	<span class="keyword">PRIMARY</span> KEY(id)</span><br><span class="line">) COMMENT <span class="string">&#x27;商品表&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> member_shop;</span><br><span class="line"><span class="comment">-- 创建第三方的表(member_shop)</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>  member_shop(</span><br><span class="line">	m_id <span class="type">INT</span> COMMENT <span class="string">&#x27;参照member中的id&#x27;</span>,</span><br><span class="line">	s_id <span class="type">INT</span> COMMENT <span class="string">&#x27;参照shop中的id&#x27;</span>,</span><br><span class="line">	<span class="keyword">FOREIGN</span> KEY(m_id) <span class="keyword">REFERENCES</span> <span class="keyword">member</span>(id),</span><br><span class="line">	<span class="keyword">FOREIGN</span> KEY(s_id) <span class="keyword">REFERENCES</span> shop(id)</span><br><span class="line">) ENGINE<span class="operator">=</span>INNODB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 COMMENT <span class="string">&#x27;第三方的表&#x27;</span>;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="17-mysql的多字段查询"><a href="#17-mysql的多字段查询" class="headerlink" title="17. mysql的多字段查询"></a>17. mysql的多字段查询</h1><blockquote>
<p>select * 这种方式不建议使用,我们只查询需要的字段,select * 这种方式对性能有影响</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询多个字段</span></span><br><span class="line"><span class="keyword">SELECT</span> nick_name,age <span class="keyword">FROM</span> <span class="keyword">member</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询字段并且指定字段的别名</span></span><br><span class="line"><span class="keyword">SELECT</span> nick_name <span class="keyword">AS</span> nname,age <span class="keyword">FROM</span> <span class="keyword">member</span>;</span><br><span class="line"><span class="keyword">SELECT</span> nick_name  nname,age <span class="keyword">FROM</span> <span class="keyword">member</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 这才是一条完整的sql语句,我们在实际的开发中不会写这个多的东西,会省略一些东西(库名,字段的别名,表的别名...),sql的执行引擎会帮我们进行词法和语法的补全</span></span><br><span class="line"><span class="keyword">SELECT</span> db3.member.nick_name <span class="keyword">AS</span> nick_name,db3.member.age <span class="keyword">AS</span> age <span class="keyword">FROM</span> db3.member <span class="keyword">AS</span> <span class="keyword">member</span>;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="18-mysql中的排序"><a href="#18-mysql中的排序" class="headerlink" title="18. mysql中的排序"></a>18. mysql中的排序</h1><blockquote>
<p>ORDER BY col_name ASC|DESC</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 不指定任何的排序字段的情况下,默认是按主键的升序排列的</span></span><br><span class="line"><span class="keyword">SELECT</span> id,nick_name,age <span class="keyword">FROM</span> <span class="keyword">member</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 指定按age来排序(默认是升序)</span></span><br><span class="line"><span class="keyword">SELECT</span> id,nick_name,age <span class="keyword">FROM</span> <span class="keyword">member</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> age ;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 指定按age的降序进行排序</span></span><br><span class="line"><span class="keyword">SELECT</span> id,nick_name,age <span class="keyword">FROM</span> <span class="keyword">member</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> age <span class="keyword">DESC</span> ;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="19-mysql中的分组查询"><a href="#19-mysql中的分组查询" class="headerlink" title="19. mysql中的分组查询"></a>19. mysql中的分组查询</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建学生表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> student(</span><br><span class="line">    id <span class="type">INT</span> AUTO_INCREMENT,</span><br><span class="line">    sname <span class="type">VARCHAR</span>(<span class="number">64</span>),</span><br><span class="line">    age TINYINT UNSIGNED,</span><br><span class="line">    grade <span class="type">VARCHAR</span>(<span class="number">32</span>),</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY(id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询grade字段不为NULL的总记录数</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(grade) <span class="keyword">FROM</span> student ;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询每个班级及其班级的总人数</span></span><br><span class="line"><span class="keyword">SELECT</span> grade, <span class="built_in">COUNT</span>(grade) <span class="keyword">FROM</span> student <span class="keyword">GROUP</span> <span class="keyword">BY</span>(grade);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- HAVING 是对分组后的数据进行条件过滤</span></span><br><span class="line"><span class="keyword">SELECT</span> grade, <span class="built_in">COUNT</span>(grade) <span class="keyword">FROM</span> student <span class="keyword">GROUP</span> <span class="keyword">BY</span>(grade) <span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(grade)<span class="operator">&gt;</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询年龄age&gt;25的,班级及其班级里面的人数  WHERE 是对分组之前的数据进行筛选</span></span><br><span class="line"><span class="keyword">SELECT</span> grade,<span class="built_in">COUNT</span>(grade) <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age<span class="operator">&gt;</span><span class="number">25</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span>(grade) ;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询年龄age&gt;25的,班级人数&gt;1的,班级及其班级里面的人数</span></span><br><span class="line"><span class="keyword">SELECT</span> grade,<span class="built_in">COUNT</span>(grade) <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age<span class="operator">&gt;</span><span class="number">25</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span>(grade) <span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(grade)<span class="operator">&gt;</span><span class="number">1</span> ;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="20-mysql中的分页查询"><a href="#20-mysql中的分页查询" class="headerlink" title="20. mysql中的分页查询"></a>20. mysql中的分页查询</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">limit</span><br><span class="line"><span class="comment">-- 用来限定查询结果的起始行和总行数的。</span></span><br><span class="line"><span class="comment">-- 用来实现分页查询</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">ORDER</span> <span class="keyword">BY</span> id LIMIT <span class="number">0</span>,<span class="number">3</span>;</span><br><span class="line"><span class="comment">-- 0表示从第一条数据开始，3表示查询3条数据</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">ORDER</span> <span class="keyword">BY</span> id LIMIT <span class="number">3</span>,<span class="number">3</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">ORDER</span> <span class="keyword">BY</span> id LIMIT <span class="number">6</span>,<span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<h1 id="21-查询小结"><a href="#21-查询小结" class="headerlink" title="21. 查询小结"></a>21. 查询小结</h1><p><strong>基本查询语句的书写顺序和执行顺序</strong></p>
<ul>
<li><p>书写顺序：</p>
<p><code>select-from-where-group by-having-order by-limit;</code></p>
</li>
<li><p>执行顺序：</p>
<p><code>from-where-group by-having-select-order by-limit;</code></p>
</li>
</ul>
<h1 id="22-AND和OR"><a href="#22-AND和OR" class="headerlink" title="22. AND和OR"></a>22. AND和OR</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- and代表两个添加都成立</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">member</span> <span class="keyword">WHERE</span>  age<span class="operator">&gt;</span><span class="number">25</span> <span class="keyword">AND</span> sex<span class="operator">=</span><span class="string">&#x27;女&#x27;</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- or其中只要有一个成立则查出来</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">member</span> <span class="keyword">WHERE</span>  age<span class="operator">&gt;</span><span class="number">25</span> <span class="keyword">OR</span> sex<span class="operator">=</span><span class="string">&#x27;女&#x27;</span> </span><br></pre></td></tr></table></figure>

<hr>
<h1 id="23-IN和NOT-IN"><a href="#23-IN和NOT-IN" class="headerlink" title="23. IN和NOT IN"></a>23. IN和NOT IN</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 多个OR连接并不是很方便</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">member</span> <span class="keyword">WHERE</span> age <span class="operator">=</span> <span class="number">30</span> <span class="keyword">OR</span> age<span class="operator">=</span><span class="number">40</span> <span class="keyword">OR</span> age<span class="operator">=</span><span class="number">50</span> <span class="keyword">OR</span> age<span class="operator">=</span><span class="number">45</span> ;</span><br><span class="line"><span class="comment">-- 使用IN进行匹配,达到上面OR的效果</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">member</span> <span class="keyword">WHERE</span> age <span class="keyword">IN</span>(<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>,<span class="number">45</span>) ;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 多个AND连接不方便</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">member</span> <span class="keyword">WHERE</span> age <span class="operator">!=</span> <span class="number">30</span> <span class="keyword">AND</span> age<span class="operator">!=</span><span class="number">40</span> <span class="keyword">AND</span> age<span class="operator">!=</span><span class="number">50</span> <span class="keyword">AND</span> age<span class="operator">!=</span><span class="number">45</span> ;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">member</span> <span class="keyword">WHERE</span> age <span class="keyword">NOT</span> <span class="keyword">IN</span>(<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>,<span class="number">45</span>) ;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="24-BETWEEN…AND"><a href="#24-BETWEEN…AND" class="headerlink" title="24. BETWEEN…AND"></a>24. BETWEEN…AND</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询指定区域内的数据</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">member</span> <span class="keyword">WHERE</span> age<span class="operator">&gt;=</span><span class="number">30</span> <span class="keyword">AND</span> age<span class="operator">&lt;=</span><span class="number">40</span></span><br><span class="line"><span class="comment">-- 也可以使用BETWEEN...and来代替</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">member</span> <span class="keyword">WHERE</span> age <span class="keyword">BETWEEN</span> <span class="number">30</span> <span class="keyword">AND</span> <span class="number">40</span>;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="23-NOT-BETWEEN…AND"><a href="#23-NOT-BETWEEN…AND" class="headerlink" title="23. NOT BETWEEN…AND"></a>23. NOT BETWEEN…AND</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">member</span> <span class="keyword">WHERE</span> age<span class="operator">&lt;</span><span class="number">30</span> <span class="keyword">OR</span> age<span class="operator">&gt;</span><span class="number">40</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">member</span> <span class="keyword">WHERE</span> age <span class="keyword">NOT</span> <span class="keyword">BETWEEN</span> <span class="number">30</span> <span class="keyword">AND</span> <span class="number">40</span>;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="26-mysql的子查询"><a href="#26-mysql的子查询" class="headerlink" title="26. mysql的子查询"></a>26. mysql的子查询</h1><p>把一个查询的结果当成另一个查询的条件进行使用</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询小花购买过的全部的商品</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">  <span class="operator">*</span> </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">  member_shop </span><br><span class="line"><span class="keyword">WHERE</span> m_id <span class="operator">=</span> </span><br><span class="line">  (<span class="keyword">SELECT</span> </span><br><span class="line">    id</span><br><span class="line">  <span class="keyword">FROM</span></span><br><span class="line">    <span class="keyword">member</span> </span><br><span class="line">  <span class="keyword">WHERE</span> nick_name <span class="operator">=</span> <span class="string">&#x27;小花&#x27;</span>)</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="27-多表查询"><a href="#27-多表查询" class="headerlink" title="27. 多表查询"></a>27. 多表查询</h1><h2 id="合并结果集"><a href="#合并结果集" class="headerlink" title="合并结果集"></a>合并结果集</h2><ul>
<li><p><strong>去重：union</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> aa(</span><br><span class="line">	id <span class="type">INT</span>,</span><br><span class="line">	NAME <span class="type">VARCHAR</span>(<span class="number">10</span>)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> aa <span class="keyword">VALUES</span>(<span class="number">1</span>,<span class="string">&#x27;aaa&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> aa <span class="keyword">VALUES</span>(<span class="number">2</span>,<span class="string">&#x27;bbb&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> aa <span class="keyword">VALUES</span>(<span class="number">3</span>,<span class="string">&#x27;ccc&#x27;</span>);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> bb(</span><br><span class="line">	id <span class="type">INT</span>,</span><br><span class="line">	NAME <span class="type">VARCHAR</span>(<span class="number">10</span>)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> bb <span class="keyword">VALUES</span>(<span class="number">1</span>,<span class="string">&#x27;aaa&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> bb <span class="keyword">VALUES</span>(<span class="number">2</span>,<span class="string">&#x27;bbb&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> bb <span class="keyword">VALUES</span>(<span class="number">4</span>,<span class="string">&#x27;ddd&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> aa <span class="keyword">UNION</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> bb;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>不去重：union all</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> aa <span class="keyword">UNION</span> <span class="keyword">ALL</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> bb;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="多表连接查询"><a href="#多表连接查询" class="headerlink" title="多表连接查询"></a>多表连接查询</h2><p><strong>使用关联关系可以去除无用笛卡尔积</strong></p>
<ul>
<li><p><strong>内连接(显式内连接)</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询小花下过的订单(使用多表连接进行查询)  笛卡尔积</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">  member.id m_id,</span><br><span class="line">  member.nick_name,</span><br><span class="line">  orders.`address`,</span><br><span class="line">  orders.`create_time` </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">  <span class="keyword">member</span> <span class="keyword">INNER</span> <span class="keyword">JOIN</span> orders </span><br><span class="line"><span class="keyword">ON</span> member.id <span class="operator">=</span> orders.m_id </span><br><span class="line"><span class="keyword">WHERE</span> member.nick_name <span class="operator">=</span> <span class="string">&#x27;小花&#x27;</span> ;</span><br></pre></td></tr></table></figure>

<p>注意:我们使用内连接的时候可以省略<code>INNER JOIN</code>,使<code>逗号</code>在多个表之间进行连接(隐式连接),连接条件也要使用<code>WHERE</code>关键系代替<code>ON</code>关键字</p>
<p>隐式连接的<strong>语法不太友好</strong>,简单的多个表之间的查询可以使用,但是复杂的sql就不建议使用<code>隐式连接</code></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询小花下过的订单(使用多表连接进行查询)  笛卡尔积</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">  m.id  m_id,</span><br><span class="line">  m.nick_name,</span><br><span class="line">  o.`address`,</span><br><span class="line">  o.`create_time`</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">  <span class="keyword">member</span> m,</span><br><span class="line">  orders o</span><br><span class="line"><span class="keyword">WHERE</span> m.id <span class="operator">=</span> o.m_id </span><br><span class="line">  <span class="keyword">AND</span> m.nick_name <span class="operator">=</span> <span class="string">&#x27;小花&#x27;</span> ;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>外链接 outer join on</strong></p>
<ul>
<li><p><strong>左外连接 left outer join</strong></p>
<p>特点：<strong>查询的结果存在不满足条件等式的可能性</strong>。</p>
<p>以<strong>左边的表为主表</strong>，先查询左表中的所有内容，然后在查询右表，<strong>右表满足条件的显示，不满足条件的显示为null</strong>。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">  member.id m_id,</span><br><span class="line">  member.nick_name,</span><br><span class="line">  orders.`address`,</span><br><span class="line">  orders.`create_time` </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line"><span class="keyword">member</span> <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> orders </span><br><span class="line"><span class="keyword">ON</span> member.id <span class="operator">=</span> orders.m_id </span><br><span class="line"><span class="keyword">AND</span> member.nick_name <span class="operator">=</span> <span class="string">&#x27;小花&#x27;</span> ;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>右外连接 right outer join</strong>(不建议使用,因为可以直接转换为左外链接)</p>
</li>
</ul>
</li>
<li><p><strong>自然链接   natural join</strong></p>
<ul>
<li><p>链接查询会产生笛卡尔积，可以使用主外键关系等式去除笛卡尔积。自然链接，我们不需要自己给出主外键关系等式，它会自己找到。自动拿2个表中名字和类型一样的列作为条件。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">NATURAL</span> <span class="keyword">JOIN</span> dept;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">NATURAL</span> <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> dept;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">NATURAL</span> <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> dept;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<hr>
<h1 id="28-多表的连接的商业项目使用建议"><a href="#28-多表的连接的商业项目使用建议" class="headerlink" title="28. 多表的连接的商业项目使用建议"></a>28. 多表的连接的商业项目使用建议</h1><ul>
<li>多表连接时尽量使用<strong>显式连接</strong>,因为显式连接的sql的语义明确</li>
<li>生产环境建议表的联查个数不要超过3张表(可以是3张)</li>
<li>如果3张表的联查还不能解决你的问题,那么你就需要在<strong>业务层面解决</strong>或者是<strong>数据库设计缺陷</strong></li>
<li><strong>在项目中不建议使用外键</strong>,我们完全可以在业务层保证数据的安全性;<ul>
<li>数据库本质的作用是用来存储数据,而不是进行数据约束的;因为外键会造成我们数据源库迁移的灾难;</li>
</ul>
</li>
</ul>
<hr>
<h1 id="29-级联删除与级联更新"><a href="#29-级联删除与级联更新" class="headerlink" title="29. 级联删除与级联更新"></a>29. 级联删除与级联更新</h1><p>外键的级联删除：如果父表中的记录被删除，则子表中对应的记录自动被删除</p>
<p>父表——被外键引用的表</p>
<p>子表——引用父表中的主键作为外键的表</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- ON DELETE CASCADE  级联删除</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> orders <span class="keyword">ADD</span> <span class="keyword">FOREIGN</span> KEY(`m_id`) <span class="keyword">REFERENCES</span> <span class="keyword">member</span>(`id`) <span class="keyword">ON</span> <span class="keyword">DELETE</span> CASCADE ;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- ON UPDATE CASCADE  级联更新</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> orders <span class="keyword">ADD</span> <span class="keyword">FOREIGN</span> KEY(`m_id`) <span class="keyword">REFERENCES</span> <span class="keyword">member</span>(`id`)  <span class="keyword">ON</span> <span class="keyword">UPDATE</span> CASCADE;</span><br></pre></td></tr></table></figure>

<p>当然级联更新和级联删除时可以同时设置的</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> orders <span class="keyword">ADD</span> <span class="keyword">FOREIGN</span> KEY (`m_id`) <span class="keyword">REFERENCES</span> <span class="keyword">member</span> (`id`) </span><br><span class="line"><span class="keyword">ON</span> <span class="keyword">DELETE</span> CASCADE  <span class="keyword">ON</span> <span class="keyword">UPDATE</span> CASCADE;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>也可以借助可视化工具进行修改级联删除和级联更新</p>
</blockquote>
<hr>
<h1 id="30-mysql中的分隔符-定界符"><a href="#30-mysql中的分隔符-定界符" class="headerlink" title="30. mysql中的分隔符(定界符)"></a>30. mysql中的分隔符(定界符)</h1><p>mysql中默认的分割符是 <code>;</code>  也就是说遇到 <code>;</code> 就会立即执行sql</p>
<p>在<strong>函数存储过程</strong>这些特性中需要写多个sql组成一个整体,当成整体来执行,而这些特性中,一条一条的语句之间语法规定必须用<code>;</code>来分开</p>
<p>所以我们要创建函数 存储过程 必须先要把默认的分隔符 <code>;</code>替换成其他的符号;</p>
<p><strong>在会话中替换默认的分隔符,使用下面语句</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER $$  </span><br></pre></td></tr></table></figure>

<hr>
<h1 id="31-mysql中的函数"><a href="#31-mysql中的函数" class="headerlink" title="31. mysql中的函数"></a>31. mysql中的函数</h1><p>函数:在编程中函数其实就是一段业务的封装</p>
<p>mysql中的函数: 对多个sql业务的封装,<strong>避免反复的进行词法和语法分析</strong></p>
<h2 id="31-1-系统函数"><a href="#31-1-系统函数" class="headerlink" title="31.1 系统函数"></a>31.1 系统函数</h2><p>mysql系统帮我们定义的函数</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询mysql系统当前时间</span></span><br><span class="line"><span class="keyword">SELECT</span> NOW();</span><br><span class="line"><span class="comment">-- 查询当前mysql的版本</span></span><br><span class="line"><span class="keyword">SELECT</span> VERSION();</span><br><span class="line"><span class="comment">-- 查询当前所在的数据库</span></span><br><span class="line"><span class="keyword">SELECT</span> DATABASE();</span><br><span class="line"><span class="comment">-- 查询当前登录mysql的用户和主机</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">USER</span>();</span><br><span class="line"><span class="comment">-- 获取一个字符串对应的md5值</span></span><br><span class="line"><span class="keyword">SELECT</span> MD5(&quot;HELLO&quot;);</span><br><span class="line"><span class="comment">-- 查询去重</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> university <span class="keyword">from</span> user_profile;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="31-2-聚合函数"><a href="#31-2-聚合函数" class="headerlink" title="31.2 聚合函数"></a>31.2 聚合函数</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 统计某个字段的记录数</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(`age`) <span class="keyword">FROM</span> student;</span><br><span class="line"><span class="comment">-- 查询某个字段的最大值</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MAX</span>(age) <span class="keyword">FROM</span> student;</span><br><span class="line"><span class="comment">-- 查询某个字段的最小值</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MIN</span>(age) <span class="keyword">FROM</span> student;</span><br><span class="line"><span class="comment">-- 查询某个字段的平均值</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">AVG</span>(age) <span class="keyword">FROM</span> student;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="31-3-数学函数"><a href="#31-3-数学函数" class="headerlink" title="31.3 数学函数"></a>31.3 数学函数</h2><p>数学函数主要用于处理数字，包括整型、浮点数等。</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/873abdbc9f3e48afb773d6f1a43cc9b2.png" alt="img"></p>
<h2 id="31-4-字符串函数"><a href="#31-4-字符串函数" class="headerlink" title="31.4 字符串函数"></a>31.4 字符串函数</h2><p>字符串函数是MySQL中最常用的一类函数，字符串函数主要用于处理表中的字符串。</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/b9ae4e4455ab4bdfb6376f9340079471.png" alt="img"></p>
<h2 id="31-5-日期时间函数"><a href="#31-5-日期时间函数" class="headerlink" title="31.5 日期时间函数"></a>31.5 日期时间函数</h2><p>MySQL的日期和时间函数主要用于处理日期时间。</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/1cd4478fee414b94adeb284222be5dc7.png" alt="img"></p>
<h2 id="31-6-条件判断函数"><a href="#31-6-条件判断函数" class="headerlink" title="31.6 条件判断函数"></a>31.6 条件判断函数</h2><p>条件判断函数用来在SQL语句中进行条件判断。根据是否满足判断条件，SQL语句执行不同的分支。例如,从员工表中查询员工的业绩。如果业绩高于指定值n,则输出good;否则，输出bad。下面是各种条件判断函数的表达式、作用和使用方法。</p>
<ul>
<li><p><strong>IF(expr,v1,v2)函数</strong></p>
<p>IF(expr,vl,v2)函数中，如果表达式expr成立，返回结果v1;否则，返回结果v2。</p>
</li>
<li><p><strong>IFNULL(v1,v2)函数</strong></p>
<p>IFNULL(v1,v2)函数中，如果v1的值不为空，就显示v1的值;否则就显示v2的值。</p>
</li>
<li><p><strong>CASE函数</strong></p>
<ul>
<li><p><strong>CASE WHEN expr1 THEN v1 [WHEN expr2 THEN v2…] [ELSE vn] END</strong></p>
<p>CASE WHEN exprl THEN v1 [WHEN expr2 THEN v2…] [ELSE vn] END函数中，CASE表示函数开始，END表示函数结束。如果表达式expr1成立时，返回v1的值。如果表达式expr2成立时，返回v2的值。依次类推，最后遇到ELSE时，返回vn 的值。</p>
</li>
<li><p><strong>CASE expr WHEN e1 THEN v1 [WHEN e2 THEN v2…] [ELSE vn] END</strong></p>
<p>CASE expr WHEN e1 THEN v1 [WHEN e2 THEN v2…] [ELSE vn] END 函数中，如果表达式expr取值等于e1时,返回v1的值。如果表达式expr取值等于e2时，返回v2的值。依次类推，最后遇到ELSE时，返回vn的值。CASE表示函数开始，END表示函数结束。</p>
</li>
</ul>
</li>
</ul>
<h2 id="31-7-自定义函数-了解"><a href="#31-7-自定义函数-了解" class="headerlink" title="31.7 自定义函数(了解)"></a>31.7 自定义函数(了解)</h2><p>我们自己编写的函数</p>
<ul>
<li>函数的参数</li>
<li>返回值</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- 函数的可以返回任意类型的值,也可以接受任意类型的值为参数</span><br><span class="line">- 函数的返回值和参数没有必然联系的</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> 函数名称(参数名称 参数类型) <span class="keyword">RETURNS</span> 返回值类型</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	函数语句 #函数语句只有一条时,可以省略<span class="keyword">BEGIN</span>和<span class="keyword">END</span></span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 首先创建函数之前一定要先修改其定界符,要不然遇到函数中的第一个;就会执行报错</span></span><br><span class="line">DELIMITER $$</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> MYADD (a <span class="type">INT</span>,b <span class="type">INT</span>) <span class="keyword">RETURNS</span> <span class="type">INT</span> </span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">  <span class="keyword">DECLARE</span> i <span class="type">INT</span> ; <span class="comment">-- 变量的定义</span></span><br><span class="line">  <span class="keyword">SET</span> i <span class="operator">=</span> a<span class="operator">+</span>b ; <span class="comment">-- 给变量设置值</span></span><br><span class="line">  <span class="keyword">RETURN</span> i ;  <span class="comment">-- 返回数据</span></span><br><span class="line"><span class="keyword">END</span> $$</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> MYADD(<span class="number">12</span>,<span class="number">22</span>); <span class="comment">-- 函数的调用</span></span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建自定义函数</span></span><br><span class="line">DELIMITER $$</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> STUAGEGTCOUNT (a <span class="type">INT</span>) <span class="keyword">RETURNS</span> <span class="type">BIGINT</span> </span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">   <span class="keyword">DECLARE</span> c <span class="type">BIGINT</span>;</span><br><span class="line">   <span class="keyword">SET</span> c<span class="operator">=</span>(<span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age<span class="operator">&gt;</span>a);</span><br><span class="line">   <span class="keyword">RETURN</span> c;</span><br><span class="line"><span class="keyword">END</span> $$</span><br><span class="line"><span class="comment">-- 调用自定义函数</span></span><br><span class="line"><span class="keyword">SELECT</span> STUAGEGTCOUNT(<span class="number">30</span>);</span><br></pre></td></tr></table></figure>

<p><strong>函数的调用</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 函数名称(实参列表);</span><br></pre></td></tr></table></figure>

<p><strong>删除函数</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">FUNCTION</span> [IF <span class="keyword">EXISTS</span>]  `MYADD`</span><br></pre></td></tr></table></figure>

<p><strong>自定义函数可能出现错误:</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">错误代码： <span class="number">1418</span></span><br><span class="line">This <span class="keyword">function</span> has <span class="keyword">none</span> <span class="keyword">of</span> <span class="keyword">DETERMINISTIC</span>, <span class="keyword">NO</span> <span class="keyword">SQL</span>, <span class="keyword">or</span> <span class="keyword">READS</span> <span class="keyword">SQL</span> DATA <span class="keyword">in</span> its declaration <span class="keyword">and</span> <span class="type">binary</span> logging <span class="keyword">is</span> enabled (you <span class="operator">*</span>might<span class="operator">*</span> want <span class="keyword">to</span> use the less safe log_bin_trust_function_creators variable)</span><br></pre></td></tr></table></figure>

<p><strong>原因</strong>：mysql在新版本中添加<strong>函数保护器</strong>,默认如果不进行配置,则无法创建自定义函数,我们需要在当前会话中把函数保护器关掉,尽量不要在全局(系统的配置文件)关闭函数保护器;</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看函数保护器的状态</span></span><br><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> &quot;%log_bin_trust_function_creators%&quot;</span><br><span class="line">	<span class="comment">-- OFF:不能创建自定义函数(保护器处于开启状态)</span></span><br><span class="line">	<span class="comment">-- ON:能创建自定义函数(保护器关闭)</span></span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 允许创建自定义函数</span></span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> log_bin_trust_function_creators<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>经过上面的设置我们就可以正常的创建自定义函数了;</p>
<hr>
<h1 id="32-mysql存储过程-了解"><a href="#32-mysql存储过程-了解" class="headerlink" title="32. mysql存储过程(了解)"></a>32. mysql存储过程(了解)</h1><h2 id="32-1-sql语句的执行流程"><a href="#32-1-sql语句的执行流程" class="headerlink" title="32.1 sql语句的执行流程"></a>32.1 sql语句的执行流程</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sql</span>语句<span class="comment">---&gt;sql执行优化器(编译)---&gt;词法分析,语法分析---&gt;sql优化---&gt;运行sql(读取数据)--&gt;结果</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="32-2-什么是存储过程"><a href="#32-2-什么是存储过程" class="headerlink" title="32.2 什么是存储过程?"></a>32.2 什么是存储过程?</h2><p>sql语句的编译的集合,以名称来存储,合并为一个单元处理;</p>
<p>如果在实现用户的某些需求时，需要编写一组复杂的SQL语句才能实现的时候，那么我们就可以将这组复杂的SQL语句集提前编写在数据库中，由JDBC调用来执行这组SQL语句。</p>
<p>把编写在数据库中的SQL语句集称为存储过程。</p>
<p>存储过程就类似于Java中的方法，需要先定义，使用时需要调用。存储过程可以定义参数，参数分为<code>IN、OUT、INOUT</code>类型三种类型。</p>
<ol>
<li>IN类型的参数表示接受调用者传入的数据；</li>
<li>OUT类型的参数表示向调用者返回数据；</li>
<li>INOUT类型的参数即可以接受调用者传入的参数，也可以向调用者返回数据。</li>
</ol>
<hr>
<h2 id="32-3-存储过程的特点"><a href="#32-3-存储过程的特点" class="headerlink" title="32.3 存储过程的特点"></a>32.3 存储过程的特点</h2><p><strong>优点</strong></p>
<ul>
<li>实现较快的执行速度(避免重复的编译,词法分析,语法分析等操作)</li>
<li>减少网络流量，<strong>减少应用程序和数据库服务器之间的流量</strong>。</li>
<li>存储的程序是<strong>安全的</strong>。数据库管理员是可以向访问数据库中存储过程的应用程序授予适当的权限，而不是向基础数据库表提供任何权限。</li>
<li><strong>简化对变动的管理</strong>。如果表名、列名、或业务逻辑有了变化。只需要更改存储过程的代码。使用它的人不用更改自己的代码。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>如果使用大量的存储过程，那么使用这些存储过程的每个连接的内存使用量将大大增加。此外，如果在存储过程中过度使用大量的逻辑操作，那么CPU的使用率也在增加，因为MySQL数据库最初的设计就侧重于高效的查询，而不是逻辑运算。</li>
<li>存储过程的构造使得开发具有了复杂的业务逻辑的存储过程变得困难。</li>
<li>很难调试存储过程。只有少数数据库管理系统允许调试存储过程。不幸的是，MySQL不提供调试存储过程的功能。</li>
<li>开发和维护存储过程都不容易。开发和维护存储过程通常需要一个不是所有应用程序开发人员拥有的专业技能。这可能导致应用程序开发和维护阶段的问题。</li>
<li><strong>对数据库依赖程度较高，移值性差</strong>。</li>
</ul>
<hr>
<h2 id="32-4-存储过程的语法"><a href="#32-4-存储过程的语法" class="headerlink" title="32.4 存储过程的语法"></a>32.4 存储过程的语法</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建存储过程</span></span><br><span class="line">DELIMITER $$</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> proc2 (a <span class="type">INT</span>) </span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">  <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age<span class="operator">&gt;</span>a;</span><br><span class="line">  <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">member</span>;</span><br><span class="line"><span class="keyword">END</span> $$</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 调用存储过程</span></span><br><span class="line"><span class="keyword">CALL</span> proc2(<span class="number">20</span>)</span><br></pre></td></tr></table></figure>

<h2 id="32-5-删除存储过程"><a href="#32-5-删除存储过程" class="headerlink" title="32.5 删除存储过程"></a>32.5 删除存储过程</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span> proc1;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="33-mysql函数和存储过程对比"><a href="#33-mysql函数和存储过程对比" class="headerlink" title="33. mysql函数和存储过程对比"></a>33. mysql函数和存储过程对比</h1><ul>
<li><p>存储过程和函数都是为了提高<strong>程序的运行效率</strong>和<strong>减少网络带宽</strong>而存在的</p>
</li>
<li><p>存储过程可以实现相对复杂的功能,而函数针对性比较强</p>
</li>
<li><p>存储过程可以返回多个值(无需<code>return</code>关键字),函数只能有一个返回值</p>
</li>
<li><p><strong>在实际商业项目中尽量不要使用存储过程和自定义函数</strong></p>
</li>
</ul>
<hr>
<h1 id="34-mysql中的视图-了解"><a href="#34-mysql中的视图-了解" class="headerlink" title="34. mysql中的视图(了解)"></a>34. mysql中的视图(了解)</h1><p>视图其实就是一个虚拟表,这虚拟表可以存储我们查询的结果,方便我们进行二次查询,提升查询效率;查询的时候就可以像使用表一样用视图;</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建视图(View)</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> myStudentView <span class="keyword">AS</span> (<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age<span class="operator">&gt;</span><span class="number">20</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询视图的数据(可以把视图当成表来使用)</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> myStudentView;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 删除视图</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">VIEW</span> myStudentView;</span><br></pre></td></tr></table></figure>

<p><strong>注意: 视图是依赖表而存在的,如果表被删除了,视图就无效了;</strong></p>
<hr>
<h1 id="35-mysql中的触发器-了解"><a href="#35-mysql中的触发器-了解" class="headerlink" title="35. mysql中的触发器(了解)"></a>35. mysql中的触发器(了解)</h1><p>触发器(trigger)：监听事件,并触发某操作</p>
<p>触发器的四要素:</p>
<ul>
<li>监视地点(table)</li>
<li>监视事件(insert&#x2F;update&#x2F;delete)</li>
<li>触发时机(after&#x2F;before)</li>
<li>触发事件(insert&#x2F;update&#x2F;delete)</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建班级表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> grade (</span><br><span class="line">  id <span class="type">INT</span> AUTO_INCREMENT,</span><br><span class="line">  gname <span class="type">VARCHAR</span> (<span class="number">64</span>),</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY(id)</span><br><span class="line">);</span><br><span class="line"><span class="comment">-- 创建学生表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> student (</span><br><span class="line">  id <span class="type">INT</span> AUTO_INCREMENT,</span><br><span class="line">  nickname <span class="type">VARCHAR</span> (<span class="number">64</span>),</span><br><span class="line">  age TINYINT UNSIGNED,</span><br><span class="line">  g_id TINYINT UNSIGNED,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY(id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>需求: 我们删除班级,实现自动删除班级对应的学生 </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建触发器</span></span><br><span class="line">DELIMITER $$</span><br><span class="line"><span class="comment">-- 触发地点:grade  监听事件: delete  触发时机: before  触发事件:delete</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> `tigger1` BEFORE <span class="keyword">DELETE</span> <span class="keyword">ON</span> `grade` </span><br><span class="line">    <span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span> </span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"> <span class="keyword">DELETE</span> <span class="keyword">FROM</span> student; </span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line">$$</span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="36-mysql中的存储引擎"><a href="#36-mysql中的存储引擎" class="headerlink" title="36. mysql中的存储引擎"></a>36. mysql中的存储引擎</h1><p>mysql可以将数据以不同的技术存储在文件或者(内存)中,这种技术叫存储引擎;</p>
<p>每种存储引擎都有不同的<strong>存储机制,索引技术,表锁定技术</strong>,最终应用的场景各不相同,但是现在最主流的mysql的存储引擎用的对多的还是<code>INNODB</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 查询数据库支持哪些存储引擎</span><br><span class="line">show enginess \G;</span><br><span class="line">-- 查询数据库默认的存储引擎</span><br><span class="line">show variables like &#x27;%storage_engine%&#x27;;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">存储引擎</th>
<th align="center">MYISAM</th>
<th align="center">INNODB</th>
<th align="center">MEMORY</th>
</tr>
</thead>
<tbody><tr>
<td align="center">存储限制</td>
<td align="center">256TB</td>
<td align="center">64TB</td>
<td align="center">有限制</td>
</tr>
<tr>
<td align="center"><strong>事务安全性</strong></td>
<td align="center">NO</td>
<td align="center"><strong>YES</strong></td>
<td align="center">NO</td>
</tr>
<tr>
<td align="center"><strong>支持索引</strong></td>
<td align="center">YES</td>
<td align="center"><strong>YES</strong></td>
<td align="center">YES</td>
</tr>
<tr>
<td align="center">数据压缩</td>
<td align="center">YES</td>
<td align="center">NO</td>
<td align="center">NO</td>
</tr>
<tr>
<td align="center"><strong>是否支持外键</strong></td>
<td align="center">NO</td>
<td align="center"><strong>YES</strong></td>
<td align="center">NO</td>
</tr>
</tbody></table>
<blockquote>
<p>如果没有特殊要求,在互联网项目中,INNODB存储引擎是我们首选;</p>
</blockquote>
<hr>
<h1 id="37-执行mysql的脚本"><a href="#37-执行mysql的脚本" class="headerlink" title="37.  执行mysql的脚本"></a>37.  执行mysql的脚本</h1><ul>
<li><p>登录mysql之后执行sql脚本</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source sqlpath</span><br></pre></td></tr></table></figure>
</li>
<li><p>登录mysql时候直接执行sql脚本</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot -p &lt;sqlpath</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用可视化工具备份和还原(推荐做法)</strong></p>
</li>
</ul>
<hr>
<h1 id="38-Mysql管理工具"><a href="#38-Mysql管理工具" class="headerlink" title="38. Mysql管理工具"></a>38. Mysql管理工具</h1><ul>
<li>Workbench(mysql官方推荐使用的)  免费的 跨平台的 </li>
<li>Sequel Pro 只在mac端有</li>
<li>HeidiSQL(免费  开源)</li>
<li>phpMyAdmin(web应用)</li>
<li>mysqlfont(免费  轻量级) 只有windows端有,对高分辨率屏支持不好</li>
<li><strong>Navicat(商业 收费) 跨平台  功能最强大  UI最漂亮</strong>  </li>
<li><strong>SQLyog(收费  不跨平台)</strong> 对高分辨率屏支持不好</li>
</ul>
<hr>
<h1 id="39-mysql的版本升级"><a href="#39-mysql的版本升级" class="headerlink" title="39. mysql的版本升级"></a>39. mysql的版本升级</h1><p>升级数据库版本之前一定要先备份数据,再执行升级;</p>
<ul>
<li>备份数据</li>
<li>卸载老版本的mysql<ul>
<li>停止系统的mysql服务</li>
<li>检查系统服务是否存在如果存在先删除 <code>sc delete mysql</code>,这个命令必须使用管理员用户权限</li>
<li>删除数据目录</li>
</ul>
</li>
<li>安装新版本的<code>mysql-8.0.22.0</code></li>
<li>恢复数据(执行前面备份的sql脚本)</li>
</ul>
<hr>
<h1 id="40-mysql中的模糊查询"><a href="#40-mysql中的模糊查询" class="headerlink" title="40. mysql中的模糊查询"></a>40. mysql中的模糊查询</h1><p><code>%</code>: 匹配0个或者多个任意字符</p>
<p><code>_</code>: 匹配任意一个字符</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询昵称中以 &#x27;小&#x27; 开头的数据</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">member</span> <span class="keyword">WHERE</span> nickname <span class="keyword">LIKE</span> <span class="string">&#x27;小%&#x27;</span>;</span><br><span class="line"><span class="comment">-- 查询昵称中包含 &#x27;小&#x27; 的数据</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">member</span> <span class="keyword">WHERE</span> nickname <span class="keyword">LIKE</span> <span class="string">&#x27;%小%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>模糊查询的前缀查询效率<code>极低</code>(要进行全表扫描),要慎重使用;</li>
<li>一般生产环境会直接禁用<strong>like</strong>模糊查询功能;</li>
<li><strong>左模糊查询(“%abc”)不会使用索引</strong></li>
<li><strong>右模糊查询(“abc%”)会使用索引abc</strong></li>
</ul>
<hr>
<h1 id="41-mysql中的事务"><a href="#41-mysql中的事务" class="headerlink" title="41. mysql中的事务"></a>41. mysql中的事务</h1><h2 id="41-1-mysql事务介绍"><a href="#41-1-mysql事务介绍" class="headerlink" title="41.1 mysql事务介绍"></a>41.1 mysql事务介绍</h2><p>事务是一个最小的不可在分的工作单元，把做完一个业务分成好多单元,整个过程每个单元<strong>全部</strong>处理成功,才算整个的业务处理成功,只要有任何一个单元处理失败,则认为业务处理失败;</p>
<p><strong>作用: 保证了数据的完整性</strong></p>
<p>属性：传播行为、隔离级别、只读和事务超时</p>
<hr>
<h2 id="41-2-事务控制"><a href="#41-2-事务控制" class="headerlink" title="41.2 事务控制"></a>41.2 事务控制</h2><p>整个过程的每一个单元全部处理成功那么事务才会<strong>提交(commit)<strong>，只要其中任何一个单元出现异常,我们则让事务</strong>回滚(rollback)</strong></p>
<hr>
<h2 id="41-3-事务的特性"><a href="#41-3-事务的特性" class="headerlink" title="41.3 事务的特性"></a>41.3 事务的特性</h2><p><strong>ACID</strong></p>
<p><strong>atomicity(原子性)</strong>: 事务中所有的操作要么全部成功,要么全部失败;</p>
<p><strong>consistency(一致性)</strong>: 事务执行前后的状态(数据)保持一致</p>
<p><strong>isolation(隔离性)</strong>: 多个事务在执行过程中互相不受影响</p>
<p><strong>durability(持久性)</strong>: 事务一旦被提交,那么对数据库中的数据的改变时永久性的,即使在数据库系统遇到故障的时候,排除故障之后这些数据也不会丢失;</p>
<p>注意: 只有当前三条性质都满足了，才能保证事务的一致性；事务这个特性其实我们一直在使用,只是我们没有特别的在意这个事,因为mysql默认的事务的提交方式是自动提交的</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> &quot;%autocommit%&quot;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="41-4-手动控制事务的提交与回滚"><a href="#41-4-手动控制事务的提交与回滚" class="headerlink" title="41.4 手动控制事务的提交与回滚"></a>41.4 手动控制事务的提交与回滚</h2><p>mysql默认事务的提交方式是自动提交的,但是我们一般使用到事务的时候都会进行手动的控制,也就是要关闭mysql的事务自动提交;</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 开启事务(临时关闭mysql的&quot;事务自动提交&quot;)</span></span><br><span class="line"><span class="keyword">START</span> TRANSACTION;<span class="comment">-- 或者使用 BEGIN;</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">member</span>(nickname,sex,age)<span class="keyword">VALUES</span>(&quot;小胖1&quot;,<span class="string">&#x27;男&#x27;</span>,<span class="number">30</span>);</span><br><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">member</span> <span class="keyword">SET</span> age<span class="operator">=</span><span class="number">10</span> <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">3</span>;</span><br><span class="line"><span class="comment">-- 提交事务</span></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 开启事务(临时关闭mysql的&quot;事务自动提交&quot;)</span></span><br><span class="line"><span class="keyword">START</span> TRANSACTION;  <span class="comment">-- 或者使用BEGIN;</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">member</span>(nickname,sex,age)<span class="keyword">VALUES</span>(&quot;小胖1&quot;,<span class="string">&#x27;男&#x27;</span>,<span class="number">30</span>);</span><br><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">member</span> <span class="keyword">SET</span> age<span class="operator">=</span><span class="number">10</span> <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">3</span>;</span><br><span class="line"><span class="comment">-- 回滚事务</span></span><br><span class="line"><span class="keyword">ROLLBACK</span>;</span><br></pre></td></tr></table></figure>

<h2 id="41-5-事务的隔离性"><a href="#41-5-事务的隔离性" class="headerlink" title="41.5 事务的隔离性"></a>41.5 事务的隔离性</h2><p>隔离性保证了,多个事务在执行过程中互相不受影响;</p>
<p>mysql中的事务隔离级别有以下几种:</p>
<ul>
<li><strong>Read UNCOMMITTED(读未提交)</strong></li>
<li><strong>READ COMMITTED(读已提交)</strong> —-&gt;oracle中事务默认的隔离级别</li>
<li><strong>REPEATABLE READ(重复读)</strong> —&gt;<strong>mysql中的事务的隔离级别</strong></li>
<li><strong>SERIALIZABLE(串行化)</strong></li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询默认的事务隔离级别</span></span><br><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@tx</span>_isolation;  <span class="comment">--老版本中的查询方式</span></span><br><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@transaction</span>_isolation; <span class="comment">-- 新版本中查询方式</span></span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 更改当前会话的隔离级别</span></span><br><span class="line"><span class="keyword">set</span> session transaction isolation level read uncommitted; <span class="comment">-- 设置当前会话隔离级别为读未提交</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="41-6-事务隔离级别引发的问题"><a href="#41-6-事务隔离级别引发的问题" class="headerlink" title="41.6 事务隔离级别引发的问题"></a>41.6 事务隔离级别引发的问题</h2><blockquote>
<p>脏读问题</p>
</blockquote>
<ul>
<li><p>脏读:  设置事务的隔离级别为 <code>READ UNCOMMITTED</code>,会读到其他事务没有提交的数据;</p>
</li>
<li><p>例如：事务A读取到了事务已经修改但未提交的数据，这种数据就叫脏数据，是不正确的</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/0e5ac64c906c4d13b6dbdecda01b5910.png" alt="img"></p>
</li>
<li><p>解决脏读: 设置事务的隔离级别为 <code>READ COMMITTED</code>,既可以解决数据脏读问题</p>
</li>
</ul>
<blockquote>
<p>不可重复读问题</p>
</blockquote>
<ul>
<li><p>不可重复读: 在一个事务中,前后两次读到的数据不一致</p>
</li>
<li><p>例如：对于事务A多次读取同一个数据时，由于其他是事务也在访问这个数据，进行修改且提交，对于事务A，读取同一个数据时，有可能导致数据不一致，叫不可重复读。</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/2b755a18343a4122a434c5d955804492.png" alt="img"></p>
</li>
<li><p>解决不可重复读: 使用的<code>REPEATABLE READ</code>隔离级别可以解决;</p>
</li>
</ul>
<blockquote>
<p>虚读|幻读问题</p>
</blockquote>
<ul>
<li><p>虚读: 设置为<code>READ UNCOMMITTED ,READ COMMITTED,REPEATABLE READ</code>的事务,有时候可以读取到其他事务新插入的行,这种情况就称为虚读;</p>
</li>
<li><p>解决虚读: 把事务的隔离级别设置成 <code>SERIALIZABLE</code>之后就可以解决虚读问题;</p>
</li>
</ul>
<blockquote>
<p>解决方案: 我们在实际开发过程中一般不会使用两个极端的隔离级别(读未提交,  串行化),我们会使用中间的两个;</p>
</blockquote>
<hr>
<h2 id="41-7-事务的传播特性"><a href="#41-7-事务的传播特性" class="headerlink" title="41.7 事务的传播特性"></a>41.7 事务的传播特性</h2><p><strong>PROPAGATION_REQUIRED</strong>–支持当前事务，如果当前没有事务，就新建一个事务。这是最常见的选择。 </p>
<p><strong>PROPAGATION_SUPPORTS</strong>–支持当前事务，如果当前没有事务，就以非事务方式执行。 </p>
<p><strong>PROPAGATION_MANDATORY</strong>–支持当前事务，如果当前没有事务，就抛出异常。 </p>
<p><strong>PROPAGATION_REQUIRES_NEW</strong>–新建事务，如果当前存在事务，把当前事务挂起。 </p>
<p><strong>PROPAGATION_NOT_SUPPORTED</strong>–以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。 </p>
<p><strong>PROPAGATION_NEVER</strong>–以非事务方式执行，如果当前存在事务，则抛出异常。</p>
<h1 id="42-innodb锁机制"><a href="#42-innodb锁机制" class="headerlink" title="42. innodb锁机制"></a>42. innodb锁机制</h1><h2 id="42-1-innodb锁机制介绍"><a href="#42-1-innodb锁机制介绍" class="headerlink" title="42.1 innodb锁机制介绍"></a>42.1 innodb锁机制介绍</h2><p>从锁的颗粒来说锁分为行锁和表锁;</p>
<p>在innodb中提供了两种锁机制:</p>
<ul>
<li><p>乐观锁:  并不是硬编码的实现,而是通过version版本号来进行实现&#x3D;&#x3D;(innodb中并没有实现乐观锁)&#x3D;&#x3D;</p>
</li>
<li><p>悲观锁: 这是innodb存储引擎默认实现的锁机制,这种锁是<strong>表锁</strong>,而悲观锁的实现又分为两种实现:</p>
<ul>
<li><p>共享锁(S锁),读锁</p>
<ul>
<li><p>在读取的行设置一个共享模式的锁,这个共享锁允许其他的会话读取数据,但是不允许修改,如果其他的会话也需要修改数据,则</p>
<p>要等待持有共享锁的会话结束锁的释放,才能修改数据;</p>
</li>
<li><p>可以在多个会话中加多个共享锁</p>
</li>
</ul>
</li>
<li><p><strong>添加多个共享锁容易出现互相等待释放的情况,造成死锁问题,所以使用多个共享锁一定要慎重;</strong></p>
</li>
<li><p>排它锁(X锁),写锁</p>
<ul>
<li>排它锁是不允许重复添加的</li>
<li>排它锁没有死锁问题</li>
</ul>
</li>
</ul>
<hr>
</li>
</ul>
<h2 id="42-2-显式加锁"><a href="#42-2-显式加锁" class="headerlink" title="42.2 显式加锁"></a>42.2 显式加锁</h2><ul>
<li>共享锁的添加: <code>lock in share mode</code></li>
<li>排它锁的添加: <code>for update</code></li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from account lock in share mode;</span><br><span class="line">select * from account for update;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="42-3-mvcc并发系统快照读与当前读"><a href="#42-3-mvcc并发系统快照读与当前读" class="headerlink" title="42.3 mvcc并发系统快照读与当前读"></a>42.3 mvcc并发系统快照读与当前读</h2><p><strong>快照读:</strong> 不加锁的select操作就属于快照读</p>
<p>当前读: 加锁的操作属于当前读</p>
<p>当前读读到的是最新的数据,而且在读取的过程中是&#x3D;&#x3D;不允许&#x3D;&#x3D;其他的事务修改数据;</p>
<hr>
<h1 id="43-mysql中的执行计划"><a href="#43-mysql中的执行计划" class="headerlink" title="43. mysql中的执行计划"></a>43. mysql中的执行计划</h1><p>mysql执行流程:</p>
<p>客户端(sql语句)—&gt;mysql-rdbms–&gt;innodb存储引擎–&gt;sql查询优化器(sql语句的优化)—&gt;….</p>
<p>sql查询优化器会把优化的东西形成一个产物,这个产物就是执行计划; 简单来说就是SQL在数据库中执行时的表现情况。</p>
<p>我们在实际的开发过程中,一般涉及到mysql的优化都会先查看其执行计划;</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> shop;</span><br></pre></td></tr></table></figure>

<ul>
<li>执行计划看的时候先看执行计划的id,<strong>id越大的先执行</strong>;</li>
<li>如果id相同从上往下看</li>
</ul>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/mysql%E6%9E%B6%E6%9E%84.jpg" alt="mysql架构"></p>
<hr>
<h1 id="44-mysql中的索引技术-非常重要"><a href="#44-mysql中的索引技术-非常重要" class="headerlink" title="44. mysql中的索引技术(非常重要)"></a>44. mysql中的索引技术(非常重要)</h1><h2 id="44-1-索引技术的介绍"><a href="#44-1-索引技术的介绍" class="headerlink" title="44.1 索引技术的介绍"></a>44.1 索引技术的介绍</h2><ul>
<li>mysql中的索引技术可以帮助我们快速检索数据</li>
<li>innodb底层索引技术就是通过B+tree实现的</li>
<li>索引其实就是我们平常用到的 ‘<code>目录</code>‘</li>
<li>索引在mysql启动时就会加到内存中,形成B+Tree,在mysql停止的时候会持久化到硬盘;</li>
</ul>
<hr>
<h2 id="44-2-索引的分类"><a href="#44-2-索引的分类" class="headerlink" title="44.2 索引的分类"></a>44.2 索引的分类</h2><ul>
<li>普通索引</li>
<li>主键索引</li>
<li>唯一索引</li>
<li>全文索引</li>
</ul>
<hr>
<h2 id="44-3-普通索引"><a href="#44-3-普通索引" class="headerlink" title="44.3 普通索引"></a>44.3 普通索引</h2><p>普通索引如果不指定名称,则索引的名称和字段的名称相同;</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建索引的第一种方式</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_nickname <span class="keyword">ON</span> account(nickname); </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建索引的第二种方式(不常用)</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> account <span class="keyword">ADD</span> INDEX idx_nickname1(nickname);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建索引的第三种方式</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> u1(nickname <span class="type">VARCHAR</span>(<span class="number">64</span>),age TINYINT UNSIGNED,KEY idx_nickname(nickname));</span><br></pre></td></tr></table></figure>

<ul>
<li>建立普通索引的列的数据是可以重复的</li>
</ul>
<hr>
<h2 id="44-4-主键索引"><a href="#44-4-主键索引" class="headerlink" title="44.4 主键索引"></a>44.4 主键索引</h2><p>主键索引如果不指定索引的名称,则主键索引的名称为 <code>PRIMARY</code></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 声明为主键的列就是自动添加主键索引</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> u1(id <span class="type">INT</span> ,nickname <span class="type">VARCHAR</span>(<span class="number">64</span>),age TINYINT UNSIGNED,<span class="keyword">PRIMARY</span> KEY(id));</span><br></pre></td></tr></table></figure>

<ul>
<li><p>主键索引的列的数据非空,唯一的</p>
</li>
<li><p>一个表中建议只有一个主键列</p>
</li>
</ul>
<hr>
<h2 id="44-5-唯一索引"><a href="#44-5-唯一索引" class="headerlink" title="44.5 唯一索引"></a>44.5 唯一索引</h2><p>唯一索引如果不指定名称,则索引的名称和字段的名称相同;</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建索引的第一种方式</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> INDEX uk_nickname <span class="keyword">ON</span> u1(nickname); </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建表时创建唯一索引</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> u1 (</span><br><span class="line">  id <span class="type">INT</span>,</span><br><span class="line">  nickname <span class="type">VARCHAR</span> (<span class="number">64</span>) ,</span><br><span class="line">  age TINYINT UNSIGNED,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (id),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY uk_nickname(nickname) </span><br><span class="line">) ;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果一列被约束为<code>UNIQUE</code>,则在这一列默认添加唯一索引</li>
<li>添加唯一索引的列可以为<code>NULL</code>值,这也是和主键索引,不同的地方</li>
</ul>
<hr>
<h2 id="44-6-全文索引"><a href="#44-6-全文索引" class="headerlink" title="44.6 全文索引"></a>44.6 全文索引</h2><blockquote>
<p>全文索引,通过建立<code>倒排索引</code>,可以提高数据的检索效率,解决判断字段中 <code>是否包含</code> 的问题;</p>
</blockquote>
<p>我们如果使用like关键字会出现很多问题:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 我们已经给nickname字段添加了普通索引</span></span><br><span class="line"><span class="comment">-- 会使用索引</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> account <span class="keyword">WHERE</span> nickname<span class="operator">=</span><span class="string">&#x27;小明&#x27;</span>;</span><br><span class="line"><span class="comment">-- 会使用索引</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> account <span class="keyword">WHERE</span> nickname <span class="keyword">LIKE</span> <span class="string">&#x27;小明%&#x27;</span>;</span><br><span class="line"><span class="comment">-- 不会使用索引</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> account <span class="keyword">WHERE</span> nickname <span class="keyword">LIKE</span> <span class="string">&#x27;%小明%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>不使用到索引我们如果进行大规模数据检索时,效率会大大的降低,所以前面我们说过 <code>我们只在简单业务或者数据量小的时候才考虑使用like关键字</code>;</p>
<blockquote>
<p>全文索引注意的地方:</p>
</blockquote>
<ul>
<li><p>mysql5.6以前,只有<code>MYISAM</code>存储引擎支持全文索引</p>
</li>
<li><p>在5.6中<code>INNODB</code>存储引擎加入了对全文索引的支持,<strong>但是只支持英文的全文索引,不支持中文的全文索引</strong></p>
</li>
<li><p>&#x3D;&#x3D;<strong>在5.7.6中,mysql内置了<code>ngram</code>分词器,用来支持中文;</strong>&#x3D;&#x3D;</p>
</li>
</ul>
<blockquote>
<p>配置ngram分词的最小长度:      </p>
</blockquote>
<p>默认长度为2,当然我们也可以设置成1,但是设置成1的话就会浪费大量的空间,不是很好,<code>mysql建议我们配置为2</code>;</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">ngram分词器对分词最小长度(也就是说分词器,分词的时候最小也是两个词一分)</span></span><br><span class="line">[mysqld]</span><br><span class="line">ft_min_word_len=2</span><br></pre></td></tr></table></figure>

<blockquote>
<p>创建全文索引</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建索引的第一种方式</span></span><br><span class="line"><span class="keyword">CREATE</span> FULLTEXT INDEX ft_nickname <span class="keyword">ON</span> account(nickname) <span class="keyword">WITH</span> PARSER ngram ; </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建索引的第二种方式(不常用)</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> account <span class="keyword">ADD</span> FULLTEXT INDEX ft_nickname(nickname) <span class="keyword">WITH</span> PARSER ngram;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建索引的第三种方式</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> u1(nickname <span class="type">VARCHAR</span>(<span class="number">64</span>),age TINYINT UNSIGNED,FULLTEXT KEY ft_nickname(nickname) <span class="keyword">WITH</span> PARSER ngram );</span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用全文索引</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> account <span class="keyword">WHERE</span> <span class="keyword">MATCH</span>(nickname) AGAINST(&quot;你觉得华为笔记本合小米手机哪个好&quot;);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>match</code>中的字段和创建全文建索引时的字段<strong>必须一致</strong>;</li>
</ul>
<blockquote>
<p>全文索引的检索流程</p>
</blockquote>
<p>用户输入词—&gt;sql执行引擎—&gt;<code>ngram</code>分词器对用户输入的词进行分词(配置了最小的分词个数)—&gt;把分词器分的词依次的去倒排索引中去查找,找出相应的记录返回;</p>
<hr>
<h2 id="44-7-组合索引"><a href="#44-7-组合索引" class="headerlink" title="44.7 组合索引"></a>44.7 组合索引</h2><p><strong>包含多个字段的索引</strong>称为组合索引;</p>
<blockquote>
<p>组合索引包含</p>
</blockquote>
<ul>
<li>组合普通索引</li>
<li>组合主键索引</li>
<li>组合唯一索引</li>
<li>组合全文索引</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建复合索引时必须指定索引的名称,不能省略</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX mu_title_content <span class="keyword">ON</span> article(title,content,publish_time);</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> article <span class="keyword">WHERE</span> title <span class="keyword">LIKE</span> <span class="string">&#x27;小米%&#x27;</span>; <span class="comment">-- 使用到索引</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> article <span class="keyword">WHERE</span> title <span class="keyword">LIKE</span> <span class="string">&#x27;小米%&#x27;</span> <span class="keyword">AND</span> content <span class="keyword">LIKE</span> <span class="string">&#x27;小米%&#x27;</span>; <span class="comment">-- 使用了索引</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> article <span class="keyword">WHERE</span>  content <span class="keyword">LIKE</span> <span class="string">&#x27;小米%&#x27;</span>; <span class="comment">-- 没有索引</span></span><br></pre></td></tr></table></figure>

<p><strong>建议多列索引的列不要超过2个列</strong></p>
<ul>
<li><p>以上这个复合索引相当于建立了这3个索引</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(title),(title,content),(title,content,publish_time)</span><br></pre></td></tr></table></figure>
</li>
<li><p>多列索引遵循<strong>最左前缀</strong>的原则</p>
</li>
<li><p>多列索引在创建的时候,如果其中有字段时<code>TEXT</code>或<code>BLOB</code>类型,就必须指定索引的长度;</p>
</li>
</ul>
<hr>
<h2 id="44-8-使用索引的优点"><a href="#44-8-使用索引的优点" class="headerlink" title="44.8 使用索引的优点"></a>44.8 使用索引的优点</h2><ul>
<li>使用主键索引或者唯一索引,可以保证数据库中的表的数据是唯一</li>
<li><strong>通过建立索引可以大大的提高数据检索的效率,减少表扫描的行数(避免进行全表扫描)</strong></li>
<li>我们在进行多表连接的时候,可以使用索引加速表之间的连接</li>
</ul>
<hr>
<h2 id="44-9-使用索引的缺点"><a href="#44-9-使用索引的缺点" class="headerlink" title="44.9 使用索引的缺点"></a>44.9 使用索引的缺点</h2><ul>
<li>在创建索引和维护索引时都需要耗费时间;</li>
<li>索引文件会占用物理存储空间,除了表的数据占用一部分空间,索引文件也会占用一部分空间;</li>
<li><strong>设置为<code>text</code>和<code>blob</code>类型的字段强烈不建议添加索引;</strong></li>
</ul>
<hr>
<h1 id="45-mysql中的记录截取"><a href="#45-mysql中的记录截取" class="headerlink" title="45. mysql中的记录截取"></a>45. mysql中的记录截取</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> account LIMIT <span class="keyword">start</span>,count;</span><br><span class="line"><span class="keyword">start</span>:开始位置,从<span class="number">0</span>开始</span><br><span class="line">count:截取的记录数量</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="46-mysql数据库设计-了解"><a href="#46-mysql数据库设计-了解" class="headerlink" title="46. mysql数据库设计(了解)"></a>46. mysql数据库设计(了解)</h1><ul>
<li><p><strong>第一设计范式 ：表中的每一列都不能再分(不要出现二维表)</strong></p>
</li>
<li><p>第二设计范式：满足第一设计范式，除主键外每一列都必须依靠主键</p>
</li>
<li><p>第三设计范式：满足第二设计范式，除主键列外，每一列都不能相互依靠</p>
</li>
</ul>
<p>数据库范式的提出是很早以前的事了,在很早以前硬盘是非常昂贵的,一般都会遵循1,2,3范式,但是随着互联网的发展,硬盘非常便宜,所以我们在现在的商业项目中一般不会遵循2,3范式(用时间换空间),<strong>第一范式会遵循</strong>;</p>
<hr>
<h1 id="47-国内大厂的数据库开发规范-参照阿里的开发规范"><a href="#47-国内大厂的数据库开发规范-参照阿里的开发规范" class="headerlink" title="47. 国内大厂的数据库开发规范(参照阿里的开发规范)"></a>47. 国内大厂的数据库开发规范(参照阿里的开发规范)</h1><ol>
<li><p>库名与应用名称尽量一致</p>
</li>
<li><p>表名、字段名必须使用小写字母或数字，禁止出现数字开头,如果一个单词不能表达那就使用下划线分隔;</p>
</li>
<li><p>表名不使用复数名词;</p>
</li>
<li><p>表的命名最好是加上“业务名称_表的作用”。如，edu_teacher </p>
</li>
<li><p>表必备三字段：id, gmt_create, gmt_modified<br>说明：其中 id 必为主键，类型为 bigint unsigned、单表时自增、步长为 1。（如果使用分库分表集群部署，则id类型为varchar，非自增，业务中使用分布式id生成器）<br>gmt_create, gmt_modified 的类型均为 datetime 类型，前者现在时表示主动创建，后者过去分词表示被动更新。</p>
</li>
<li><p>单表行数超过 500 万行或者单表容量超过 2GB，才推荐进行分库分表。 说明：如果预计三年后的数据量根本达不到这个级别，请不要在创建表时就分库分表。</p>
</li>
<li><p>表达是与否概念的字段，必须使用 is_xxx 的方式命名，数据类型是 unsigned tinyint （1 表示是，0 表示否）。<br>说明：任何字段如果为非负数，必须是 unsigned。<br>注意：POJO 类中的任何布尔类型的变量，都不要加 is 前缀。数据库表示是与否的值，使用 tinyint 类型，坚持 is_xxx 的 命名方式是为了明确其取值含义与取值范围。<br>正例：表达逻辑删除的字段名 is_deleted，1 表示删除，0 表示未删除。</p>
</li>
<li><p>小数类型为 decimal，禁止使用 float 和 double。 说明：float 和 double 在存储的时候，存在精度损失的问题，很可能在值的比较时，得到不 正确的结果。如果存储的数据范围超过 decimal 的范围，建议将数据拆成整数和小数分开存储。</p>
</li>
<li><p>如果存储的字符串长度几乎相等，使用 char 定长字符串类型。</p>
</li>
<li><p>varchar 是可变长字符串，不预先分配存储空间，长度不要超过 5000，如果存储长度大于此值，定义字段类型为 text，独立出来一张表，用主键来对应，避免影响其它字段索 引效率。</p>
</li>
<li><p>唯一索引名为 uk_字段名；普通索引名则为 idx_字段名。<br>说明：uk_ 即 unique key；idx_ 即 index 的简称</p>
</li>
<li><p><strong>不得使用外键与级联，一切外键概念必须在应用层解决</strong>。外键与级联更新适用于单机低并发，不适合分布式、高并发集群；级联更新是强阻塞，存在数据库更新风暴的风险；外键影响数据库的插入速度</p>
</li>
<li><p>慎重使用<code>like</code>进行模糊查询, 通配符如果在前面则不会使用到索引,影响检索效率;</p>
</li>
<li><p>如果是简单的搜索业务建议使用mysql5.7中新增的全文索引,不建议直接上solor,elasticsearch这样的检索系统,因为会使得维护成本增加;</p>
</li>
</ol>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-JUC：线程与进程"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
	
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/08/02/JUC%EF%BC%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B/"
    >线程与进程</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/08/02/JUC%EF%BC%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B/" class="article-date">
  <time datetime="2022-08-02T06:55:01.000Z" itemprop="datePublished">2022-08-02</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/JUC/">JUC</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/0-00000005.png" alt="img"></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-JVM：再谈类的加载器"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
	
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/08/01/JVM%EF%BC%9A%E5%86%8D%E8%B0%88%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8/"
    >再谈类的加载器</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/08/01/JVM%EF%BC%9A%E5%86%8D%E8%B0%88%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8/" class="article-date">
  <time datetime="2022-08-01T08:33:26.000Z" itemprop="datePublished">2022-08-01</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/JVM/">JVM</a> / <a class="article-category-link" href="/categories/JVM/2-%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E7%AF%87/">2.字节码与类的加载篇</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>类加载器是JVM执行类加载机制的前提。</p>
<p><strong>ClassLoader的作用：</strong></p>
<p>ClassLoader是Java的核心组件，所有的Class都是由ClassLoader进行加载的，ClassLoader负责通过各种方式将Class信息的二进制数据流读入JVM内部，<strong>转换为一个与目标类对应的java.lang.Class对象实例</strong>。然后交给Java虚拟机进行链接、初始化等操作。因此，ClassLoader在整个装载阶段，<strong>只能影响到类的加载</strong>，而无法通过ClassLoader去改变类的链接和初始化行为。至于它是否可以运行，则由Execution Engine决定。</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220801165131938.png" alt="image-20220801165131938"></p>
<p><strong>大厂面试题</strong></p>
<p><strong>蚂蚁金服：</strong> </p>
<p>深入分析ClassLoader，双亲委派机制 </p>
<p>类加载器的双亲委派模型是什么？一面：双亲委派机制及使用原因 </p>
<p><strong>百度：</strong> </p>
<p>都有哪些类加载器，这些类加载器都加载哪些文件？ </p>
<p>手写一个类加载器Demo </p>
<p>Class的forName（“java.lang.String”）和Class的getClassLoader（）的Loadclass（“java.lang.String”）有什么区别？ </p>
<p><strong>腾讯：</strong> </p>
<p>什么是双亲委派模型？ </p>
<p>类加载器有哪些？ </p>
<p><strong>小米：</strong> </p>
<p>双亲委派模型介绍一下 </p>
<p><strong>滴滴：</strong> </p>
<p>简单说说你了解的类加载器一面：讲一下双亲委派模型，以及其优点 </p>
<p><strong>字节跳动：</strong> </p>
<p>什么是类加载器，类加载器有哪些？</p>
<p><strong>京东：</strong></p>
<p>类加载器的双亲委派模型是什么？</p>
<p>双亲委派机制可以打破吗？为什么</p>
<h2 id="类加载的分类"><a href="#类加载的分类" class="headerlink" title="类加载的分类"></a>类加载的分类</h2><p>类的加载分类：<strong>显式加载 vs 隐式加载</strong></p>
<p>class文件的显式加载与隐式加载的方式是指<strong>JVM加载class文件到内存的方式</strong>。</p>
<ul>
<li>显式加载指的是在代码中通过调用ClassLoader加载class对象，如直接使用Class.forName(name)或this.getClass().getClassLoader().loadClass()加载class对象。</li>
<li>隐式加载则是不直接在代码中调用ClassLoader的方法加载class对象，而是通过虚拟机自动加载到内存中，如在加载某个类的class文件时，该类的class文件中引用了另外一个类的对象，此时额外引用的类将通过JVM自动加载到内存中。</li>
</ul>
<p>在日常开发以上两种方式一般会混合使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//隐式加载</span></span><br><span class="line">User user=<span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line"><span class="comment">//显式加载，并初始化</span></span><br><span class="line">Class clazz=Class.forName(<span class="string">&quot;com.test.java.User&quot;</span>);</span><br><span class="line"><span class="comment">//显式加载，但不初始化</span></span><br><span class="line">ClassLoader.getSystemClassLoader().loadClass(<span class="string">&quot;com.test.java.Parent&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="类加载器的必要性"><a href="#类加载器的必要性" class="headerlink" title="类加载器的必要性"></a>类加载器的必要性</h2><p>一般情况下，Java开发人员并不需要在程序中显式地使用类加载器，但是了解类加载器的加载机制却显得至关重要。从以下几个方面说：</p>
<ul>
<li>避免在开发中遇到java.lang.ClassNotFoundException异常或java.lang.NoClassDefFoundError异常时，手足无措。只有了解类加载器的 加载机制才能够在出现异常的时候快速地根据错误异常日志定位问题和解决问题</li>
<li>需要支持类的动态加载或需要对编译后的字节码文件进行加解密操作时，就需要与类加载器打交道了。</li>
<li>开发人员可以在程序中编写自定义类加载器来重新定义类的加载规则，以便实现一些自定义的处理逻辑。</li>
</ul>
<h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><p><strong>何为类的唯一性？</strong></p>
<ul>
<li><strong>对于任意一个类，都需要由加载它的类加载器和这个类本身一同确认其在Java虚拟机中的唯一性。</strong></li>
<li>每一个类加载器，都拥有一个独立的类名称空间：<strong>比较两个类是否相等，只有在这两个类是由同一个类加载器加载的前提下才有意义</strong>。否则，即使这两个类源自同一个Class文件，被同一个虚拟机加载，只要加载他们的类加载器不同，那这两个类就必定不相等。</li>
</ul>
<p><strong>命名空间</strong></p>
<ul>
<li>每个类加载器都有自己的命名空间，命名空间由该加载器及所有的父加载器所加载的类组成 </li>
<li>在同一命名空间中，不会出现类的完整名字（包括类的包名）相同的两个类 </li>
<li>在不同的命名空间中，有可能会出现类的完整名字（包括类的包名）相同的两个类</li>
</ul>
<p>在大型应用中，我们往往借助这一特性，来运行同一个类的不同版本。</p>
<h2 id="类加载机制的基本特征"><a href="#类加载机制的基本特征" class="headerlink" title="类加载机制的基本特征"></a>类加载机制的基本特征</h2><ul>
<li><strong>双亲委派模型</strong>。但不是所有类加载都遵守这个模型，有的时候，启动类加载器所加载的类型，是可能要加载用户代码的，比如JDK内部的ServiceProvider&#x2F;ServiceLoader机制，用户可以在标准API框架上，提供自己的实现，JDK也需要提供些默认的参考实现。例如，Java中JNDI、JDBC、文件系统、Cipher等很多方面，都是利用的这种机制，这种情况就不会用双亲委派模型去加载，而是利用所谓的上下文加载器。</li>
<li><strong>可见性</strong>，子类加载器可以访问父加载器加载的类型，但是反过来是不允许的。不然，因为缺少必要的隔离，我们就没有办法利用类加载器去实现容器的逻辑。</li>
<li><strong>单一性</strong>，由于父加载器的类型对于子加载器是可见的，所以父加载器中加载过的类型，就不会在子加载器中重复加载。但是注意，类加载器“邻居”间，同一类型仍然可以被加载多次，因为互相并不可见。</li>
</ul>
<h2 id="类加载器之间的关系"><a href="#类加载器之间的关系" class="headerlink" title="类加载器之间的关系"></a>类加载器之间的关系</h2><p>Launcher类核心代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Launcher.ExtClassLoader var1;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    var1 = Launcher.ExtClassLoader.getExtClassLoader();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException var10) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InternalError</span>(<span class="string">&quot;Could not create extension class loader&quot;</span>, var10);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.loader = Launcher.AppClassLoader.getAppClassLoader(var1);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException var9) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InternalError</span>(<span class="string">&quot;Could not create application class loader&quot;</span>, var9);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Thread.currentThread().setContextClassLoader(<span class="built_in">this</span>.loader);</span><br></pre></td></tr></table></figure>

<ul>
<li>ExtClassLoader的Parent类是null</li>
<li>AppClassLoader的Parent类是ExtClassLoader</li>
<li>当前线程的ClassLoader是AppClassLoader</li>
</ul>
<p><strong>注意，这里的Parent类并不是Java语言意义上的继承关系，而是一种包含关系</strong></p>
<h1 id="类的加载器分类"><a href="#类的加载器分类" class="headerlink" title="类的加载器分类"></a>类的加载器分类</h1><ul>
<li>JVM支持两种类型的类加载器，分别为<strong>引导类加载器（Bootstrap ClassLoader）和自定义类加载器（User-Defined ClassLoader）</strong>。</li>
<li>从概念上来讲，自定义类加载器一般指的是程序中由开发人员自定义的一类类加载器，但是Java虚拟机规范却没有这么定义，而是将所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器。无论类加载器的类型如何划分，在程序中我们最常见的类加载器结构主要是如下情况：</li>
</ul>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220801170741523.png" alt="image-20220801170741523"></p>
<ul>
<li>除了顶层的启动类加载器外，其余的类加载器都应当有自己的“父类”加载器。</li>
<li>不同类加载器看似是继承（Inheritance）关系，实际上是<strong>包含关系</strong>。在下层加载器中，包含着上层加载器的引用。</li>
</ul>
<p>父类加载器和子类加载器的关系：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ClassLoader</span>&#123;</span><br><span class="line">    ClassLoader parent;<span class="comment">//父类加载器</span></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">ClassLoader</span><span class="params">(ClassLoader parent)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.parent = parent;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ParentClassLoader</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ParentClassLoader</span><span class="params">(ClassLoader parent)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(parent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ChildClassLoader</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ChildClassLoader</span><span class="params">(ClassLoader parent)</span>&#123; <span class="comment">//parent = new ParentClassLoader();</span></span><br><span class="line">        <span class="built_in">super</span>(parent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正是由于子类加载器中包含着父类加载器的引用，所以可以通过子类加载器的方法获取对应的父类加载器</p>
<p><strong>注意：</strong></p>
<p>启动类加载器通过C&#x2F;C++语言编写，而自定义类加载器都是由Java语言编写的，虽然扩展类加载器和应用程序类加载器是被jdk开发人员使用java语言来编写的，但是也是由java语言编写的，所以也被称为自定义类加载器</p>
<h2 id="引导类加载器"><a href="#引导类加载器" class="headerlink" title="引导类加载器"></a>引导类加载器</h2><p><strong><code>启动类加载器（引导类加载器，Bootstrap ClassLoader）</code></strong></p>
<ul>
<li>这个类加载使用C&#x2F;C++语言实现的，嵌套在JVM内部。 </li>
<li>它用来加载Java的核心库（JAVAHOME&#x2F;jre&#x2F;lib&#x2F;rt.jar或sun.boot.class.path路径下的内容）。用于提供JVM自身需要的类。 </li>
<li>并不继承自java.lang.ClassLoader，没有父加载器。 </li>
<li>出于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类 </li>
<li>加载扩展类和应用程序类加载器，并指定为他们的父类加载器。</li>
</ul>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220801171139803.png" alt="image-20220801171139803"></p>
<p>​				使用-XX:+TraceClassLoading参数得到。 </p>
<p>启动类加载器使用C++编写的？Yes！</p>
<ul>
<li>C&#x2F;C++：指针函数&amp;函数指针、C++支持多继承、更加高效</li>
<li>Java：由C演变而来，（C）–版，单继承</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;＊＊＊＊＊＊＊＊＊＊启动类加载器＊＊＊＊＊＊＊＊＊＊&quot;</span>);</span><br><span class="line"><span class="comment">// 获取BootstrapclassLoader能够加载的api的路径</span></span><br><span class="line">URL[] urLs = sun.misc.Launcher.getBootstrapcLassPath().getURLs();</span><br><span class="line"><span class="keyword">for</span> (URL element : urLs) &#123;</span><br><span class="line">    System.out.println(element.toExternalForm());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 从上面的路径中随意选择一个类，来看看他的类加载器是什么：引导类加载器</span></span><br><span class="line"><span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> java.security.Provider.class.getClassLoader();</span><br><span class="line">System.out.println(classLoader);</span><br></pre></td></tr></table></figure>

<p><strong>执行结果</strong></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220801171535415.png" alt="image-20220801171535415"></p>
<h2 id="扩展类加载器"><a href="#扩展类加载器" class="headerlink" title="扩展类加载器"></a>扩展类加载器</h2><p><strong><code>扩展类加载器（Extension ClassLoader）</code></strong></p>
<ul>
<li>Java语言编写，由sun.misc.Launcher$ExtClassLoader实现。 </li>
<li>继承于ClassLoader类 </li>
<li>父类加载器为启动类加载器 </li>
<li>从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的jre&#x2F;lib&#x2F;ext子目录下加载类库。如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;＊＊＊＊＊＊＊＊＊＊＊扩展类加载器＊＊＊＊＊＊＊＊＊＊＊&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">extDirs</span> <span class="operator">=</span>System.getProperty(<span class="string">&quot;java.ext.dirs&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (String path :extDirs.split( regex:<span class="string">&quot;;&quot;</span>))&#123;</span><br><span class="line">    System.out.println(path);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从上面的路径中随意选择一个类，来看看他的类加载器是什么：扩展类加载器</span></span><br><span class="line"><span class="type">lassLoader</span> <span class="variable">classLoader1</span> <span class="operator">=</span> sun.security.ec.CurveDB.class.getClassLoader();</span><br><span class="line">System.out.print1n(classLoader1); <span class="comment">//sun.misc. Launcher$ExtCLassLoader@1540e19d</span></span><br></pre></td></tr></table></figure>

<p><strong>执行结果</strong></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220801182018580.png" alt="image-20220801182018580"></p>
<h2 id="系统类加载器"><a href="#系统类加载器" class="headerlink" title="系统类加载器"></a>系统类加载器</h2><p><strong><code>应用程序类加载器（系统类加载器，AppClassLoader）</code></strong></p>
<ul>
<li>java语言编写，由sun.misc.Launcher$AppClassLoader实现</li>
<li>继承于ClassLoader类</li>
<li>父类加载器为扩展类加载器</li>
<li>它负责加载环境变量classpath或系统属性java.class.path 指定路径下的类库</li>
<li>应用程序中的类加载器默认是系统类加载器。</li>
<li>它是<strong>用户自定义类加载器的默认父加载器</strong></li>
<li>通过ClassLoader的getSystemClassLoader()方法可以获取到该类加载器</li>
</ul>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220801191221763.png" alt="image-20220801191221763"></p>
<h2 id="用户自定义类加载器"><a href="#用户自定义类加载器" class="headerlink" title="用户自定义类加载器"></a>用户自定义类加载器</h2><p><strong>用户自定义类加载器</strong> </p>
<ul>
<li>在Java的日常应用程序开发中，类的加载几乎是由上述3种类加载器相互配合执行的。在必要时，我们还可以自定义类加载器，来定制类的加载方式。</li>
<li>体现Java语言强大生命力和巨大魅力的关键因素之一便是，Java开发者可以自定义类加载器来实现类库的动态加载，加载源可以是本地的JAR包，也可以是网络上的远程资源。</li>
<li><strong>通过类加载器可以实现非常绝妙的插件机制</strong>，这方面的实际应用案例举不胜举。例如，著名的OSGI组件框架，再如Eclipse的插件机制。类加载器为应用程序提供了一种动态增加新功能的机制，这种机制无须重新打包发布应用程序就能实现。</li>
<li>同时，<strong>自定义加载器能够实现应用隔离</strong>，例如Tomcat，Spring等中间件和组件框架都在内部实现了自定义的加载器，并通过自定义加载器隔离不同的组件模块。这种机制比C&#x2F;C程序要好太多，想不修改C&#x2F;C程序就能为其新增功能，几乎是不可能的，仅仅一个兼容性便能阻挡住所有美好的设想。</li>
<li>自定义类加载器通常需要继承于ClassLoader。</li>
</ul>
<h1 id="测试不同的类的加载器"><a href="#测试不同的类的加载器" class="headerlink" title="测试不同的类的加载器"></a>测试不同的类的加载器</h1><p>每个Class对象都会包含一个定义它的ClassLoader的一个引用。</p>
<p><strong>获取ClassLoader的途径</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获得当前类的ClassLoader</span></span><br><span class="line">clazz.getClassLoader()</span><br><span class="line"><span class="comment">// 获得当前线程上下文的ClassLoader</span></span><br><span class="line">Thread.currentThread().getContextClassLoader()</span><br><span class="line"><span class="comment">// 获得系统的ClassLoader</span></span><br><span class="line">ClassLoader.getSystemClassLoader()</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong></p>
<ul>
<li>站在程序的角度看，引导类加载器与另外两种类加载器（系统类加载器和扩展类加载器）并不是同一个层次意义上的加 载器，引导类加载器是使用C++语言编写而成的，而另外两种类加载器则是使用Java语言编写而成的。由于引导类加载 器压根儿就不是一个Java类，因此在Java程序中只能打印出空值。</li>
<li>数组类的Class对象，不是由类加载器去创建的，而是在Java运行期JVM根据需要自动创建的。对于数组类的类加载器 来说，是通过Class.getClassLoader()返回的，与数组当中元素类型的类加载器是一样的；如果数组当中的元素类型 是基本数据类型，数组类是没有类加载器的。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 运行结果：null</span></span><br><span class="line">String[] strArr = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">6</span>];</span><br><span class="line">System.out.println(strArr.getClass().getClassLoader());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果：sun．misc．Launcher＄AppCLassLoader＠18b4aac2</span></span><br><span class="line">ClassLoaderTest[] test=<span class="keyword">new</span> <span class="title class_">ClassLoaderTest</span>[<span class="number">1</span>];</span><br><span class="line">System.out.println(test.getClass().getClassLoader());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果：null</span></span><br><span class="line"><span class="type">int</span>[]ints =<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">System.out.println(ints.getClass().getClassLoader());</span><br></pre></td></tr></table></figure>

<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassLoaderTest1</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//获取系统该类加载器</span></span><br><span class="line">        ClassLoader systemClassLoader=ClassLoader.getSystemCLassLoader();</span><br><span class="line">        System.out.print1n(systemClassLoader);<span class="comment">//sun.misc.Launcher$AppCLassLoader@18b4aac2</span></span><br><span class="line">        <span class="comment">//获取扩展类加载器</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">extClassLoader</span> <span class="operator">=</span>systemClassLoader.getParent();</span><br><span class="line">        System.out.println(extClassLoader);<span class="comment">//sun.misc. Launcher$ExtCLassLoader@1540e19d</span></span><br><span class="line">        <span class="comment">//试图获取引导类加载器：失败</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">bootstrapClassLoader</span> <span class="operator">=</span>extClassLoader.getParent();</span><br><span class="line">        System.out.print1n(bootstrapClassLoader);<span class="comment">//null</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//##################################</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span>Class.forName(<span class="string">&quot;java.lang.String&quot;</span>).getClassLoader();</span><br><span class="line">            System.out.println(classLoader);</span><br><span class="line">            <span class="comment">//自定义的类默认使用系统类加载器</span></span><br><span class="line">            ClassLoader classLoader1=Class.forName(<span class="string">&quot;com.atguigu.java.ClassLoaderTest1&quot;</span>).getClassLoader();</span><br><span class="line">            System.out.println(classLoader1);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//关于数组类型的加载：使用的类的加载器与数组元素的类的加载器相同</span></span><br><span class="line">            String[] arrstr = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">10</span>];</span><br><span class="line">            System.out.println(arrstr.getClass().getClassLoader());<span class="comment">//null：表示使用的是引导类加载器</span></span><br><span class="line">                </span><br><span class="line">            ClassLoaderTest1[] arr1 =<span class="keyword">new</span> <span class="title class_">ClassLoaderTest1</span>[<span class="number">10</span>];</span><br><span class="line">            System.out.println(arr1.getClass().getClassLoader());<span class="comment">//sun.misc. Launcher$AppcLassLoader@18b4aac2</span></span><br><span class="line">            </span><br><span class="line">            <span class="type">int</span>[] arr2 = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">            System.out.println(arr2.getClass().getClassLoader());<span class="comment">//null:不需要类的加载器</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="ClassLoader源码解析"><a href="#ClassLoader源码解析" class="headerlink" title="ClassLoader源码解析"></a>ClassLoader源码解析</h1><p><strong>ClassLoader与现有类的关系：</strong></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220801192113919.png" alt="image-20220801192113919"></p>
<p>除了以上虚拟机自带的加载器外，用户还可以定制自己的类加载器。Java提供了抽象类java.lang.ClassLoader，所有用户自定义的类加载器都应该继承ClassLoader类。</p>
<h2 id="ClassLoader的主要方法"><a href="#ClassLoader的主要方法" class="headerlink" title="ClassLoader的主要方法"></a>ClassLoader的主要方法</h2><p>抽象类ClassLoader的主要方法：（内部没有抽象方法）</p>
<ol>
<li>返回该类加载器的超类加载器</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> ClassLoader <span class="title function_">getParent</span><span class="params">()</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>加载名称为name的类，返回结果为java.lang.Class类的实例。如果找不到类，则返回 ClassNotFoundException异常。该方法中的逻辑就是<strong>双亲委派模式的实现</strong>。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试代码：</span></span><br><span class="line">ClassLoader.getSyatemClassLoader().loadClass(<span class="string">&quot;com.ysy.User&quot;</span>) ;</span><br><span class="line"></span><br><span class="line"><span class="comment">//涉及到对如下方法的调用</span></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="type">boolean</span> resolve)<span class="comment">//resolve: true-加载class的同时进行解析操作</span></span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;<span class="comment">//同步操作，保证只能加载一次</span></span><br><span class="line">        <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">        <span class="comment">//首先，在缓存中查找是否已经加载同名的类</span></span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">t0</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//获取当前类加载器的父类加载器</span></span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//如果存在父类加载器，则调用父类加载器进行类的加载</span></span><br><span class="line">                    c = parent.loadClass(name, <span class="literal">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//parent==null：父类加载器是引导类加载器</span></span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">            &#125;</span><br><span class="line">加载器</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;<span class="comment">//当前类的加载器的父类未加载此类 or 当前类的加载器未加载此类</span></span><br><span class="line">                <span class="comment">// If still not found, then invoke findClass in order to find the class.</span></span><br><span class="line">                <span class="comment">// 调用当前ClassLoader的findClass()</span></span><br><span class="line">                <span class="type">long</span> <span class="variable">t1</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">                c = findClass(name);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;<span class="comment">//是否进行解析操作</span></span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>查找二进制名称为name的类，返回结果为java.lang.Class类的实例。<strong>这是一个受保护的方法</strong>，JVM鼓励我们重写此方法，需要自定义加载器遵循双亲委托机制，该方法会在检查完父类加载器之后被loadClass()方法调用。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException</span><br></pre></td></tr></table></figure>

<ul>
<li>在JDK1.2之前，在自定义类加载时，总会去继承ClassLoader类并重写loadClass方法，从而实现自定义的类加载类。但是在JDK1.2之后已不再建议用户去覆盖loadClass()方法，而是建议把自定义的类加载逻辑写在findClass()方法中，从前面的分析可知，findClass()方法是在loadClass()方法中被调用的，当loadClass()方法中父加载器加载失败后，则会调用自己的findClass()方法来完成类加载，这样就可以保证自定义的类加载器也符合双亲委托模式。</li>
<li>需要注意的是ClassLoader类中并没有实现findClass()方法的具体代码逻辑，取而代之的是抛出ClassNotFoundException异常，同时应该知道的是findClass方法通常是和defineClass方法一起使用的。<strong>一般情况下，在自定义类加载器时，会直接覆盖ClassLoader的findClass()方法并编写加载规则，取得要加载类的字节码后转换成流，然后调用defineClass()方法生成类的Class对象。</strong></li>
</ul>
<ol start="4">
<li>根据给定的字节数组b转换为Class的实例，off和len参数表示实际Class信息在byte数组中的位置和长度，其中byte数组b是ClassLoader从外部获取的。这是受保护的方法，只有在自定义ClassLoader子类中可以使用。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Class&lt;?&gt; defineClass(String name, <span class="type">byte</span>[] b,<span class="type">int</span> off,<span class="type">int</span> len)</span><br></pre></td></tr></table></figure>

<ul>
<li>defineClass()方法是用来将byte字节流解析成JVM能够识别的Class对象（ClassLoader中已实现该方法逻辑），通过这个方法不仅能够通过class文件实例化class对象，也可以通过其他方式实例化class对象，如通过网络接收一个类的字节码，然后转换为byte字节流创建对应的Class对象。</li>
<li><strong>defineClass()方法通常与findClass()方法一起使用，一般情况下，在自定义类加载器时，会直接覆盖ClassLoader的findClass()方法并编写加载规则，取得要加载类的字节码后转换成流，然后调用defineClass()方法生成类的Class对象</strong></li>
</ul>
<p><strong>简单举例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="comment">// 获取类的字节数组</span></span><br><span class="line">    <span class="type">byte</span>[] classData =getClassData(name);</span><br><span class="line">    <span class="keyword">if</span> (classData == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassNotFoundException</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//使用defineClass生成class对象</span></span><br><span class="line">        <span class="keyword">return</span> defineClass(name,classData,θ,classData.length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>链接指定的一个Java类。使用该方法可以使用类的Class对象创建完成的同时也被解析。前面我们说链接阶段主要是对字节码进行验证，为类变量分配内存并设置初始值同时将字节码文件中的符号引用转换为直接引用。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">resolveClass</span><span class="params">(Class&lt;?&gt; c)</span></span><br></pre></td></tr></table></figure>

<ol start="6">
<li>查找名称为name的已经被加载过的类，返回结果为java.lang.Class类的实例。这个方法是final方法，无法被修改。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Class&lt;?&gt; findLoadedClass(String name)</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>它也是一个ClassLoader的实例，这个字段所表示的ClassLoader也称为这个ClassLoader的双亲。在类加载的过程中，ClassLoader可能会将某些请求交予自己的双亲处理。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ClassLoader parent;</span><br></pre></td></tr></table></figure>

<h2 id="SecureClassLoader与URLClassLoader"><a href="#SecureClassLoader与URLClassLoader" class="headerlink" title="SecureClassLoader与URLClassLoader"></a>SecureClassLoader与URLClassLoader</h2><ul>
<li>接着SecureClassLoader扩展了ClassLoader，新增了几个与使用相关的代码源（对代码源的位置及其证书的验证）和权限定义类验证（主要指对class源码的访问权限）的方法，一般我们不会直接跟这个类打交道，更多是与它的子类URLClassLoader有所关联。</li>
<li>前面说过，ClassLoader是一个抽象类，很多方法是空的没有实现，比如findClass()、findResource()等。而URLClassLoader这个实现类为这些方法提供了具体的实现。并新增了URLClassPath类协助取得Class字节码流等功能。<strong>在编写自定义类加载器时，如果没有太过于复杂的需求，可以直接继承URLClassLoader类</strong>，这样就可以避免自己去编写findClass()方法及其获取字节码流的方式，使自定义类加载器编写更加简洁。</li>
</ul>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220801195807846.png" alt="image-20220801195807846"></p>
<h2 id="ExtClassLoader与AppClassLoader"><a href="#ExtClassLoader与AppClassLoader" class="headerlink" title="ExtClassLoader与AppClassLoader"></a>ExtClassLoader与AppClassLoader</h2><ul>
<li><p>了解完URLClassLoader后接着看看剩余的两个类加载器，即拓展类加载器ExtClassLoader和系统类加载器AppClassLoader，这两个类都继承自URLClassLoader，是sun.misc.Launcher的静态内部类。</p>
</li>
<li><p>sun.misc.Launcher主要被系统用于启动主应用程序，ExtClassLoader和AppClassLoader都是由sun.misc.Launcher创建的，其类主要类结构如下：</p>
</li>
</ul>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220801200002661.png" alt="image-20220801200002661"></p>
<ul>
<li>我们发现ExtClassLoader并没有重写loadClass()方法，这足矣说明其<strong>遵循双亲委派模式</strong>，而AppClassLoader重载了loadClass()方法，但最终调用的还是父类loadClass()方法，因此依然遵守双亲委派模式。</li>
</ul>
<h2 id="Class-forName-与ClassLoader-loadClass"><a href="#Class-forName-与ClassLoader-loadClass" class="headerlink" title="Class.forName()与ClassLoader.loadClass()"></a>Class.forName()与ClassLoader.loadClass()</h2><p><strong>Class.forName()</strong></p>
<ul>
<li><p>Class.forName()：是一个<strong>静态方法</strong>，最常用的是Class.forName(String className); </p>
</li>
<li><p>根据传入的类的全限定名返回一个Class对象。<strong>该方法在将Class文件加载到内存的同时，会执行类的初始化</strong>。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class.forName(<span class="string">&quot;com.atguigu.java.Helloworld&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>ClassLoader.loadClass()</strong></p>
<ul>
<li><p>ClassLoader.loadClass()：这是一个实例方法，需要一个ClassLoader对象来调用该方法。 </p>
</li>
<li><p><strong>该方法将Class文件加载到内存时，并不会执行类的初始化，直到这个类第一次使用时才进行初始化</strong>。该方法因为需要得到一个ClassLoader对象，所以可以根据需要指定使用哪个类加载器。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Classloader</span> <span class="variable">cl</span> <span class="operator">=</span> ......; cl.loadClass(<span class="string">&quot;com.atguigu.java.Helloworld&quot;</span>);</span><br></pre></td></tr></table></figure>

<h1 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h1><h2 id="定义与本质"><a href="#定义与本质" class="headerlink" title="定义与本质"></a>定义与本质</h2><p>类加载器用来把类加载到Java虚拟机中。从JDK1.2版本开始，类的加载过程采用双亲委派机制，这种机制能更好地保证Java平台的安全。</p>
<p><strong>定义</strong></p>
<p>如果一个类加载器在接到加载类的请求时，它首先不会自己尝试去加载这个类，而是把这个请求任务委托给父类加载器去完成，依次递归，如果父类加载器可以完成类加载任务，就成功返回。只有父类加载器无法完成此加载任务时，才自己去加载。</p>
<p><strong>本质</strong></p>
<p>规定了类加载的顺序是：<strong>引导类加载器先加载，若加载不到，由扩展类加载器加载，若还加载不到，才会由系统类加载器或自定义的类加载器进行加载。</strong></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220801200314590.png" alt="image-20220801200314590"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220801200333015.png" alt="image-20220801200333015"></p>
<h2 id="优势与劣势"><a href="#优势与劣势" class="headerlink" title="优势与劣势"></a>优势与劣势</h2><p><strong>双亲委派机制优势</strong> </p>
<ul>
<li>避免类的重复加载，确保一个类的全局唯一性 ，<strong>Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关系可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。</strong></li>
<li>保护程序安全，防止核心API被随意篡改</li>
</ul>
<p><strong>代码支持</strong></p>
<p>双亲委派机制在java.lang.ClassLoader.loadClass(String，boolean)接口中体现。该接口的逻辑如下：</p>
<ol>
<li>先在当前加载器的缓存中查找有无目标类，如果有，直接返回。</li>
<li>判断当前加载器的父加载器是否为空，如果不为空，则调用parent.loadClass(name，false)接口进行加载。</li>
<li>反之，如果当前加载器的父类加载器为空，则调用findBootstrapClassorNull(name)接口，让引导类加载器进行加载。</li>
<li>如果通过以上3条路径都没能成功加载，则调用findClass(name)接口进行加载。该接口最终会调用java.lang.ClassLoader接口的defineClass系列的native接口加载目标Java类。</li>
</ol>
<p>双亲委派的模型就隐藏在这第2和第3步中。</p>
<p><strong>举例</strong></p>
<p>假设当前加载的是java.lang.Object这个类，很显然，该类属于JDK中核心得不能再核心的一个类，因此一定只能由引导类加载器进行加载。当]VM准备加载javaJang.Object时，JVM默认会使用系统类加载器去加载，按照上面4步加载的逻辑，在第1步从系统类的缓存中肯定查找不到该类，于是进入第2步。由于从系统类加载器的父加载器是扩展类加载器，于是扩展类加载器继续从第1步开始重复。由于扩展类加载器的缓存中也一定查找不到该类，因此进入第2步。扩展类的父加载器是null，因此系统调用findClass（String），最终通过引导类加载器进行加载。</p>
<p><strong>思考</strong></p>
<p>如果在自定义的类加载器中重写java.lang.ClassLoader.loadClass(String)或java.lang.ClassLoader.loadclass(String，boolean)方法，抹去其中的双亲委派机制，仅保留上面这4步中的第l步与第4步，那么是不是就能够加载核心类库了呢？</p>
<p>这也不行！因为<strong>JDK还为核心类库提供了一层保护机制</strong>。不管是自定义的类加载器，还是系统类加载器抑或扩展类加载器，最终都<strong>必须调用 java.lang.ClassLoader.defineclass(String，byte[]，int，int，ProtectionDomain)方法</strong>，而<strong>该方法会执行preDefineClass()接口，该接口中提供了对JDK核心类库的保护。</strong></p>
<p><strong>弊端</strong></p>
<p>检查类是否加载的委托过程是单向的，这个方式虽然从结构上说比较清晰，使各个ClassLoader的职责非常明确，但是同时会带来一个问题，即<strong>顶层的ClassLoader无法访问底层的ClassLoader所加载的类。</strong></p>
<p>通常情况下，启动类加载器中的类为系统核心类，包括一些重要的系统接口，而在应用类加载器中，为应用类。按照这种模式，<strong>应用类访问系统类自然是没有问题，但是系统类访问应用类就会出现问题</strong>。比如在系统类中提供了一个接口，该接口需要在应用类中得以实现，该接口还绑定一个工厂方法，用于创建该接口的实例，而接口和工厂方法都在启动类加载器中。这时，就会出现该工厂方法无法创建由应用类加载器加载的应用实例的问题。</p>
<p><strong>结论</strong></p>
<p><strong>由于Java虚拟机规范并没有明确要求类加载器的加载机制一定要使用双亲委派模型，只是建议采用这种方式而已。</strong>比如在Tomcat中，类加载器所采用的加载机制就和传统的双亲委派模型有一定区别，当缺省的类加载器接收到一个类的加载任务时，首先会由它自行加载，当它加载失败时，才会将类的加载任务委派给它的超类加载器去执行，这同时也是Serylet规范推荐的一种做法。</p>
<h2 id="破坏双亲委派机制"><a href="#破坏双亲委派机制" class="headerlink" title="破坏双亲委派机制"></a>破坏双亲委派机制</h2><p>双亲委派模型并不是一个具有强制性约束的模型，而是Java设计者推荐给开发者们的类加载器实现方式。 </p>
<p>在Java的世界中大部分的类加载器都遵循这个模型，但也有例外的情况，直到Java模块化出现为止，双亲委派模型主要出现过3次较大规模“被破坏”的情况。 </p>
<p><strong>第一次破坏双亲委派机制</strong> </p>
<p>双亲委派模型的第一次“被破坏”其实发生在双亲委派模型出现之前一—即JDK1.2面世以前的“远古”时代。 由于双亲委派模型在JDK 1.2之后才被引入，但是类加载器的概念和抽象类java.lang.ClassLoader则在Java的第一个版本中就已经存在，面对经存在的用户自定义类加载器的代码，Java设计者们引入双亲委派模型时不得不做出一些妥协，<strong>为了兼容这些已有代码，无法再以技术手段避免loadClass()被子类覆盖的可能性</strong>，只能在JDK1.2之后的java.lang.ClassLoader中添加一个新的protected方法findClass()，并引导用户编写的类加载逻辑时尽可能去重写这个方法，而不是在loadClass()中编写代码。上节我们已经分析过loadClass()方法，双亲委派的具体逻辑就实现在这里面，按照loadClass()方法的逻辑，如果父类加载失败，会自动调用自己的findClass()方法来完成加载，这样既不影响用户按照自己的意愿去加载类，又可以保证新写出来的类加载器是符合双亲委派规则的。</p>
<p><strong>第二次破坏双亲委派机制：线程上下文类加载器</strong></p>
<p>双亲委派模型的第二次“被破坏”是由这个模型自身的缺陷导致的，双亲委派很好地解决了各个类加载器协作时基础类型的一致性问题（<strong>越基础的类由越上层的加载器进行加载</strong>），基础类型之所以被称为“基础”，是因为它们总是作为被用户代码继承、调用的API存在，但程序设计往往没有绝对不变的完美规则，<strong>如果有基础类型又要调用回用户的代码，那该怎么办呢？</strong></p>
<p>这并非是不可能出现的事情，一个典型的例子便是JNDI服务，JNDI现在已经是Java的标准服务，它的代码由启动类加载器来完成加载（在JDK 1.3时加入到rt.jar的），肯定属于Java中很基础的类型了。但JNDI存在的目的就是对资源进行查找和集中管理，它需要调用由其他厂商实现并部署在应用程序的ClassPath下的JNDI服务提供者接口（Service Provider Interface，SPI）的代码，现在问题来了，<strong>启动类加载器是绝不可能认识、加载这些代码的，那该怎么办？</strong>（SPI：在Java平台中，通常把核心类rt.jar中提供外部服务、可由应用层自行实现的接口称为SPI） </p>
<p>为了解决这个困境，Java的设计团队只好引入了一个不太优雅的设计：<strong>线程上下文类加载器（Thread Context ClassLoader）</strong>。这个类加载器可以通过java.lang.Thread类的setContextClassLoader()方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过的话，那这个类加载器默认就是应用程序类加载器。 </p>
<p>有了线程上下文类加载器，程序就可以做一些“舞弊”的事情了。JNDI服务使用这个线程上下文类加载器去加载所需的SPI服务代码，<strong>这是一种父类加载器去请求子类加载器完成类加载的行为，这种行为实际上是打通了双亲委派模型的层次结构来逆向使用类加载器，已经违背了双亲委派模型的一般性原则</strong>，但也是无可奈何的事情。 例如JNDI、JDBC、JCE、JAXB和JBI等。不过，当SPI的服务提供者多于一个的时候，代码就只能根据具体提供者的类型来硬编码判断，为了消除这种极不优雅的实现方式，在JDK6时，JDK提供了java.util.ServiceLoader类，以META-INF&#x2F;services中的配置信息，辅以责任链模式，这才算是给SPI的加载提供了一种相对合理的解决方案。</p>
<p> <img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220801201949469.png" alt="image-20220801201949469"></p>
<p>默认上下文加载器就是应用类加载器，这样以上下文加载器为中介，使得启动类加载器中的代码也可以访问应用类加载器中的类。</p>
<p><strong>第三次破坏双亲委派机制</strong></p>
<p>双亲委派模型的第三次“被破坏”是由于用户对程序动态性的追求而导致的。如：**代码热替换(Hot Swap)、模块热部署(Hot Deployment)**等</p>
<p>IBM公司主导的JSR-291(即OSGiR4.2)实现模块化热部署的关键是它自定义的类加载器机制的实现，每一个程序模块(osGi中称为Bundle)都有一个自己的类加载器，当需要更换一个Bundle时，就把Bund1e连同类加载器一起换掉以实现代码的热替换。在oSGi环境下，类加载器不再双亲委派模型推荐的树状结构，而是进一步发展为更加复杂的<strong>网状结构</strong>。</p>
<p>当收到类加载请求时，OSGi将按照下面的顺序进行类搜索：</p>
<ol>
<li>*<em>将以java.<em>开头的类，委派给父类加载器加载。</em></em></li>
<li><strong>否则，将委派列表名单内的类，委派给父类加载器加载。</strong></li>
<li>否则，将Import列表中的类，委派给Export这个类的Bundle的类加载器加载。</li>
<li>否则，查找当前Bundle的ClassPath，使用自己的类加载器加载。</li>
<li>否则，查找类是否在自己的Fragment Bundle中，如果在，则委派给Fragment Bundle的类加载器加载。</li>
<li>否则，查找Dynamic Import列表的Bundle，委派给对应Bund1e的类加载器加载。</li>
<li>否则，类查找失败。</li>
</ol>
<p>说明：只有开头两点仍然符合双亲委派模型的原则，其余的类查找都是在平级的类加载器中进行的</p>
<p>小结：这里，我们使用了“被破坏”这个词来形容上述不符合双亲委派模型原则的行为，但这里“被破坏”并不一定是带有贬义的。只要有明确的目的和充分的理由，突破旧有原则无疑是一种创新。</p>
<p>正如：OSGi中的类加载器的设计不符合传统的双亲委派的类加载器架构，且业界对其为了实现热部署而带来的额外的高复杂度还存在不少争议，但对这方面有了解的技术人员基本还是能达成一个共识，认为<strong>OSGi中对类加载器的运用是值得学习的，完全弄懂了OSGi的实现，就算是掌握了类加载器的精粹。</strong></p>
<h2 id="热替换的实现"><a href="#热替换的实现" class="headerlink" title="热替换的实现"></a>热替换的实现</h2><p>热替换是指在程序的运行过程中，不停止服务，只通过替换程序文件来修改程序的行为。<strong>热替换的关键需求在于服务不能中断，修改必须立即表现正在运行的系统之中。</strong>基本上大部分脚本语言都是天生支持热替换的，比如：PHP，只要替换了PHP源文件，这种改动就会立即生效，而无需重启Web服务器。</p>
<p>但对Java来说，热替换并非天生就支持，如果一个类已经加载到系统中，通过修改类文件，并无法让系统再来加载并重定义这个类。因此，在Java中实现这一功能的一个可行的方法就是灵活运用ClassLoader。</p>
<p>注意：由不同ClassLoader加载的同名类属于不同的类型，不能相互转换和兼容。即两个不同的ClassLoader加载同一个类，在虚拟机内部，会认为这2个类是完全不同的。</p>
<p>根据这个特点，可以用来模拟热替换的实现，基本思路如下图所示：</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220801202415612.png" alt="image-20220801202415612"></p>
<h1 id="沙箱安全机制"><a href="#沙箱安全机制" class="headerlink" title="沙箱安全机制"></a>沙箱安全机制</h1><p>沙箱安全机制 </p>
<ul>
<li>保证程序安全</li>
<li>保护Java原生的JDK代码</li>
</ul>
<p><strong>Java安全模型的核心就是Java沙箱（sandbox）</strong>。什么是沙箱？沙箱是一个限制程序运行的环境。 </p>
<p>沙箱机制就是<strong>将Java代码限定在虚拟机（JVM）特定的运行范围中，并且严格限制代码对本地系统资源访问。</strong>通过这样的措施来保证对代码的有限隔离，防止对本地系统造成破坏。 </p>
<p><strong>沙箱主要限制系统资源访问</strong>，那系统资源包括什么？CPU、内存、文件系统、网络。不同级别的沙箱对这些资源访问的限制也可以不一样。 </p>
<p>所有的Java程序运行都可以指定沙箱，可以定制安全策略。</p>
<h2 id="JDK1-0时期"><a href="#JDK1-0时期" class="headerlink" title="JDK1.0时期"></a>JDK1.0时期</h2><p>在Java中将执行程序分成本地代码和远程代码两种，本地代码默认视为可信任的，而远程代码则被看作是不受信的。对于授信的本地代码，可以访问一切本地资源。而对于非授信的远程代码在早期的Java实现中，安全依赖于<strong>沙箱（Sandbox）机制</strong>。如下图所示JDK1.0安全模型</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220801202834014.png" alt="image-20220801202834014"></p>
<h2 id="JDK1-1时期"><a href="#JDK1-1时期" class="headerlink" title="JDK1.1时期"></a>JDK1.1时期</h2><p>JDK1.0中如此严格的安全机制也给程序的功能扩展带来障碍，比如当用户希望远程代码访问本地系统的文件时候，就无法实现。</p>
<p>因此在后续的Java1.1版本中，针 对安全机制做了改进，增加了<strong>安全策略</strong>。允许用户指定代码对本地资源的访问权限。</p>
<p>如下图所示JDK1.1安全模型</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220801202852367.png" alt="image-20220801202852367"></p>
<h2 id="JDK1-2时期"><a href="#JDK1-2时期" class="headerlink" title="JDK1.2时期"></a>JDK1.2时期</h2><p>在Java1.2版本中，再次改进了安全机制，增加了<strong>代码签名</strong>。不论本地代码或是远程代码，都会按照用户的安全策略设定，由类加载器加载到虚拟机中权限不同的运行空间，来实现差异化的代码执行权限控制。如下图所示JDK1.2安全模型：</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220801202951518.png" alt="image-20220801202951518"></p>
<h2 id="JDK1-6时期"><a href="#JDK1-6时期" class="headerlink" title="JDK1.6时期"></a>JDK1.6时期</h2><p>当前最新的安全机制实现，则引入了<strong>域</strong>（Domain）的概念。</p>
<p> 虚拟机会把所有代码加载到不同的系统域和应用域。<strong>系统域部分专门负责与关键资源进行交互，</strong>而各个应用域部分则通过系统域的部分代理来对各种需要的资源进行访问。虚拟机中不同的受保护域（Protected Domain），对应不一样的权限（Permission）。存在于不同域中的类文件就具有了当前域的全部权限，如下图所示，最新的安全模型（jdk1.6）</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220801203023638.png" alt="image-20220801203023638"></p>
<h1 id="自定义类的加载器"><a href="#自定义类的加载器" class="headerlink" title="自定义类的加载器"></a>自定义类的加载器</h1><h2 id="为什么要自定义类加载器？"><a href="#为什么要自定义类加载器？" class="headerlink" title="为什么要自定义类加载器？"></a>为什么要自定义类加载器？</h2><ul>
<li><p>隔离加载类</p>
<p>在某些框架内进行中间件与应用的模块隔离，把类加载到不同的环境。比如:阿里内某容器框架通过自定义类加载器确保应用中依赖的jar包不会影响到中间件运行时使用的jar包。再比如:Tomcat这类Web应用服务器，内部自定义了好几种类加载器，用于隔离同一个Web应用服务器上的不同应用程序。（类的仲裁–&gt;类冲突）</p>
</li>
<li><p>修改类加载的方式</p>
<p>类的加载模型并非强制，除Bootstrap外，其他的加载并非一定要引入，或者根据实际情况在某个时间点进行按需进行动态加载  </p>
</li>
<li><p>扩展加载源 </p>
<p>比如从数据库、网络、甚至是电视机机顶盒进行加载 </p>
</li>
<li><p>防止源码泄漏</p>
<p>Java代码容易被编译和篡改，可以进行编译加密。那么类加载也需要自定义，还原加密的字节码。</p>
</li>
</ul>
<h2 id="常见的场景"><a href="#常见的场景" class="headerlink" title="常见的场景"></a>常见的场景</h2><ul>
<li><p>实现类似进程内隔离，类加载器实际上用作不同的命名空间，以提供类似容器、模块化的效果。例如，两个模块依赖于某个类库的不同版本，如果分别被不同的容器加载，就可以互不干扰。这个方面的集大成者是JavaEE和OSGI、JPMS等框架。</p>
</li>
<li><p>应用需要从不同的数据源获取类定义信息，例如网络数据源，而不是本地文件系统。或者是需要自己操纵字节码，动态修改或者生成类型。</p>
</li>
</ul>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>在一般情况下，使用不同的类加载器去加载不同的功能模块，会提高应用程序的安全性。但是，如果涉及Java类型转换，则加载器反而容易产生不美好的事情。在做Java类型转换时，只有两个类型都是由同一个加载器所加载，才能进行类型转换，否则转换时会发生异常。</p>
<h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><p>Java提供了抽象类java.lang.ClassLoader，所有用户自定义的类加载器都应该继承ClassLoader类。</p>
<p>在自定义ClassLoader的子类时候，我们常见的会有两种做法:</p>
<ul>
<li>方式一:重写loadClass()方法</li>
<li>方式二:重写findclass()方法</li>
</ul>
<p><strong>对比</strong></p>
<p>这两种方法本质上差不多，毕竟loadClass()也会调用findClass()，但是从逻辑上讲我们最好不要直接修改loadClass()的内部逻辑。建议的做法是只在findClass()里重写自定义类的加载方法，根据参数指定类的名字，返回对应的Class对象的引用。</p>
<ul>
<li><p>loadclass()这个方法是实现双亲委派模型逻辑的地方，擅自修改这个方法会导致模型被破坏，容易造成问题。<strong>因此我们最好是在双亲委派模型框架内进行小范围的改动，不破坏原有的稳定结构。</strong>同时，也避免了自己重写loadClass()方法的过程中必须写双亲委托的重复代码，从代码的复用性来看，不直接修改这个方法始终是比较好的选择。</p>
</li>
<li><p>当编写好自定义类加载器后，便可以在程序中调用loadClass()方法来实现类加载操作。</p>
</li>
</ul>
<p><strong>说明</strong></p>
<ul>
<li>其父类加载器是系统类加载器</li>
<li>JVM中的所有类加载都会使用java.lang.ClassLoader.loadClass(String)接口(自定义类加载器并重写java.lang.ClassLoader.loadClass(String)接口的除外)，连JDK的核心类库也不能例外。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClassLoader</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String byteCodePath;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyClassLoader</span><span class="params">(String byteCodePath)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.byteCodePath = byteCodePath;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyClassLoader</span><span class="params">(ClassLoader parent, String byteCodePath)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(parent);</span><br><span class="line">        <span class="built_in">this</span>.byteCodePath = byteCodePath;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String className) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//获取字节码的完整路径</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> byteCodePath + className + <span class="string">&quot;.class&quot;</span>;</span><br><span class="line">            <span class="comment">//获取一个输入流</span></span><br><span class="line">            bis = <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(fileName));</span><br><span class="line">            <span class="comment">//获取一个输出流</span></span><br><span class="line">            baos = <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//具体读入数据并写出的过程</span></span><br><span class="line">            <span class="type">int</span> len;</span><br><span class="line">            <span class="type">byte</span>[] data = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">while</span> ((len = bis.read(data)) != -<span class="number">1</span>)&#123;</span><br><span class="line">                baos.write(data, <span class="number">0</span>, len);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//获取内存中的完整的字节数组的数据</span></span><br><span class="line">            <span class="type">byte</span>[] byteCodes = baos.toByteArray();</span><br><span class="line">            <span class="comment">//调用defineClass方法，将字节数组的数据转换为Class的实例</span></span><br><span class="line">            Class&lt;?&gt; clazz = defineClass(<span class="literal">null</span>, byteCodes, <span class="number">0</span>, byteCodes.length);</span><br><span class="line">            <span class="keyword">return</span> clazz;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(baos != <span class="literal">null</span>)</span><br><span class="line">                    baos.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(bis != <span class="literal">null</span>)</span><br><span class="line">                    bis.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClassLoaderTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyClassLoader</span> <span class="variable">myClassLoader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClassLoader</span>(<span class="string">&quot;d:/&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class&lt;?&gt; clazz = myClassLoader.loadClass(<span class="string">&quot;Demo1&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;加载此类的类的加载器为：&quot;</span> + clazz.getClassLoader().getClass().getName());<span class="comment">//com.ysy.MyClassLoader</span></span><br><span class="line">            System.out.println(<span class="string">&quot;加载当前类的父类加载器为：&quot;</span> + clazz.getClassLoader().getParent().getClass().getName());<span class="comment">//sun.misc.Launcher$AppClassLoader</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Java9新特性"><a href="#Java9新特性" class="headerlink" title="Java9新特性"></a>Java9新特性</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassLoaderTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(ClassLoaderTest.class.getClassLoader());</span><br><span class="line">        System.out.println(ClassLoaderTest.class.getClassLoader().getParent());</span><br><span class="line">        System.out.println(ClassLoaderTest.class.getClassLoader().getParent().getParent());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取系统类加载器</span></span><br><span class="line">        System.out.println(ClassLoader.getSystemClassLoader());</span><br><span class="line">        <span class="comment">//获取平台类加载器</span></span><br><span class="line">        System.out.println(ClassLoader.getPlatformClassLoader());</span><br><span class="line">        <span class="comment">//获取类的加载器的名称</span></span><br><span class="line">        System.out.println(ClassLoaderTest.class.getClassLoader().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了保证兼容性，JDK9没有从根本上改变三层类加载器架构和双亲委派模型，但为了模块化系统的顺利运行，仍然发生了一些值得被注意的变动。</p>
<ol>
<li>扩展机制被移除，扩展类加载器由于向后兼容性的原因被保留，不过被**重命名为平台类加载器(platform class loader)**。可以通过classLoader的新方法getPlatformClassLoader()来获取。<br>JDK9时基于模块化进行构建(原来的rt.jar和tools.jar被拆分成数十个JMOD文件)，其中的Java类库就已天然地满足了可扩展的需求，那自然无须再保留<JAVA_HOME>\lib\ext目录，此前使用这个目录或者java.ext.dirs系统变量来扩展JDK功能的机制已经没有继续存在的价值了。 </li>
<li>平台类加载器和应用程序类加载器都不再继承自java.net.URLClassLoader。<br>现在启动类加载器、平台类加载器、应用程序类加载器全都继承于jdk.internal.loader.BuiltinClassLoader。</li>
</ol>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220801211150773.png" alt="image-20220801211150773"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220801210659674.png" alt="image-20220801210659674"></p>
<p>如果有程序直接依赖了这种继承关系，或者依赖了URLClassLoader类的特定方法，那代码很可能会在JDK9及更高版本的JDK中崩溃。</p>
<ol>
<li>在Java9中，类加载器有了名称。该名称在构造方法中指定，可以通过getName()方法来获取。平台类加载器的名称是platform，应用类加载器的名称是app。<strong>类加载器的名称在调试与类加载器相关的问题时会非常有用</strong>。</li>
<li>启动类加载器现在是在jvm内部和java类库共同协作实现的类加载器（以前是C++实现），但为了与之前代码兼容，在获取启动类加载器的场景中仍然会返回null，而不会得到BootClassLoader实例。</li>
<li>类加载的委派关系也发生了变动。当平台及应用程序类加载器收到类加载请求，在委派给父加载器加载前，要先判断该类是否能够归属到某一个系统模块中，如果可以找到这样的归属关系，就要优先委派给负责那个模块的加载器完成加载。</li>
</ol>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220801211004879.png" alt="image-20220801211004879"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220801210941474.png" alt="image-20220801210941474"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220801211059364.png" alt="image-20220801211059364"></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-JVN：类的加载过程"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
	
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/07/31/JVN%EF%BC%9A%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/"
    >类的加载过程（类的生命周期）详解</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/07/31/JVN%EF%BC%9A%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/" class="article-date">
  <time datetime="2022-07-31T09:52:06.000Z" itemprop="datePublished">2022-07-31</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/JVM/">JVM</a> / <a class="article-category-link" href="/categories/JVM/2-%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E7%AF%87/">2.字节码与类的加载篇</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><ul>
<li><p>在Java中数据类型分为基本数据类型和引用数据类型。<strong>基本数据类型由虚拟机预先定义，引用数据类型则需要进行类的加载。</strong></p>
</li>
<li><p>按照Java虚拟机规范，从class文件到加载到内存中的类，到类卸载出内存为止，它的整个生命周期包括如下7个阶段：</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220731180803901.png" alt="image-20220731180803901"></p>
<ul>
<li>其中，验证、准备、解析3个部分统称为链接（Linking）</li>
</ul>
</li>
<li><p>从程序中类的使用过程看</p>
</li>
</ul>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220731180739033.png" alt="image-20220731180739033"></p>
<p><strong>大厂面试题</strong></p>
<p><strong>蚂蚁金服：</strong></p>
<ul>
<li>描述一下JVM加载Class文件的原理机制？</li>
<li>一面：类加载过程</li>
</ul>
<p><strong>百度：</strong></p>
<ul>
<li>类加载的时机</li>
<li>java类加载过程？</li>
<li>简述java类加载机制？</li>
</ul>
<p><strong>腾讯：</strong></p>
<ul>
<li>JVM中类加载机制，类加载过程？</li>
</ul>
<p><strong>滴滴：</strong></p>
<ul>
<li>JVM类加载机制</li>
</ul>
<p><strong>美团：</strong></p>
<ul>
<li><p>Java类加载过程</p>
</li>
<li><p>描述一下jvm加载class文件的原理机制</p>
</li>
</ul>
<p><strong>京东：</strong></p>
<ul>
<li><p>什么是类的加载？</p>
</li>
<li><p>哪些情况会触发类的加载？</p>
</li>
<li><p>讲一下JVM加载一个类的过程JVM的类加载机制是什么？</p>
</li>
</ul>
<h1 id="过程一：Loading-加载-阶段"><a href="#过程一：Loading-加载-阶段" class="headerlink" title="过程一：Loading(加载)阶段"></a>过程一：Loading(加载)阶段</h1><h2 id="加载完成的操作"><a href="#加载完成的操作" class="headerlink" title="加载完成的操作"></a>加载完成的操作</h2><h3 id="加载的理解"><a href="#加载的理解" class="headerlink" title="加载的理解"></a>加载的理解</h3><ul>
<li><p><strong><code>所谓加载，简而言之就是将Java类的字节码文件加载到机器内存中，并在内存中构建出Java类的原型—类模板对象。</code></strong></p>
</li>
<li><p>所谓类模板对象，其实就是Java类在]VM内存中的一个快照，JVM将从字节码文件中解析出的常量池、类字段、类方法等信息存储到类模板中，这样]VM在运行期便能通过类模板而获取Java类中的任意信息，能够对Java类的成员变量进行遍历，也能进行Java方法的调用。</p>
</li>
<li><p>反射的机制即基于这一基础。如果JVM没有将Java类的声明信息存储起来，则JVM在运行期也无法反射。</p>
</li>
</ul>
<h3 id="加载完成的操作-1"><a href="#加载完成的操作-1" class="headerlink" title="加载完成的操作"></a>加载完成的操作</h3><ul>
<li><strong><code>加载阶段，简而言之，查找并加载类的二进制数据，生成Class的实例</code></strong></li>
<li>在加载类时，Java虚拟机必须完成以下3件事情：<ul>
<li>通过类的全名，获取类的二进制数据流。 </li>
<li>解析类的二进制数据流为方法区内的数据结构（Java类模型） </li>
<li>创建java.lang.Class类的实例，表示该类型。作为方法区这个类的各种数据的访问入口</li>
</ul>
</li>
</ul>
<h2 id="二进制流的获取方式"><a href="#二进制流的获取方式" class="headerlink" title="二进制流的获取方式"></a>二进制流的获取方式</h2><ul>
<li><p>对于类的二进制数据流，虚拟机可以通过多种途径产生或获得。（<strong>只要所读取的字节码符合JVM规范即可</strong>）</p>
<ol>
<li>虚拟机可能通过文件系统读入一个class后缀的文件（<strong>最常见</strong>）</li>
<li>读入jar、zip等归档数据包，提取类文件。</li>
<li>事先存放在数据库中的类的二进制数据</li>
<li>使用类似于HTTP之类的协议通过网络进行加载</li>
<li>在运行时生成一段class的二进制信息等</li>
</ol>
</li>
<li><p>在获取到类的二进制信息后，Java虚拟机就会处理这些数据，并最终转为一个<strong>java.lang.Class的实例</strong>。</p>
</li>
<li><p>如果输入数据不是ClassFile的结构，则会<strong>抛出ClassFormatError</strong>。</p>
</li>
</ul>
<h2 id="类模型与Class实例的位置"><a href="#类模型与Class实例的位置" class="headerlink" title="类模型与Class实例的位置"></a>类模型与Class实例的位置</h2><h3 id="类模型的位置"><a href="#类模型的位置" class="headerlink" title="类模型的位置"></a>类模型的位置</h3><ul>
<li>加载的类在JVM中创建相应的类结构，类结构会存储在方法区（JDKl.8之前：永久代；J0Kl.8及之后：元空间）。</li>
</ul>
<h3 id="Class实例的位置"><a href="#Class实例的位置" class="headerlink" title="Class实例的位置"></a>Class实例的位置</h3><ul>
<li>类将.class文件加载至元空间后，会在堆中创建一个Java.lang.Class对象，用来封装类位于方法区内的数据结构，该Class对象是在加载类的过程中创建的，每个类都对应有一个Class类型的对象。</li>
</ul>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220731183112237.png" alt="image-20220731183112237"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.lang.String&quot;</span>);</span><br><span class="line"><span class="comment">//获取当前运行时类声明的所有方法</span></span><br><span class="line">Method[] ms = clazz.getDecla#FF0000Methods();</span><br><span class="line"><span class="keyword">for</span> (Method m : ms) &#123;</span><br><span class="line">    <span class="comment">//获取方法的修饰符</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">mod</span> <span class="operator">=</span> Modifier.toString(m.getModifiers());</span><br><span class="line">    System.out.print(mod + <span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="comment">//获取方法的返回值类型</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">returnType</span> <span class="operator">=</span> (m.getReturnType()).getSimpleName();</span><br><span class="line">    System.out.print(returnType + <span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="comment">//获取方法名</span></span><br><span class="line">    System.out.print(m.getName() + <span class="string">&quot;(&quot;</span>);</span><br><span class="line">    <span class="comment">//获取方法的参数列表</span></span><br><span class="line">    Class&lt;?&gt;[] ps = m.getParameterTypes();</span><br><span class="line">    <span class="keyword">if</span> (ps.length == <span class="number">0</span>) &#123;</span><br><span class="line">        System.out.print(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ps.length; i++) &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">end</span> <span class="operator">=</span> (i == ps.length - <span class="number">1</span>) ? <span class="string">&#x27;)&#x27;</span> : <span class="string">&#x27;,&#x27;</span>;</span><br><span class="line">        <span class="comment">//获取参教的类型</span></span><br><span class="line">        System.out.print(ps[i].getSimpleName() + end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数组类的加载"><a href="#数组类的加载" class="headerlink" title="数组类的加载"></a>数组类的加载</h2><ul>
<li><p>创建数组类的情况稍微有些特殊，因为<strong>数组类本身并不是由类加载器负责创建</strong>，而是由JVM在运行时根据需要而直接创建的，但<strong>数组的元素类型仍然需要依靠类加载器去创建</strong>。创建数组类（下述简称A）的过程：</p>
<ol>
<li>如果数组的元素类型是引用类型，那么就遵循定义的加载过程递归加载和创建数组A的元素类型；</li>
<li>JVM使用指定的元素类型和数组维度来创建新的数组类。</li>
</ol>
</li>
<li><p>如果数组的元素类型是引用类型，数组类的可访问性就由元素类型的可访问性决定。否则数组类的可访问性将被缺省定义为public。</p>
</li>
</ul>
<h1 id="过程二：Linking-链接-阶段"><a href="#过程二：Linking-链接-阶段" class="headerlink" title="过程二：Linking(链接)阶段"></a>过程二：Linking(链接)阶段</h1><h2 id="环节1：链接阶段之Verification（验证）"><a href="#环节1：链接阶段之Verification（验证）" class="headerlink" title="环节1：链接阶段之Verification（验证）"></a>环节1：链接阶段之Verification（验证）</h2><ul>
<li><p>当类加载到系统后，就开始链接操作，验证是链接操作的第一步。</p>
</li>
<li><p><strong><code>目的：保证加载的字节码是合法、合理并规范的</code></strong></p>
</li>
<li><p>验证的步骤比较复杂，实际要验证的项目也很繁多，大体上Java虚拟机需要做以下检查，如图所示。</p>
</li>
</ul>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220731183634377.png" alt="image-20220731183634377"></p>
<p><strong>整体说明：</strong></p>
<p>验证的内容则涵盖了类数据信息的格式验证、语义检查、字节码验证，以及符号引用验证等。</p>
<ul>
<li><p>**<code>其中格式验证会和加载阶段一起执行</code>**。验证通过之后，类加载器才会成功将类的二进制数据信息加载到方法区中。</p>
</li>
<li><p><strong><code>格式验证之外的验证操作将会在方法区中进行</code></strong></p>
</li>
</ul>
<p>链接阶段的验证虽然拖慢了加载速度，但是它避免了在字节码运行时还需要进行各种检查。（磨刀不误砍柴工）</p>
<p><strong>具体说明：</strong></p>
<ol>
<li><strong>格式验证</strong>：<strong>是否以魔数0XCAFEBABE开头</strong>，主版本和副版本号是否在当前Java虚拟机的支持范围内，数据中每一个项是否都拥有正确的长度等。 </li>
<li><strong>语义检查</strong>：Java虚拟机会进行字节码的语义检查，但凡在语义上不符合规范的，虚拟机也不会给予验证通过。比如：</li>
</ol>
<ul>
<li><ul>
<li>是否所有的类都有父类的存在（在Java里，除了object外，其他类都应该有父类）</li>
</ul>
</li>
<li><ul>
<li>是否一些被定义为final的方法或者类被重写或继承了</li>
</ul>
</li>
<li><ul>
<li>非抽象类是否实现了所有抽象方法或者接口方法</li>
</ul>
</li>
</ul>
<ol start="3">
<li><strong>字节码验证</strong>：Java虚拟机还会进行字节码验证，<strong>字节码验证也是验证过程中最为复杂的一个过程</strong>。它试图通过对字节码流的分析，判断字节码是否可以被正确地执行。比如：</li>
</ol>
<ul>
<li><ul>
<li>在字节码的执行过程中，是否会跳转到一条不存在的指令</li>
</ul>
</li>
<li><ul>
<li>函数的调用是否传递了正确类型的参数</li>
</ul>
</li>
<li><ul>
<li>变量的赋值是不是给了正确的数据类型等</li>
</ul>
</li>
</ul>
<p><strong>栈映射帧（StackMapTable）</strong>就是在这个阶段，用于检测在特定的字节码处，其局部变量表和操作数栈是否有着正确的数据类型。但遗憾的是，100%准确地判断一段字节码是否可以被安全执行是无法实现的，因此，该过程只是尽可能地检查出可以预知的明显的问题。如果在这个阶段无法通过检查，虚拟机也不会正确装载这个类。但是，如果通过了这个阶段的检查，也不能说明这个类是完全没有问题的。</p>
<p><strong>在前面3次检查中，已经排除了文件格式错误、语义错误以及字节码的不正确性。但是依然不能确保类是没有问题的</strong></p>
<ol start="4">
<li><strong>符号引用的验证</strong>：校验器还将进符号引用的验证。Class文件在其常量池会通过字符串记录自己将要使用的其他类或者方法。因此，在验证阶段，<strong>虚拟机就会检查这些类或者方法确实是存在的</strong>，并且当前类有权限访问这些数据，如果一个需要使用类无法在系统中找到，则会抛出<strong>NoClassDefFoundError</strong>，如果一个方法无法被找到，则会抛出<strong>NoSuchMethodError</strong>。此阶段在解析环节才会执行。</li>
</ol>
<h2 id="环节2：链接阶段之Preparation（准备）"><a href="#环节2：链接阶段之Preparation（准备）" class="headerlink" title="环节2：链接阶段之Preparation（准备）"></a>环节2：链接阶段之Preparation（准备）</h2><ul>
<li><p><strong><code>为类的静态变量分配内存，并将其初始化为默认值</code></strong></p>
</li>
<li><p>当一个类验证通过时，虚拟机就会进入准备阶段。在这个阶段，虚拟机就会为这个类分配相应的内存空间，并设置默认初始值。Java虚拟机为各类型变量默认的初始值如表所示。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>默认初始值</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>(byte)0</td>
</tr>
<tr>
<td>short</td>
<td>(shory)0</td>
</tr>
<tr>
<td>int</td>
<td>0</td>
</tr>
<tr>
<td>long</td>
<td>0L</td>
</tr>
<tr>
<td>float</td>
<td>0.0f</td>
</tr>
<tr>
<td>double</td>
<td>0.0</td>
</tr>
<tr>
<td>char</td>
<td>\u0000</td>
</tr>
<tr>
<td>boolean</td>
<td>false</td>
</tr>
<tr>
<td>reference</td>
<td>null</td>
</tr>
</tbody></table>
<p>Java并不支持boolean类型，对于boolean类型，内部实现是int，由于int的默认值是0，故对应的，boolean的默认值就是false。</p>
</li>
</ul>
<p><strong>注意</strong></p>
<ul>
<li><p><strong>这里不包含基本数据类型的字段用 static final 修饰的情况，因为 final 在编译的时候就会分配了，准备阶段会显示赋值</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一般情况：static final修饰的基本数据类型、字符串类型字面量会在准备阶段赋值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello world&quot;</span>;</span><br><span class="line"><span class="comment">// 特殊情况：static final修饰的引用类型不会在准备阶段赋值，而是在初始化阶段赋值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Hello world&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>注意这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中。 </p>
</li>
<li><p>在这个阶段并不会像初始化阶段中那样会有初始化或者代码被执行。</p>
</li>
</ul>
<h2 id="环节3：链接阶段之Resolution（解析）"><a href="#环节3：链接阶段之Resolution（解析）" class="headerlink" title="环节3：链接阶段之Resolution（解析）"></a>环节3：链接阶段之Resolution（解析）</h2><p>在准备阶段完成后，就进入了解析阶段。</p>
<p>解析阶段（Resolution），简言之，**<code>将类、接口、字段和方法的符号引用转为直接引用</code>**</p>
<p><strong>具体描述</strong>： </p>
<p>符号引用就是一些字面量的引用，和虚拟机的内部数据结构和和内存布局无关。比较容易理解的就是在Class类文件中，通过常量池进行了大量的符号引用。但是在程序实际运行时，只有符号引用是不够的，比如当如下println()方法被调用时，系统需要明确知道该方法的位置。</p>
<p><strong>举例</strong>：</p>
<p>输出操作System.out.println()对应的字节码： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">invokevirtual #<span class="number">24</span> &lt;java/io/PrintStream.println&gt;</span><br></pre></td></tr></table></figure>

<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220731192409362.png" alt="image-20220731192409362"></p>
<p>以方法为例，Java虚拟机为每个类都准备了一张方法表，将其所有的方法都列在表中，当需要调用一个类的方法的时候，只要知道这个方法在方法表中的偏移量就可以直接调用该方法。<strong>通过解析操作，符号引用就可以转换为目标方法在类中方法表中的位置，从而使得方法被成功调用</strong></p>
<h1 id="过程三：Initialization-初始化-阶段"><a href="#过程三：Initialization-初始化-阶段" class="headerlink" title="过程三：Initialization(初始化)阶段"></a>过程三：Initialization(初始化)阶段</h1><p>初始化阶段，简言之，**<code>为类的静态变量赋予正确的初始值</code>**。</p>
<p><strong>具体描述</strong></p>
<ul>
<li>类的初始化是类装载的最后一个阶段。如果前面的步骤都没有问题，那么表示类可以顺利装载到系统中。此时，类才会开始执行Java字节码。(即: <strong>到了初始化阶段，才真正开始执行类中定的Java程序代码</strong>。)</li>
<li><strong>初始化阶段的重要工作是执行类的初始化方法: &lt; clinit &gt;()方法。</strong><ul>
<li>该方法仅能由Java编译器生成并由JVM调用，程序开发者无法自定义一个同名的方法，更无法直接在Java程序中调用该方法，虽然该方法也是由字节码指令所组成。</li>
<li>它是由类静态成员的赋值语句以及static语句块合并产生的。</li>
</ul>
</li>
</ul>
<p><strong>说明</strong></p>
<ul>
<li>在加载一个类之前，虚拟机总是会试图加载该类的父类，因此父类的&lt; clinit &gt;总是在子类&lt; clinit &gt;之前被调用。也就是说，父类的static块优先级高于子类。</li>
<li>口诀：<strong>由父及子，静态先行</strong></li>
<li>Java编译器并不会为所有的类都产生&lt; clinit &gt;()初始化方法。哪些类在编译为字节码后，字节码文件中将不会包含&lt; clinit &gt;()方法?</li>
<li>一个类中并没有声明任何的类变量，也没有静态代码块时</li>
<li>一个类中声明类变量，但是没有明确使用类变量的初始化语句以及静态代码块来执行初始化操作时</li>
<li>一个类中包含static final修饰的基本数据类型的字段，这些类字段初始化语句采用编译时常量表达式</li>
</ul>
<h2 id="static与final的搭配问题"><a href="#static与final的搭配问题" class="headerlink" title="static与final的搭配问题"></a>static与final的搭配问题</h2><p><strong>说明</strong></p>
<ul>
<li>使用static+ final修饰的字段的显式赋值的操作，到底是在哪个阶段进行的赋值？<ul>
<li>情况1：在链接阶段的准备环节赋值 </li>
<li>情况2：在初始化阶段&lt; clinit &gt;()中赋值</li>
</ul>
</li>
</ul>
<p><strong>结论</strong></p>
<ul>
<li><p>在链接阶段的准备环节赋值的情况</p>
<ul>
<li>对于基本数据类型的字段来说，如果使用static final修饰，则显式赋值(直接赋值常量，而非调用方法通常是在链接阶段的准备环节进行 </li>
<li>对于String来说，如果使用字面量的方式赋值，使用static final修饰的话，则显式赋值通常是在链接阶段的准备环节进行</li>
</ul>
</li>
<li><p>在初始化阶段&lt; clinit &gt;()中赋值的情况： 排除上述的在准备环节赋值的情况之外的情况。</p>
</li>
</ul>
<p><strong>最终结论</strong>：使用static+final修饰，且显式赋值中不涉及到方法或构造器调用的基本数据类到或String类型的显式赋值，是在链接阶段的准备环节进行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INT_CONSTANT</span> <span class="operator">=</span> <span class="number">10</span>;                                <span class="comment">// 在链接阶段的准备环节赋值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NUM1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">10</span>);                  <span class="comment">// 在初始化阶段clinit&gt;()中赋值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;                                                  <span class="comment">// 在初始化阶段&lt;clinit&gt;()中赋值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">INTEGER_CONSTANT1</span> <span class="operator">=</span> Integer.valueOf(<span class="number">100</span>);     <span class="comment">// 在初始化阶段&lt;clinit&gt;()中赋值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">Integer</span> <span class="variable">INTEGER_CONSTANT2</span> <span class="operator">=</span> Integer.valueOf(<span class="number">100</span>);           <span class="comment">// 在初始化阶段&lt;clinit&gt;()中概值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">s0</span> <span class="operator">=</span> <span class="string">&quot;helloworld0&quot;</span>;                            <span class="comment">// 在链接阶段的准备环节赋值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;helloworld1&quot;</span>);                <span class="comment">// 在初始化阶段&lt;clinit&gt;()中赋值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;hellowrold2&quot;</span>;                                  <span class="comment">// 在初始化阶段&lt;clinit&gt;()中赋值</span></span><br></pre></td></tr></table></figure>

<h2 id="lt-clinit-gt-的线程安全性"><a href="#lt-clinit-gt-的线程安全性" class="headerlink" title="&lt; clinit &gt; ()的线程安全性"></a>&lt; clinit &gt; ()的线程安全性</h2><ul>
<li>对于&lt; clinit &gt;()方法的调用，也就是类的初始化，虚拟机会在内部确保其多线程环境中的安全性。</li>
<li>虚拟机会保证一个类的()方法在多线程环境中被正确地加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的&lt; clinit &gt;()方法，其他线程都需要阻塞等待，直到活动线程执行&lt; clinit &gt;()方法完毕。</li>
<li>正是因为<strong>函数&lt; clint &gt;()带锁线程安全的</strong>，因此，如果在一个类的&lt; clinit &gt;()方法中有耗时很长的操作，就可能造成多个线程阻塞，引发死锁。并且这种死锁是很难发现的，因为看起来它们并没有可用的锁信息。</li>
<li>如果之前的线程成功加载了类，则等在队列中的线程就没有机会再执行&lt; clinit &gt;()方法了。那么，当需要使用这个类时，虚拟机会直接返回给它已经准备好的信息。</li>
</ul>
<h2 id="类的初始化情况：主动使用vs被动使用"><a href="#类的初始化情况：主动使用vs被动使用" class="headerlink" title="类的初始化情况：主动使用vs被动使用"></a>类的初始化情况：主动使用vs被动使用</h2><p>Java程序对类的使用分为两种：<strong>主动使用和被动使用</strong>。(会不会调用&lt; clinit &gt;()方法)</p>
<p>使用命令查看类的使用情况：**-XX:+TraceClassLoading**</p>
<h3 id="主动使用"><a href="#主动使用" class="headerlink" title="主动使用"></a>主动使用</h3><p>Class只有在必须要首次使用的时候才会被装载，Java虚拟机不会无条件地装载Class类型。Java虚拟机规定，一个类或接口在初次使用前，必须要进行初始化。这里指的“使用”，是指主动使用，主动使用只有下列几种情况：（即：如果出现如下的情况，则会对类进行初始化操作。而初始化操作之前的加载、验证、准备已经完成。</p>
<ol>
<li><p><strong>实例化</strong>：当创建一个类的实例时，比如使用new关键字，或者通过反射、克隆、反序列化。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 反序列化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Class Order <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Order类的初始化&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 序列化</span></span><br><span class="line">        oos = <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;order.dat&quot;</span>));</span><br><span class="line">        oos.writeObject(<span class="keyword">new</span> <span class="title class_">Order</span>());</span><br><span class="line">        <span class="comment">// 反序列化</span></span><br><span class="line">        ois = <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;order.dat&quot;</span>));</span><br><span class="line">        <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> ois.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (ClassNotFoundException e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (oos != <span class="literal">null</span>) &#123;</span><br><span class="line">                oos.close();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ois != <span class="literal">null</span>) &#123;</span><br><span class="line">                ois.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>静态方法</strong>：当调用类的静态方法时，即当使用了字节码invokestatic指令。 </p>
</li>
<li><p><strong>静态字段</strong>：当使用类、接口的静态字段时（final修饰特殊考虑），比如，使用getstatic或者putstatic指令。（对应访问变量、赋值变量操作）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ActiveUse</span> &#123;</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(User.num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;User类的初始化&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">1</span>;<span class="comment">//不会</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">10</span>);<span class="comment">//会初始化，主动使用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>反射</strong>：当使用java.lang.reflect包中的方法反射类的方法时。比如：Class.forName(“com.atguigu.java.Test”) </p>
</li>
<li><p><strong>继承</strong>：当初始化子类时，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</p>
</li>
</ol>
<blockquote>
<p>当Java虚拟机初始化一个类时，要求它的所有父类都已经被初始化，但是这条规则并不适用于接口。</p>
<ul>
<li>在初始化一个类时，并不会先初始化它所实现的接口</li>
<li>在初始化一个接口时，并不会先初始化它的父接口</li>
<li>因此，一个父接口并不会因为它的子接口或者实现类的初始化而初始化。只有当程序首次使用特定接口的静态字段时，才会导致该接口的初始化。</li>
</ul>
</blockquote>
<ol start="6">
<li><p><strong>default方法</strong>：如果一个接口定义了default方法，那么直接实现或者间接实现该接口的类的初始化，该接口要在其之前被初始化。</p>
</li>
<li><p><strong>main方法</strong>：当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。</p>
</li>
</ol>
<blockquote>
<p>JVM启动的时候通过引导类加载器加载一个初始类。这个类在调用public static void main(String[])方法之前被链接和初始化。这个方法的执行将依次导致所需的类的加载，链接和初始化。</p>
</blockquote>
<ol start="8">
<li><strong>MethodHandle</strong>：当初次调用MethodHandle实例时，初始化该MethodHandle指向的方法所在的类。（涉及解析REF getStatic、REF_putStatic、REF invokeStatic方法句柄对应的类）</li>
</ol>
<h3 id="被动使用"><a href="#被动使用" class="headerlink" title="被动使用"></a>被动使用</h3><p>除了以上的情况属于主动使用，其他的情况均属于被动使用。</p>
<p>被动使用不会引起类的初始化</p>
<p>也就是说：<strong>并不是在代码中出现的类，就一定会被加载或者初始化</strong>。如果不符合主动使用的条件，类就不会初始化。<strong>没有初始化的类，不意味着没有加载</strong></p>
<ol>
<li><p><strong>静态字段</strong>：当通过子类引用父类的静态变量，不会导致子类初始化，只有真正声明这个字段的类才会被初始化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PassiveUse</span> &#123;</span><br><span class="line"> 	<span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(Child.num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Child类的初始化&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Parent类的初始化&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>数组定义</strong>：通过数组定义类引用，不会触发此类的初始化。</p>
</li>
</ol>
   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Parent[] parents= <span class="keyword">new</span> <span class="title class_">Parent</span>[<span class="number">10</span>];</span><br><span class="line">System.out.println(parents.getClass()); </span><br><span class="line"><span class="comment">// new的话才会初始化</span></span><br><span class="line">parents[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">Parent</span>();</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>引用常量</strong>：引用常量不会触发此类或接口的初始化。因为常量在链接阶段就已经被显式赋值了。</li>
</ol>
   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PassiveUse</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(Serival.num);</span><br><span class="line">        <span class="comment">// 但引用其他类的话还是会初始化</span></span><br><span class="line">        System.out.println(Serival.num2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Serival</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Serival初始化&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><strong>loadClass方法</strong>：调用ClassLoader类的loadClass()方法加载一个类，并不是对类的主动使用，不会导致类的初始化。</li>
</ol>
   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> ClassLoader.getSystemClassLoader().loadClass(<span class="string">&quot;com.test.java.Person&quot;</span>);</span><br></pre></td></tr></table></figure>

<h1 id="过程四：类的Using-使用"><a href="#过程四：类的Using-使用" class="headerlink" title="过程四：类的Using(使用)"></a>过程四：类的Using(使用)</h1><ul>
<li>任何一个类型在使用之前都必须经历过完整的加载、链接和初始化3个类加载步骤。一旦一个类型成功经历过这3个步骤之后，便“厉事俱备只欠东风”，就等着开发者使用了。</li>
<li>开发人员可以在程序中访问和调用它的静态类成员信息（比如：静态字段、静态方法），或者使用new关键字为其创建对象实例。</li>
</ul>
<h1 id="过程五：类的Unloading-卸载"><a href="#过程五：类的Unloading-卸载" class="headerlink" title="过程五：类的Unloading(卸载)"></a>过程五：类的Unloading(卸载)</h1><h2 id="类、类的加载器、类的实例之间的引用关系"><a href="#类、类的加载器、类的实例之间的引用关系" class="headerlink" title="类、类的加载器、类的实例之间的引用关系"></a>类、类的加载器、类的实例之间的引用关系</h2><ul>
<li>在类加载器的内部实现中，用一个Java集合来存放所加载类的引用。另一方面，一个Class对象总是会引用它的类加载器，调用Class对象的getClassLoader()方法，就能获得它的类加载器。由此可见，代表某个类的Class实例与其类的加载器之间为双向关联关系。</li>
<li>一个类的实例总是引用代表这个类的Class对象。在Object类中定义了getClass()方法，这个方法返回代表对象所属类的Class对象的引用。此外，所有的java类都有一个静态属性class，它引用代表这个类的Class对象。</li>
</ul>
<h2 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h2><ul>
<li>当Sample类被加载、链接和初始化后，它的生命周期就开始了。当代表Sample类的Class对象不再被引用，即不可触及时，Class对象就会结束生命周期，Sample类在方法区内的数据也会被卸载，从而结束Sample类的生命周期。</li>
<li><strong>一个类何时结束生命周期，取决于代表它的Class对象何时结束生命周期</strong></li>
</ul>
<h2 id="具体例子"><a href="#具体例子" class="headerlink" title="具体例子"></a>具体例子</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220801162102729.png" alt="image-20220801162102729"></p>
<p>loader1变量和obj变量间接应用代表Sample类的Class对象，而objClass变量则直接引用它。</p>
<p>如果程序运行过程中，将上图左侧三个引用变量都置为null，此时Sample对象结束生命周期，MyClassLoader对象结束生命周期，代表Sample类的Class对象也结束生命周期，Sample类在方法区内的二进制数据被卸载。</p>
<p>当再次有需要时，会检查Sample类的Class对象是否存在，如果存在会直接使用，不再重新加载；如果不存在Sample类会被重新加载，在Java虚拟机的堆区会生成一个新的代表Sample类的Class实例（可以通过哈希码查看是否是同一个实例）</p>
<h2 id="类的卸载"><a href="#类的卸载" class="headerlink" title="类的卸载"></a>类的卸载</h2><ol>
<li>启动类加载器加载的类型在整个运行期间是不可能被卸载的（jvm和jls规范）</li>
<li>被系统类加载器和扩展类加载器加载的类型在运行期间不太可能被卸载，因为系统类加载器实例或者扩展类的实例基本上在整个运行期间总能直接或者间接的访问的到，其达到unreachable的可能性极小。</li>
<li>被开发者自定义的类加载器实例加载的类型只有在很简单的上下文环境中才能被卸载，而且一般还要借助于强制调用虚拟机的垃圾收集功能才可以做到。可以预想，稍微复杂点的应用场景中（比如：很多时候用户在开发自定义类加载器实例的时候采用缓存的策略以提高系统性能），被加载的类型在运行期间也是几乎不太可能被卸载的（至少卸载的时间是不确定的）。</li>
</ol>
<p>综合以上三点，一个已经加载的类型被卸载的几率很小至少被卸载的时间是不确定的。同时我们可以看的出来，开发者在开发代码时候，不应该对虚拟机的类型卸载做任何假设的前提下，来实现系统中的特定功能。</p>
<h2 id="回顾：方法区的垃圾回收"><a href="#回顾：方法区的垃圾回收" class="headerlink" title="回顾：方法区的垃圾回收"></a>回顾：方法区的垃圾回收</h2><ul>
<li><p>方法区的垃圾收集主要回收两部分内容：<strong>常量池中废弃的常量和不再使用的类型</strong>。</p>
</li>
<li><p>HotSpot虚拟机对常量池的回收策略是很明确的，只要常量池中的常量没有被任何地方引用，就可以被回收。</p>
</li>
<li><p>判定一个常量是否“废弃”还是相对简单，而要判定一个类型是否属于“不再使用的类”的条件就比较苛刻了。需要同时满足下面三个条件：</p>
<ul>
<li><strong>该类所有的实例都已经被回收。</strong>也就是Java堆中不存在该类及其任何派生子类的实例。</li>
<li><strong>加载该类的类加载器已经被回收。</strong>这个条件除非是经过精心设计的可替换类加载器的场景，如OSGi、JSP的重加载等，否则通常是很难达成的。</li>
<li><strong>该类对应的java.lang.Class对象没有在任何地方被引用</strong>，无法在任何地方通过反射访问该类的方法。</li>
</ul>
</li>
<li><p>Java虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是“被允许”，而并不是和对象一样，没有引用了就必然会回收。</p>
</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-JVM：垃圾回收器"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
	
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/07/31/JVM%EF%BC%9A%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/"
    >垃圾回收器</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/07/31/JVM%EF%BC%9A%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/" class="article-date">
  <time datetime="2022-07-31T03:17:19.000Z" itemprop="datePublished">2022-07-31</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/JVM/">JVM</a> / <a class="article-category-link" href="/categories/JVM/1-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/">1.内存与垃圾回收篇</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="GC-分类与性能指标"><a href="#GC-分类与性能指标" class="headerlink" title="GC 分类与性能指标"></a>GC 分类与性能指标</h1><h2 id="垃圾回收器概述"><a href="#垃圾回收器概述" class="headerlink" title="垃圾回收器概述"></a>垃圾回收器概述</h2><ul>
<li>垃圾收集器没有在规范中进行过多的规定，可以由不同的厂商、不同版本的JVM来实现。</li>
<li>由于JDK的版本处于高速迭代过程中，因此Java发展至今已经衍生了众多的GC版本。</li>
<li>从不同角度分析垃圾收集器，可以将GC分为不同的类型。</li>
</ul>
<p><strong>Java不同版本新特性</strong></p>
<ul>
<li><strong>语法层面</strong>：Lambda表达式、switch、自动拆箱装箱、enum、泛型</li>
<li><strong>API层面</strong>：Stream API、新的日期时间、Optional、String、集合框架</li>
<li><strong>底层优化</strong>：JVM优化、GC的变化、元空间、静态域、字符串常量池等</li>
</ul>
<h2 id="垃圾回收器分类"><a href="#垃圾回收器分类" class="headerlink" title="垃圾回收器分类"></a>垃圾回收器分类</h2><ul>
<li><strong>按<code>线程数</code>分（垃圾回收线程数），可以分为串行垃圾回收器和并行垃圾回收器。</strong></li>
</ul>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220726210912537.png" alt="image-20220726210912537"></p>
<ol>
<li>串行回收指的是在同一时间段内只允许有一个CPU用于执行垃圾回收操作，此时工作线程被暂停，直至垃圾收集工作结束。<ul>
<li>在诸如单CPU处理器或者较小的应用内存等硬件平台不是特别优越的场合，串行回收器的性能表现可以超过并行回收器和并发回收器。所以，串<strong>行回收默认被应用在客户端的Client模式下的JVM中</strong></li>
<li>在并发能力比较强的CPU上，并行回收器产生的停顿时间要短于串行回收器</li>
</ul>
</li>
<li>和串行回收相反，并行收集可以运用多个CPU同时执行垃圾回收，因此提升了应用的吞吐量，不过并行回收仍然与串行回收一样，采用独占式，使用了“Stop-the-World”机制。</li>
</ol>
<ul>
<li><strong>按照<code>工作模式</code>分，可以分为并发式垃圾回收器和独占式垃圾回收器。</strong></li>
</ul>
<ol>
<li>并发式垃圾回收器与应用程序线程交替工作，以尽可能减少应用程序的停顿时间。</li>
<li>独占式垃圾回收器（Stop the World）一旦运行，就停止应用程序中的所有用户线程，直到垃圾回收过程完全结束。</li>
</ol>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220726211056288.png" alt="image-20220726211056288"></p>
<ul>
<li><strong>按<code>碎片处理方式</code>分，可分为压缩式垃圾回收器和非压缩式垃圾回收器。</strong></li>
</ul>
<ol>
<li>压缩式垃圾回收器会在回收完成后，对存活对象进行压缩整理，消除回收后的碎片。再分配对象空间使用指针碰撞<ul>
<li>再分配对象空间使用：指针碰撞</li>
</ul>
</li>
<li>非压缩式的垃圾回收器不进行这步操作，分配对象空间使用空闲列表<ul>
<li>再分配对象空间使用：空闲列表</li>
</ul>
</li>
</ol>
<ul>
<li><strong>按<code>工作的内存区间</code>分，又可分为年轻代垃圾回收器和老年代垃圾回收器。</strong></li>
</ul>
<h2 id="评估-GC-的性能指标"><a href="#评估-GC-的性能指标" class="headerlink" title="评估 GC 的性能指标"></a>评估 GC 的性能指标</h2><h3 id="指标"><a href="#指标" class="headerlink" title="指标"></a>指标</h3><ol>
<li><strong>吞吐量：运行用户代码的时间占总运行时间的比例</strong>（总运行时间 &#x3D; 程序的运行时间 + 内存回收的时间）</li>
<li>垃圾收集开销：吞吐量的补数，垃圾收集所用时间与总运行时间的比例。</li>
<li><strong>暂停时间：执行垃圾收集时，程序的工作线程被暂停的时间</strong>。</li>
<li>收集频率：相对于应用程序的执行，收集操作发生的频率。</li>
<li><strong>内存占用：Java堆区所占的内存大小</strong>。</li>
<li>快速：一个对象从诞生到被回收所经历的时间。</li>
</ol>
<ul>
<li>吞吐量、暂停时间、内存占用这三者共同构成一个“不可能三角”。三者总体的表现会随着技术进步而越来越好。一款优秀的收集器通常最多同时满足其中的两项。</li>
<li>这三项里，暂停时间的重要性日益凸显。因为随着硬件发展，内存占用多些越来越能容忍，硬件性能的提升也有助于降低收集器运行时对应用程序的影响，即提高了吞吐量。而内存的扩大，对延迟反而带来负面效果。</li>
<li>简单来说，主要抓住两点：<ul>
<li><strong>吞吐量</strong></li>
<li><strong>暂停时间</strong></li>
</ul>
</li>
</ul>
<h3 id="吞吐量（throughput）"><a href="#吞吐量（throughput）" class="headerlink" title="吞吐量（throughput）"></a>吞吐量（throughput）</h3><ol>
<li>吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即<strong>吞吐量&#x3D;运行用户代码时间 &#x2F;（运行用户代码时间+垃圾收集时间）</strong><ul>
<li>比如：虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。</li>
</ul>
</li>
<li>这种情况下，应用程序能容忍较高的暂停时间，因此，高吞吐量的应用程序有更长的时间基准，快速响应是不必考虑的</li>
<li><strong>吞吐量优先，意味着在单位时间内，STW的时间最短</strong>：0.2+0.2&#x3D;0.4</li>
</ol>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220726211854440.png" alt="image-20220726211854440"></p>
<h3 id="暂停时间（pause-time）"><a href="#暂停时间（pause-time）" class="headerlink" title="暂停时间（pause time）"></a>暂停时间（pause time）</h3><ol>
<li>“暂停时间”是指一个时间段内应用程序线程暂停，让GC线程执行的状态。<ul>
<li>例如，GC期间100毫秒的暂停时间意味着在这100毫秒期间内没有应用程序线程是活动的</li>
</ul>
</li>
<li><strong>暂停时间优先，意味着尽可能让单次STW的时间最短</strong>：0.1+0.1 + 0.1+ 0.1+ 0.1&#x3D;0.5，但是总的GC时间可能会长</li>
</ol>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220726211948109.png" alt="image-20220726211948109"></p>
<h3 id="吞吐量-vs-暂停时间"><a href="#吞吐量-vs-暂停时间" class="headerlink" title="吞吐量 vs 暂停时间"></a>吞吐量 vs 暂停时间</h3><ol>
<li><p><strong>高吞吐量较好</strong>因为这会让应用程序的最终用户感觉只有应用程序线程在做“生产性”工作。直觉上，吞吐量越高程序运行越快。</p>
</li>
<li><p><strong>低暂停时间（低延迟）较好</strong>，是从最终用户的角度来看，不管是GC还是其他原因导致一个应用被挂起始终是不好的。这取决于应用程序的类型，<strong>有时候甚至短暂的200毫秒暂停都可能打断终端用户体验</strong>。因此，具有较低的暂停时间是非常重要的，特别是对于一个<strong>交互式应用程序</strong>（就是和用户交互比较多的场景）。</p>
</li>
<li><p>不幸的是”高吞吐量”和”低暂停时间”是一对相互竞争的目标（矛盾）。</p>
<ul>
<li>因为如果选择以吞吐量优先，那么<strong>必然需要降低内存回收的执行频率</strong>，但是这样会导致GC需要更长的暂停时间来执行内存回收。</li>
<li>相反的，如果选择以低延迟优先为原则，那么为了降低每次执行内存回收时的暂停时间，也只能<strong>频繁地执行内存回收</strong>，但这又引起了年轻代内存的缩减和导致程序吞吐量的下降。</li>
</ul>
</li>
<li><p>在设计（或使用）GC算法时，我们必须确定我们的目标：<strong>一个GC算法只可能针对两个目标之一（即只专注于较大吞吐量或最小暂停时间），或尝试找到一个二者的折衷。</strong></p>
</li>
<li><p>现在标准：**<code>在最大吞吐量优先的情况下，降低停顿时间</code>**</p>
</li>
</ol>
<h1 id="不同的垃圾回收器概述"><a href="#不同的垃圾回收器概述" class="headerlink" title="不同的垃圾回收器概述"></a>不同的垃圾回收器概述</h1><ol>
<li>垃圾收集机制是Java的招牌能力，极大地提高了开发效率。这当然也是面试的热点。</li>
<li>那么，Java常见的垃圾收集器有哪些？</li>
</ol>
<h2 id="垃圾收集器发展史"><a href="#垃圾收集器发展史" class="headerlink" title="垃圾收集器发展史"></a>垃圾收集器发展史</h2><p>有了虚拟机，就一定需要收集垃圾的机制，这就是Garbage Collection，对应的产品我们称为Garbage Collector。</p>
<ol>
<li>1999年随JDK1.3.1一起来的是串行方式的Serial GC，它是第一款GC。ParNew垃圾收集器是Serial收集器的多线程版本</li>
<li>2002年2月26日，Parallel GC和Concurrent Mark Sweep GC跟随JDK1.4.2一起发布·</li>
<li>Parallel GC在JDK6之后成为HotSpot默认GC。</li>
<li>2012年，在JDK1.7u4版本中，G1可用。</li>
<li>2017年，JDK9中G1变成默认的垃圾收集器，以替代CMS。</li>
<li>2018年3月，JDK10中G1垃圾回收器的并行完整垃圾回收，实现并行性来改善最坏情况下的延迟。</li>
<li>2018年9月，JDK11发布。引入Epsilon 垃圾回收器，又被称为 “No-Op(无操作)“ 回收器。同时，引入ZGC：可伸缩的低延迟垃圾回收器（Experimental）</li>
<li>2019年3月，JDK12发布。增强G1，自动返回未用堆内存给操作系统。同时，引入Shenandoah GC：低停顿时间的GC（Experimental）。</li>
<li>2019年9月，JDK13发布。增强ZGC，自动返回未用堆内存给操作系统。</li>
<li>2020年3月，JDK14发布。删除CMS垃圾回收器。扩展ZGC在macOS和Windows上的应用</li>
</ol>
<h2 id="7款经典的垃圾收集器"><a href="#7款经典的垃圾收集器" class="headerlink" title="7款经典的垃圾收集器"></a>7款经典的垃圾收集器</h2><ol>
<li>串行回收器：**<code>Serial、Serial old</code>**</li>
<li>并行回收器：**<code>ParNew、Parallel Scavenge、Parallel old</code>**</li>
<li>并发回收器：**<code>CMS、G1</code>**</li>
</ol>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220726213224809.png" alt="image-20220726213224809"></p>
<p><strong>7款经典回收器与垃圾分代之间的关系</strong></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220726213341676.png" alt="image-20220726213341676"></p>
<ol>
<li><p>新生代收集器：Serial、ParNew、Parallel Scavenge；</p>
</li>
<li><p>老年代收集器：Serial old、Parallel old、CMS；</p>
</li>
<li><p>整堆收集器：G1；</p>
</li>
</ol>
<h2 id="垃圾收集器的组合关系"><a href="#垃圾收集器的组合关系" class="headerlink" title="垃圾收集器的组合关系"></a>垃圾收集器的组合关系</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220726213425161.png" alt="image-20220726213425161"></p>
<ol>
<li>两个收集器间有连线，表明它们可以搭配使用：<ul>
<li>Serial&#x2F;Serial old</li>
<li>Serial&#x2F;CMS    （JDK9废弃）</li>
<li>ParNew&#x2F;Serial Old （JDK9废弃）</li>
<li>ParNew&#x2F;CMS</li>
<li>Parallel Scavenge&#x2F;Serial Old  （预计废弃）</li>
<li>Parallel Scavenge&#x2F;Parallel Old</li>
<li>G1</li>
</ul>
</li>
<li>其中Serial Old作为CMS出现”Concurrent Mode Failure”失败的后备预案。</li>
<li>（红色虚线）由于维护和兼容性测试的成本，在JDK 8时将Serial+CMS、ParNew+Serial Old这两个组合声明为废弃（JEP173），并在JDK9中完全取消了这些组合的支持（JEP214），即：移除。</li>
<li>（绿色虚线）JDK14中：弃用Parallel Scavenge和Serial Old GC组合（JEP366）</li>
<li>（青色虚线）JDK14中：删除CMS垃圾回收器（JEP363）</li>
</ol>
<ul>
<li>为什么要有很多收集器，一个不够吗？<ul>
<li>因为Java的使用场景很多，移动端，服务器等。所以就需要针对不同的场景，提供不同的垃圾收集器，提高垃圾收集的性能。</li>
</ul>
</li>
<li>虽然我们会对各个收集器进行比较，但并非为了挑选一个最好的收集器出来。没有一种放之四海皆准、任何场景下都适用的完美收集器存在，更加没有万能的收集器。所以<strong>我们选择的只是对具体应用最合适的收集器</strong>。</li>
</ul>
<h2 id="查看默认垃圾收集器"><a href="#查看默认垃圾收集器" class="headerlink" title="查看默认垃圾收集器"></a>查看默认垃圾收集器</h2><ol>
<li><strong>-XX:+PrintCommandLineFlags</strong>：查看命令行相关参数（包含使用的垃圾收集器）</li>
<li>使用命令行指令：<strong>jinfo -flag 相关垃圾回收器参数 进程ID</strong></li>
</ol>
<h3 id="JDK8"><a href="#JDK8" class="headerlink" title="JDK8"></a>JDK8</h3><p><strong>在 JDK 8 下，设置 JVM 参数</strong></p>
<p>-XX:+PrintCommandLineFlags</p>
<p>程序打印输出：-XX:+UseParallelGC 表示使用使用 ParallelGC ，ParallelGC 默认和 Parallel Old 绑定使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:InitialHeapSize=<span class="number">266620736</span> -XX:MaxHeapSize=<span class="number">4265931776</span> -XX:+PrintCommandLineFlags -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:-UseLargePagesIndividualAllocation -XX:+UseParallelGC </span><br></pre></td></tr></table></figure>

<p><strong>通过命令行指令查看</strong></p>
<p>命令行命令</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jps</span><br><span class="line">jinfo -flag UseParallelGC 进程id</span><br><span class="line">jinfo -flag UseParallelOldGC 进程id</span><br></pre></td></tr></table></figure>

<p>JDK 8 中默认使用 <strong>ParallelGC 和 ParallelOldGC 的组合</strong></p>
<img src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_012/0009.png">

<h3 id="JDK9"><a href="#JDK9" class="headerlink" title="JDK9"></a>JDK9</h3><img src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_012/0010.png">

<h1 id="Serial-回收器：串行回收"><a href="#Serial-回收器：串行回收" class="headerlink" title="Serial 回收器：串行回收"></a>Serial 回收器：串行回收</h1><p><strong>Serial 回收器：串行回收</strong></p>
<ol>
<li>Serial收集器是最基本、历史最悠久的垃圾收集器了。JDK1.3之前回收新生代唯一的选择。</li>
<li>Serial收集器作为HotSpot中Client模式下的默认新生代垃圾收集器。</li>
<li><strong>Serial收集器采用复制算法、串行回收和”Stop-the-World”机制的方式执行内存回收。</strong></li>
<li>除了年轻代之外，Serial收集器还提供用于执行老年代垃圾收集的Serial Old收集器。<strong>Serial old收集器同样也采用了串行回收和”Stop the World”机制，只不过内存回收算法使用的是标记-压缩算法。</strong></li>
</ol>
<ul>
<li><p>Serial Old是运行在Client模式下默认的老年代的垃圾回收器</p>
</li>
<li><p>Serial Old在Server模式下主要有两个用途：①与新生代的Parallel Scavenge配合使用②作为老年代CMS收集器的后备垃圾收集方案</p>
</li>
<li><p>这个收集器是一个单线程的收集器，“单线程”的意义：它<strong>只会使用一个CPU（串行）或一条收集线程去完成垃圾收集工作</strong>。更重要的是在它进行垃圾收集时，<strong>必须暂停其他所有的工作线程</strong>，直到它收集结束（Stop The World）</p>
</li>
</ul>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220726214837404.png" alt="image-20220726214837404"></p>
<p><strong>Serial 回收器的优势</strong></p>
<ol>
<li><strong>简单而高效</strong>（与其他收集器的单线程比），对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。<ul>
<li>运行在Client模式下的虚拟机是个不错的选择。</li>
</ul>
</li>
<li>在用户的桌面应用场景中，可用内存一般不大（几十MB至一两百MB），可以在较短时间内完成垃圾收集（几十ms至一百多ms），只要不频繁发生，使用串行回收器是可以接受的。</li>
<li>在HotSpot虚拟机中，使用**-XX:+UseSerialGC**参数可以指定年轻代和老年代都使用串行收集器。<ul>
<li>等价于新生代用Serial GC，且老年代用Serial Old GC</li>
</ul>
</li>
</ol>
<p><strong>总结</strong></p>
<ol>
<li><p>这种垃圾收集器大家了解，现在已经不用串行的了。而且在限定单核CPU才可以用。现在都不是单核的了。</p>
</li>
<li><p>对于交互较强的应用而言，这种垃圾收集器是不能接受的。一般在Java Web应用程序中是不会采用串行垃圾收集器的。</p>
</li>
</ol>
<h1 id="ParNew-回收器：并行回收"><a href="#ParNew-回收器：并行回收" class="headerlink" title="ParNew 回收器：并行回收"></a>ParNew 回收器：并行回收</h1><ol>
<li>如果说Serial GC是年轻代中的单线程垃圾收集器，那么ParNew收集器则是Serial收集器的多线程版本。<ul>
<li>Par是Parallel的缩写，New：只能处理新生代</li>
</ul>
</li>
<li>ParNew 收集器除了采用<strong>并行回收</strong>的方式执行内存回收外，两款垃圾收集器之间几乎没有任何区别。ParNew收集器在年轻代中同样也是采用**复制算法、”Stop-the-World”**机制。</li>
<li><strong>ParNew 是很多JVM运行在Server模式下新生代的默认垃圾收集器</strong>。</li>
</ol>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220729160617268.png" alt="image-20220729160617268"></p>
<ul>
<li>对于新生代，回收次数频繁，使用并行方式高效。</li>
<li>对于老年代，回收次数少，使用串行方式节省资源。（CPU并行需要切换线程，串行可以省去切换线程的资源）</li>
</ul>
<p><strong>ParNew 回收器与 Serial 回收器比较</strong></p>
<p>Q：由于ParNew收集器基于并行回收，那么是否可以断定ParNew收集器的回收效率在任何场景下都会比Serial收集器更高效？</p>
<p>A：<strong>不能</strong></p>
<ol>
<li>ParNew收集器运行在多CPU的环境下，由于可以充分利用多CPU、多核心等物理硬件资源优势，可以更快速地完成垃圾收集，提升程序的吞吐量。</li>
<li>但是<strong>在单个CPU的环境下，ParNew收集器不比Serial收集器更高效</strong>。虽然Serial收集器是基于串行回收，但是由于CPU不需要频繁地做任务切换，因此可以有效避免多线程交互过程中产生的一些额外开销。</li>
<li>除Serial外，目前只有ParNew GC能与CMS收集器配合工作</li>
</ol>
<p><strong>设置 ParNew 垃圾回收器</strong></p>
<ol>
<li><p>在程序中，开发人员可以通过选项”<strong>-XX:+UseParNewGC</strong>“手动指定使用ParNew收集器执行内存回收任务。它表示年轻代使用并行收集器，不影响老年代。</p>
</li>
<li><p><strong>-XX:ParallelGCThreads</strong>限制线程数量，默认开启和CPU数据相同的线程数。</p>
</li>
</ol>
<h1 id="Parallel-Scavenge回收器：吞吐量优先"><a href="#Parallel-Scavenge回收器：吞吐量优先" class="headerlink" title="Parallel Scavenge回收器：吞吐量优先"></a>Parallel Scavenge回收器：吞吐量优先</h1><p><strong>Parallel Scavenge 回收器：吞吐量优先</strong></p>
<ol>
<li><p>HotSpot的年轻代中除了拥有ParNew收集器是基于并行回收的以外，Parallel Scavenge收集器同样也采用了**复制算法、并行回收和”Stop the World”**机制。</p>
</li>
<li><p>那么Parallel收集器的出现是否多此一举？</p>
<ul>
<li>和ParNew收集器不同，Parallel Scavenge收集器的目标则是达到一个<strong>可控制的吞吐量</strong>（Throughput），它也被称为吞吐量优先的垃圾收集器。</li>
<li><strong>自适应调节策略</strong>也是Parallel Scavenge与ParNew一个重要区别。（动态调整内存分配情况，以达到一个最优的吞吐量或低延迟）</li>
</ul>
</li>
<li><p>高吞吐量则可以高效率地利用CPU时间，尽快完成程序的运算任务，<strong>主要适合在后台运算而不需要太多交互的任务</strong>。因此，常见在服务器环境中使用。例如，那些执行批量处理、订单处理、工资支付、科学计算的应用程序。</p>
</li>
<li><p>Parallel收集器在JDK1.6时提供了用于执行老年代垃圾收集的Parallel Old收集器，用来代替老年代的Serial Old收集器。</p>
</li>
<li><p>Parallel Old收集器采用了<strong>标记-压缩</strong>算法，但同样也是基于**并行回收和”Stop-the-World”**机制。</p>
</li>
</ol>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220729161553622.png" alt="image-20220729161553622"></p>
<ol>
<li>在程序吞吐量优先的应用场景中，Parallel收集器和Parallel Old收集器的组合，在server模式下的内存回收性能很不错。</li>
<li><strong>在Java8中，默认是此垃圾收集器。</strong></li>
</ol>
<p><strong>Parallel Scavenge 回收器参数设置</strong></p>
<ol>
<li><p><strong>-XX:+UseParallelGC</strong> ：手动指定年轻代使用Parallel并行收集器执行内存回收任务。</p>
</li>
<li><p><strong>-XX:+UseParallelOldGC</strong>：手动指定老年代都是使用并行回收收集器。</p>
</li>
</ol>
<ul>
<li><p>分别适用于新生代和老年代</p>
</li>
<li><p>上面两个参数分别适用于新生代和老年代。默认jdk8是开启的。默认开启一个，另一个也会被开启。（互相激活）</p>
</li>
</ul>
<ol start="3">
<li><p><strong>-XX:ParallelGCThreads</strong>：设置年轻代并行收集器的线程数。一般地，<strong>最好与CPU数量相等</strong>，以避免过多的线程数影响垃圾收集性能。</p>
</li>
<li><p>在默认情况下，当CPU数量小于8个，ParallelGCThreads的值等于CPU数量。</p>
<ol start="2">
<li>当CPU数量大于8个，ParallelGCThreads的值等于3+[5*CPU_Count]&#x2F;8]</li>
</ol>
</li>
<li><p><strong>-XX:MaxGCPauseMillis</strong> ：设置垃圾收集器最大停顿时间（即STW的时间）。单位是毫秒。</p>
<ol>
<li>为了尽可能地把停顿时间控制在XX:MaxGCPauseMillis 以内，收集器在工作时会调整Java堆大小或者其他一些参数。</li>
<li>对于用户来讲，停顿时间越短体验越好。但是在服务器端，我们注重高并发，整体的吞吐量。所以服务器端适合Parallel，进行控制。</li>
<li>该参数使用需谨慎。</li>
</ol>
</li>
<li><p><strong>-XX:GCTimeRatio</strong>：垃圾收集时间占总时间的比例，即等于 <strong>1 &#x2F; (N+1)</strong> ，用于衡量吞吐量的大小。</p>
<ol>
<li><p>取值范围(0, 100)。默认值99，也就是垃圾回收时间占比不超过1。</p>
</li>
<li><p>与前一个-XX:MaxGCPauseMillis参数有一定矛盾性，STW暂停时间越长，Radio参数就容易超过设定的比例。</p>
</li>
</ol>
</li>
<li><p><strong>-XX:+UseAdaptiveSizePolicy</strong> ：设置Parallel Scavenge收集器具有<strong>自适应调节策略</strong></p>
<ol>
<li><p>在这种模式下，年轻代的大小、Eden和Survivor的比例、晋升老年代的对象年龄等参数会被自动调整，已达到在堆大小、吞吐量和停顿时间之间的平衡点。</p>
</li>
<li><p>在手动调优比较困难的场合，可以直接使用这种自适应的方式，仅指定虚拟机的最大堆、目标的吞吐量（GCTimeRatio）和停顿时间（MaxGCPauseMillis），让虚拟机自己完成调优工作。</p>
</li>
</ol>
</li>
</ol>
<h1 id="CMS-回收器：低延迟"><a href="#CMS-回收器：低延迟" class="headerlink" title="CMS 回收器：低延迟"></a>CMS 回收器：低延迟</h1><h2 id="CMS-回收器"><a href="#CMS-回收器" class="headerlink" title="CMS 回收器"></a>CMS 回收器</h2><ol>
<li>在JDK1.5时期，Hotspot推出了一款在<strong>强交互应用中（就是和用户打交道的引用）</strong>几乎可认为有划时代意义的垃圾收集器：<code>CMS（Concurrent-Mark-Sweep）</code>收集器，<strong>这款收集器是HotSpot虚拟机中第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程同时工作。</strong></li>
<li>CMS收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间。停顿时间越短（低延迟）就越适合与用户交互的程序，良好的响应速度能提升用户体验。<ul>
<li><strong>目前很大一部分的Java应用集中在互联网站或者B&#x2F;S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短</strong>，以给用户带来较好的体验。CMS收集器就非常符合这类应用的需求。</li>
</ul>
</li>
<li>CMS的垃圾收集算法采用<strong>标记-清除</strong>算法，并且也会**”Stop-the-World”**</li>
<li>不幸的是，CMS作为老年代的收集器，却无法与JDK1.4.0中已经存在的新生代收集器Parallel Scavenge配合工作（因为实现的框架不一样，没办法兼容使用），所以在JDK1.5中使用CMS来收集老年代的时候，新生代只能选择ParNew或者Serial收集器中的一个。</li>
<li>在G1出现之前，CMS使用还是非常广泛的。一直到今天，仍然有很多系统使用CMS GC。</li>
</ol>
<h2 id="CMS-工作原理（过程）"><a href="#CMS-工作原理（过程）" class="headerlink" title="CMS 工作原理（过程）"></a>CMS 工作原理（过程）</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220729172255112.png" alt="image-20220729172255112"></p>
<p>CMS整个过程比之前的收集器要复杂，整个过程分为4个主要阶段，即<strong>初始标记阶段、并发标记阶段、重新标记阶段和并发清除阶段</strong>。(涉及STW的阶段主要是：初始标记 和 重新标记)</p>
<ol>
<li>初始标记（Initial-Mark）阶段：在这个阶段中，程序中所有的工作线程都将会因为“Stop-the-World”机制而出现短暂的暂停，<strong>这个阶段的主要任务仅仅只是标记出GC Roots能直接关联到的对象</strong>。一旦标记完成之后就会恢复之前被暂停的所有应用线程。由于直接关联对象比较小，所以这里的<strong>速度非常快</strong>。</li>
<li>并发标记（Concurrent-Mark）阶段：从GC Roots的<strong>直接关联对象开始遍历整个对象图的过程</strong>，这个过程<strong>耗时较长</strong>但是<strong>不需要停顿用户线程</strong>，<strong>可以与垃圾收集线程一起并发运行</strong>。</li>
<li>重新标记（Remark）阶段：由于在并发标记阶段中，程序的工作线程会和垃圾收集线程同时运行或者交叉运行，<strong>因此为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，</strong>这个阶段的停顿时间通常会比初始标记阶段稍长一些，并且也会导致“Stop-the-World”的发生，但也远比并发标记阶段的时间短。</li>
<li>并发清除（Concurrent-Sweep）阶段：此阶段<strong>清理删除掉标记阶段判断的已经死亡的对象，释放内存空间</strong>。<strong>由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的</strong></li>
</ol>
<h2 id="CMS分析"><a href="#CMS分析" class="headerlink" title="CMS分析"></a>CMS分析</h2><ul>
<li>尽管CMS收集器采用的是并发回收（非独占式），<strong>但是在其初始化标记和再次标记这两个阶段中仍然需要执行“Stop-the-World”机制</strong>暂停程序中的工作线程，不过暂停时间并不会太长，因此可以说明目前所有的垃圾收集器都做不到完全不需要“Stop-the-World”，只是尽可能地缩短暂停时间。</li>
<li><strong>由于最耗费时间的并发标记与并发清除阶段都不需要暂停工作，所以整体的回收是低停顿的</strong>。</li>
<li>另外，由于在垃圾收集阶段用户线程没有中断，所以<strong>在CMS回收过程中，还应该确保应用程序用户线程有足够的内存可用</strong>。因此，CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，<strong>而是当堆内存使用率达到某一阈值时，便开始进行回收</strong>，以确保应用程序在CMS工作过程中依然有足够的空间支持应用程序运行。要是CMS运行期间预留的内存无法满足程序需要，就会出现一次<strong>“Concurrent Mode Failure”</strong> 失败，这时虚拟机将启动后备预案：临时启用Serial old收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了。</li>
<li>CMS收集器的垃圾收集算法采用的是<strong>标记-清除算法</strong>，这意味着每次执行完内存回收后，由于被执行内存回收的无用对象所占用的内存空间极有可能是不连续的一些内存块，<strong>不可避免地将会产生一些内存碎片</strong>。那么CMS在为新对象分配内存空间时，将无法使用指针碰撞（Bump the Pointer）技术，而只能够选择空闲列表（Free List）执行内存分配。</li>
</ul>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220729172849771.png" alt="image-20220729172849771"></p>
<p><strong>为什么 CMS 不采用标记-压缩算法呢？</strong></p>
<ul>
<li>答案其实很简答，因为当并发清除的时候，用Compact整理内存的话，原来的用户线程使用的内存还怎么用呢？<strong>要保证用户线程能继续执行，前提的它运行的资源不受影响</strong>嘛。Mark Compact更适合“stop the world”这种场景下使用</li>
</ul>
<h2 id="CMS-的优点与弊端"><a href="#CMS-的优点与弊端" class="headerlink" title="CMS 的优点与弊端"></a>CMS 的优点与弊端</h2><p><strong>优点</strong></p>
<ol>
<li><strong>并发收集</strong></li>
<li><strong>低延迟</strong></li>
</ol>
<p><strong>弊端</strong></p>
<ol>
<li><strong>会产生内存碎片</strong>，导致并发清除后，用户线程可用的空间不足。在无法分配大对象的情况下，不得不提前触发Full GC。</li>
<li><strong>CMS收集器对CPU资源非常敏感</strong>。在并发阶段，它虽然不会导致用户停顿，但是会因为占用了一部分线程而导致应用程序变慢，总吞吐量会降低。</li>
<li><strong>CMS收集器无法处理浮动垃圾</strong>。可能出现“Concurrent Mode Failure”失败而导致另一次Full GC的产生。在并发标记阶段由于程序的工作线程和垃圾收集线程是同时运行或者交叉运行的，<strong>那么在并发标记阶段如果产生新的垃圾对象，CMS将无法对这些垃圾对象进行标记，最终会导致这些新产生的垃圾对象没有被及时回收，</strong>从而只能在下一次执行GC时释放这些之前未被回收的内存空间。</li>
</ol>
<h2 id="CMS-参数配置"><a href="#CMS-参数配置" class="headerlink" title="CMS 参数配置"></a>CMS 参数配置</h2><ul>
<li><p><strong>-XX:+UseConcMarkSweepGC</strong>：手动指定使用CMS收集器执行内存回收任务。</p>
</li>
<li><p>开启该参数后会自动将-XX:+UseParNewGC打开。即：<strong>ParNew（Young区）+CMS（Old区）+Serial Old</strong>（Old区备选方案）的组合。</p>
</li>
<li><p><strong>-XX:CMSInitiatingOccupanyFraction</strong>：设置堆内存使用率的阈值，一旦达到该阈值，便开始进行回收。</p>
<ul>
<li><strong>JDK5及以前版本的默认值为68</strong>，即当老年代的空间使用率达到68%时，会执行一次CMS回收。<strong>JDK6及以上版本默认值为92%</strong></li>
<li>如果内存增长缓慢，则可以设置一个稍大的值，大的阀值可以有效降低CMS的触发频率，减少老年代回收的次数可以较为明显地改善应用程序性能。反之，如果应用程序内存使用率增长很快，则应该降低这个阈值，以避免频繁触发老年代串行收集器。因此<strong>通过该选项便可以有效降低Full GC的执行次数</strong>。</li>
</ul>
</li>
<li><p><strong>-XX:+UseCMSCompactAtFullCollection</strong>：用于指定在执行完Full GC后对内存空间进行压缩整理，以此避免内存碎片的产生。不过由于内存压缩整理过程无法并发执行，所带来的问题就是停顿时间变得更长了。</p>
</li>
<li><p><strong>-XX:CMSFullGCsBeforeCompaction</strong>：设置在执行多少次Full GC后对内存空间进行压缩整理。</p>
</li>
<li><p><strong>-XX:ParallelCMSThreads</strong>：设置CMS的线程数量。</p>
<ul>
<li>CMS默认启动的线程数是 <strong>(ParallelGCThreads + 3) &#x2F; 4</strong>，ParallelGCThreads是年轻代并行收集器的线程数，可以当做是 CPU 最大支持的线程数。当CPU资源比较紧张时，受到CMS收集器线程的影响，应用程序的性能在垃圾回收阶段可能会非常糟糕。</li>
</ul>
</li>
</ul>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>HotSpot有这么多的垃圾回收器，那么如果有人问，Serial GC、Parallel GC、Concurrent Mark Sweep GC这三个GC有什么不同呢？</p>
<ol>
<li>如果你想要最小化地使用内存和并行开销，请选Serial GC；</li>
<li>如果你想要最大化应用程序的吞吐量，请选Parallel GC；</li>
<li>如果你想要最小化GC的中断或停顿时间，请选CMS GC。</li>
</ol>
<h2 id="JDK-后续版本中-CMS-的变化"><a href="#JDK-后续版本中-CMS-的变化" class="headerlink" title="JDK 后续版本中 CMS 的变化"></a>JDK 后续版本中 CMS 的变化</h2><ol>
<li>JDK9新特性：CMS被标记为Deprecate了（JEP291）<ul>
<li>如果对JDK9及以上版本的HotSpot虚拟机使用参数-XX:+UseConcMarkSweepGC来开启CMS收集器的话，用户会收到一个警告信息，提示CMS未来将会被废弃。</li>
</ul>
</li>
<li>JDK14新特性：删除CMS垃圾回收器（JEP363）移除了CMS垃圾收集器，<ul>
<li>如果在JDK14中使用XX:+UseConcMarkSweepGC的话，JVM不会报错，只是给出一个warning信息，但是不会exit。JVM会自动回退以默认GC方式启动JVM</li>
</ul>
</li>
</ol>
<h1 id="G1-回收器：区域化分代式"><a href="#G1-回收器：区域化分代式" class="headerlink" title="G1 回收器：区域化分代式"></a>G1 回收器：区域化分代式</h1><h2 id="为什么还需要G1"><a href="#为什么还需要G1" class="headerlink" title="为什么还需要G1"></a>为什么还需要G1</h2><p><strong>既然我们已经有了前面几个强大的 GC ，为什么还要发布 Garbage First（G1）GC？</strong></p>
<ol>
<li>原因就在于应用程序所应对<strong>的业务越来越庞大、复杂，用户越来越多</strong>，没有GC就不能保证应用程序正常进行，而经常造成STW的GC又跟不上实际的需求，所以才会不断地尝试对GC进行优化。</li>
<li>G1（Garbage-First）垃圾回收器是在Java7 update4之后引入的一个新的垃圾回收器，是当今收集器技术发展的最前沿成果之一。</li>
<li>与此同时，<strong>为了适应现在不断扩大的内存和不断增加的处理器数量</strong>，进一步降低暂停时间（pause time），同时兼顾良好的吞吐量。</li>
<li><strong><code>官方给G1设定的目标是在延迟可控的情况下获得尽可能高的吞吐量，所以才担当起“全功能收集器”的重任与期望。</code></strong></li>
</ol>
<h2 id="为什么名字叫Garbage-First-G1-呢？"><a href="#为什么名字叫Garbage-First-G1-呢？" class="headerlink" title="为什么名字叫Garbage First(G1)呢？"></a>为什么名字叫Garbage First(G1)呢？</h2><ol>
<li>因为G1是一个并行回收器，它把堆内存分割为很多不相关的区域（Region）（物理上不连续的）。使用不同的Region来表示Eden、幸存者0区，幸存者1区，老年代等。</li>
<li>G1 GC有计划地避免在整个Java堆中进行全区域的垃圾收集。G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，<strong>每次根据允许的收集时间，优先回收价值最大的Region。</strong></li>
<li>由于这种方式的侧重点在于<strong>回收垃圾最大量的区间</strong>（Region），所以我们给G1一个名字：<strong>垃圾优先（Garbage First）</strong>。</li>
<li>G1（Garbage-First）是一款面向服务端应用的垃圾收集器，<strong>主要针对配备多核CPU及大容量内存的机器</strong>，以极高概率满足GC停顿时间的同时，还兼具高吞吐量的性能特征。</li>
<li>在JDK1.7版本正式启用，移除了Experimental的标识，<strong>是JDK9以后的默认垃圾回收器</strong>，取代了CMS回收器以及Parallel+Parallel Old组合。被Oracle官方称为<strong>“全功能的垃圾收集器”</strong>。</li>
<li>与此同时，CMS已经在JDK9中被标记为废弃（deprecated）。<strong>G1在JDK8中还不是默认的垃圾回收器</strong>，需要使用**-XX:+UseG1GC**来启用。</li>
</ol>
<h2 id="G1-回收器的优势"><a href="#G1-回收器的优势" class="headerlink" title="G1 回收器的优势"></a>G1 回收器的优势</h2><p>与其他GC收集器相比，G1使用了全新的分区算法，其特点如下所示：</p>
<ol>
<li><strong>并行与并发兼备</strong><ul>
<li>并行性：G1在回收期间，可以有多个GC线程同时工作，有效利用多核计算能力。此时用户线程STW</li>
<li>并发性：G1拥有与应用程序交替执行的能力，部分工作可以和应用程序同时执行，因此，一般来说，不会在整个回收阶段发生完全阻塞应用程序的情况</li>
</ul>
</li>
<li><strong>分代收集</strong><ul>
<li>从分代上看，<strong>G1依然属于分代型垃圾回收器</strong>，它会区分年轻代和老年代，年轻代依然有Eden区和Survivor区。但从堆的结构上看，它不要求整个Eden区、年轻代或者老年代都是连续的，也不再坚持固定大小和固定数量。</li>
<li>将堆空间分为若干个区域（Region），这些区域中包含了逻辑上的年轻代和老年代。</li>
<li>和之前的各类回收器不同，它<strong>同时兼顾年轻代和老年代</strong>。对比其他回收器，或者工作在年轻代，或者工作在老年代；</li>
</ul>
</li>
</ol>
<p>G1的分代，已经不是下面这样的了</p>
<img src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_012/0016.png">

<p>G1的分区是这样的一个区域</p>
<img src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_012/0017.png">

<ol start="3">
<li><p><strong>空间整合</strong></p>
<ul>
<li>CMS：“标记-清除”算法、内存碎片、若干次GC后进行一次碎片整理</li>
<li>G1将内存划分为一个个的region。内存的回收是以region作为基本单位的。<strong>Region之间是复制算法，但整体上实际可看作是标记-压缩（Mark-Compact）算法</strong>，两种算法都可以避免内存碎片。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC。尤其是当Java堆非常大的时候，G1的优势更加明显。</li>
</ul>
</li>
<li><p><strong>可预测的停顿时间模型（即：软实时soft real-time）</strong></p>
</li>
</ol>
<p>这是G1相对于CMS的另一大优势，G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者<strong>明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。</strong></p>
<ol>
<li>由于分区的原因，G1可以只选取部分区域进行内存回收，这样缩小了回收的范围，因此对于全局停顿情况的发生也能得到较好的控制。</li>
<li>G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，<strong>每次根据允许的收集时间，优先回收价值最大的Region</strong>。保证了G1收集器在有限的时间内可以获取尽可能高的收集效率。</li>
<li>相比于CMS GC，G1未必能做到CMS在最好情况下的延时停顿，但是最差情况要好很多。</li>
</ol>
<h2 id="G1-回收器的缺点"><a href="#G1-回收器的缺点" class="headerlink" title="G1 回收器的缺点"></a>G1 回收器的缺点</h2><ol>
<li>相较于CMS，G1还不具备全方位、压倒性优势。比如在用户程序运行过程中，G1无论是为了垃圾收集产生的内存占用（Footprint）还是程序运行时的额外执行负载（overload）都要比CMS要高。</li>
<li>从经验上来说，在小内存应用上CMS的表现大概率会优于G1，而G1在大内存应用上则发挥其优势。平衡点在<strong>6-8GB</strong>之间。</li>
</ol>
<h2 id="G1-参数设置"><a href="#G1-参数设置" class="headerlink" title="G1 参数设置"></a>G1 参数设置</h2><ul>
<li><p><strong>-XX:+UseG1GC</strong>：手动指定使用G1垃圾收集器执行内存回收任务</p>
</li>
<li><p><strong>-XX:G1HeapRegionSize</strong>：设置每个Region的大小。<strong>值是2的幂</strong>，<strong>范围是1MB到32MB之间</strong>，目标是根据最小的Java堆大小划分出约2048个区域。默认是堆内存的1&#x2F;2000。</p>
</li>
<li><p><strong>-XX:MaxGCPauseMillis</strong>：设置期望达到的最大GC停顿时间指标，JVM会尽力实现，但不保证达到。<strong>默认值是200ms</strong></p>
</li>
<li><p><strong>-XX:+ParallelGCThread</strong>：设置STW时GC线程数的值。<strong>最多设置为8</strong></p>
</li>
<li><p><strong>-XX:ConcGCThreads</strong>：设置并发标记的线程数。将n设置为并行垃圾回收线程数（ParallelGcThreads）的1&#x2F;4左右。</p>
</li>
<li><p><strong>-XX:InitiatingHeapOccupancyPercent</strong>：设置触发并发GC周期的Java堆占用率阈值。超过此值，就触发GC。<strong>默认值是45</strong>。</p>
</li>
</ul>
<h2 id="G1-收集器的常见操作步骤"><a href="#G1-收集器的常见操作步骤" class="headerlink" title="G1 收集器的常见操作步骤"></a>G1 收集器的常见操作步骤</h2><p>G1的设计原则就是简化JVM性能调优，开发人员只需要简单的三步即可完成调优：</p>
<ol>
<li>第一步：开启G1垃圾收集器</li>
<li>第二步：设置堆的最大内存</li>
<li>第三步：设置最大的停顿时间</li>
</ol>
<p>G1中提供了三种垃圾回收模式：YoungGC、Mixed GC和Full GC，在不同的条件下被触发。</p>
<h2 id="G1-的适用场景"><a href="#G1-的适用场景" class="headerlink" title="G1 的适用场景"></a>G1 的适用场景</h2><ol>
<li>面向<strong>服务端</strong>应用，针对具有<strong>大内存、多处理器</strong>的机器。（在普通大小的堆里表现并不惊喜）</li>
<li>最主要的应用是需要<strong>低GC延迟，并具有大堆的应用程序</strong>提供解决方案；<ul>
<li>如：在堆大小约6GB或更大时，可预测的暂停时间可以低于0.5秒；（G1通过每次只清理一部分而不是全部的Region的增量式清理来保证每次GC停顿时间不会过长）。</li>
</ul>
</li>
<li>用来替换掉JDK1.5中的CMS收集器；在下面的情况时，使用G1可能比CMS好：<ul>
<li>超过50%的Java堆被活动数据占用；</li>
<li>对象分配频率或年代提升频率变化很大；</li>
<li>GC停顿时间过长（长于0.5至1秒）</li>
</ul>
</li>
<li>HotSpot垃圾收集器里，除了G1以外，其他的垃圾收集器均使用内置的JVM线程执行GC的多线程操作，而G1 GC可以采用应用线程承担后台运行的GC工作，即当JVM的GC线程处理速度慢时，系统会调用应用程序线程帮助加速垃圾回收过程。</li>
</ol>
<h2 id="分区-Region"><a href="#分区-Region" class="headerlink" title="分区 Region"></a>分区 Region</h2><p><strong>分区 Region：化整为零</strong></p>
<ol>
<li><p>使用G1收集器时，它将整个Java堆划分成约2048个大小相同的独立Region块，每个Region块大小根据堆空间的实际大小而定，整体被控制在1MB到32MB之间，且为2的N次幂，即1MB，2MB，4MB，8MB，16MB，32MB。可以通过 <strong>-XX:G1HeapRegionSize</strong> 设定。<strong>所有的Region大小相同，且在JVM生命周期内不会被改变。</strong></p>
</li>
<li><p>虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分Region（不需要连续）的集合。通过Region的动态分配方式实现逻辑上的连续。</p>
</li>
<li><p>一个Region有可能属于Eden，Survivor或者Old&#x2F;Tenured内存区域。但是一个Region只可能属于一个角色，但是不固定，谁占用属于谁。图中的E表示该Region属于Eden内存区域，S表示属于Survivor内存区域，O表示属于Old内存区域。图中空白的表示未使用的内存空间。</p>
</li>
<li><p>G1垃圾收集器还增加了一种新的内存区域，叫做Humongous内存区域，如图中的H块。主要用于存储大对象，如果超过1.5个Region，就放到H。</p>
</li>
</ol>
<blockquote>
<p>纠错：尚硅谷视频里这里写的是超过1.5个region。根据<a target="_blank" rel="noopener" href="https://www.oracle.com/technetwork/tutorials/tutorials-1876574.html">官方文档</a>:  <strong>The G1 Garbage Collector Step by Step</strong></p>
<p>As shown regions can be allocated into Eden, survivor, and old generation regions. In addition, there is a fourth type of object known as Humongous regions. These regions are designed to hold objects that are 50% the size of a standard region or larger. They are stored as a set of contiguous regions. Finally the last type of regions would be the unused areas of the heap.</p>
<p>翻译：</p>
<p>如图所示，可以将区域分配到Eden，幸存者和旧时代区域。 此外，还有第四种类型的物体被称为巨大区域。 这些区域旨在容纳标准区域大小的50％或更大的对象。 它们存储为一组连续区域。 最后，最后一种区域类型是堆的未使用区域。</p>
</blockquote>
<img src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_012/0018.png">

<p><strong>设置 H 的原因</strong></p>
<p>对于堆中的大对象，默认直接会被分配到老年代，但是如果<strong>它是一个短期存在的大对象</strong>就会对垃圾收集器造成负面影响。为了解决这个问题，G1划分了一个Humongous区，它用来专门存放大对象。如<strong>果一个H区装不下一个大对象，那么G1会寻找连续的H区来存储</strong>。为了能找到连续的H区，有时候不得不启动Full GC。G1的大多数行为都把H区作为老年代的一部分来看待。</p>
<p><strong>Regio的细节</strong></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220730205740527.png" alt="image-20220730205740527"></p>
<ol>
<li>每个Region都是通过指针碰撞来分配空间</li>
<li>G1为每一个Region设计了两个名为TAMS（Top at Mark Start）的指针，把Region中的一部分空间划分出来用于并发回收过程中的新对象分配，并发回收时新分配的对象地址都必须要在这两个指针位置以上。</li>
<li>TLAB还是用来保证并发性</li>
</ol>
<h2 id="G1-垃圾回收流程"><a href="#G1-垃圾回收流程" class="headerlink" title="G1 垃圾回收流程"></a>G1 垃圾回收流程</h2><p>G1 GC的垃圾回收过程主要包括如下三个环节：</p>
<ul>
<li>年轻代GC（Young GC）</li>
<li>老年代并发标记过程（Concurrent Marking）</li>
<li>混合回收（Mixed GC）</li>
<li>（如果需要，单线程、独占式、高强度的Full GC还是继续存在的。它针对GC的评估失败提供了一种失败保护机制，即强力回收。）</li>
</ul>
<img src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_012/0020.png">

<p>顺时针，Young GC –&gt; Young GC+Concurrent Marking –&gt; Mixed GC顺序，进行垃圾回收</p>
<p><strong>回收流程</strong></p>
<ol>
<li>应用程序分配内存，<strong>当年轻代的Eden区用尽时开始年轻代回收过程</strong>；G1的年轻代收集阶段是一个<strong>并行的独占式收集器</strong>。在年轻代回收期，G1 GC暂停所有应用程序线程，启动多线程执行年轻代回收。然后<strong>从年轻代区间移动存活对象到Survivor区间或者老年区间，也有可能是两个区间都会涉及。</strong></li>
<li>当堆内存使用达到一定值（默认**45%**）时，开始老年代并发标记过程。</li>
<li>标记完成马上开始混合回收过程。对于一个混合回收期，G1 GC从老年区间移动存活对象到空闲区间，这些空闲区间也就成为了老年代的一部分。和年轻代不同，老年代的G1回收器和其他GC不同，<strong>G1的老年代回收器不需要整个老年代被回收，一次只需要扫描&#x2F;回收一小部分老年代的Region就可以了</strong>。同时，这个老年代Region是和年轻代一起被回收的。</li>
<li>举个例子：一个Web服务器，Java进程最大堆内存为4G，每分钟响应1500个请求，每45秒钟会新分配大约2G的内存。G1会每45秒钟进行一次年轻代回收，每31个小时整个堆的使用率会达到45%，会开始老年代并发标记过程，标记完成后开始四到五次的混合回收。</li>
</ol>
<h2 id="Remembered-Set（记忆集）"><a href="#Remembered-Set（记忆集）" class="headerlink" title="Remembered Set（记忆集）"></a>Remembered Set（记忆集）</h2><p><strong>问题：</strong></p>
<ol>
<li><p>一个对象被不同区域引用的问题</p>
</li>
<li><p>一个Region不可能是孤立的，一个Region中的对象可能被其他任意Region中对象引用，判断对象存活时，是否需要扫描整个Java堆才能保证准确？</p>
</li>
<li><p>在其他的分代收集器，也存在这样的问题（而G1更突出，因为G1主要针对大堆）</p>
</li>
<li><p>回收新生代也不得不同时扫描老年代？这样的话会降低Minor GC的效率</p>
</li>
</ol>
<p><strong>解决方法：</strong></p>
<ol>
<li><p>无论G1还是其他分代收集器，JVM都是使用Remembered Set来避免全堆扫描；</p>
</li>
<li><p><strong>每个Region都有一个对应的Remembered Set</strong></p>
</li>
<li><p>每次Reference类型数据写操作时，都会产生一个Write Barrier暂时中断操作；</p>
</li>
<li><p>然后检查将要写入的引用指向的对象是否和该Reference类型数据在不同的Region（其他收集器：检查老年代对象是否引用了新生代对象）；</p>
</li>
<li><p>如果不同，通过CardTable把相关引用信息记录到引用指向对象的所在Region对应的Remembered Set中；</p>
</li>
<li><p>当进行垃圾收集时，在GC根节点的枚举范围加入Remembered Set；就可以保证不进行全局扫描，也不会有遗漏。</p>
</li>
</ol>
<img src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_012/0021.png">

<ol>
<li>在回收 Region 时，为了不进行全堆的扫描，引入了 Remembered Set</li>
<li>Remembered Set 记录了当前 Region 中的对象被哪个对象引用了</li>
<li>这样在进行 Region 复制时，就不要扫描整个堆，只需要去 Remembered Set 里面找到引用了当前 Region 的对象</li>
<li>Region 复制完毕后，修改 Remembered Set 中对象的引用即可</li>
</ol>
<h2 id="G1回收过程一：年轻代-GC"><a href="#G1回收过程一：年轻代-GC" class="headerlink" title="G1回收过程一：年轻代 GC"></a>G1回收过程一：年轻代 GC</h2><ol>
<li>JVM启动时，G1先准备好Eden区，程序在运行过程中不断创建对象到Eden区，当Eden空间耗尽时，G1会启动一次年轻代垃圾回收过程。</li>
<li><strong>年轻代回收只回收Eden区和Survivor区</strong></li>
<li>YGC时，首先G1停止应用程序的执行（Stop-The-World），G1创建回收集（Collection Set），回收集是指需要被回收的内存分段的集合，年轻代回收过程的回收集包含年轻代Eden区和Survivor区所有的内存分段。</li>
</ol>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220730211000278.png" alt="image-20220730211000278"></p>
<p>图的大致意思就是：</p>
<p>1、回收完E和S区，剩余存活的对象会复制到新的S区</p>
<p>2、S区达到一定的阈值可以晋升为O区</p>
<p><strong>细致过程：</strong></p>
<ol>
<li><p>第一阶段，<strong>扫描根</strong></p>
<ul>
<li>根是指GC Roots，根引用连同RSet记录的外部引用作为扫描存活对象的入口。</li>
</ul>
</li>
<li><p>第二阶段，<strong>更新RSet</strong></p>
<ul>
<li>处理dirty card queue(见备注)中的card，更新RSet。此阶段完成后，<strong>RSet可以准确的反映老年代对所在的内存分段中对象的引用</strong></li>
</ul>
</li>
<li><p>第三阶段，<strong>处理RSet</strong></p>
<ul>
<li>识别被老年代对象指向的Eden中的对象，这些被指向的Eden中的对象被认为是存活的对象。</li>
</ul>
</li>
<li><p>第四阶段，<strong>复制对象</strong></p>
<ul>
<li>此阶段，对象树被遍历，Eden区内存段中存活的对象会被复制到Survivor区中空的内存分段，Survivor区内存段中存活的对象</li>
<li>如果年龄未达阈值，年龄会加1，达到阀值会被会被复制到Old区中空的内存分段。</li>
<li>如果Survivor空间不够，Eden空间的部分数据会直接晋升到老年代空间。</li>
</ul>
</li>
<li><p>第五阶段，<strong>处理引用</strong></p>
<ul>
<li>处理Soft，Weak，Phantom，Final，JNI Weak 等引用。最终Eden空间的数据为空，GC停止工作，而目标内存中的对象都是连续存储的，没有碎片，所以复制过程可以达到内存整理的效果，减少碎片。</li>
</ul>
</li>
</ol>
<p><strong>备注：</strong></p>
<ol>
<li>对于应用程序的引用赋值语句 oldObject.field（这个是老年代）&#x3D;object（这个是新生代），JVM会在之前和之后执行特殊的操作以在dirty card queue中入队一个保存了对象引用信息的card。在年轻代回收的时候，G1会对Dirty Card Queue中所有的card进行处理，以更新RSet，保证RSet实时准确的反映引用关系。</li>
<li>那为什么不在引用赋值语句处直接更新RSet呢？这是为了性能的需要，RSet的处理需要线程同步，开销会很大，使用队列性能会好很多。</li>
</ol>
<h2 id="G1回收过程二：并发标记过程"><a href="#G1回收过程二：并发标记过程" class="headerlink" title="G1回收过程二：并发标记过程"></a>G1回收过程二：并发标记过程</h2><ol>
<li><strong>初始标记阶段</strong>：标记从根节点直接可达的对象。这个阶段是STW的，并且会触发一次年轻代GC。正是由于该阶段时STW的，所以我们只扫描根节点可达的对象，以节省时间。</li>
<li><strong>根区域扫描（Root Region Scanning）</strong>：G1 GC扫描Survivor区直接可达的老年代区域对象，并标记被引用的对象。这一过程必须在Young GC之前完成，因为Young GC会使用复制算法对Survivor区进行GC。</li>
<li><strong>并发标记（Concurrent Marking）</strong>：<ul>
<li>在整个堆中进行并发标记（和应用程序并发执行），此过程可能被Young GC中断。</li>
<li><strong>在并发标记阶段，若发现区域对象中的所有对象都是垃圾，那这个区域会被立即回收。</strong></li>
<li>同时，并发标记过程中，会计算每个区域的对象活性（区域中存活对象的比例）。</li>
</ul>
</li>
<li><strong>再次标记（Remark）</strong>：由于应用程序持续进行，需要修正上一次的标记结果。是STW的。G1中采用了比CMS更快的原始快照算法：Snapshot-At-The-Beginning（SATB）。</li>
<li><strong>独占清理（cleanup，STW）</strong>：计算各个区域的存活对象和GC回收比例，并进行排序，识别可以混合回收的区域。为下阶段做铺垫。是STW的。这个阶段并不会实际上去做垃圾的收集</li>
<li><strong>并发清理阶段</strong>：识别并清理完全空闲的区域。</li>
</ol>
<h2 id="G1回收过程三：混合回收过程"><a href="#G1回收过程三：混合回收过程" class="headerlink" title="G1回收过程三：混合回收过程"></a>G1回收过程三：混合回收过程</h2><p>当越来越多的对象晋升到老年代Old Region时，为了避免堆内存被耗尽，虚拟机会触发一个混合的垃圾收集器，即Mixed GC，该算法并不是一个Old GC，除了回收整个Young Region，还会回收一部分的Old Region。这里需要注意：<strong>是一部分老年代，而不是全部老年代</strong>。可以选择哪些Old Region进行收集，从而可以对垃圾回收的耗时时间进行控制。也要注意的是Mixed GC并不是Full GC。</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220730212004610.png" alt="image-20220730212004610"></p>
<p><strong>混合回收的细节</strong></p>
<ol>
<li>并发标记结束以后，老年代中百分百为垃圾的内存分段被回收了，部分为垃圾的内存分段被计算了出来。默认情况下，这些老年代的内存分段会分8次（可以通过-XX:G1MixedGCCountTarget设置）被回收。【意思就是一个Region会被分为8个内存段】</li>
<li>混合回收的回收集（Collection Set）包括八分之一的老年代内存分段，Eden区内存分段，Survivor区内存分段。混合回收的算法和年轻代回收的算法完全一样，只是回收集多了老年代的内存分段。具体过程请参考上面的年轻代回收过程。</li>
<li>由于老年代中的内存分段默认分8次回收，G1会优先回收垃圾多的内存分段。垃圾占内存分段比例越高的，越会被先回收。并且有一个阈值会决定内存分段是否被回收。XX:G1MixedGCLiveThresholdPercent，默认为65%，意思是垃圾占内存分段比例要达到65%才会被回收。如果垃圾占比太低，意味着存活的对象占比高，在复制的时候会花费更多的时间。</li>
<li>混合回收并不一定要进行8次。有一个阈值**-XX:G1HeapWastePercent**，默认值为10%，意思是允许整个堆内存中有10%的空间被浪费，意味着如果发现可以回收的垃圾占堆内存的比例低于10%，则不再进行混合回收。因为GC会花费很多的时间但是回收到的内存却很少。</li>
</ol>
<h2 id="G1-回收可选的过程四：Full-GC"><a href="#G1-回收可选的过程四：Full-GC" class="headerlink" title="G1 回收可选的过程四：Full GC"></a>G1 回收可选的过程四：Full GC</h2><ol>
<li><p>G1的初衷就是要避免Full GC的出现。但是如果上述方式不能正常工作，<strong>G1会停止应用程序的执行（Stop-The-World）</strong>，使用<strong>单线程</strong>的内存回收算法进行垃圾回收，性能会非常差，应用程序停顿时间会很长。</p>
</li>
<li><p>要避免Full GC的发生，一旦发生Full GC，需要对JVM参数进行调整。什么时候会发生Ful1GC呢？比如<strong>堆内存太小</strong>，当G1在复制存活对象的时候没有空的内存分段可用，则会回退到Full GC，这种情况可以通过增大内存解决。</p>
</li>
</ol>
<p><strong>导致G1 Full GC的原因可能有两个：</strong></p>
<ol>
<li>EVacuation的时候没有足够的to-space来存放晋升的对象；</li>
<li>并发处理过程完成之前空间耗尽。</li>
</ol>
<h2 id="G1补充"><a href="#G1补充" class="headerlink" title="G1补充"></a>G1补充</h2><p>从Oracle官方透露出来的信息可获知，回收阶段（Evacuation）其实本也有想过设计成与用户程序一起并发执行，但这件事情做起来比较复杂，考虑到G1只是回一部分Region，停顿时间是用户可控制的，所以并不迫切去实现，<strong>而选择把这个特性放到了G1之后出现的低延迟垃圾收集器（即ZGC）中。</strong>另外，还考虑到G1不是仅仅面向低延迟，停顿用户线程能够最大幅度提高垃圾收集效率，为了保证吞吐量所以才选择了完全暂停用户线程的实现方案。</p>
<p><strong>G1 回收器的优化建议</strong></p>
<ol>
<li>年轻代大小<ul>
<li>避免使用-Xmn或-XX:NewRatio等相关选项显式设置年轻代大小，因为固定年轻代的大小会覆盖可预测的暂停时间目标。我们让G1自己去调整</li>
</ul>
</li>
<li>暂停时间目标不要太过严苛<ul>
<li>G1 GC的吞吐量目标是90%的应用程序时间和10%的垃圾回收时间</li>
<li>评估G1 GC的吞吐量时，暂停时间目标不要太严苛。目标太过严苛表示你愿意承受更多的垃圾回收开销，而这些会直接影响到吞吐量。</li>
</ul>
</li>
</ol>
<h1 id="垃圾回收器总结"><a href="#垃圾回收器总结" class="headerlink" title="垃圾回收器总结"></a>垃圾回收器总结</h1><h2 id="7-种垃圾回收器的比较"><a href="#7-种垃圾回收器的比较" class="headerlink" title="7 种垃圾回收器的比较"></a>7 种垃圾回收器的比较</h2><p>截止JDK1.8，一共有7款不同的垃圾收集器。每一款的垃圾收集器都有不同的特点，在具体使用的时候，需要根据具体的情况选用不同的垃圾收集器。</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220730212626643.png" alt="image-20220730212626643"></p>
<img src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_012/0024.png">

<h2 id="怎么选择垃圾回收器"><a href="#怎么选择垃圾回收器" class="headerlink" title="怎么选择垃圾回收器"></a>怎么选择垃圾回收器</h2><p>Java垃圾收集器的配置对于JVM优化来说是一个很重要的选择，选择合适的垃圾收集器可以让JVM的性能有一个很大的提升。怎么选择垃圾收集器？</p>
<ol>
<li>优先调整堆的大小让JVM自适应完成。</li>
<li>如果内存小于100M，使用串行收集器</li>
<li>如果是单核、单机程序，并且没有停顿时间的要求，串行收集器</li>
<li>如果是多CPU、需要高吞吐量、允许停顿时间超过1秒，选择并行或者JVM自己选择</li>
<li>如果是多CPU、追求低停顿时间，需快速响应（比如延迟不能超过1秒，如互联网应用），使用并发收集器</li>
<li>官方推荐G1，性能高。现在互联网的项目，基本都是使用G1。</li>
</ol>
<p>最后需要明确一个观点：</p>
<ol>
<li>没有最好的收集器，更没有万能的收集算法</li>
<li>调优永远是针对特定场景、特定需求，不存在一劳永逸的收集器</li>
</ol>
<p><strong>面试</strong></p>
<ol>
<li>对于垃圾收集，面试官可以循序渐进从理论、实践各种角度深入，也未必是要求面试者什么都懂。但如果你懂得原理，一定会成为面试中的加分项。</li>
<li>这里较通用、基础性的部分如下：<ul>
<li>垃圾收集的算法有哪些？如何判断一个对象是否可以回收？</li>
<li>垃圾收集器工作的基本流程。</li>
</ul>
</li>
<li>另外，大家需要多关注垃圾回收器这一章的各种常用的参数</li>
</ol>
<h1 id="GC-日志分析"><a href="#GC-日志分析" class="headerlink" title="GC 日志分析"></a>GC 日志分析</h1><h2 id="常用参数配置"><a href="#常用参数配置" class="headerlink" title="常用参数配置"></a>常用参数配置</h2><blockquote>
<p><strong>GC 日志参数设置</strong></p>
</blockquote>
<p><strong>通过阅读GC日志，我们可以了解Java虚拟机内存分配与回收策略。</strong></p>
<p>内存分配与垃圾回收的参数列表</p>
<ol>
<li><strong>-XX:+PrintGC</strong> ：输出GC日志。类似：-verbose:gc</li>
<li><strong>-XX:+PrintGCDetails</strong> ：输出GC的详细日志</li>
<li><strong>-XX:+PrintGCTimestamps</strong> ：输出GC的时间戳（以基准时间的形式）</li>
<li><strong>-XX:+PrintGCDatestamps</strong> ：输出GC的时间戳（以日期的形式，如2013-05-04T21: 53: 59.234 +0800）</li>
<li><strong>-XX:+PrintHeapAtGC</strong> ：在进行GC的前后打印出堆的信息</li>
<li><strong>-Xloggc:…&#x2F;logs&#x2F;gc.log</strong> ：日志文件的输出路径</li>
</ol>
<blockquote>
<p><strong>verbose:gc</strong></p>
</blockquote>
<p>1、JVM 参数</p>
<p><code>-verbose:gc</code></p>
<p>2、这个只会显示总的GC堆的变化，如下：</p>
<img src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_012/0025.png">

<p>3、参数解析</p>
<img src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_012/0026.png">

<blockquote>
<p><strong>PrintGCDetails</strong></p>
</blockquote>
<p>1、JVM 参数</p>
<p><code>-XX:+PrintGCDetails</code></p>
<p>2、输入信息如下</p>
<img src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_012/0027.png">

<p>3、参数解析</p>
<img src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_012/0028.png">

<blockquote>
<p><strong>PrintGCTimestamps 和 PrintGCDatestamps</strong></p>
</blockquote>
<p>1、JVM 参数</p>
<p><code>-XX:+PrintGCTimeStamps -XX:+PrintGCDateStamps</code></p>
<p>2、输出信息如下</p>
<img src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_012/0029.png">

<p>3、说明：日志带上了日期和时间</p>
<h2 id="GC-日志补充说明"><a href="#GC-日志补充说明" class="headerlink" title="GC 日志补充说明"></a>GC 日志补充说明</h2><ol>
<li><p>“[GC”和”[Full GC”说明了这次垃圾收集的停顿类型，如果有”Full”则说明GC发生了”Stop The World”</p>
</li>
<li><p>使用Serial收集器在新生代的名字是Default New Generation，因此显示的是”[DefNew”</p>
</li>
<li><p>使用ParNew收集器在新生代的名字会变成”[ParNew”，意思是”Parallel New Generation”</p>
</li>
<li><p>使用Parallel scavenge收集器在新生代的名字是”[PSYoungGen”</p>
</li>
<li><p>老年代的收集和新生代道理一样，名字也是收集器决定的</p>
</li>
<li><p>使用G1收集器的话，会显示为”garbage-first heap”</p>
</li>
<li><p>Allocation Failure表明本次引起GC的原因是因为在年轻代中没有足够的空间能够存储新的数据了。</p>
</li>
<li><p>[ PSYoungGen: 5986K-&gt;696K(8704K) ] 5986K-&gt;704K (9216K)</p>
<ul>
<li>中括号内：GC回收前年轻代大小，回收后大小，（年轻代总大小）</li>
<li>括号外：GC回收前年轻代和老年代大小，回收后大小，（年轻代和老年代总大小）</li>
</ul>
</li>
<li><p>user代表用户态回收耗时，sys内核态回收耗时，real实际耗时。由于多核线程切换的原因，时间总和可能会超过real时间</p>
</li>
</ol>
<h3 id="Young-GC"><a href="#Young-GC" class="headerlink" title="Young GC"></a>Young GC</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220730214301391.png" alt="image-20220730214301391"></p>
<h3 id="Full-GC"><a href="#Full-GC" class="headerlink" title="Full GC"></a>Full GC</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220730214415439.png" alt="image-20220730214415439"></p>
<h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在jdk7 和 jdk8中分别执行</span></span><br><span class="line"><span class="comment"> * -verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8 -XX:+UseSerialGC</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GCLogTest1</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_1MB</span> <span class="operator">=</span> <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testAllocation</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">byte</span>[] allocation1, allocation2, allocation3, allocation4;</span><br><span class="line">        allocation1 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">        allocation2 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">        allocation3 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">        allocation4 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] agrs)</span> &#123;</span><br><span class="line">        testAllocation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>JDK7 中的情况</strong></p>
<p>1、首先我们会将3个2M的数组存放到Eden区，然后后面4M的数组来了后，将无法存储，因为Eden区只剩下2M的剩余空间了，那么将会进行一次Young GC操作，将原来Eden区的内容，存放到Survivor区，但是Survivor区也存放不下，那么就会直接晋级存入Old 区</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220730214824946.png" alt="image-20220730214824946"></p>
<p>2、然后我们将4M对象存入到Eden区中</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220730215136327.png" alt="image-20220730215136327"></p>
<p>老年代图画的有问题，free应该是4M</p>
<p><strong>JDK8 中的情况</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">com.atguigu.java.GCLogTest1</span><br><span class="line">[GC (Allocation Failure) [DefNew: 6322K-&gt;668K(9216K), <span class="number">0.0034812</span> secs] 6322K-&gt;4764K(19456K), <span class="number">0.0035169</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">Heap</span><br><span class="line"> def <span class="keyword">new</span> <span class="title class_">generation</span>   total 9216K, used 7050K [<span class="number">0x00000000fec00000</span>, <span class="number">0x00000000ff600000</span>, <span class="number">0x00000000ff600000</span>)</span><br><span class="line">  eden space 8192K,  <span class="number">77</span>% used [<span class="number">0x00000000fec00000</span>, <span class="number">0x00000000ff23b668</span>, <span class="number">0x00000000ff400000</span>)</span><br><span class="line">  from space 1024K,  <span class="number">65</span>% used [<span class="number">0x00000000ff500000</span>, <span class="number">0x00000000ff5a71d8</span>, <span class="number">0x00000000ff600000</span>)</span><br><span class="line">  to   space 1024K,   <span class="number">0</span>% used [<span class="number">0x00000000ff400000</span>, <span class="number">0x00000000ff400000</span>, <span class="number">0x00000000ff500000</span>)</span><br><span class="line"> tenured generation   total 10240K, used 4096K [<span class="number">0x00000000ff600000</span>, <span class="number">0x0000000100000000</span>, <span class="number">0x0000000100000000</span>)</span><br><span class="line">   the space 10240K,  <span class="number">40</span>% used [<span class="number">0x00000000ff600000</span>, <span class="number">0x00000000ffa00020</span>, <span class="number">0x00000000ffa00200</span>, <span class="number">0x0000000100000000</span>)</span><br><span class="line"> Metaspace       used 3469K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">space</span>    used 381K, capacity 388K, committed 512K, reserved 1048576K</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure>

<img src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_012/0035.jpg">

<p>与 JDK7 不同的是，JDK8 直接判定 4M 的数组为大对象，直接怼到老年区去了</p>
<h2 id="常用日志分析工具"><a href="#常用日志分析工具" class="headerlink" title="常用日志分析工具"></a>常用日志分析工具</h2><p><strong>保存日志文件</strong></p>
<p><strong>JVM参数</strong>：<code>-XLoggc:./logs/gc.log</code>，  .&#x2F; 表示当前目录，在 IDEA中程序运行的当前目录是工程的根目录，而不是模块的根目录</p>
<p>可以用一些工具去分析这些GC日志，常用的日志分析工具有：</p>
<p>GCViewer(Github上的jar包)、GCEasy、GCHisto、GCLogViewer、Hpjmeter、garbagecat等</p>
<p><strong>推荐：GCeasy</strong></p>
<p>在线分析网址：gceasy.io</p>
<img src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_012/0036.jpg">

<img src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_012/0037.png">

<img src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_012/0038.png">

<h1 id="垃圾回收器的新发展"><a href="#垃圾回收器的新发展" class="headerlink" title="垃圾回收器的新发展"></a>垃圾回收器的新发展</h1><h2 id="垃圾回收器的发展过程"><a href="#垃圾回收器的发展过程" class="headerlink" title="垃圾回收器的发展过程"></a>垃圾回收器的发展过程</h2><ol>
<li>GC仍然处于飞速发展之中，目前的默认选项<strong>G1 GC在不断的进行改进</strong>，很多我们原来认为的缺点，例如串行的Full GC、Card Table扫描的低效等，都已经被大幅改进，例如，JDK10以后，Fu11GC已经是并行运行，在很多场景下，其表现还略优于ParallelGC的并行Ful1GC实现。</li>
<li>即使是SerialGC，虽然比较古老，但是简单的设计和实现未必就是过时的，它本身的开销，不管是GC相关数据结构的开销，还是线程的开销，都是非常小的，所以随着云计算的兴起，<strong>在serverless等新的应用场景下，Serial Gc找到了新的舞台</strong>。</li>
<li>比较不幸的是CMSGC，因为其算法的理论缺陷等原因，虽然现在还有非常大的用户群体，但在JDK9中已经被标记为废弃，并在JDK14版本中移除</li>
<li>现在G1回收器已成为默认回收器好几年了。我们还看到了引入了两个新的收集器：<strong>ZGC（JDK11出现）和Shenandoah（Open JDK12）</strong>，其特点：<strong>主打低停顿时间</strong></li>
</ol>
<h2 id="Shenandoah-GC"><a href="#Shenandoah-GC" class="headerlink" title="Shenandoah GC"></a>Shenandoah GC</h2><p><strong>Open JDK12的Shenandoash GC：低停顿时间的GC（实验性）</strong></p>
<ol>
<li><p>Shenandoah无疑是众多GC中最孤独的一个。是第一款不由Oracle公司团队领导开发的Hotspot垃圾收集器。不可避免的受到官方的排挤。比如号称openJDK和OracleJDK没有区别的Oracle公司仍拒绝在OracleJDK12中支持Shenandoah。</p>
</li>
<li><p>Shenandoah垃圾回收器最初由RedHat进行的一项垃圾收集器研究项目Pauseless GC的实现，<strong>旨在针对JVM上的内存回收实现低停顿的需求</strong>。在2014年贡献给OpenJDK。</p>
</li>
<li><p>Red Hat研发Shenandoah团队对外宣称，<strong>Shenandoah垃圾回收器的暂停时间与堆大小无关，这意味着无论将堆设置为200MB还是200GB，99.9%的目标都可以把垃圾收集的停顿时间限制在十毫秒以内</strong>。不过实际使用性能将取决于实际工作堆的大小和工作负载。</p>
</li>
</ol>
<p>这是RedHat在2016年发表的论文数据，测试内容是使用ES对200GB的维基百科数据进行索引。从结果看：</p>
<ol>
<li>停顿时间比其他几款收集器确实有了质的飞跃，但也未实现最大停顿时间控制在十毫秒以内的目标。</li>
<li>而吞吐量方面出现了明显的下降，总运行时间是所有测试收集器里最长的。</li>
</ol>
<img src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_012/0039.png">

<p>总结</p>
<ol>
<li>Shenandoah GC的弱项：<strong>高运行负担下的吞吐量下降。</strong></li>
<li>Shenandoah GC的强项：<strong>低延迟时间。</strong></li>
</ol>
<h2 id="令人震惊、革命性的-ZGC"><a href="#令人震惊、革命性的-ZGC" class="headerlink" title="令人震惊、革命性的 ZGC"></a>令人震惊、革命性的 ZGC</h2><ol>
<li><p>官方文档：<a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/12/gctuning/">https://docs.oracle.com/en/java/javase/12/gctuning/</a></p>
</li>
<li><p>ZGC与Shenandoah目标高度相似，<strong>在尽可能对吞吐量影响不大的前提下，实现在任意堆内存大小下都可以把垃圾收集的停颇时间限制在十毫秒以内的低延迟。</strong></p>
</li>
<li><p>《深入理解Java虚拟机》一书中这样定义ZGC：ZGC收集器是一款基于Region内存布局的，（暂时）不设分代的，使用了读屏障、染色指针和内存多重映射等技术来实现<strong>可并发的标记-压缩算法</strong>的，以<strong>低延迟为首要目标</strong>的一款垃圾收集器。</p>
</li>
<li><p>ZGC的工作过程可以分为4个阶段：<strong>并发标记 - 并发预备重分配 - 并发重分配 - 并发重映射</strong> 等。</p>
</li>
<li><p>ZGC几乎在所有地方并发执行的，除了初始标记的是STW的。所以停顿时间几乎就耗费在初始标记上，这部分的实际时间是非常少的。</p>
</li>
</ol>
<p><strong>吞吐量</strong></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220731111325771.png" alt="image-20220731111325771"></p>
<p>max-JOPS：以低延迟为首要前提下的数据</p>
<p>critical-JOPS：不考虑低延迟下的数据</p>
<p><strong>低延迟</strong></p>
<img src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_012/0041.png">

<p>在ZGC的强项停顿时间测试上，它毫不留情的将Parallel、G1拉开了两个数量级的差距。无论平均停顿、95%停顿、998停顿、99. 98停顿，还是最大停顿时间，ZGC都能毫不费劲控制在10毫秒以内。</p>
<p>虽然ZGC还在试验状态，没有完成所有特性，但此时性能已经相当亮眼，用“令人震惊、革命性”来形容，不为过。</p>
<p><strong>未来将在服务端、大内存、低延迟应用的首选垃圾收集器。</strong></p>
<img src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_012/0042.png">



<ol>
<li><p>JDK14之前，ZGC仅Linux才支持。</p>
</li>
<li><p>尽管许多使用ZGC的用户都使用类Linux的环境，但在Windows和macOS上，人们也需要ZGC进行开发部署和测试。许多桌面应用也可以从ZGC中受益。因此，ZGC特性被移植到了Windows和macOS上。</p>
</li>
<li><p>现在mac或Windows上也能使用ZGC了，示例如下：</p>
<p>-XX:+UnlockExperimentalVMOptions-XX：+UseZGC</p>
</li>
</ol>
<h2 id="面向大堆的-AliGC"><a href="#面向大堆的-AliGC" class="headerlink" title="面向大堆的 AliGC"></a>面向大堆的 AliGC</h2><p>AliGC是阿里巴巴JVM团队基于G1算法，面向大堆（LargeHeap）应用场景。指定场景下的对比：</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220731111601134.png" alt="image-20220731111601134"></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-JVM：垃圾回收相关概念"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
	
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/07/25/JVM%EF%BC%9A%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"
    >垃圾回收相关概念</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/07/25/JVM%EF%BC%9A%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/" class="article-date">
  <time datetime="2022-07-25T09:59:50.000Z" itemprop="datePublished">2022-07-25</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/JVM/">JVM</a> / <a class="article-category-link" href="/categories/JVM/1-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/">1.内存与垃圾回收篇</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="System-gc-的理解"><a href="#System-gc-的理解" class="headerlink" title="System.gc() 的理解"></a>System.gc() 的理解</h1><ul>
<li>在默认情况下，通过System.gc()者Runtime.getRuntime().gc() 的调用，<strong>会显式触发Full GC</strong>，同时对老年代和新生代进行回收，尝试释放被丢弃对象占用的内存。</li>
<li>然而System.gc()调用附带一个免责声明，无法保证对垃圾收集器的调用(不能确保立即生效)</li>
<li>JVM实现者可以通过System.gc() 调用来决定JVM的GC行为。而一般情况下，垃圾回收应该是自动进行的，<strong>无须手动触发，否则就太过于麻烦了。</strong>在一些特殊情况下，如我们正在编写一个性能基准，我们可以在运行之间调用System.gc()</li>
</ul>
<p><strong>代码示例：手动执行 GC 操作</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SystemGCTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">SystemGCTest</span>();</span><br><span class="line">        System.gc();<span class="comment">//提醒jvm的垃圾回收器执行gc,但是不确定是否马上执行gc</span></span><br><span class="line">        <span class="comment">//与Runtime.getRuntime().gc();的作用一样。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        System.runFinalization();//强制调用使用引用的对象的finalize()方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果发生了GC，这个finalize()一定会被调用</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="built_in">super</span>.finalize();</span><br><span class="line">        System.out.println(<span class="string">&quot;SystemGCTest 重写了finalize()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果不确定：有时候会调用 finalize() 方法，有时候并不会调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SystemGCTest 重写了finalize()</span><br><span class="line">或</span><br><span class="line">空</span><br></pre></td></tr></table></figure>

<h2 id="手动-GC-理解不可达对象的回收行为"><a href="#手动-GC-理解不可达对象的回收行为" class="headerlink" title="手动 GC 理解不可达对象的回收行为"></a>手动 GC 理解不可达对象的回收行为</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加上参数：  -XX:+PrintGCDetails</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LocalVarGC</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">localvarGC1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>];<span class="comment">//10MB</span></span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">localvarGC2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">        buffer = <span class="literal">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">localvarGC3</span><span class="params">()</span> &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">localvarGC4</span><span class="params">()</span> &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">localvarGC5</span><span class="params">()</span> &#123;</span><br><span class="line">        localvarGC1();</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">LocalVarGC</span> <span class="variable">local</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LocalVarGC</span>();</span><br><span class="line">        <span class="comment">//通过在main方法调用这几个方法进行测试</span></span><br><span class="line">        local.localvarGC1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>1、调用 localvarGC1() 方法</strong></p>
<p>执行 System.gc() 仅仅是将年轻代的 buffer 数组对象放到了老年代，buffer对象仍然没有回收</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[GC (System.gc()) [PSYoungGen: 15497K-&gt;10728K(76288K)] 15497K-&gt;10912K(251392K), <span class="number">0.0049863</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.01</span> secs] </span><br><span class="line">[Full <span class="title function_">GC</span> <span class="params">(System.gc()</span>) [PSYoungGen: 10728K-&gt;0K(76288K)] [ParOldGen: 184K-&gt;10842K(175104K)] 10912K-&gt;10842K(251392K), [Metaspace: 3222K-&gt;3222K(1056768K)], <span class="number">0.0045188</span> secs] [Times: user=<span class="number">0.02</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 76288K, used 1966K [<span class="number">0x000000076b200000</span>, <span class="number">0x0000000770700000</span>, <span class="number">0x00000007c0000000</span>)</span><br><span class="line">  eden space 65536K, <span class="number">3</span>% used [<span class="number">0x000000076b200000</span>,<span class="number">0x000000076b3eb9e0</span>,<span class="number">0x000000076f200000</span>)</span><br><span class="line">  from space 10752K, <span class="number">0</span>% used [<span class="number">0x000000076f200000</span>,<span class="number">0x000000076f200000</span>,<span class="number">0x000000076fc80000</span>)</span><br><span class="line">  to   space 10752K, <span class="number">0</span>% used [<span class="number">0x000000076fc80000</span>,<span class="number">0x000000076fc80000</span>,<span class="number">0x0000000770700000</span>)</span><br><span class="line"> ParOldGen       total 175104K, used 10842K [<span class="number">0x00000006c1600000</span>, <span class="number">0x00000006cc100000</span>, <span class="number">0x000000076b200000</span>)</span><br><span class="line">  object space 175104K, <span class="number">6</span>% used [<span class="number">0x00000006c1600000</span>,<span class="number">0x00000006c2096ac8</span>,<span class="number">0x00000006cc100000</span>)</span><br><span class="line"> Metaspace       used 3231K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">space</span>    used 350K, capacity 388K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure>

<p><strong>2、调用 localvarGC2() 方法</strong></p>
<p>由于 buffer 数组对象没有引用指向它，执行 System.gc() 将被回收</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[GC (System.gc()) [PSYoungGen: 15497K-&gt;792K(76288K)] 15497K-&gt;800K(251392K), <span class="number">0.0006368</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">[Full <span class="title function_">GC</span> <span class="params">(System.gc()</span>) [PSYoungGen: 792K-&gt;0K(76288K)] [ParOldGen: 8K-&gt;627K(175104K)] 800K-&gt;627K(251392K), [Metaspace: 3238K-&gt;3238K(1056768K)], <span class="number">0.0033067</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 76288K, used 655K [<span class="number">0x000000076b200000</span>, <span class="number">0x0000000770700000</span>, <span class="number">0x00000007c0000000</span>)</span><br><span class="line">  eden space 65536K, <span class="number">1</span>% used [<span class="number">0x000000076b200000</span>,<span class="number">0x000000076b2a3ee8</span>,<span class="number">0x000000076f200000</span>)</span><br><span class="line">  from space 10752K, <span class="number">0</span>% used [<span class="number">0x000000076f200000</span>,<span class="number">0x000000076f200000</span>,<span class="number">0x000000076fc80000</span>)</span><br><span class="line">  to   space 10752K, <span class="number">0</span>% used [<span class="number">0x000000076fc80000</span>,<span class="number">0x000000076fc80000</span>,<span class="number">0x0000000770700000</span>)</span><br><span class="line"> ParOldGen       total 175104K, used 627K [<span class="number">0x00000006c1600000</span>, <span class="number">0x00000006cc100000</span>, <span class="number">0x000000076b200000</span>)</span><br><span class="line">  object space 175104K, <span class="number">0</span>% used [<span class="number">0x00000006c1600000</span>,<span class="number">0x00000006c169cc20</span>,<span class="number">0x00000006cc100000</span>)</span><br><span class="line"> Metaspace       used 3244K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">space</span>    used 352K, capacity 388K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure>

<p><strong>3、调用 localvarGC3() 方法</strong></p>
<p>虽然出了代码块的作用域，但是 buffer 数组对象并没有被回收</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[GC (System.gc()) [PSYoungGen: 15497K-&gt;10728K(76288K)] 15497K-&gt;10992K(251392K), <span class="number">0.0041267</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">[Full <span class="title function_">GC</span> <span class="params">(System.gc()</span>) [PSYoungGen: 10728K-&gt;0K(76288K)] [ParOldGen: 264K-&gt;10867K(175104K)] 10992K-&gt;10867K(251392K), [Metaspace: 3237K-&gt;3237K(1056768K)], <span class="number">0.0044806</span> secs] [Times: user=<span class="number">0.03</span> sys=<span class="number">0.02</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 76288K, used 655K [<span class="number">0x000000076b200000</span>, <span class="number">0x0000000770700000</span>, <span class="number">0x00000007c0000000</span>)</span><br><span class="line">  eden space 65536K, <span class="number">1</span>% used [<span class="number">0x000000076b200000</span>,<span class="number">0x000000076b2a3ee8</span>,<span class="number">0x000000076f200000</span>)</span><br><span class="line">  from space 10752K, <span class="number">0</span>% used [<span class="number">0x000000076f200000</span>,<span class="number">0x000000076f200000</span>,<span class="number">0x000000076fc80000</span>)</span><br><span class="line">  to   space 10752K, <span class="number">0</span>% used [<span class="number">0x000000076fc80000</span>,<span class="number">0x000000076fc80000</span>,<span class="number">0x0000000770700000</span>)</span><br><span class="line"> ParOldGen       total 175104K, used 10867K [<span class="number">0x00000006c1600000</span>, <span class="number">0x00000006cc100000</span>, <span class="number">0x000000076b200000</span>)</span><br><span class="line">  object space 175104K, <span class="number">6</span>% used [<span class="number">0x00000006c1600000</span>,<span class="number">0x00000006c209cc30</span>,<span class="number">0x00000006cc100000</span>)</span><br><span class="line"> Metaspace       used 3244K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">space</span>    used 352K, capacity 388K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure>

<p><strong>原因：</strong></p>
<p>1、来看看字节码：实例方法局部变量表第一个变量肯定是 this</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220725161734878.png" alt="image-20220725161734878"></p>
<p>2、你有没有看到，局部变量表的大小是 2。但是局部变量表里只有一个索引为0的啊？那索引为1的是哪个局部变量呢？实际上索引为1的位置是buffer在占用着，执行 System.gc() 时，栈中还有 buffer 变量指向堆中的字节数组，所以没有进行GC</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220725161759121.png" alt="image-20220725161759121"></p>
<p>3、那么这种代码块的情况，什么时候会被GC呢？我们来看第四个方法</p>
<p><strong>4、调用 localvarGC4() 方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[GC (System.gc()) [PSYoungGen: 15497K-&gt;824K(76288K)] 15497K-&gt;832K(251392K), <span class="number">0.0006443</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">[Full <span class="title function_">GC</span> <span class="params">(System.gc()</span>) [PSYoungGen: 824K-&gt;0K(76288K)] [ParOldGen: 8K-&gt;627K(175104K)] 832K-&gt;627K(251392K), [Metaspace: 3238K-&gt;3238K(1056768K)], <span class="number">0.0036469</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 76288K, used 655K [<span class="number">0x000000076b200000</span>, <span class="number">0x0000000770700000</span>, <span class="number">0x00000007c0000000</span>)</span><br><span class="line">  eden space 65536K, <span class="number">1</span>% used [<span class="number">0x000000076b200000</span>,<span class="number">0x000000076b2a3ee8</span>,<span class="number">0x000000076f200000</span>)</span><br><span class="line">  from space 10752K, <span class="number">0</span>% used [<span class="number">0x000000076f200000</span>,<span class="number">0x000000076f200000</span>,<span class="number">0x000000076fc80000</span>)</span><br><span class="line">  to   space 10752K, <span class="number">0</span>% used [<span class="number">0x000000076fc80000</span>,<span class="number">0x000000076fc80000</span>,<span class="number">0x0000000770700000</span>)</span><br><span class="line"> ParOldGen       total 175104K, used 627K [<span class="number">0x00000006c1600000</span>, <span class="number">0x00000006cc100000</span>, <span class="number">0x000000076b200000</span>)</span><br><span class="line">  object space 175104K, <span class="number">0</span>% used [<span class="number">0x00000006c1600000</span>,<span class="number">0x00000006c169cc20</span>,<span class="number">0x00000006cc100000</span>)</span><br><span class="line"> Metaspace       used 3244K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">space</span>    used 352K, capacity 388K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure>

<p>Q：就多定义了一个局部变量 value ，就可以把字节数组回收了呢？</p>
<p>A：局部变量表长度为 2 ，这说明了出了代码块时，buffer 就出了其作用域范围，此时没有为 value 开启新的槽，value 变量直接占据了 buffer 变量的槽（Slot），导致堆中的字节数组没有引用再指向它，执行 System.gc() 时被回收。看 value 位于局部变量表中索引为 1 的位置。value这个局部变量把原本属于buffer的slot给占用了，这样栈上就没有buffer变量指向<code>new byte[10 * 1024 * 1024]</code>实例了。</p>
<blockquote>
<p>这点看不懂的可以看我前面的文章：虚拟机栈 –&gt; Slot的重复利用</p>
</blockquote>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220725162030672.png" alt="image-20220725162030672"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220725162011910.png" alt="image-20220725162011910"></p>
<p><strong>5、调用 localvarGC5() 方法</strong></p>
<p>局部变量除了方法范围就是失效了，堆中的字节数组铁定被回收</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[GC (System.gc()) [PSYoungGen: 15497K-&gt;10728K(76288K)] 15497K-&gt;10928K(251392K), <span class="number">0.0095102</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.01</span> secs] </span><br><span class="line">[Full <span class="title function_">GC</span> <span class="params">(System.gc()</span>) [PSYoungGen: 10728K-&gt;0K(76288K)] [ParOldGen: 200K-&gt;10867K(175104K)] 10928K-&gt;10867K(251392K), [Metaspace: 3237K-&gt;3237K(1056768K)], <span class="number">0.0209722</span> secs] [Times: user=<span class="number">0.05</span> sys=<span class="number">0.01</span>, real=<span class="number">0.02</span> secs] </span><br><span class="line">[GC (System.gc()) [PSYoungGen: 0K-&gt;0K(76288K)] 10867K-&gt;10867K(251392K), <span class="number">0.0005611</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">[Full <span class="title function_">GC</span> <span class="params">(System.gc()</span>) [PSYoungGen: 0K-&gt;0K(76288K)] [ParOldGen: 10867K-&gt;627K(175104K)] 10867K-&gt;627K(251392K), [Metaspace: 3237K-&gt;3237K(1056768K)], <span class="number">0.0108176</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.01</span> secs] </span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 76288K, used 655K [<span class="number">0x000000076b200000</span>, <span class="number">0x0000000770700000</span>, <span class="number">0x00000007c0000000</span>)</span><br><span class="line">  eden space 65536K, <span class="number">1</span>% used [<span class="number">0x000000076b200000</span>,<span class="number">0x000000076b2a3ee8</span>,<span class="number">0x000000076f200000</span>)</span><br><span class="line">  from space 10752K, <span class="number">0</span>% used [<span class="number">0x000000076fc80000</span>,<span class="number">0x000000076fc80000</span>,<span class="number">0x0000000770700000</span>)</span><br><span class="line">  to   space 10752K, <span class="number">0</span>% used [<span class="number">0x000000076f200000</span>,<span class="number">0x000000076f200000</span>,<span class="number">0x000000076fc80000</span>)</span><br><span class="line"> ParOldGen       total 175104K, used 627K [<span class="number">0x00000006c1600000</span>, <span class="number">0x00000006cc100000</span>, <span class="number">0x000000076b200000</span>)</span><br><span class="line">  object space 175104K, <span class="number">0</span>% used [<span class="number">0x00000006c1600000</span>,<span class="number">0x00000006c169cc20</span>,<span class="number">0x00000006cc100000</span>)</span><br><span class="line"> Metaspace       used 3244K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">space</span>    used 352K, capacity 388K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure>

<h1 id="内存溢出与内存泄漏"><a href="#内存溢出与内存泄漏" class="headerlink" title="内存溢出与内存泄漏"></a>内存溢出与内存泄漏</h1><h2 id="内存溢出"><a href="#内存溢出" class="headerlink" title="内存溢出"></a>内存溢出</h2><ul>
<li>内存溢出相对于内存泄漏来说，尽管更容易被理解，但是同样的，内存溢出也是引发程序崩溃的罪魁祸首之一。</li>
<li>由于GC一直在发展，所有一般情况下，除非应用程序占用的内存增长速度非常快，造成垃圾回收已经跟不上内存消耗的速度，否则不太容易出现OOM的情况。</li>
<li>大多数情况下，GC会进行各种年龄段的垃圾回收，实在不行了就放大招，来一次独占式的Full GC操作，这时候会回收大量的内存，供应用程序继续使用</li>
<li>Javadoc中对OutofMemoryError的解释是，没有空闲内存，并且垃圾收集器也无法提供更多内存。</li>
</ul>
<p><strong>内存溢出（OOM）原因分析</strong></p>
<p>首先说没有空闲内存的情况：说明Java虚拟机的堆内存不够。原因有二：</p>
<ol>
<li>Java虚拟机的堆内存设置不够。<ul>
<li>比如：可能存在内存泄漏问题；也很有可能就是堆的大小不合理，比如我们要处理比较可观的数据量，但是没有显式指定JVM堆大小或者指定数值偏小。我们可以通过参数-Xms 、-Xmx来调整。</li>
</ul>
</li>
<li>代码中创建了大量大对象，并且长时间不能被垃圾收集器收集（存在被引用）<ul>
<li>对于老版本的Oracle JDK，因为永久代的大小是有限的，并且JVM对永久代垃圾回收（如，常量池回收、卸载不再需要的类型）非常不积极，所以当我们不断添加新类型的时候，永久代出现OutOfMemoryError也非常多见。尤其是在运行时存在大量动态类型生成的场合；类似intern字符串缓存占用太多空间，也会导致OOM问题。对应的异常信息，会标记出来和永久代相关：“java.lang.OutOfMemoryError:PermGen space”。</li>
<li>随着元数据区的引入，方法区内存已经不再那么窘迫，所以相应的OOM有所改观，出现OOM，异常则变成了：“java.lang.OutofMemoryError:Metaspace”。直接内存不足，也会导致OOM。</li>
</ul>
</li>
</ol>
<ul>
<li><p>这里面隐含着一层意思是，在抛出OutofMemoryError之前，通常垃圾收集器会被触发，尽其所能去清理出空间。</p>
<ul>
<li>例如：在引用机制分析中，涉及到JVM会去尝试<strong>回收软引用指向的对象</strong>等。</li>
<li>在java.nio.Bits.reserveMemory()方法中，我们能清楚的看到，System.gc()会被调用，以清理空间。</li>
</ul>
</li>
<li><p>当然，也不是在任何情况下垃圾收集器都会被触发的</p>
<ul>
<li>比如，我们去分配一个超大对象，类似一个超大数组超过堆的最大值，JVM可以判断出垃圾收集并不能解决这个问题，所以直接抛出OutofMemoryError。</li>
</ul>
</li>
</ul>
<h2 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h2><ul>
<li>也称作“存储渗漏”。严格来说，<strong>只有对象不会再被程序用到了，但是GC又不能回收他们的情况，才叫内存泄漏。</strong></li>
<li>但实际情况很多时候一些不太好的实践（或疏忽）会导致对象的生命周期变得很长甚至导致OOM，也可以叫做<strong>宽泛意义上的“内存泄漏”</strong>。</li>
<li>尽管内存泄漏并不会立刻引起程序崩溃，但是一旦发生内存泄漏，程序中的可用内存就会被逐步蚕食，直至耗尽所有内存，最终出现OutofMemory异常，导致程序崩溃。</li>
<li>注意，这里的存储空间并不是指物理内存，而是指虚拟内存大小，这个虚拟内存大小取决于磁盘交换区设定的大小。</li>
</ul>
<p><strong>内存泄露官方例子</strong></p>
<p>左边的图：Java使用可达性分析算法，最上面的数据不可达，就是需要被回收的对象。</p>
<p>右边的图：后期有一些对象不用了，按道理应该断开引用，但是存在一些链没有断开（图示中的Forgotten Reference Memory Leak），从而导致没有办法被回收。</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220725163213420.png" alt="image-20220725163213420"></p>
<p><strong>常见例子</strong></p>
<ol>
<li>单例模式<ul>
<li>单例的生命周期和应用程序是一样长的，所以在单例程序中，如果持有对外部对象的引用的话，那么这个外部对象是不能被回收的，则会导致内存泄漏的产生。</li>
</ul>
</li>
<li>一些提供close()的资源未关闭导致内存泄漏<ul>
<li>数据库连接 dataSourse.getConnection()，网络连接socket和io连接必须手动close，否则是不能被回收的。</li>
</ul>
</li>
</ol>
<h1 id="Stop-the-World"><a href="#Stop-the-World" class="headerlink" title="Stop the World"></a>Stop the World</h1><ol>
<li>Stop-the-World，简称STW，指的是GC事件发生过程中，会产生应用程序的停顿。<strong>停顿产生时整个应用程序线程都会被暂停，没有任何响应</strong>，有点像卡死的感觉，这个停顿称为STW。<ul>
<li>可达性分析算法中枚举根节点（GC Roots）会导致所有Java执行线程停顿，为什么需要停顿所有 Java 执行线程呢？<ul>
<li>分析工作必须在一个能确保<strong>一致性</strong>的快照中进行</li>
<li>一致性指整个分析期间整个执行系统看起来像被冻结在某个时间点上</li>
<li><strong>如果出现分析过程中对象引用关系还在不断变化，则分析结果的准确性无法保证</strong></li>
</ul>
</li>
</ul>
</li>
<li>被STW中断的应用程序线程会在完成GC之后恢复，频繁中断会让用户感觉像是网速不快造成电影卡带一样，所以我们需要减少STW的发生。</li>
<li>STW事件和采用哪款GC无关，所有的GC都有这个事件。</li>
<li>哪怕是G1也不能完全避免Stop-the-world情况发生，只能说垃圾回收器越来越优秀，回收效率越来越高，尽可能地缩短了暂停时间。</li>
<li>STW是JVM在<strong>后台自动发起和自动完成</strong>的。在用户不可见的情况下，把用户正常的工作线程全部停掉。</li>
<li>开发中不要用System.gc() ，这会导致Stop-the-World的发生。</li>
</ol>
<h2 id="代码感受-Stop-the-World"><a href="#代码感受-Stop-the-World" class="headerlink" title="代码感受 Stop the World"></a>代码感受 Stop the World</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StopTheWorldDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">WorkThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        List&lt;<span class="type">byte</span>[]&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;<span class="type">byte</span>[]&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; <span class="number">1000</span>;i++)&#123;</span><br><span class="line">                        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">                        list.add(buffer);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span>(list.size() &gt; <span class="number">10000</span>)&#123;</span><br><span class="line">                        list.clear();</span><br><span class="line">                        System.gc();<span class="comment">//会触发full gc，进而会出现STW事件</span></span><br><span class="line">                     </span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                ex.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">PrintThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                    <span class="comment">// 每秒打印时间信息</span></span><br><span class="line">                    <span class="type">long</span> <span class="variable">t</span> <span class="operator">=</span> System.currentTimeMillis() - startTime;</span><br><span class="line">                    System.out.println(t / <span class="number">1000</span> + <span class="string">&quot;.&quot;</span> + t % <span class="number">1000</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                ex.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">WorkThread</span> <span class="variable">w</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WorkThread</span>();</span><br><span class="line">        <span class="type">PrintThread</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintThread</span>();</span><br><span class="line">        w.start();</span><br><span class="line">        p.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关闭工作线程 w ，观察输出：当前时间间隔与上次时间间隔<strong>基本</strong>是每隔1秒打印一次</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.1</span></span><br><span class="line"><span class="number">1.1</span></span><br><span class="line"><span class="number">2.2</span></span><br><span class="line"><span class="number">3.2</span></span><br><span class="line"><span class="number">4.3</span></span><br><span class="line"><span class="number">5.3</span></span><br><span class="line"><span class="number">6.3</span></span><br><span class="line"><span class="number">7.3</span></span><br><span class="line"></span><br><span class="line">Process finished with exit code -<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>开启工作线程 w ，观察打印输出：当前时间间隔与上次时间间隔相差 1.3s ，可以明显感受到 Stop the World 的存在</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.1</span></span><br><span class="line"><span class="number">1.4</span></span><br><span class="line"><span class="number">2.7</span></span><br><span class="line"><span class="number">3.8</span></span><br><span class="line"><span class="number">4.12</span></span><br><span class="line"><span class="number">5.13</span></span><br><span class="line"></span><br><span class="line">Process finished with exit code -<span class="number">1</span></span><br></pre></td></tr></table></figure>

<h1 id="垃圾回收的并行与并发"><a href="#垃圾回收的并行与并发" class="headerlink" title="垃圾回收的并行与并发"></a>垃圾回收的并行与并发</h1><h2 id="并发的概念"><a href="#并发的概念" class="headerlink" title="并发的概念"></a>并发的概念</h2><ul>
<li>在操作系统中，是指<strong>一个时间段</strong>中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理器上运行</li>
<li>并发不是真正意义上的“同时进行”，只是CPU把一个时间段划分成几个时间片段（时间区间），然后在这几个时间区间之间来回切换。由于CPU处理的速度非常快，只要时间间隔处理得当，即可让用户感觉是多个应用程序同时在进行</li>
</ul>
<img src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_011/0007.png">



<h2 id="并行的概念"><a href="#并行的概念" class="headerlink" title="并行的概念"></a>并行的概念</h2><ul>
<li>当系统有一个以上CPU时，当一个CPU执行一个进程时，另一个CPU可以执行另一个进程，两个进程互不抢占CPU资源，可以<strong>同时</strong>进行，我们称之为并行（Parallel）</li>
<li>其实决定并行的因素不是CPU的数量，而是CPU的核心数量，比如一个CPU多个核也可以并行</li>
<li>适合科学计算，后台处理等弱交互场景</li>
</ul>
<img src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_011/0008.png">

<blockquote>
<p><strong>并发与并行的对比</strong></p>
</blockquote>
<ol>
<li>并发，指的是多个事情，在<strong>同一时间段内同时发生了</strong>。</li>
<li>并行，指的是多个事情，在<strong>同一时间点上（或者说同一时刻）同时发生了</strong>。</li>
<li>并发的多个任务之间是互相抢占资源的。并行的多个任务之间是不互相抢占资源的。</li>
<li>只有在多CPU或者一个CPU多核的情况中，才会发生并行。否则，看似同时发生的事情，其实都是并发执行的。</li>
</ol>
<h2 id="垃圾回收的并发与并行"><a href="#垃圾回收的并发与并行" class="headerlink" title="垃圾回收的并发与并行"></a>垃圾回收的并发与并行</h2><p>并发和并行，在谈论垃圾收集器的上下文语境中，它们可以解释如下：</p>
<ol>
<li>并行（Parallel）：指多条垃圾收集线程并行工作，但此时用户线程仍处于等待状态。<ul>
<li>如ParNew、Parallel Scavenge、Parallel Old</li>
</ul>
</li>
<li>串行（Serial）<ul>
<li>相较于并行的概念，单线程执行。</li>
<li>如果内存不够，则程序暂停，启动JVM垃圾回收器进行垃圾回收（单线程）</li>
</ul>
</li>
</ol>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220725164638321.png" alt="image-20220725164638321"></p>
<ol start="3">
<li>并发（Concurrent）：指<strong>用户线程与垃圾收集线程同时执行</strong>（但不一定是并行的，可能会交替执行），垃圾回收线程在执行时不会停顿用户程序的运行。<ul>
<li>比如用户程序在继续运行，而垃圾收集程序线程运行于另一个CPU上；</li>
<li>如：CMS、G1</li>
</ul>
</li>
</ol>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220725164852058.png" alt="image-20220725164852058"></p>
<h1 id="HotSpot的算法实现细节"><a href="#HotSpot的算法实现细节" class="headerlink" title="HotSpot的算法实现细节"></a>HotSpot的算法实现细节</h1><h2 id="根节点枚举"><a href="#根节点枚举" class="headerlink" title="根节点枚举"></a>根节点枚举</h2><p>1、固定可作为GC Roots的节点主要在全局性的引用（例如常量或类静态属性）与执行上下文（例如栈帧中的本地变量表）中，尽管目标明确，但查找过程要做到高效并非一件容易的事情，现在Java应用越做越庞大，光是方法区的大小就常有数百上千兆，里面的类、常量等更是恒河沙数，若要逐个检查以这里为起源的引用肯定得消耗不少时间。 </p>
<p>2、迄今为止，<strong>所有收集器在根节点枚举这一步骤时都是必须暂停用户线程的</strong>，因此毫无疑问根节点 枚举与之前提及的整理内存碎片一样会面临相似的“Stop The World”的困扰。现在可达性分析算法耗时 最长的查找引用链的过程已经可以做到与用户线程一起并发，<strong>但根节点枚举始终还 是必须在一个能保障一致性的快照中才得以进行</strong>——这里“一致性”的意思是整个枚举期间执行子系统 看起来就像被冻结在某个时间点上，不会出现分析过程中，根节点集合的对象引用关系还在不断变化 的情况，若这点不能满足的话，分析结果准确性也就无法保证。这是导致垃圾收集过程必须停顿所有 用户线程的其中一个重要原因，即使是号称停顿时间可控，或者（几乎）不会发生停顿的CMS、G1、 ZGC等收集器，枚举根节点时也是必须要停顿的。</p>
<p>3、由于目前主流Java虚拟机使用的都是<strong>准确式垃圾收集</strong>，所以当用户线程停顿下来之后，其实并不需要一个不漏地检查完所有 执行上下文和全局的引用位置，虚拟机应当是有办法直接得到哪些地方存放着对象引用的。在HotSpot 的解决方案里，是使用一组称为<strong>OopMap的数据结构</strong>来达到这个目的。一旦类加载动作完成的时候， HotSpot就会把对象内什么偏移量上是什么类型的数据计算出来，在即时编译过程中，也 会在特定的位置记录下栈里和寄存器里哪些位置是引用。这样收集器在扫描时就可以直接得知这些信 息了，<strong>并不需要真正一个不漏地从方法区等GC Roots开始查找</strong>。</p>
<p>4、Exact VM因它使用<strong>准确式内存管理</strong>（Exact Memory Management，也可以叫Non-Con- servative&#x2F;Accurate Memory Management）而得名。准确式内存管理是指虚拟机可以知道内存中某个位 置的数据具体是什么类型。譬如内存中有一个32bit的整数123456，虚拟机将有能力分辨出它到底是一 个指向了123456的内存地址的引用类型还是一个数值为123456的整数，准确分辨出哪些内存是引用类 型，这也是在垃圾收集时准确判断堆上的数据是否还可能被使用的前提。【<strong>这个不是特别重要，了解一下即可</strong>】</p>
<blockquote>
<p>常考面试：<strong>在OopMap的协助下，HotSpot可以快速准确地完成GC Roots枚举</strong></p>
</blockquote>
<h2 id="安全点与安全区域"><a href="#安全点与安全区域" class="headerlink" title="安全点与安全区域"></a>安全点与安全区域</h2><p><strong>安全点（Safepoint）</strong></p>
<ol>
<li><p>程序执行时并非在所有地方都能停顿下来开始GC，只有在特定的位置才能停顿下来开始GC，这些位置称为“<strong>安全点（Safepoint）</strong>”。</p>
</li>
<li><p>Safe Point的选择很重要，<strong>如果太少可能导致GC等待的时间太长，如果太频繁可能导致运行时的性能问题</strong>。大部分指令的执行时间都非常短暂，通常会根据“<code>是否具有让程序长时间执行的特征</code>”为标准。比如：选择一些执行时间较长的指令作为Safe Point，<strong>如方法调用、循环跳转和异常跳转等</strong>。</p>
</li>
</ol>
<p><strong>如何在GC发生时，检查所有线程都跑到最近的安全点停顿下来呢？</strong></p>
<ol>
<li><strong>抢先式中断</strong>：（<strong>目前没有虚拟机采用了</strong>）首先中断所有线程。如果还有线程不在安全点，就恢复线程，让线程跑到安全点。</li>
<li><strong>主动式中断</strong>：设置一个中断标志，各个线程运行到Safe Point的时候<strong>主动轮询</strong>这个标志，如果中断标志为真，则将自己进行中断挂起。</li>
</ol>
<p><strong>安全区域（Safe Region）</strong></p>
<ol>
<li><strong>Safepoint</strong> 机制保证了程序执行时，在不太长的时间内就会遇到可进入<strong>GC的Safepoint</strong>。但是，程序“不执行”的时候呢？</li>
<li>例如线程处于<strong>Sleep状态或Blocked 状态</strong>，这时候线程无法响应JVM的中断请求，“走”到安全点去中断挂起，JVM也不太可能等待线程被唤醒。对于这种情况，就需要<strong>安全区域（Safe Region）</strong>来解决。</li>
<li><strong>安全区域是指在一段代码片段中，对象的引用关系不会发生变化，在这个区域中的任何位置开始GC都是安全的</strong>。我们也可以把Safe Region看做是被扩展了的Safepoint。</li>
</ol>
<p><strong>安全区域的执行流程</strong></p>
<ol>
<li>当线程运行到<strong>Safe Region</strong>的代码时，首先<strong>标识已经进入了Safe Region</strong>，如果这段时间内发生<strong>GC，JVM</strong>会<strong>忽略标识为Safe Region状态的线程</strong></li>
<li>当线程即将离开<strong>Safe Region</strong>时，会<strong>检查JVM是否已经完成根节点枚举</strong>（即GC Roots的枚举），如果完成了，则继续运行，否则线程必须等待直到收到可以安全离开<strong>Safe Region</strong>的信号为止；</li>
</ol>
<h2 id="记忆集与卡表"><a href="#记忆集与卡表" class="headerlink" title="记忆集与卡表"></a>记忆集与卡表</h2><h3 id="什么是跨代引用？"><a href="#什么是跨代引用？" class="headerlink" title="什么是跨代引用？"></a>什么是跨代引用？</h3><p>1、一般的垃圾回收算法至少会划分出两个年代，年轻代和老年代。但是单纯的分代理论在垃圾回收的时候存在一个巨大的缺陷：为了找到年轻代中的存活对象，却不得不遍历整个老年代，反过来也是一样的。</p>
<img src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_011/0011.png">

<p>2、如果我们从年轻代开始遍历，那么可以断定N, S, P, Q都是存活对象。但是，V却不会被认为是存活对象，其占据的内存会被回收了。这就是一个惊天的大漏洞！因为U本身是老年代对象，而且有外部引用指向它，也就是说U是存活对象，而U指向了V，也就是说V也应该是存活对象才是！而这都是因为我们只遍历年轻代对象！</p>
<p>3、所以，为了解决这种跨代引用的问题，最笨的办法就是遍历老年代的对象，找出这些跨代引用来。这种方案存在极大的性能浪费。因为从两个分代假说里面，其实隐含了一个推论：跨代引用是极少的。也就是为了找出那么一点点跨代引用，我们却得遍历整个老年代！从上图来说，很显然的是，我们根本不必遍历R。</p>
<p>4、因此，为了避免这种遍历老年代的性能开销，通常的分代垃圾回收器会引入一种称为<strong>记忆集</strong>的技术。<strong>简单来说，记忆集就是用来记录跨代引用的表。</strong></p>
<h3 id="记忆集与卡表-1"><a href="#记忆集与卡表-1" class="headerlink" title="记忆集与卡表"></a>记忆集与卡表</h3><p>1、为解决对象跨代引用所带来的问题，垃圾收集器在新生代中建 立了名为<strong>记忆集（Remembered Set）的数据结构</strong>，用以避免把整个老年代加进GC Roots扫描范围。事实上并不只是新生代、老年代之间才有跨代引用的问题，所有涉及部分区域收集（Partial GC）行为的 垃圾收集器，典型的如G1、ZGC和Shenandoah收集器，都会面临相同的问题，因此我们有必要进一步 理清记忆集的原理和实现方式，以便在后续章节里介绍几款最新的收集器相关知识时能更好地理解。</p>
<p>2、记忆集是一种用于记录<strong>从非收集区域指向收集区域的指针集合的抽象数据结构</strong>。如果我们不考虑效率和成本的话，最简单的实现可以用非收集区域中所有含跨代引用的对象数组来实现这个数据结构。</p>
<blockquote>
<p>比如说我们有老年代（非收集区域）和年轻代（收集区域）的对象之间有一条引用链</p>
</blockquote>
<p>3、这种记录全部含跨代引用对象的实现方案，无论是空间占用还是维护成本都相当高昂。而在垃圾 收集的场景中，收集器只需要通过记忆集判断出某一块非收集区域是否存在有指向了收集区域的指针 就可以了，并不需要了解这些跨代指针的全部细节。那设计者在实现记忆集的时候，便可以选择更为 粗犷的记录粒度来节省记忆集的存储和维护成本，下面列举了一些可供选择（当然也可以选择这个范 围以外的）的记录精度：</p>
<ul>
<li>字长精度：每个记录精确到一个机器字长（就是处理器的寻址位数，如常见的32位或64位，这个 精度决定了机器访问物理内存地址的指针长度），该字包含跨代指针。 </li>
<li>对象精度：每个记录精确到一个对象，该对象里有字段含有跨代指针。 </li>
<li>卡精度：每个记录精确到一块内存区域，该区域内有对象含有跨代指针。</li>
</ul>
<p>4、其中，第三种“卡精度”所指的是用一种称为“卡表”（Card Table）的方式去实现记忆集，这也是 目前最常用的一种记忆集实现形式，一些资料中甚至直接把它和记忆集混为一谈。前面定义中提到记 忆集其实是一种“抽象”的数据结构，抽象的意思是只定义了记忆集的行为意图，并没有定义其行为的 具体实现。卡表就是记忆集的一种具体实现，它定义了记忆集的记录精度、与堆内存的映射关系等。 关于卡表与记忆集的关系，读者不妨按照Java语言中HashMap与Map的关系来类比理解。 卡表最简单的形式可以只是一个字节数组，而HotSpot虚拟机确实也是这样做的</p>
<blockquote>
<p>读者只需要知道有这个东西，面试的时候能说出来，再细致一点的就需要看周志明老师的第三版书了</p>
</blockquote>
<h1 id="再谈引用概述"><a href="#再谈引用概述" class="headerlink" title="再谈引用概述"></a>再谈引用概述</h1><ol>
<li><p>我们希望能描述这样一类对象：当内存空间还足够时，则能保留在内存中；如果内存空间在进行垃圾收集后还是很紧张，则可以抛弃这些对象。</p>
</li>
<li><p>既偏门又非常高频的面试题：<strong>强引用、软引用、弱引用、虚引用有什么区别？具体使用场景是什么？</strong></p>
</li>
<li><p>在JDK1.2版之后，Java对引用的概念进行了扩充，将引用分为：</p>
<ul>
<li><strong>强引用（Strong Reference）</strong></li>
<li><strong>软引用（Soft Reference）</strong></li>
<li><strong>弱引用（Weak Reference）</strong></li>
<li><strong>虚引用（Phantom Reference）</strong></li>
</ul>
</li>
<li><p>这4种<strong>引用强度依次逐渐减弱</strong>。除强引用外，其他3种引用均可以在java.lang.ref包中找到它们的身影。如下图，显示了这3种引用类型对应的类，开发人员可以在应用程序中直接使用它们。</p>
</li>
</ol>
<img src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_011/0012.png" >

<p>Reference子类中只有终结器引用是包内可见的，其他3种引用类型均为public，可以在应用程序中直接使用</p>
<ol>
<li><strong>强引用（StrongReference）</strong>：最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似“<code>object obj=new Object()</code>”这种引用关系。<strong>无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。宁可报OOM，也不会GC强引用</strong></li>
<li><strong>软引用（SoftReference）</strong>：在系统将要发生内存溢出之前，将会把这些对象列入回收范围之中进行第二次回收。如果这次回收后还没有足够的内存，才会抛出内存溢出异常。<strong>内存不足即回收</strong></li>
<li><strong>弱引用（WeakReference）</strong>：被弱引用关联的对象只能生存到下一次垃圾收集之前。当垃圾收集器工作时，无论内存空间是否足够，都会回收掉被弱引用关联的对象。</li>
<li><strong>虚引用（PhantomReference）</strong>：一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来获得一个对象的实例。为一个对象设置虚引用关联的唯一目的就是<strong>能在这个对象被收集器回收时收到一个系统通知</strong>。</li>
</ol>
<h1 id="再谈引用：强引用"><a href="#再谈引用：强引用" class="headerlink" title="再谈引用：强引用"></a>再谈引用：强引用</h1><ol>
<li><p>在Java程序中，最常见的引用类型是强引用（<strong>普通系统99%以上都是强引用</strong>），也就是我们最常见的普通对象引用，<strong>也是默认的引用类型</strong>。</p>
</li>
<li><p>当在Java语言中使用new操作符创建一个新的对象，并将其赋值给一个变量的时候，这个变量就成为指向该对象的一个强引用。</p>
</li>
<li><p><strong>只要强引用的对象是可触及的，垃圾收集器就永远不会回收掉被引用的对象。</strong>只要强引用的对象是可达的，jvm宁可报OOM，也不会回收强引用。</p>
</li>
<li><p>对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应（强）引用赋值为null，就是可以当做垃圾被收集了，当然具体回收时机还是要看垃圾收集策略。</p>
</li>
<li><p>相对的，软引用、弱引用和虚引用的对象是软可触及、弱可触及和虚可触及的，在一定条件下，都是可以被回收的。所以，<strong>强引用是造成Java内存泄漏的主要原因之一</strong>。</p>
</li>
</ol>
<p><strong>强引用代码举例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StrongReferenceTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span> (<span class="string">&quot;Hello,尚硅谷&quot;</span>);</span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">str1</span> <span class="operator">=</span> str;</span><br><span class="line"></span><br><span class="line">        str = <span class="literal">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(str1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello,尚硅谷</span><br></pre></td></tr></table></figure>

<p>局部变量str指向stringBuffer实例所在堆空间，通过str可以操作该实例，那么str就是stringBuffer实例的强引用对应内存结构：</p>
<p><code>StringBuffer str = new StringBuffer(&quot;hello,尚硅谷&quot;);</code></p>
<img src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_011/0013.png">



<p><strong>总结</strong></p>
<p>本例中的两个引用，都是强引用，强引用具备以下特点：</p>
<ol>
<li>强引用可以直接访问目标对象。</li>
<li>强引用所指向的对象在任何时候都不会被系统回收，虚拟机宁愿抛出OOM异常，也不会回收强引用所指向对象。</li>
<li>强引用可能导致内存泄漏。</li>
</ol>
<h1 id="再谈引用：软引用"><a href="#再谈引用：软引用" class="headerlink" title="再谈引用：软引用"></a>再谈引用：软引用</h1><p><strong>软引用（Soft Reference）：内存不足即回收</strong></p>
<ol>
<li><p>软引用是用来描述一些还有用，但非必需的对象。<strong>只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收</strong>，如果这次回收还没有足够的内存，才会抛出内存溢出异常。注意，这里的<strong>第一次回收是不可达的对象</strong></p>
</li>
<li><p>软引用通常<strong>用来实现内存敏感的缓存</strong>。比如：<strong>高速缓存</strong>就有用到软引用。如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。</p>
</li>
<li><p>垃圾回收器在某个时刻决定回收软可达的对象的时候，会清理软引用，并可选地把引用存放到一个引用队列（Reference Queue）。</p>
</li>
<li><p>类似弱引用，只不过Java虚拟机会尽量让软引用的存活时间长一些，迫不得已才清理。</p>
</li>
<li><p>一句话概括：<strong>当内存足够时，不会回收软引用可达的对象。内存不够时，会回收软引用的可达对象</strong></p>
</li>
</ol>
<p>在JDK1.2版之后提供了SoftReference类来实现软引用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();<span class="comment">// 声明强引用</span></span><br><span class="line">SoftReference&lt;Object&gt; sf = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;&gt;(obj);</span><br><span class="line">obj = <span class="literal">null</span>; <span class="comment">//销毁强引用</span></span><br></pre></td></tr></table></figure>

<p><strong>软引用代码举例</strong></p>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SoftReferenceTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(<span class="type">int</span> id, String name)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.id = id;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> id;</span><br><span class="line">        <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;[id=&quot;</span> + id + <span class="string">&quot;, name=&quot;</span> + name + <span class="string">&quot;] &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建对象，建立软引用</span></span><br><span class="line"><span class="comment">//        SoftReference&lt;User&gt; userSoftRef = new SoftReference&lt;User&gt;(new User(1, &quot;songhk&quot;));</span></span><br><span class="line">        <span class="comment">//上面的一行代码，等价于如下的三行代码</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">u1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">1</span>,<span class="string">&quot;songhk&quot;</span>);</span><br><span class="line">        SoftReference&lt;User&gt; userSoftRef = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;User&gt;(u1);</span><br><span class="line">        u1 = <span class="literal">null</span>;<span class="comment">//取消强引用</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//从软引用中重新获得强引用对象</span></span><br><span class="line">        System.out.println(userSoftRef.get());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;---目前内存还不紧张---&quot;</span>);</span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(<span class="string">&quot;After GC:&quot;</span>);</span><br><span class="line"><span class="comment">//        //垃圾回收之后获得软引用中的对象</span></span><br><span class="line">        System.out.println(userSoftRef.get());<span class="comment">//由于堆空间内存足够，所有不会回收软引用的可达对象。</span></span><br><span class="line">        System.out.println(<span class="string">&quot;---下面开始内存紧张了---&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//让系统认为内存资源紧张、不够</span></span><br><span class="line"><span class="comment">//            byte[] b = new byte[1024 * 1024 * 7];</span></span><br><span class="line">            <span class="type">byte</span>[] b = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">7168</span> - <span class="number">635</span> * <span class="number">1024</span>];</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//再次从软引用中获取数据</span></span><br><span class="line">            System.out.println(userSoftRef.get());<span class="comment">//在报OOM之前，垃圾回收器会回收软引用的可达对象。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JVM参数</p>
<p><code>-Xms10m -Xmx10m</code></p>
<p>在 JVM 内存不足时，会清理软引用对象</p>
<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[id=<span class="number">1</span>, name=songhk] </span><br><span class="line">---目前内存还不紧张---</span><br><span class="line">After GC:</span><br><span class="line">[id=<span class="number">1</span>, name=songhk] </span><br><span class="line">---下面开始内存紧张了---</span><br><span class="line">java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">	at com.ysy.SoftReferenceTest.main(SoftReferenceTest.java:<span class="number">41</span>)</span><br><span class="line"><span class="literal">null</span></span><br></pre></td></tr></table></figure>

<h1 id="再谈引用：弱引用"><a href="#再谈引用：弱引用" class="headerlink" title="再谈引用：弱引用"></a>再谈引用：弱引用</h1><blockquote>
<p><strong>弱引用（Weak Reference）发现即回收</strong></p>
</blockquote>
<ol>
<li><p>弱引用也是用来描述那些非必需对象，<strong>只被弱引用关联的对象只能生存到下一次垃圾收集发生为止。在系统GC时，只要发现弱引用，不管系统堆空间使用是否充足，都会回收掉只被弱引用关联的对象</strong>。</p>
</li>
<li><p>但是，由于垃圾回收器的线程通常优先级很低，因此，并不一定能很快地发现持有弱引用的对象。<strong>在这种情况下，弱引用对象可以存在较长的时间</strong>。</p>
</li>
<li><p>弱引用和软引用一样，在构造弱引用时，也可以指定一个引用队列，当弱引用对象被回收时，就会加入指定的引用队列，通过这个队列可以跟踪对象的回收情况。</p>
</li>
<li><p><strong>软引用、弱引用都非常适合来保存那些可有可无的缓存数据</strong>。如果这么做，当系统内存不足时，这些缓存数据会被回收，不会导致内存溢出。而当内存资源充足时，这些缓存数据又可以存在相当长的时间，从而起到加速系统的作用。</p>
</li>
</ol>
<p>在JDK1.2版之后提供了WeakReference类来实现弱引用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明强引用</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">WeakReference&lt;Object&gt; sf = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;&gt;(obj);</span><br><span class="line">obj = <span class="literal">null</span>; <span class="comment">//销毁强引用</span></span><br></pre></td></tr></table></figure>

<ul>
<li>弱引用对象与软引用对象的最大不同就在于，当GC在进行回收时，需要通过算法检查是否回收软引用对象，而对于弱引用对象，GC总是进行回收。<strong>弱引用对象更容易、更快被GC回收。</strong></li>
</ul>
<p><strong>面试题：你开发中使用过WeakHashMap吗？</strong></p>
<p><strong>弱引用代码举例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WeakReferenceTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(<span class="type">int</span> id, String name)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.id = id;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> id;</span><br><span class="line">        <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;[id=&quot;</span> + id + <span class="string">&quot;, name=&quot;</span> + name + <span class="string">&quot;] &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//构造了弱引用</span></span><br><span class="line">        WeakReference&lt;User&gt; userWeakRef = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;User&gt;(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">1</span>, <span class="string">&quot;songhk&quot;</span>));</span><br><span class="line">        <span class="comment">//从弱引用中重新获取对象</span></span><br><span class="line">        System.out.println(userWeakRef.get());</span><br><span class="line"></span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="comment">// 不管当前内存空间足够与否，都会回收它的内存</span></span><br><span class="line">        System.out.println(<span class="string">&quot;After GC:&quot;</span>);</span><br><span class="line">        <span class="comment">//重新尝试从弱引用中获取对象</span></span><br><span class="line">        System.out.println(userWeakRef.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行垃圾回收后，软引用对象必定被清除</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[id=<span class="number">1</span>, name=songhk] </span><br><span class="line">After GC:</span><br><span class="line"><span class="literal">null</span></span><br></pre></td></tr></table></figure>

<h1 id="再谈引用：虚引用"><a href="#再谈引用：虚引用" class="headerlink" title="再谈引用：虚引用"></a>再谈引用：虚引用</h1><p><strong>虚引用（Phantom Reference）：对象回收跟踪</strong></p>
<ol>
<li><p>也称为“幽灵引用”或者“幻影引用”，是所有引用类型中最弱的一个</p>
</li>
<li><p>一个对象是否有虚引用的存在，完全不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它和没有引用几乎是一样的，随时都可能被垃圾回收器回收。</p>
</li>
<li><p>它不能单独使用，也无法通过虚引用来获取被引用的对象。当试图通过虚引用的get()方法取得对象时，总是null 。<strong>即通过虚引用无法获取到我们的数据</strong></p>
</li>
<li><p><strong>为一个对象设置虚引用关联的唯一目的在于跟踪垃圾回收过程。比如：能在这个对象被收集器回收时收到一个系统通知。</strong></p>
</li>
<li><p><strong>虚引用必须和引用队列一起使用</strong>。虚引用在创建时必须提供一个引用队列作为参数。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象后，将这个虚引用加入引用队列，以通知应用程序对象的回收情况。</p>
</li>
<li><p>由于虚引用可以跟踪对象的回收时间，因此，也可以将一些资源释放操作放置在虚引用中执行和记录。</p>
</li>
</ol>
<p>在JDK1.2版之后提供了PhantomReference类来实现虚引用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明强引用</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="comment">// 声明引用队列</span></span><br><span class="line"><span class="type">ReferenceQueue</span> <span class="variable">phantomQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>();</span><br><span class="line"><span class="comment">// 声明虚引用（还需要传入引用队列）</span></span><br><span class="line">PhantomReference&lt;Object&gt; sf = <span class="keyword">new</span> <span class="title class_">PhantomReference</span>&lt;&gt;(obj, phantomQueue);</span><br><span class="line">obj = <span class="literal">null</span>; </span><br></pre></td></tr></table></figure>

<p><strong>虚引用代码示例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PhantomReferenceTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> PhantomReferenceTest obj;<span class="comment">//当前类对象的声明</span></span><br><span class="line">    <span class="keyword">static</span> ReferenceQueue&lt;PhantomReferenceTest&gt; phantomQueue = <span class="literal">null</span>;<span class="comment">//引用队列</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">CheckRefQueue</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (phantomQueue != <span class="literal">null</span>) &#123;</span><br><span class="line">                    PhantomReference&lt;PhantomReferenceTest&gt; objt = <span class="literal">null</span>;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        objt = (PhantomReference&lt;PhantomReferenceTest&gt;) phantomQueue.remove();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (objt != <span class="literal">null</span>) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;追踪垃圾回收过程：PhantomReferenceTest实例被GC了&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123; <span class="comment">//finalize()方法只能被调用一次！</span></span><br><span class="line">        <span class="built_in">super</span>.finalize();</span><br><span class="line">        System.out.println(<span class="string">&quot;调用当前类的finalize()方法&quot;</span>);</span><br><span class="line">        obj = <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CheckRefQueue</span>();</span><br><span class="line">        t.setDaemon(<span class="literal">true</span>);<span class="comment">//设置为守护线程：当程序中没有非守护线程时，守护线程也就执行结束。</span></span><br><span class="line">        t.start();</span><br><span class="line"></span><br><span class="line">        phantomQueue = <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>&lt;PhantomReferenceTest&gt;();</span><br><span class="line">        obj = <span class="keyword">new</span> <span class="title class_">PhantomReferenceTest</span>();</span><br><span class="line">        <span class="comment">//构造了 PhantomReferenceTest 对象的虚引用，并指定了引用队列</span></span><br><span class="line">        PhantomReference&lt;PhantomReferenceTest&gt; phantomRef = <span class="keyword">new</span> <span class="title class_">PhantomReference</span>&lt;PhantomReferenceTest&gt;(obj, phantomQueue);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//不可获取虚引用中的对象</span></span><br><span class="line">            System.out.println(phantomRef.get());</span><br><span class="line">			System.out.println(<span class="string">&quot;第 1 次 gc&quot;</span>);</span><br><span class="line">            <span class="comment">//将强引用去除</span></span><br><span class="line">            obj = <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">//第一次进行GC,由于对象可复活，GC无法回收该对象</span></span><br><span class="line">            System.gc();</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            <span class="keyword">if</span> (obj == <span class="literal">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;obj 是 null&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;obj 可用&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;第 2 次 gc&quot;</span>);</span><br><span class="line">            obj = <span class="literal">null</span>;</span><br><span class="line">            System.gc(); <span class="comment">//一旦将obj对象回收，就会将此虚引用存放到引用队列中。</span></span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            <span class="keyword">if</span> (obj == <span class="literal">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;obj 是 null&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;obj 可用&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1、第一次尝试获取虚引用的值，发现无法获取的，这是因为虚引用是无法直接获取对象的值，然后进行第一次GC，因为会调用finalize方法，将对象复活了，所以对象没有被回收</p>
<p>2、但是调用第二次GC操作的时候，因为finalize方法只能执行一次，所以就触发了GC操作，将对象回收了，同时将会触发第二个操作就是将待回收的对象存入到引用队列中。</p>
<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">null</span></span><br><span class="line">第 <span class="number">1</span> 次 gc</span><br><span class="line">调用当前类的finalize()方法</span><br><span class="line">obj 可用</span><br><span class="line">第 <span class="number">2</span> 次 gc</span><br><span class="line">追踪垃圾回收过程：PhantomReferenceTest实例被GC了</span><br><span class="line">obj 是 <span class="literal">null</span></span><br></pre></td></tr></table></figure>

<h1 id="再谈引用：终结器引用（了解）"><a href="#再谈引用：终结器引用（了解）" class="headerlink" title="再谈引用：终结器引用（了解）"></a>再谈引用：终结器引用（了解）</h1><ol>
<li><p>它用于实现对象的finalize() 方法，也可以称为终结器引用</p>
</li>
<li><p>无需手动编码，其内部配合引用队列使用</p>
</li>
<li><p>在GC时，终结器引用入队。由Finalizer线程通过终结器引用找到被引用对象调用它的finalize()方法，第二次GC时才回收被引用的对象</p>
</li>
</ol>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
  </article>
  

  
  <nav class="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2022
        <i class="ri-heart-fill heart_icon"></i> Shiyu Yang
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="Healer"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>