<!DOCTYPE html>


<html lang="en">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title> Healer</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      
<section class="cover">
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover1.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">Healer</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.staticfile.org/typed.js/2.0.12/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['面朝大海，春暖花开', '愿你一生努力，一生被爱', '想要的都拥有，得不到的都释怀'],
        startDelay: 0,
        typeSpeed: 200,
        loop: true,
        backSpeed: 100,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  
  
  

<div class="notice" style="margin-top:50px">
    <i class="ri-heart-fill"></i>
    <div class="notice-content" id="broad"></div>
</div>
<script type="text/javascript">
    fetch('https://v1.hitokoto.cn')
        .then(response => response.json())
        .then(data => {
            document.getElementById("broad").innerHTML = data.hitokoto;
        })
        .catch(console.error)
</script>

<style>
    .notice {
        padding: 20px;
        border: 1px dashed #e6e6e6;
        color: #969696;
        position: relative;
        display: inline-block;
        width: 100%;
        background: #fbfbfb50;
        border-radius: 10px;
    }

    .notice i {
        float: left;
        color: #999;
        font-size: 16px;
        padding-right: 10px;
        vertical-align: middle;
        margin-top: -2px;
    }

    .notice-content {
        display: initial;
        vertical-align: middle;
    }
</style>
  
  <article class="articles">
    
    
    
    
    <article
  id="post-JavaSE"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
	
		置顶
	
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/06/28/JavaSE/"
    >JavaSE
  <i class="article-topping">Sticky</i>
</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/06/28/JavaSE/" class="article-date">
  <time datetime="2022-06-28T05:58:06.000Z" itemprop="datePublished">2022-06-28</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/JavaSE/">JavaSE</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="Java-概述"><a href="#Java-概述" class="headerlink" title="Java 概述"></a>Java 概述</h1><h2 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h2><p>计算机执行某些操作或解决某个问题而编写的一系列有序指令的集合</p>
<h2 id="Java-重要特点"><a href="#Java-重要特点" class="headerlink" title="Java 重要特点"></a>Java 重要特点</h2><ol>
<li><p>Java 语言是<strong>面向对象</strong>的(oop)</p>
</li>
<li><p>Java 语言是<strong>健壮</strong>的。Java 的强类型机制、异常处理、垃圾的自动收集等是 Java 程序健壮性的重要保证 </p>
</li>
<li><p>Java 语言是<strong>跨平台性</strong>的。[即: 一个编译好的.class 文件可以在多个系统下运行，这种特性称为跨平台]</p>
</li>
<li><p>Java 语言是<strong>解释型</strong>的。</p>
</li>
</ol>
<p>​		<strong>解释性语言：javascript,PHP, java</strong> </p>
<p>​		<strong>编译性语言: c &#x2F; c++</strong> </p>
<p>​		区别是：解释性语言，编译后的代码，不能直接被机器执行,需要解释器来执行, 编译性语言, 编译后的代码, 可以直接被机器执行, c &#x2F;c+</p>
<h2 id="JDK，JRE介绍"><a href="#JDK，JRE介绍" class="headerlink" title="JDK，JRE介绍"></a>JDK，JRE介绍</h2><p>1）JDK 的全称(Java Development Kit Java 开发工具包)</p>
<pre><code>     **JDK = JRE + java 开发工具集 **   [java, javac,javadoc,javap,java编译工具等] 
</code></pre>
<p>​		JDK 是提供给 Java 开发人员使用的，其中包含了 java 的开发工具，也包括了 JRE。所以安装了 JDK，就不用在单独安装 JRE了</p>
<p>2）JRE(Java Runtime Environment Java 运行环境)</p>
<p>​		 <strong>JRE &#x3D; JVM + Java 的核心类库[类]</strong> </p>
<p>​		包括 Java 虚拟机(JVM Java Virtual Machine)和 Java 程序所需的核心类库等，如果想要运行一个开发好的 Java 程序， 计算机中只需要安装 JRE 即可。</p>
<h2 id="Java虚拟机-JVM"><a href="#Java虚拟机-JVM" class="headerlink" title="Java虚拟机-JVM"></a>Java虚拟机-JVM</h2><ol>
<li><p>JVM 是一个虚拟的计算机，具有指令集并使用不同的存储区域。负责执行指令，管理数据、内存、寄存器，<strong>包含在 JDK 中</strong>. </p>
</li>
<li><p>对于不同的平台，有不同的虚拟机。 </p>
</li>
<li><p>Java 虚拟机机制屏蔽了底层运行平台的差别，实现了“<strong>一次编译，到处运行”</strong></p>
</li>
</ol>
<h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><p>私有:java虚拟机栈，程序计数器，本地方法栈 共享:java堆，方法区</p>
<ol>
<li><p>栈： 一般存放基本数据类型(局部变量) </p>
</li>
<li><p>堆： 存放对象(Cat cat , 数组等) </p>
</li>
<li><p>方法区：常量池(常量，比如字符串)， 类加载信息</p>
</li>
</ol>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220511221502453.png" alt="image-20220511221502453"></p>
<h2 id="Java-转义字符"><a href="#Java-转义字符" class="headerlink" title="Java 转义字符"></a>Java 转义字符</h2><p>在控制台使用 <strong>tab</strong> 可补全命令</p>
<p>\t ：一个制表位，实现对齐的功能 </p>
<p>\n ：换行符 </p>
<p>\ \：一个\</p>
<p>\ &quot; :一个”</p>
<p>\ &#39; ：一个’ </p>
<p>\r :一个回车</p>
<p>\0:空字符</p>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>用于注解说明解释程序的文字，提高了代码的阅读性(可读性)</p>
<p>被注释的文字，不会被 JVM（java 虚拟机）解释执行</p>
<p> 多行注释里面不允许有多行注释嵌套</p>
<p>文档注释：javadoc -d 文件名 -author -version xx.java</p>
<h2 id="常用dos命令"><a href="#常用dos命令" class="headerlink" title="常用dos命令"></a>常用dos命令</h2><ol>
<li><p>查看当前目录是有什么内容：dir </p>
</li>
<li><p>切换到其他盘下：盘符号 + ：</p>
</li>
<li><p>切换到上一级：cd .. </p>
</li>
<li><p>切换到根目录：cd \ </p>
</li>
<li><p>查看指定的目录下所有的子级目录：tree</p>
</li>
<li><p>清屏：cls </p>
</li>
<li><p>退出：exit</p>
</li>
</ol>
<h2 id="成员方法传参机制"><a href="#成员方法传参机制" class="headerlink" title="成员方法传参机制"></a>成员方法传参机制</h2><p><strong>实参定义</strong></p>
<p>实参全称为实际参数，是在调用时传递给函数的参数。实参可以是常量、变量、表达式、函数等，无论实参是何种类型的量，在进行函数调用时，它们都必须具有确定的值，以便把这些值 传送给形参因此应预先用赋值，输入等办法使实参获得确定值。</p>
<p><strong>形参定义</strong></p>
<p>形参全称为形式参数，由于它不是实际存在变量，所以又称虚拟变量。是在定义函数名和函数体的时候使用的参数,目的是用来接收调用该函数时传入的参数.在调用函数时，实参将赋值给形参。因而，必须注意实参的个数，类型应与形参-一对应， 并且实参必须要有确定的值。</p>
<ol>
<li><p>基本数据类型，传递的是值（值拷贝），形参的改变不影响实参</p>
</li>
<li><p>引用数据类型,，传递的是地址（传递也是值，但是值是地址），可以通过形参影响实参</p>
</li>
</ol>
<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220517173202743.png" alt="image-20220517173202743"></p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220517173304401.png" alt="image-20220517173304401"></p>
<h3 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h3><p>默认int</p>
<p>计算机底层存储的都是<strong>补码</strong>，并以补码进行数据运算，显示的是原码</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220517173405866.png"></p>
<h3 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a>浮点类型</h3><p>默认float</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220517175012934.png" alt="image-20220517175012934"></p>
<ol>
<li><p>关于浮点数在机器中存放形式的简单说明，浮点数&#x3D;符号位+指数位+尾数位 </p>
</li>
<li><p>尾数部分可能丢失，造成精度损失(小数都是近似值)</p>
</li>
</ol>
<h3 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h3><p>字符类型可以表示单个字符,字符类型是 char，char 是两个字节(可以存放汉字)，多个字符用字符串 String</p>
<p>字符型存储到计算机中，是对应的ASCII码值</p>
<h3 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h3><p>只允许取值true和false，无null，占一个字节</p>
<h2 id="基本数据类型转换"><a href="#基本数据类型转换" class="headerlink" title="基本数据类型转换"></a>基本数据类型转换</h2><p>自动类型转换：进行赋值或运算时，精度小的类型自动转换为精度大的数据类型(byte–&gt;short–&gt;int–&gt;long–&gt;float–&gt;double)(char–&gt;int–&gt;long–&gt;float–&gt;double)</p>
<p>​							byte, short 和 char 之间不会相互自动转换，但可以计算，在计算时首先转换成int类型</p>
<p>强制类型转换：将容量大的数据类型转换成容量小的数据类型</p>
<p>​							使用时要加上强制转换符()，但可能造成精度降低或溢出</p>
<p>基本数据类型和String类型的转换：基本–&gt;String：将基本数据类型的值+””</p>
<p>​															 String–&gt;基本：通过基本类型的包装类调用parseXXX方法</p>
<h2 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220517191425976.png" alt="image-20220517191425976"></p>
<p>Unicode：将世界上所有的符号都纳入其中，每个符号都给予一个独一无二的编码，使用Unicode没有乱码问题</p>
<h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220517193700932.png" alt="image-20220517193700932"></p>
<h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><p>1）基本赋值运算符   int a &#x3D; 10;</p>
<p>2）复合赋值运算符 +&#x3D; ，-&#x3D; ，*&#x3D; ， &#x2F;&#x3D; ，%&#x3D; 等</p>
<p>复合赋值运算符会进行类型转换。例如：b +&#x3D; 2; &#x2F;&#x2F; 等价 b &#x3D; (byte)(b+2)</p>
<h2 id="关系运算符-比较运算符"><a href="#关系运算符-比较运算符" class="headerlink" title="关系运算符(比较运算符)"></a>关系运算符(比较运算符)</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220517193743927.png" alt="image-20220517193743927"></p>
<h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><ol>
<li><p>短路与 &amp;&amp; ， 短路或 ||，取反 ! </p>
</li>
<li><p>逻辑与 &amp;，逻辑或 |，^ 逻辑异或</p>
</li>
</ol>
<h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220517195010581.png" alt="image-20220517195010581"></p>
<ol>
<li><p>算术右移 &gt;&gt;：低位溢出,符号位不变,并用符号位补溢出的高位 int a&#x3D;1&gt;&gt;2; &#x2F;&#x2F;1 &#x3D;&gt; 00000001 &#x3D;&gt; 00000000 本质 1&#x2F;2&#x2F;2&#x3D;0</p>
</li>
<li><p>算术左移 &lt;&lt;: 符号位不变,低位补 0 int c&#x3D;1&lt;&lt;2; &#x2F;&#x2F;1 &#x3D;&gt; 00000001 &#x3D;&gt; 00000100 本质 1 * 2 * 2 &#x3D; 4</p>
</li>
<li><blockquote>
<blockquote>
<blockquote>
<p> 逻辑右移也叫无符号右移,运算规则是: 低位溢出，高位补 0</p>
</blockquote>
</blockquote>
</blockquote>
</li>
</ol>
<h2 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h2><p>条件表达式 ? 表达式 1: 表达式 2; </p>
<p>运算规则：1）如果条件表达式为 true，运算后的结果是表达式 1； </p>
<p>​					2）如果条件表达式为 false，运算后的结果是表达式 2；</p>
<h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><p>1）由26个英文字母大小写，0-9，_或$组成</p>
<p>2）数字不能开头</p>
<p>3）不可以使用关键字和保留字，但能包含关键字和保留字</p>
<p>4）不能包含空格</p>
<h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><p><strong>都小写</strong></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220517194602552.png" alt="image-20220517194602552"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220517194633358.png" alt="image-20220517194633358"></p>
<p><strong>volatile与synchronized的区别：</strong></p>
<p>volatile本质是在告诉jvm当前变量在寄存器中的值是不确定的,需要从主存中读取,synchronized则是锁定当前变量,只有当前线程可以访问该变量,其他线程被阻塞住</p>
<p>volatile仅能使用在变量级别,synchronized则可以使用在变量,方法.</p>
<p>volatile仅能实现变量的修改可见性,但不具备原子特性,而synchronized则可以保证变量的修改可见性和原子性.</p>
<p>volatile不会造成线程的阻塞,而synchronized可能会造成线程的阻塞.</p>
<p>volatile标记的变量不会被编译器优化,而synchronized标记的变量可以被编译器优化.</p>
<p>synchronized很强大，既可以保证可见性，又可以保证原子性，而volatile不能保证原子性！</p>
<h2 id="保留字"><a href="#保留字" class="headerlink" title="保留字"></a>保留字</h2><p>Java 保留字：现有 Java 版本尚未使用，但以后版本可能会作为关键字使用。自己命名标识符时要避免使用这些保留字 byValue、cast、future、 generic、inner、 operator、 outer、 rest、 var 、 goto</p>
<h2 id="原码、反码、补码"><a href="#原码、反码、补码" class="headerlink" title="原码、反码、补码"></a>原码、反码、补码</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220517194927173.png" alt="image-20220517194927173"></p>
<h1 id="程序控制结构"><a href="#程序控制结构" class="headerlink" title="程序控制结构"></a>程序控制结构</h1><p>switch(表达式)中表达式的返回值必须是：byte, short, int, char, enum, String</p>
<p>break 语句用于终止某个语句块的执行，一般使用在 switch 或者循环[for, while, do-while]中</p>
<p>continue 语句用于结束本次循环，继续执行下一次循环，出现在多层嵌套的循环语句体中时，可以通过标签指明要跳过的是哪一层循环 </p>
<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>存放多个同一类型的数据，是一种<strong>引用类型</strong>数据</p>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>动态初始化：数据类型 数组名[] &#x3D; new  数据类型[大小] 例：int a[] &#x3D; new int[5]</p>
<p>​						数据类型 数组名[]；数组名 &#x3D; new  数据类型[大小] </p>
<p>​						数据类型 数组名[[]][[][] &#x3D; new  数据类型[大小] [大小]</p>
<p>​						数据类型 数组名[[]][[][] &#x3D; new  数据类型[大小] []</p>
<p>静态初始化：数据类型 数组名[] &#x3D; {元素值，元素值, … }</p>
<h2 id="数组细节"><a href="#数组细节" class="headerlink" title="数组细节"></a>数组细节</h2><p>1）数组是多个相同类型数据的组合</p>
<p>2）数组创建后，如果没有赋值，有默认值</p>
<p>​		int 0，short 0, byte 0, long 0, float 0.0,double 0.0，char \u0000，boolean false，String null</p>
<p>3）数组属于引用类型，数组型数据是对象(Object)</p>
<h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>1）区分相同名字的类</p>
<p>2）当类很多时，可以更好的管理类</p>
<p>3）控制访问范围</p>
<h3 id="常用的包"><a href="#常用的包" class="headerlink" title="常用的包"></a>常用的包</h3><ol>
<li><p>java.lang.* &#x2F;&#x2F;lang 包是基本包，默认引入，不需要再引入. </p>
</li>
<li><p>java.util.* &#x2F;&#x2F;util 包，系统提供的工具包, 工具类，使用 Scanner </p>
</li>
<li><p>java.net.* &#x2F;&#x2F;网络包，网络开发 </p>
</li>
<li><p>java.awt.* &#x2F;&#x2F;是做 java的界面开发，GUI</p>
</li>
</ol>
<h2 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h2><p>java 提供四种访问控制修饰符号，用于控制方法和属性(成员变量)的访问权限（范围）</p>
<ol>
<li><p>公开级别:用 <strong>public</strong> 修饰,对外公开 </p>
</li>
<li><p>受保护级别:用 <strong>protected</strong> 修饰,对子类和同一个包中的类公开</p>
</li>
<li><p>默认级别:没有修饰符号,向同一个包的类公开</p>
</li>
<li><p>私有级别:用 <strong>private</strong> 修饰,只有类本身可以访问,不对外公开</p>
</li>
</ol>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>修饰符可以修饰类中的属性，成员方法以及类</p>
<p>只有默认的和public才能修饰类</p>
<h1 id="OOP"><a href="#OOP" class="headerlink" title="OOP"></a>OOP</h1><h2 id="面向对象编程三大特征"><a href="#面向对象编程三大特征" class="headerlink" title="面向对象编程三大特征"></a>面向对象编程三大特征</h2><p>封装、继承和多态</p>
<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>把抽象出的数据[属性]和对数据的操作[方法]封装在一起，数据被保护在内部，程序的其他部分只能通过被授权的操作[方法]，才能对数据进行操作</p>
<ol>
<li><p>将属性进行私有化private</p>
</li>
<li><p>提供一个公共的set方法，用户对数据进行赋值</p>
</li>
<li><p>提供一个公共的get方法，用于获取属性的值</p>
</li>
</ol>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>继承可以解决代码复用,让我们的编程更加靠近人类思维.当多个类存在相同的属性(变量)和方法时,可以从这些类中抽象出父类,在父类中定义这些相同的属性和方法，所有的子类不需要重新定义这些属性和方法，只需要通过 extends 来声明继承父类即可。</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220503220735855.png" alt="image-20220503220735855"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220503220812342.png" alt="image-20220503220812342"></p>
<p>继承的深入讨论&#x2F;细节问题</p>
<ol>
<li><p>子类继承了所有的属性和方法，非私有的属性和方法可以在子类直接访问, 但是私有属性和方法不能在子类直接访 问，要通过父类提供公共的方法去访问</p>
</li>
<li><p>子类必须调用父类的构造器， 完成父类的初始化 </p>
</li>
<li><p>当创建子类对象时，不管使用子类的哪个构造器，默认情况下总会去调用父类的无参构造器，如果父类没有提供无参构造器，则必须在子类的构造器中用super</p>
<p>  去指定使用父类的哪个构造器完成对父类的初始化工作，否则，编译不会通过</p>
</li>
<li><p>如果希望指定去调用父类的某个构造器，则显式的调用一下 : super(参数列表)</p>
</li>
<li><p>super 在使用时，必须放在构造器第一行(super只能在构造器中使用) </p>
</li>
<li><p>super() 和 this() 都只能放在构造器第一行，因此这两个方法不能共存在一个构造器</p>
</li>
<li><p>java 所有类都是 Object 类的子类, Object 是所有类的基类. </p>
</li>
<li><p>父类构造器的调用不限于直接父类！将一直往上追溯直到 Object 类(顶级父类) </p>
</li>
<li><p>子类最多只能继承一个父类(指直接继承)，即 java 中是单继承机制。 思考：如何让 A 类继承 B 类和 C 类？ 【A 继承 B， B 继承 C】 </p>
</li>
<li><p>不能滥用继承，子类和父类之间必须满足 <strong>is-a</strong> 的逻辑</p>
</li>
</ol>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>方法或对象具有多种形态。是面向对象的第三大特征，多态是建立在封装和继承基础之上的。</p>
<ol>
<li>方法的多态：重写和重载就体现多态</li>
</ol>
<p>2）<strong>对象的多态</strong></p>
<p>a.一个对象的编译类型和运行类型可以不一致</p>
<p>b.编译类型在定义对象时就确定了，不能改变</p>
<p>c.运行类型可以改变</p>
<p><strong>d.编译看左，运行看右</strong></p>
<h4 id="多态的注意事项"><a href="#多态的注意事项" class="headerlink" title="多态的注意事项"></a>多态的注意事项</h4><p>多态的<strong>前提</strong>是：两个对象(类)存在继承关系</p>
<p><strong>多态的向上转型</strong></p>
<p>​		本质：父类引用指向子类对象</p>
<p>​		语法：父类类型 引用名 &#x3D; new 子类类型()；</p>
<p>​		特点：<strong>编译看左，运行看右</strong></p>
<p>​					可以调用父类中的所有成员</p>
<p>​					不能调用子类中的特有成员</p>
<p>​					最终运行效果看子类的具体实现</p>
<p><strong>多态的向下转型</strong></p>
<p>​		语法：子类类型 引用名 &#x3D; (子类类型) 父类引用；</p>
<p>​		特点：只能强转父类的引用，不能强转父类的对象</p>
<p>​					要求父类的引用必须指向的是当前目标类型的对象</p>
<p>​					向下转型后可以调用子类类型中的所有成员</p>
<p><strong>instanceOf</strong> 比较操作符，用于判断对象的运行类型是否为 XX 类型或 XX 类型的子类型</p>
<h4 id="java-的动态绑定机制"><a href="#java-的动态绑定机制" class="headerlink" title="java 的动态绑定机制"></a>java 的动态绑定机制</h4><p>1）当调用对象方法的时候，该方法会与该对象的内存地址&#x2F;运行类型绑定</p>
<p>2）当调用对象属性的时候，没有动态绑定机制，哪里声明，哪里使用</p>
<h2 id="super-关键字"><a href="#super-关键字" class="headerlink" title="super 关键字"></a>super 关键字</h2><p>super代表父类的引用，用于访问父类的属性、方法、构造器。</p>
<h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>1）访问父类的属性，但不能访问父类的private属性  例：super.属性名</p>
<p>2）访问父类的方法，但不能访问父类的private方法  例：super.方法名(参数列表)</p>
<p>3）访问父类的构造器 例：super(参数列表) 只能放在构造器的第一句，只能出现一句</p>
<h3 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h3><p>1）调用父类的构造器（分工明确，父类属性由父类初始化，子类属性由子类初始化）</p>
<p>2）当子类中有和父类中的成员（属性和方法）重名时，为了访问父类的成员，必须通过super</p>
<p>3）super的访问不限于直接父类，如果爷爷类有和本类中有同名的成员，也可以使用super去访问爷爷类的成员；</p>
<p>​		如果多个基类中都有相同的成员，则super访问遵循就近原则</p>
<h3 id="super与this的比较"><a href="#super与this的比较" class="headerlink" title="super与this的比较"></a>super与this的比较</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220505145216027.png" alt="image-20220505145216027"></p>
<h2 id="方法重写-x2F-覆盖-override"><a href="#方法重写-x2F-覆盖-override" class="headerlink" title="方法重写&#x2F;覆盖(override)"></a>方法重写&#x2F;覆盖(override)</h2><p>子类中有一个方法，和父类的某个方法的名称、返回值类型、参数一样</p>
<h3 id="重写与重载的区别"><a href="#重写与重载的区别" class="headerlink" title="重写与重载的区别"></a>重写与重载的区别</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220505145536052.png" alt="image-20220505145536052"></p>
<h2 id="Object-类"><a href="#Object-类" class="headerlink" title="Object 类"></a>Object 类</h2><p><img src="https://uploadfiles.nowcoder.com/images/20200717/257056865_1594996230591_77654A637F366FC03F9C293582926971" alt="img"></p>
<p><img src="https://uploadfiles.nowcoder.com/images/20190412/242025553_1555068065653_1F768A0737B2E9FBB49649C7465CBFCE" alt="img"></p>
<h3 id="equals方法"><a href="#equals方法" class="headerlink" title="equals方法"></a>equals方法</h3><h4 id="x3D-x3D-和-equals比较"><a href="#x3D-x3D-和-equals比较" class="headerlink" title="&#x3D;&#x3D;和 equals比较"></a>&#x3D;&#x3D;和 equals比较</h4><p>&#x3D;&#x3D;是一个比较运算符</p>
<p>1）&#x3D;&#x3D;：既可以判断基本类型，又可以判断引用类型</p>
<p>2）&#x3D;&#x3D;：如果判断基本类型，判断的是<strong>值</strong>是否相等</p>
<p>3）&#x3D;&#x3D;：如果判断引用类型，判断的是**地址值 **是否相等</p>
<p>4）equals：是Object类中的方法，只能判断引用类型，默认判断的是地址值是否相等，子类中往往重写该方法，用于判断<strong>内容</strong>是否相等（例：Integer, String）</p>
<h3 id="hashCode方法"><a href="#hashCode方法" class="headerlink" title="hashCode方法"></a>hashCode方法</h3><ol>
<li><p>返回对象的哈希码值，提高具有哈希结构的容器的效率！ </p>
</li>
<li><p>两个引用，如果指向的是同一个对象，则哈希值肯定是一样的！ </p>
</li>
<li><p>两个引用，如果指向的是不同对象，则哈希值是不一样的 </p>
</li>
<li><p>哈希值主要根据地址号来的！不能完全将哈希值等价于地址</p>
</li>
</ol>
<h3 id="toString-方法"><a href="#toString-方法" class="headerlink" title="toString 方法"></a>toString 方法</h3><ol>
<li>基本介绍</li>
</ol>
<p>​	默认返回：全类名+@+哈希值的十六进制</p>
<p>​	子类往往重写 toString 方法，用于返回对象的属性信息 </p>
<ol start="2">
<li><p>重写 toString 方法，打印对象或拼接对象时，都会自动调用该对象的 toString 形式</p>
</li>
<li><p>当直接输出一个对象时，toString 方法会被默认的调用</p>
</li>
</ol>
<h3 id="finalize-方法"><a href="#finalize-方法" class="headerlink" title="finalize 方法"></a>finalize 方法</h3><ol>
<li><p>当对象被回收时，系统自动调用该对象的 finalize 方法。子类可以重写该方法，做一些释放资源的操作</p>
</li>
<li><p>什么时候被回收：当某个对象没有任何引用时，则 jvm 就认为这个对象是一个垃圾对象，就会使用垃圾回收机制来销毁该对象，在销</p>
</li>
</ol>
<p>​		毁该对象前，会先调用finalize 方法。 </p>
<ol start="3">
<li>垃圾回收机制的调用，是由系统来决定(即有自己的 GC 算法), 也可以通过 System.gc() 主动触发垃圾回收机制</li>
</ol>
<h2 id="类变量和类方法（静态变量和静态方法）"><a href="#类变量和类方法（静态变量和静态方法）" class="headerlink" title="类变量和类方法（静态变量和静态方法）"></a>类变量和类方法（静态变量和静态方法）</h2><h3 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h3><p>​	特点：会被本类的所有的对象实例共享，随着类的加载而创建，可以直接通过类名调用</p>
<p>​	<strong>内存布局</strong>：在堆的永久生成区域中</p>
<p>​	定义：访问修饰符 static 数据类型 变量名；</p>
<p>​	访问：类名.变量名[前提：满足访问修饰符的访问权限和范围]</p>
<p>​	生命周期：随类的加载开始，随类的消亡而销毁</p>
<h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>​	特点：不创建实例，也可以调用，可通过类名调用；不允许使用与对象有关的关键字，<strong>this、super</strong></p>
<p>​	定义：访问修饰符 static 数据返回类型 方法名(){}</p>
<p><strong>静态方法，只能访问静态的成员，非静态方法，可以访问静态成员和非静态成员</strong></p>
<h2 id="main方法"><a href="#main方法" class="headerlink" title="main方法"></a>main方法</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220505162645471.png" alt="image-20220505162645471"></p>
<p>在main方法中，可以直接调用main方法所在类的静态方法或静态属性</p>
<p>但是，不能直接访问该类中的非静态成员，必须创建该类的一个实例对象后，才能通过这个对象去访问类中的非静态成员</p>
<h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><p>又称初始化块，属于类中的成员，类似于方法，将逻辑语句封装在方法体中，通过{}包围起来</p>
<p>但和方法不同，没有方法名，没有返回，没有参数，只有方法体，而且不能通过对象或类显示调用，而是加载类时，或创建对象时隐式调用</p>
<p>两类：静态代码块和普通&#x2F;非静态代码块</p>
<p>相当于另一种形式的构造器，可以做初始化操作</p>
<h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><p>1）静态代码块随着类的加载而执行，并且只会执行一次</p>
<p>2）<strong>类加载时间</strong></p>
<p>​		a.创建对象实例时(new)</p>
<p>​		b.创建子类对象实例，父类也会被加载</p>
<p>​		c.使用类的静态成员时</p>
<p>3）普通代码块，在创建对象实例时，会被隐式的调用</p>
<p>​		<strong>创建一次，调用一次</strong></p>
<p>4）创建对象时，类的调用顺序</p>
<p>​		a.调用静态代码块和静态属性初始化(优先级一样，按定义顺序调用)</p>
<p>​		b.调用普通代码块和普通属性初始化(优先级一样，按定义顺序调用)</p>
<p>​		c.调用构造方法</p>
<p>5）子父类的调用顺序</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220505172401550.png" alt="image-20220505172401550"></p>
<h2 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h2><p>设计模式是在大量的实践中总结和理论化之后优化的代码结构、编程风格、以及解决问题的思考方式。</p>
<p>单例设计模式：采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法</p>
<p>方式：1）饿汉式；2）懒汉式</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220506133052141.png" alt="image-20220506133052141"></p>
<ol>
<li>将构造器私有化</li>
<li>在类的内部直接创建对象(该对象是 static) </li>
<li>提供一个公共的 static 方法，返回对象</li>
</ol>
<h2 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h2><p><strong>可以修饰类、属性、方法和局部变量，不能修饰构造器</strong></p>
<p>1）被final修饰的类，不能被继承，但可以实例化</p>
<p>2）被final修饰的方法，不能被子类重写</p>
<p>3）被final修饰的局部变量或类中的某个属性，又叫常量，不能被修改</p>
<p>4）final修饰的属性在定义时，<strong>必须赋初值</strong>，赋值可以在以下位置：</p>
<p>​		a.定义时 b.在构造器中 c.在代码块中</p>
<p>5）如果final修饰的属性是静态的，则初始化的位置只能是a.定义时 b.在静态代码块中，不能在构造器中赋值</p>
<p>6）如果一个类已经是final类，就没有必要再将方法修饰成final方法</p>
<p>7）final和static往往搭配使用，效率更高，<strong>不会导致类加载</strong>，底层编译器做了优化处理</p>
<p>8）包装类，String类都是final类</p>
<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>当父类的一些方法不能确定时，可以用abstract关键字来修饰该方法，这个方法就是抽象方法，用abstract来修饰该类就是抽象类</p>
<p>1）抽象类不能被实例化</p>
<p>2）abstract只能修饰类和方法，不能修饰属性和其它的</p>
<p>3）抽象类的本质还是类，可以有任意成员，例如：非抽象方法、构造器、静态属性等</p>
<p>4）抽象方法不能有主体，即不能实现</p>
<p>5）一个类继承了抽象类，则它必须实现抽象类的所有抽象方法</p>
<p>6）<strong>抽象方法不能使用private、final和static来修饰，因为这些关键字都是和重写相违背的</strong></p>
<p>关于抽象类</p>
<p><strong>JDK 1.8以前</strong>，抽象类的方法默认访问权限为<strong>protected</strong></p>
<p><strong>JDK 1.8时</strong>，抽象类的方法默认访问权限变为<strong>default</strong></p>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>给出一些没有实现的方法，封装在一起，到某个类要使用的时候，再根据具体情况把这些方法写出来</p>
<p>接口体现了程序设计的多态和高内聚低耦合的设计思想</p>
<p>JDK7.0中接口是更加抽象的抽象类，抽象类里的方法可以有方法体，接口里的方法都没有方法体</p>
<p>JDK8.0后接口类可以有静态方法、默认方法，也就是说接口中可以有方法的具体实现</p>
<p><strong>接口中的属性，只能是final的，而且是public static final修饰符，必须初始化</strong></p>
<p>接口不能继承其他的类，但是可以继承多个接口</p>
<p><strong>接口的修饰符只能是public和默认，这点和类的修饰符一样</strong></p>
<p><strong>like-a</strong>的关系</p>
<p>关于接口</p>
<p><strong>JDK 1.8以前</strong>，接口中的方法必须是<strong>public</strong>的</p>
<p><strong>JDK 1.8时</strong>，接口中的方法可以是<strong>public</strong>的，也可以是<strong>default</strong>的</p>
<p><strong>JDK 1.9时</strong>，接口中的方法可以是<strong>private</strong>的</p>
<p><strong>高内聚低耦合</strong>，是<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/25279">软件工程</a>中的概念，是判断软件设计好坏的标准，主要用于程序的<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/2262089">面向对象</a>的设计，主要看类的内聚性是否高，<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E8%80%A6%E5%90%88%E5%BA%A6/2603938">耦合度</a>是否低。目的是使程序模块的可重用性、移植性大大增强。通常程序结构中各模块的内聚程度越高，模块间的耦合程度就越低。内聚是从功能角度来度量模块内的联系，一个好的内聚模块应当恰好做一件事，它描述的是模块内的功能联系；耦合是软件结构中各模块之间相互连接的一种<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%BA%A6%E9%87%8F/34036">度量</a>，耦合强弱取决于模块间接口的复杂程度、进入或访问一个模块的点以及通过接口的数据。</p>
<h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><p>类的五大成员：<strong>属性、方法、构造器、代码块、内部类</strong></p>
<p>类在局部位置(方法中&#x2F;代码块)：<strong>局部内部类、匿名内部类</strong></p>
<p>类在成员位置：<strong>成员内部类、静态内部类</strong></p>
<p>特点：可以直接访问私有属性，并且可以体现类与类之间的包含关系</p>
<h3 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220506150105202.png" alt="image-20220506150105202"></p>
<h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220506150255497.png" alt="image-20220506150255497"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220506150420023.png" alt="image-20220506150420023"></p>
<h3 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220506150551210.png" alt="image-20220506150551210"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220506150620993.png" alt="image-20220506150620993"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220506150656265.png" alt="image-20220506150656265"></p>
<h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220506150811300.png" alt="image-20220506150811300"></p>
<h2 id="枚举-enum"><a href="#枚举-enum" class="headerlink" title="枚举(enum)"></a>枚举(enum)</h2><p>枚举是一组常量的集合</p>
<p>枚举是一种特殊的类，里面包含一组有限的特定的对象</p>
<h3 id="自定义类实现枚举"><a href="#自定义类实现枚举" class="headerlink" title="自定义类实现枚举"></a>自定义类实现枚举</h3><p>可以提供getXxx方法，不需要提供setXxx方法，防止属性被修改，因为枚举对象通常为只读</p>
<p>对枚举对象&#x2F;属性使用final+static共同修饰，实现底层优化</p>
<p>枚举对象名全部大写</p>
<p>将构造器私有化，目的防止直接 new</p>
<p>本类内部创建一组对象</p>
<p>对外暴露对象（通过为对象添加 public final static修饰符）</p>
<h3 id="enum-关键字实现枚举"><a href="#enum-关键字实现枚举" class="headerlink" title="enum 关键字实现枚举"></a>enum 关键字实现枚举</h3><p>使用关键字 enum 替代 class</p>
<p> enum 关键字开发一个枚举类时，默认会<strong>继承 Enum 类</strong>, 而且是一个 final 类</p>
<p>public static final Season SPRING &#x3D; new Season(“春天”, “温暖”) 直接使用  SPRING(“春天”, “温暖”)    解读：<strong>常量名(实参列表)</strong></p>
<p>如果有多个常量(对象)， 使用<strong>逗号</strong>间隔，<strong>分号</strong>结尾</p>
<p>enum 来实现枚举，要求将定义常量对象，写在前面</p>
<p>如果使用无参构造器创建 枚举对象，则实参列表和小括号都可以省略</p>
<h3 id="Enum-类"><a href="#Enum-类" class="headerlink" title="Enum 类"></a>Enum 类</h3><ol>
<li><p>toString：Enum 类已经重写过了，返回的是当前对象名,子类可以重写该方法，用于返回对象的属性信息 </p>
</li>
<li><p>name：返回当前对象名（常量名），子类中不能重写 </p>
</li>
<li><p>ordinal：返回当前对象的位置号，默认从 0 开始 </p>
</li>
<li><p>values：返回当前枚举类中所有的常量</p>
</li>
<li><p>valueOf：将字符串转换成枚举对象，要求字符串必须为已有的常量名，否则报异常！</p>
</li>
<li><p>compareTo：比较两个枚举常量，比较的就是编号！</p>
</li>
</ol>
<h3 id="enum-实现接口"><a href="#enum-实现接口" class="headerlink" title="enum 实现接口"></a>enum 实现接口</h3><ol>
<li><p>使用 enum 关键字后，就不能再继承其它类了，因为 enum 会隐式继承 Enum，而 Java 是单继承机制。</p>
</li>
<li><p>枚举类和普通类一样，可以实现接口，如下形式。 enum 类名 implements 接口 1，接口 2{}</p>
</li>
</ol>
<h2 id="注解-Annotation"><a href="#注解-Annotation" class="headerlink" title="注解(Annotation)"></a>注解(Annotation)</h2><ol>
<li><p>注解(Annotation)也被称为元数据(Metadata)，用于修饰解释包、类、方法、属性、构造器、局部变量等数据信息。 </p>
</li>
<li><p>和注释一样，注解不影响程序逻辑，但注解可以被编译或运行，相当于嵌入在代码中的补充信息。 </p>
</li>
<li><p>在 JavaSE 中，注解的使用目的比较简单，例如标记过时的功能，忽略警告等。在 JavaEE 中注解占据了更重要的角 色，例如用来配置应用程序的任何切面，代	替 java EE 旧版中所遗留的繁冗代码和 XML 配置等</p>
</li>
</ol>
<p>使用 Annotation 时要在其前面增加 @ 符号, 并把该 Annotation 当成一个修饰符使用。用于修饰它支持的程序元素</p>
<p>三个基本的 Annotation: </p>
<ol>
<li>@Override: 限定某个方法，是重写父类方法, 该注解只能用于方法</li>
</ol>
<p>​	如果写了@Override 注解，编译器就会去检查该方法是否真的重写了父类的 方法，如果的确重写了，则编译通过，如果没有构成重写，则编译错误</p>
<p>​	 @Override注解源码：@Target(ElementType.METHOD)，说明只能修饰方法，不能修饰其它类、包、和属性等</p>
<ol start="2">
<li>@Deprecated: 用于表示某个程序元素(类, 方法等)已过时，即不在推荐使用，但是仍然可以使用</li>
</ol>
<p>​	@Deprecated 注解类的源码：@Target(value&#x3D;{CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE}，说明可以修饰方法，</p>
<p>​	类，字段, 包, 参数等等</p>
<p>​	@Deprecated 可以做版本升级过渡使用</p>
<ol start="3">
<li>@SuppressWarnings: 抑制编译器警告，在{“”} 中，可以写入你希望抑制(不显示)警告信息</li>
</ol>
<p>​	@SuppressWarnings 源码：@Target({TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE})，通常我们可以放置具体的语句, 方法, 类</p>
<p>​	可以指定的警告类型有 </p>
<p>​	&#x2F;&#x2F;all，抑制所有警告</p>
<p>​	&#x2F;&#x2F;boxing，抑制与封装&#x2F;拆装作业相关的警告</p>
<p>​	&#x2F;&#x2F;cast，抑制与强制转型作业相关的警告 </p>
<p>​	&#x2F;&#x2F;dep-ann，抑制与淘汰注释相关的警告</p>
<p>​	&#x2F;&#x2F;deprecation，抑制与淘汰的相关警告</p>
<p>​	&#x2F;&#x2F;fallthrough，抑制与 switch 陈述式中遗漏 break 相关的警告</p>
<p>​	&#x2F;&#x2F;finally，抑制与未传回 finally 区块相关的警告 </p>
<p>​	hiding，抑制与隐藏变数的区域变数相关的警告</p>
<p>​	&#x2F;&#x2F;incomplete-switch，抑制与 switch 陈述式(enum case)中遗漏项目相关的警告  </p>
<p>​	&#x2F;&#x2F;javadoc，抑制与 javadoc 相关的警告</p>
<p>​	&#x2F;&#x2F;nls，抑制与非 nls 字串文字相关的警告</p>
<p>​	&#x2F;&#x2F;null，抑制与空值分析相关的警告 </p>
<p>​	&#x2F;&#x2F;rawtypes，抑制与使用 raw 类型相关的警告</p>
<p>​	&#x2F;&#x2F;resource，抑制与使用 Closeable 类型的资源相关的警告 </p>
<p>​	&#x2F;&#x2F;restriction，抑制与使用不建议或禁止参照相关的警告  </p>
<p>​	&#x2F;&#x2F;serial，抑制与可序列化的类别遗漏 serialVersionUID 栏位相关的警告 </p>
<p>​	&#x2F;&#x2F;static-access，抑制与静态存取不正确相关的警告</p>
<p>​	&#x2F;&#x2F;static-method，抑制与可能宣告为 static 的方法相关的警告</p>
<p>​	&#x2F;&#x2F;super，抑制与置换方法相关但不含 super 呼叫的警告</p>
<p>​	&#x2F;&#x2F;synthetic-access，抑制与内部类别的存取未最佳化相关的警告</p>
<p>​	&#x2F;&#x2F;sync-override，抑制因为置换同步方法而遗漏同步化的警告</p>
<p>​	&#x2F;&#x2F;unchecked，抑制与未检查的作业相关的警告</p>
<p>​	&#x2F;&#x2F;unqualified-field-access，抑制与栏位存取不合格相关的警告 </p>
<p>​	&#x2F;&#x2F;unused，抑制与未用的程式码及停用的程式码相关的警告</p>
<h2 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h2><p>JDK 的元 Annotation 用于修饰其他 Annotation</p>
<p>元注解的种类：</p>
<ol>
<li>Retention &#x2F;&#x2F;指定注解的作用范围，三种 SOURCE,CLASS,RUNTIME</li>
</ol>
<p>​	只能用于修饰一个 Annotation 定义, 用于指定该 Annotation 可以保留多长时间, @Rentention 包含一个 RetentionPolicy 类型的成员变量, 使用 @Rentention 	时必须为该 value</p>
<p>@Retention 的三种值 </p>
<p>a. RetentionPolicy.SOURCE: 编译器使用后，直接丢弃这种策略的注释 </p>
<p>b. RetentionPolicy.CLASS: 编译器将把注解记录在 class 文件中. 	当运行 Java 程序时, JVM 不会保留注解。 这是默认值</p>
<p>c. RetentionPolicy.RUNTIME:编译器将把注解记录在 class 文件中. 当运行 Java 程序时, JVM 会保留注解. 程序可以 通过反射获取该注解</p>
<ol start="2">
<li><p>Target &#x2F;&#x2F; 指定注解可以在哪些地方使用 </p>
</li>
<li><p>Documented &#x2F;&#x2F;指定该注解是否会在 javadoc 体现</p>
</li>
<li><p>Inherited &#x2F;&#x2F;子类会继承父类注解</p>
</li>
</ol>
<h2 id="异常-Exception"><a href="#异常-Exception" class="headerlink" title="异常-Exception"></a>异常-Exception</h2><p>java语言中，将程序执行中发生的不正常情况称为“异常”(开发过程中的语法错误和逻辑错误不是异常)</p>
<p>两类：Error—Java虚拟机无法解决的严重问题，如：JVM系统内部错误、资源耗尽等情况</p>
<p>​			Exception—其他因编程错误或偶然的外在因素导致的一般性问题，可以使用针对性的代码进行处理。例如：空指针访问、试图读取不存在的文件、网络连接中断等，分为：运行时异常(可以不做处理，默认就是throws的方式处理，若全处理可能会对程序的可读性和运行效率产生影响)和编译时异常(必须处置，否则代码不能通过编译)。</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220506214357718.png" alt="image-20220506214357718"></p>
<h3 id="常见的运行时异常"><a href="#常见的运行时异常" class="headerlink" title="常见的运行时异常"></a>常见的运行时异常</h3><ol>
<li>NullPointerException 空指针异常</li>
</ol>
<p>​	当应用程序试图在需要对象的地方使用 null 时，抛出该异常</p>
<ol start="2">
<li>ArithmeticException 数学运算异常</li>
</ol>
<p>​	当出现异常的运算条件时，抛出此异常。例如，一个整数“除以零”时，抛出此类的一个实例</p>
<ol start="3">
<li>ArrayIndexOutOfBoundsException 数组下标越界异常</li>
</ol>
<p>​	用非法索引访问数组时抛出的异常。如果索引为负或大于等于数组大小，则该索引为非法索引</p>
<ol start="4">
<li>ClassCastException 类型转换异常</li>
</ol>
<p>​	当试图将对象强制转换为不是实例的子类时，抛出该异常。</p>
<ol start="5">
<li>NumberFormatException 数字格式不正确异常</li>
</ol>
<p>​	当应用程序试图将字符串转换成一种数值类型，但该字符串不能转换为适当格式时，抛出该异常 &#x3D;&gt; 使用异常我们 可以确保输入是满足条件数字</p>
<h3 id="常见的编译时异常"><a href="#常见的编译时异常" class="headerlink" title="常见的编译时异常"></a>常见的编译时异常</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220506215045615.png" alt="image-20220506215045615"></p>
<h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220506215331954.png" alt="image-20220506215331954"></p>
<h4 id="try-catch-finally"><a href="#try-catch-finally" class="headerlink" title="try-catch-finally"></a>try-catch-finally</h4><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220506215507298.png" alt="image-20220506215507298"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220506215617489.png" alt="image-20220506215617489"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220506220317153.png" alt="image-20220506220317153"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220506215812627.png" alt="image-20220506215812627"></p>
<h4 id="throws"><a href="#throws" class="headerlink" title="throws"></a>throws</h4><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220506220018705.png" alt="image-20220506220018705"></p>
<h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><p>当程序中出现了某些错误，但该错误信息并没有在Throwable子类中描述处理，则可以自己设计异常类，用于描述该错误信息。</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220506220807103.png" alt="image-20220506220807103"></p>
<h3 id="throw-和-throws-的区别"><a href="#throw-和-throws-的区别" class="headerlink" title="throw 和 throws 的区别"></a>throw 和 throws 的区别</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220506221123112.png" alt="image-20220506221123112"></p>
<h1 id="常用类"><a href="#常用类" class="headerlink" title="常用类"></a>常用类</h1><h2 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h2><ol>
<li><p>针对八种基本数据类型相应的引用类型—包装类 </p>
</li>
<li><p>有了类的特点，就可以调用类中的方法。</p>
</li>
</ol>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220507143234839.png" alt="image-20220507143234839"></p>
<h3 id="装箱与拆箱"><a href="#装箱与拆箱" class="headerlink" title="装箱与拆箱"></a>装箱与拆箱</h3><p>包装类与基本数据类型之间的相互转换</p>
<p>JDK5.0以后(含5.0)有自动拆装箱</p>
<p>自动拆装箱底层调用的是<strong>valueOf方法</strong>，例如：Integer.valueOf();</p>
<h3 id="Integer-类和-Character-类的常用方法"><a href="#Integer-类和-Character-类的常用方法" class="headerlink" title="Integer 类和 Character 类的常用方法"></a>Integer 类和 Character 类的常用方法</h3><p>(Integer.MIN_VALUE); &#x2F;&#x2F;返回最小值</p>
<p>(Integer.MAX_VALUE);&#x2F;&#x2F;返回最大值</p>
<p>(Character.isDigit(‘a’));&#x2F;&#x2F;判断是不是数字</p>
<p>(Character.isLetter(‘a’));&#x2F;&#x2F;判断是不是字母 </p>
<p>(Character.isUpperCase(‘a’));&#x2F;&#x2F;判断是不是大写 </p>
<p>(Character.isLowerCase(‘a’));&#x2F;&#x2F;判断是不是小写 </p>
<p>(Character.isWhitespace(‘a’));&#x2F;&#x2F;判断是不是空格 </p>
<p>(Character.toUpperCase(‘a’));&#x2F;&#x2F;转成大写 </p>
<p>(Character.toLowerCase(‘A’));&#x2F;&#x2F;转成小写</p>
<h2 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h2><p>1）String对象用于保存字符串，也就是一组字符序列</p>
<p>2）字符串常量对象是用双引号括起的字符序列</p>
<p>3）字符串的字符使用的是Unicode字符编码，一个字符(不区分字母还是汉字)占两个字节</p>
<p>4）String 类实现了接口 Serializable【String 可以串行化:可以在网络传输】  接口 Comparable [String 对象可以比较大小]</p>
<p>5）String 是 final 类，不能被其他的类继承，代表不可变的字符序列</p>
<p>6）String 有属性 private final char value[]： 用于存放字符串内容 </p>
<p>7）一定要注意：value 是一个 final 类型， 不可以修改(需要功力)：即 value 不能指向新的地址，但是单个字符内容是可以变化</p>
<p>8）字符串是不可变的。一个字符串对象一旦被分配，其内容是不可变的</p>
<p>9）intern方法：最终返回的是常量池的地址(对象)</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220507145402726.png" alt="image-20220507145402726"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220507145435192.png" alt="image-20220507145435192"></p>
<p>10）String类是保存字符串常量的。每次更新都需要重新开辟空间，效率极低，因此Java设计者还提供了StringBuilder和StringBuffer来增强String的功能</p>
<h3 id="String类常用方法"><a href="#String类常用方法" class="headerlink" title="String类常用方法"></a>String类常用方法</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220507155349012.png" alt="image-20220507155349012"></p>
<p>1）toUpperCase 转换成大写</p>
<p>2）toLowerCase 转换成小写</p>
<p>3）concat 拼接字符串</p>
<p>4）replace 替换字符串中的字符</p>
<p>5）split 分割字符串, 对于某些分割字符，我们需要转义比如 | \\等</p>
<p>6）toCharArray 转换成字符数组</p>
<p>7）compareTo 比较两个字符串的大小，如果前者大，则返回正数，后者大，则返回负数，如果相等，返回 0</p>
<p>8）format 格式字符串(占位符有:%s 字符串 %c 字符 %d 整型 %.2f 浮点)</p>
<h2 id="StringBuffer类"><a href="#StringBuffer类" class="headerlink" title="StringBuffer类"></a>StringBuffer类</h2><p><strong>可变的字符序列</strong>，可以对字符串内容进行增删(**线程安全)**。</p>
<p>很多方法与String相同，但StringBuffer是可变长度的。</p>
<p>StringBuffer是一个<strong>容器</strong>。</p>
<p>StringBuffer 的直接父类 是 AbstractStringBuilder</p>
<p>StringBuffer 实现了 Serializable, 即 StringBuffer 的对象可以串行化</p>
<p>在父类中 AbstractStringBuilder 有属性 char[] value,不是 fina，该 value 数组存放字符串内容，引出存放在堆中的</p>
<p>StringBuffer 是一个 final 类，不能被继承</p>
<p>因为 StringBuffer 字符内容是存在 char[] value, 在变化(增加&#x2F;删除)时，不用每次都更换地址(即不是每次创建新对象)， 所以效率高于 String</p>
<h3 id="String与StringBuffer的转换"><a href="#String与StringBuffer的转换" class="headerlink" title="String与StringBuffer的转换"></a>String与StringBuffer的转换</h3><h4 id="String—-gt-StringBuffer"><a href="#String—-gt-StringBuffer" class="headerlink" title="String—&gt;StringBuffer"></a>String—&gt;StringBuffer</h4><p>1）使用构造器：StringBuffer stringBuffer &#x3D; new StringBuffer(str)</p>
<p>2）使用的是 append 方法：StringBuffer stringBuffer &#x3D; new StringBuffer(); stringBuffer &#x3D; stringBuffer.append(str)</p>
<h4 id="StringBuffer—-gt-String"><a href="#StringBuffer—-gt-String" class="headerlink" title="StringBuffer—&gt;String"></a>StringBuffer—&gt;String</h4><p>StringBuffer stringBuffer &#x3D; new StringBuffer(“韩顺平教育”);</p>
<p>1）使用 StringBuffer 提供的 toString 方法：String s &#x3D; stringBuffer.toString()</p>
<p>2）使用构造器：String s &#x3D; new String(stringBuffer)</p>
<h3 id="StringBuffer类常用方法"><a href="#StringBuffer类常用方法" class="headerlink" title="StringBuffer类常用方法"></a>StringBuffer类常用方法</h3><p>1）增：append</p>
<p>2）删：delete</p>
<p>3）改：replace</p>
<p>4）查：indexOf</p>
<p>5）插：insert</p>
<p>6）长度：length</p>
<h2 id="StringBuilder-类"><a href="#StringBuilder-类" class="headerlink" title="StringBuilder 类"></a>StringBuilder 类</h2><p>一个可变的字符序列。此类提供一个与StringBuffer兼容的API，但不保证同步(<strong>线程不安全</strong>)。</p>
<p>StringBuilder 的方法，没有做互斥的处理,即没有 synchronized 关键字,因此在单线程的情况下使用</p>
<p>该类用在字符串缓冲区被单个线程使用的时候，<strong>比StringBuffer要快</strong>。</p>
<p>在StringBuilder上的主要操作是append和insert方法，可重载这些方法，已接受任意类型的数据</p>
<p>StringBuilder 接父类 是 AbstractStringBuilder</p>
<p>StringBuilder 实现了 Serializable, 即 StringBuilder 的对象可以串行化</p>
<p>在父类中 AbstractStringBuilder 有属性 char[] value,不是 fina，该 value 数组存放字符串内容，引出存放在堆中的</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220507164322409.png" alt="image-20220507164322409"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220507164338156.png" alt="image-20220507164338156"></p>
<h3 id="String、StringBuffer-和-StringBuilder-的选择"><a href="#String、StringBuffer-和-StringBuilder-的选择" class="headerlink" title="String、StringBuffer 和 StringBuilder 的选择"></a>String、StringBuffer 和 StringBuilder 的选择</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220507164449875.png" alt="image-20220507164449875"></p>
<h2 id="Math-类"><a href="#Math-类" class="headerlink" title="Math 类"></a>Math 类</h2><p>Math 类包含用于执行基本数学运算的方法，如初等指数、对数、平方根和三角函数。均为静态方法</p>
<p>abs 绝对值</p>
<p>pow 求幂</p>
<p>ceil 向上取整，返回&gt;&#x3D;该参数的最小整数(转成 double)</p>
<p>floor 向下取整，返回&lt;&#x3D;该参数的最大整数(转成 double)</p>
<p>round 四舍五入</p>
<p>sqrt 求开方</p>
<p>random 求随机数  返回的是 0 &lt;&#x3D; x &lt; 1 之间的一个随机小数</p>
<h2 id="Arrays-类"><a href="#Arrays-类" class="headerlink" title="Arrays 类"></a>Arrays 类</h2><p>Arrays里面包含了一系列静态方法，用于管理或操作数组(例如排序和搜素)</p>
<p>1）toString 返回数组的字符串形式</p>
<p>2）sort 排序</p>
<p>3）binarySearch 通过二分搜索法进行查找，要求必须排好序</p>
<p>4）copyOf 数组元素的复制</p>
<p>5）fill 数组元素的填充</p>
<p>6）equals 比较两个数组元素内容是否完全一致</p>
<p>7）asList 将一组值转换成List</p>
<h2 id="System-类"><a href="#System-类" class="headerlink" title="System 类"></a>System 类</h2><p>1）exit 退出当前程序</p>
<p>2）arraycopy 复制数组元素，比较适合底层调用，一般使用Arrays.copyOf完成复制数组</p>
<p>3）currentTimeMillens 返回当前时间距离1970-1-1的毫秒数</p>
<p>4）gc 运行垃圾回收机制</p>
<p>5）fill 数组元素的填充</p>
<p>6）equals 比较两个数组元素内容是否完全一致</p>
<p>7）asList 将一组值转换成List</p>
<h2 id="BigInteger-和-BigDecimal-类"><a href="#BigInteger-和-BigDecimal-类" class="headerlink" title="BigInteger 和 BigDecimal 类"></a>BigInteger 和 BigDecimal 类</h2><p>BigInteger 适合保存比较大的整型</p>
<p>BigDecimal适合保存精度更高的浮点型</p>
<h3 id="常见方法"><a href="#常见方法" class="headerlink" title="常见方法"></a>常见方法</h3><p>1）add 加</p>
<p>2）subtract 减</p>
<p>3）multiply 乘</p>
<p>4）divide 除</p>
<h2 id="日期类"><a href="#日期类" class="headerlink" title="日期类"></a>日期类</h2><h3 id="第一代日期类"><a href="#第一代日期类" class="headerlink" title="第一代日期类"></a>第一代日期类</h3><p>1.Date：精确到毫秒，代表特定的瞬间</p>
<p>2.SimpleDateFormat：格式和解析日期的类</p>
<h3 id="第二代日期类"><a href="#第二代日期类" class="headerlink" title="第二代日期类"></a>第二代日期类</h3><p>Calendar类：抽象类，他为特定瞬间与一组诸如YEAR、MONTH、DAY_OF_MONTH、HOUR等日历字段之间的转换提供了一些方法，并为操作日历字段提供了一</p>
<p>些方法。</p>
<h3 id="第三代日期类"><a href="#第三代日期类" class="headerlink" title="第三代日期类"></a>第三代日期类</h3><p>LocalDate：只包含日期，可以获得日期字段</p>
<p>LocalTime：只包含时间，可以获得时间字段</p>
<p>LocalDateTime：包含日期+时间，可以获取日期和时间字段</p>
<h3 id="DateTimeFormatter-格式日期类"><a href="#DateTimeFormatter-格式日期类" class="headerlink" title="DateTimeFormatter 格式日期类"></a>DateTimeFormatter 格式日期类</h3><h3 id="Instant-时间戳"><a href="#Instant-时间戳" class="headerlink" title="Instant 时间戳"></a>Instant 时间戳</h3><h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><p>数组缺点：长度开始时必须指定，而且一旦指定，不能更改</p>
<p>​					保存的必须为同一类型的元素</p>
<p>​					使用数组进行增删改查比较麻烦</p>
<p>集合：可以<strong>动态保存</strong>任意多个对象</p>
<p>​			提供了一系列方便的操作对象的方法：add、remove、set、get等</p>
<p>​			使用集合添加、删除新元素简单</p>
<p>Java的集合类主要分为两大类</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220510195334921.png" alt="image-20220510195334921"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220510195351280.png" alt="image-20220510195351280"></p>
<p><img src="http://uploadfiles.nowcoder.com/images/20151109/403938_1447079573733_4F723777B74785B7A07A73C9792B8F6F" alt="img"></p>
<p>集合主要是两组(单列集合，双列集合)</p>
<p>Collection接口有两个重要的子接口List Set，他们的实现子类都是单列集合</p>
<p>Map接口的实现子类是双列集合，存放的是K-V</p>
<h2 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a>Collection接口</h2><p>Collection实现子类可以存放多个元素，每个元素可以是Object</p>
<p>有些实现子类可以存放重复元素，有些不可以</p>
<p>有些实现子类是有序的(List)，有些是无序的(Set)</p>
<p>Collection接口没有直接的实现子类，是通过他的子接口Set和List来实现的</p>
<h3 id="Collection-接口常用方法"><a href="#Collection-接口常用方法" class="headerlink" title="Collection 接口常用方法"></a>Collection 接口常用方法</h3><p>add:添加单个元素</p>
<p>remove:删除指定元素</p>
<p>contains:查找元素是否存在</p>
<p>size:获取元素个数</p>
<p>isEmpty:判断是否为空</p>
<p>clear:清空</p>
<p>addAll:添加多个元素</p>
<p>containsAll:查找多个元素是否都存在</p>
<p>removeAll：删除多个元素</p>
<h3 id="Collection-接口遍历元素"><a href="#Collection-接口遍历元素" class="headerlink" title="Collection 接口遍历元素"></a>Collection 接口遍历元素</h3><h4 id="Iterator-迭代器"><a href="#Iterator-迭代器" class="headerlink" title="Iterator(迭代器)"></a>Iterator(迭代器)</h4><p>所有实现了Collection接口的集合类都有一个iterator()方法，用以返回一个实现了Iterator接口的对象，即可以返回一个迭代器</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220510200811204.png" alt="image-20220510200811204"></p>
<h4 id="for-循环增强"><a href="#for-循环增强" class="headerlink" title="for 循环增强"></a>for 循环增强</h4><p>语法：for(元素类型 元素名：集合名或数组名){</p>
<p>​						访问元素</p>
<p>​			}</p>
<h2 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a>List接口</h2><p>Collection接口的子接口</p>
<p>List集合类中<strong>元素有序</strong>(添加顺序与取出顺序一致)、<strong>可重复</strong></p>
<p>List集合中的每个元素都有其对应的顺序索引，即支持索引</p>
<p>List容器中的元素都对应一个整数型的序号记载其在容器中的位置，可以根据序号存取容器中的元素</p>
<h3 id="List的遍历"><a href="#List的遍历" class="headerlink" title="List的遍历"></a>List的遍历</h3><p>使用iterator</p>
<p>增强for</p>
<p>普通for</p>
<h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><p>由数组实现数据存储</p>
<p>可以加入<strong>null</strong>，并且<strong>多个</strong></p>
<p>基本等同于<strong>Vector</strong>，除了**ArrayList是线程不安全的(执行效率高)**，多线程情况下，不建议使用ArrayList</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220510203244326.png" alt="image-20220510203244326"></p>
<h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h3><p>线程同步，即<strong>线程安全</strong>，Vector类的操作方法带有<strong>synchronized</strong></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220510204207739.png" alt="image-20220510204207739"></p>
<h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><p>底层实现了双向链表和双端队列的特点</p>
<p>可以添加任意元素(元素可以重复)，包括null</p>
<p>线程不安全，没有实现同步</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220510204439516.png" alt="image-20220510204439516"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220510204620749.png" alt="image-20220510204620749"></p>
<h2 id="Set接口"><a href="#Set接口" class="headerlink" title="Set接口"></a>Set接口</h2><p><strong>无序</strong>(添加和取出的顺序不一致)，没有索引</p>
<p><strong>不允许重复元素</strong>，最多只能包含一个null</p>
<h3 id="Set的遍历"><a href="#Set的遍历" class="headerlink" title="Set的遍历"></a>Set的遍历</h3><p>使用迭代器</p>
<p>增强for</p>
<p>不能使用索引的方式来获取</p>
<h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><p>底层是HashMap，HashMap的底层是数组+链表+红黑树</p>
<p>可以存放null值，但是只能有一个</p>
<p>不能有重复元素</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220510205506684.png" alt="image-20220510205506684"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220510205702116.png" alt="image-20220510205702116"></p>
<h3 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h3><p>HashSet的子类</p>
<p>底层是LinkedHashMap，底层维护了一个数组+双向链表</p>
<p>根据元素的hashCode值来决定元素的存储位置，同时使用链表维护元素的次序，这使元素看起来是以插入顺序保存的</p>
<p>不允许添加重复元素</p>
<h2 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h2><p><strong>Map与Collection并列存在</strong>，用于保存具有映射关系的数据：Key-Value</p>
<p>Key和Value可以是任何引用类型的数据，会封装到HashMap$Node对象中</p>
<p><strong>Key不允许重复</strong>，原因和HashSet一样</p>
<p><strong>Value可以重复</strong></p>
<p><strong>Key与Value可为null</strong></p>
<p>常用String类作为Map的Key</p>
<p>Key与Value存在<strong>单向一对一</strong>关系，即通过指定的Key总能找到对应的value</p>
<p>一对K-V是存放在一个HashMap$Node中的，Node实现了Entry接口，故也可说，一对k-v就是一个Entry</p>
<h3 id="Map接口常用方法"><a href="#Map接口常用方法" class="headerlink" title="Map接口常用方法"></a>Map接口常用方法</h3><p>put：添加数据，若key相等，则替换key对应的value值</p>
<p>remove：根据键删除映射关系</p>
<p>get：根据键获取值</p>
<p>size：获取元素个数</p>
<p>isEmpty：判断个数是否为 0</p>
<p>clear：清除 k-v</p>
<p>containsKey：查找键是否存在</p>
<h3 id="Map的遍历"><a href="#Map的遍历" class="headerlink" title="Map的遍历"></a>Map的遍历</h3><p>1）containsKey：查找键是否存在</p>
<p>2）KeySet：获取所有的键</p>
<p>3）entrySet：获取所有关系</p>
<p>4）values：获取所有的值</p>
<h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p>是Map接口使用频率最高的实现类</p>
<p>以<strong>key-value</strong>对的方式来存储数据(HashMap$Node类型)</p>
<p>key不能重复，但是值可以，允许使用null键和null值</p>
<p>如果添加相同的key，则会覆盖原来的key-value，等同于修改</p>
<p><strong>无序</strong>，与HashSet一样，不保证映射的顺序，因为底层是以hash表的方式来存储的</p>
<p>Hash没有实现同步，因此是<strong>线程不安全</strong>的，方法没有做同步互斥的操作，没有synchronized</p>
<p>扩容机制</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220512151107133.png" alt="image-20220512151107133"></p>
<h3 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h3><p>存放的元素是键值对：k-v</p>
<p>hashTable的键和值都<strong>不能为null</strong>，否则会抛出NullPointerException</p>
<p>hashTable使用方法基本与hashMap一样</p>
<p>**线程安全(synchronized)**，hashMap线程不安全</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220512151637502.png" alt="image-20220512151637502"></p>
<h3 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h3><p>继承HashTable类，并实现了Map接口，也是使用一种键值对的形式来保存数据</p>
<p>使用特点和HashTable类似</p>
<p>可用于从xxx.properties文件中，加载数据到Properties类对象，并进行读取和修改</p>
<p>专门用于读写配置文件的集合类，配置文件的格式：键&#x3D;值，键值对不需要有空格，值不需要用引号一起来，默认类型是String</p>
<p>常见方法：</p>
<p>1）load：加载配置文件的键值对到Properties对象</p>
<p>2）list：将数据显示到指定设备</p>
<p>3）getProperty(key)：根据键获取值</p>
<p>4）setProperty(key, value)：设置键值对到Properties对象</p>
<p>5）store：将Properties中的键值对存储到配置文件，在idea中，保存信息到配置文件，如果含有中文，会存储为unicode码</p>
<h2 id="集合实现类的选取"><a href="#集合实现类的选取" class="headerlink" title="集合实现类的选取"></a>集合实现类的选取</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220512152145730.png" alt="image-20220512152145730"></p>
<h2 id="Collections-工具类"><a href="#Collections-工具类" class="headerlink" title="Collections 工具类"></a>Collections 工具类</h2><p>操作Set、List、和Map等集合的工具类</p>
<p>提供了一系列<strong>静态方法</strong>对集合元素进行排序、查询和修改等操作</p>
<h3 id="排序操作"><a href="#排序操作" class="headerlink" title="排序操作"></a>排序操作</h3><p>reverse(List)：反转 List 中元素的顺序</p>
<p>shuffle(List)：对 List 集合元素进行随机排序</p>
<p>sort(List)：根据元素的自然顺序对指定 List 集合元素按升序排序</p>
<p>sort(List，Comparator)：根据指定的 Comparator 产生的顺序对 List 集合元素进行排序</p>
<p>swap(List，int， int)：将指定 list 集合中的 i 处元素和 j 处元素进行交换</p>
<h3 id="查找、替换"><a href="#查找、替换" class="headerlink" title="查找、替换"></a>查找、替换</h3><p>Object max(Collection)：根据元素的自然顺序，返回给定集合中的最大元素</p>
<p>Object max(Collection，Comparator)：根据 Comparator 指定的顺序，返回给定集合中的最大元素</p>
<p>int frequency(Collection，Object)：返回指定集合中指定元素的出现次数</p>
<p>void copy(List dest,List src)：将 src 中的内容复制到 dest 中</p>
<p>boolean replaceAll(List list，Object oldVal，Object newVal)：使用新值替换 List 对象的所有旧值</p>
<h1 id="泛型E"><a href="#泛型E" class="headerlink" title="泛型E"></a>泛型E</h1><p>传统方法不能对加入到集合中的数据类型进行约束(不安全)</p>
<p>遍历的时候需要进行类型转换，如果集合中的数据量较大，对效率有影响</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220512160747944.png" alt="image-20220512160747944"></p>
<p>作用：可以在类声明时通过一个标识表示类中某个属性的类型，或者是某个方法的返回值的类型，或者是参数类型。</p>
<p>泛型的声明：interface 接口<T>{}和class 类&lt;K,V&gt;{}</p>
<p>​						T、K、V不代表值，而是表示类型，只能是<strong>引用类型</strong></p>
<p>泛型的实例化：要在类名后面指定类型参数的值(类型)</p>
<p>在给泛型指定具体类型后，可以传入该类型或者子类类型</p>
<h2 id="自定义泛型类"><a href="#自定义泛型类" class="headerlink" title="自定义泛型类"></a>自定义泛型类</h2><p>class 类名&lt;T, R…&gt;{</p>
<p>​		成员</p>
<p>}</p>
<p>普通成员可以使用泛型，静态不可以</p>
<p>使用泛型的数组，不能初始化</p>
<p>静态方法中不能使用类的泛型</p>
<p>泛型类的类型，是在创建对象的时候确定的(因为创建对象时，需要指定确定类型</p>
<p>如果在创建对象时，没有指定类型，默认为Object</p>
<h2 id="自定义泛型接口"><a href="#自定义泛型接口" class="headerlink" title="自定义泛型接口"></a>自定义泛型接口</h2><p>interface 接口名&lt;T,R…&gt;{}</p>
<p>接口中，静态成员也不能使用泛型</p>
<p>泛型接口的类型，在继承接口或者实现接口时确定</p>
<p>没有指定类型，默认为Object</p>
<h2 id="自定义泛型方法"><a href="#自定义泛型方法" class="headerlink" title="自定义泛型方法"></a>自定义泛型方法</h2><p>修饰符 &lt;T,R&gt;返回类型 方法名(参数列表){}</p>
<p>泛型方法，可以定义在普通类中，也可以定义在泛型类中</p>
<p>泛型方法被调用时，类型会确定</p>
<h2 id="泛型的继承和通配符"><a href="#泛型的继承和通配符" class="headerlink" title="泛型的继承和通配符"></a>泛型的继承和通配符</h2><p>泛型不具备继承性</p>
<p>&lt; ? &gt;：支持任意泛型类型</p>
<p>&lt; ? extends A &gt;：支持A类以及A类的子类，规定了泛型的上限</p>
<p>&lt; ? super A &gt;：支持A类以及A类的父类，不限于直接父类，规定了泛型的下限</p>
<h2 id="JUnit"><a href="#JUnit" class="headerlink" title="JUnit"></a>JUnit</h2><p>一个类有很多功能代码需要测试，为了测试，就需要写入到main方法中，如果有多个功能代码测试，就需要来回注销，切换很麻烦</p>
<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>进程是指运行中的程序，比如我们使用QQ，就启动了一个进程，操作系统就会为该进程分配内存空间。当我们使用迅雷，又启动了一个进程，操作系统将为迅雷分配性的内存空间。</p>
<p>进程是程序的一次执行过程，或是正在运行的一个程序。是动态过程：有他自身的产生、存在和消亡的过程。</p>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>由进程创建，是进程的一个实体</p>
<p>一个进程可以拥有多个线程</p>
<p>单线程：同一时刻，只允许执行一个线程</p>
<p>多线程：同一时刻，可以执行多个线程，比如：一个QQ进程，可以同时打开多个聊天窗口，一个迅雷进程，可以同时下载多个文件</p>
<p>并发：同一时刻，多个任务交替执行，造成一种“貌似同时”的错觉，简单地说，单核CPU实现的多任务就是并发</p>
<p>并行：同一时刻，多个任务同时执行。多个CPU可以实现并行</p>
<h2 id="线程的基本使用"><a href="#线程的基本使用" class="headerlink" title="线程的基本使用"></a>线程的基本使用</h2><h3 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h3><p>1）继承Thread类，重写run方法</p>
<p>2）实现Runnable接口，实现run方法</p>
<p>​		java是单继承的，在某些情况下一个类可能已经继承了某个父类，这时再用继承Thread类方法来创建线程显然不可能了，需要new Thread()来使用start方法</p>
<p>​		实现Runnable接口方式更加适合多个线程共享一个资源情况，并且避免了单继承的限制，建议使用Runnable</p>
<p>3）线程池创建线程</p>
<h3 id="线程常用方法"><a href="#线程常用方法" class="headerlink" title="线程常用方法"></a>线程常用方法</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220514203110588.png" alt="image-20220514203110588"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220514203153934.png" alt="image-20220514203153934"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220514203305654.png" alt="image-20220514203305654"></p>
<p>用户线程：也叫工作线程，当线程的任务执行完成或通知方式结束</p>
<p>守护线程：一般是为工作线程服务的，当所有的用户线程结束，守护线程自动结束（常见的守护线程：垃圾回收机制）setDaemon()方法</p>
<h2 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h2><p>Thread.State枚举表示了线程的几种状态</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220514204340007.png" alt="image-20220514204340007"></p>
<p><img src="https://uploadfiles.nowcoder.com/images/20180316/8955099_1521189690989_0BB28C2A1ECCC47EC020E89E8A554BBC" alt="img"></p>
<p><strong>TCP客户端：</strong> </p>
<p>1.建立连接套接字，设置Ip和端口监听，socket()</p>
<p>2.建立连接 connect</p>
<p>3.write() 获取网络流对象 发送数据</p>
<p>4.read()获取网络流对象 接收数据</p>
<p>5.关闭套接字</p>
<p><strong>TCP服务器端：</strong></p>
<p>1.建立端口监听 socket()</p>
<p>2.绑定指定端口 bind()</p>
<p>3.listen 进行端口监听</p>
<p>4.accept() 阻塞式 直到有客户端访问</p>
<p>5.read()获取客户端发送数据</p>
<p>6.write()发送返回数据</p>
<p>7.close关闭端口监听</p>
<h2 id="线程的同步"><a href="#线程的同步" class="headerlink" title="线程的同步"></a>线程的同步</h2><h3 id="线程同步机制"><a href="#线程同步机制" class="headerlink" title="线程同步机制"></a>线程同步机制</h3><p> <strong>Synchronized</strong></p>
<p>在多线程编程，一些敏感数据不允许被多个线程同时访问，此时就使用同步访问技术，保证数据在任何同一时刻，最多有一个线程访问，以保证数据的完整性</p>
<p>线程同步：即当有一个线程在内存进行操作时，其他线程都不可以对这个内存地址进行操作，直到该线程完成操作，其他线程才能对该内存地址进行操作</p>
<h3 id="同步具体方法-Synchronized"><a href="#同步具体方法-Synchronized" class="headerlink" title="同步具体方法-Synchronized"></a>同步具体方法-Synchronized</h3><p>1）同步代码块，尽量使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(对象) &#123; <span class="comment">//得到对象的锁，才能操作同步代码块</span></span><br><span class="line">	<span class="comment">//需要被同步代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2）synchronized还可以放在方法声明中，表示整个方法为同步方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">m</span><span class="params">(String name)</span>&#123;</span><br><span class="line">    <span class="comment">//需要被同步的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><p>Java语言中，引入了对象互斥锁的概念，来保证共享数据操作的完整性</p>
<p>每个对象都对应于一个可称为”互斥锁“的标记，这个标记用来保证在任一时刻，只能有一个线程访问该对象</p>
<p>关键字synchronized来与对象的互斥锁联系。当某个对象用synchronized修饰时，表明该对象在任一时刻只能由一个线程访问</p>
<p>同步的局限性：导致程序的执行效率要降低</p>
<p>同步方法(非静态的)的锁可以是this，也可以是其他对象(要求是同一个对象)</p>
<p>同步方法(静态的)的锁为当前类本身</p>
<p>同步方法如果没有使用static修饰：默认锁对象为this，如果使用static修饰，默认锁对象为：当前类.class</p>
<p>要求多个线程的锁对象为同一个即可！</p>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>多个线程都占用了对方的锁资源，但不肯相让，导致了死锁，在编程是一定要避免死锁的发生</p>
<p>释放锁：当前线程的同步方法、同步代码块执行结束</p>
<p>​				当前线程在同步代码块、同步方法中遇到break、return</p>
<p>​				当前线程在同步代码块、同步方法中出现了未处理的Error或Exception，导致异常结束</p>
<p>​				当前线程在同步代码块、同步方法中执行了线程对象的wait()方法，当前线程暂停，并释放锁</p>
<p>不会释放锁：线程执行同步代码块或同步方法时，程序调用Thread.sleep()、Thread.yield()方法暂停当前线程的执行，不会释放锁</p>
<p>​						线程执行同步代码块时，其他线程调用了该线程的suspend()方法将该线程挂起</p>
<h1 id="IO-流"><a href="#IO-流" class="headerlink" title="IO 流"></a>IO 流</h1><h2 id="文件流"><a href="#文件流" class="headerlink" title="文件流"></a>文件流</h2><p>文件在程序中是以流的形式来操作的</p>
<p>流：数据在数据源(文件)和程序(内存)之间经历的路径</p>
<p>输入流：数据从数据源(文件)到程序(内存)的路径</p>
<p>输出流：数据从程序(内存)到数据源(文件)的路径</p>
<h2 id="常见的文件操作"><a href="#常见的文件操作" class="headerlink" title="常见的文件操作"></a>常见的文件操作</h2><p>创建文件相关构造器和方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">File</span>(String pathname)<span class="comment">//根据路径构建一个File对象</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">File</span>(File parent, String child)<span class="comment">//根据父目录文件+子路径构建一个File对象</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">File</span>(String parent, String child)<span class="comment">//根据父目录+子路径构建一个File对象</span></span><br><span class="line">    </span><br><span class="line">creatNewFile <span class="comment">//创建新文件</span></span><br></pre></td></tr></table></figure>

<p>获取文件的相关信息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">getNmae<span class="comment">//文件名字</span></span><br><span class="line">getAbsolutePath<span class="comment">//文件绝对路径</span></span><br><span class="line">getParent<span class="comment">//&quot;文件父级目录</span></span><br><span class="line">length<span class="comment">//文件大小(字节)</span></span><br><span class="line">exists<span class="comment">//文件是否存在</span></span><br><span class="line">isFile<span class="comment">//是不是一个文件</span></span><br><span class="line">isDirectory<span class="comment">//是不是一个目录</span></span><br></pre></td></tr></table></figure>

<p>目录的操作和文件删除</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">makdir<span class="comment">//创建一级目录</span></span><br><span class="line">mkdirs<span class="comment">//创建多级目录</span></span><br><span class="line">delete<span class="comment">//删除空目录或文件</span></span><br></pre></td></tr></table></figure>

<h2 id="IO-流原理及流的分类"><a href="#IO-流原理及流的分类" class="headerlink" title="IO 流原理及流的分类"></a>IO 流原理及流的分类</h2><p><strong>原理</strong></p>
<p>1）I&#x2F;O是Input&#x2F;Output的缩写，I&#x2F;O技术，用于处理数据传输</p>
<p>2）Java程序中，对于数据的输入&#x2F;输出操作以“流(stream)”的方式进行</p>
<p>3）java.io包下提供了各种“流”类和接口，用以获得不同种类的数据，并通过方法输入或输出数据</p>
<p>4）输入input：读取外部数据(磁盘、光盘等存储设备的数据)到程序(内存)中</p>
<p>5）输出output：将程序(内存)数据输出到磁盘、光盘等存储设备中</p>
<p><strong>分类</strong></p>
<p>按操作数据单位不同：字节流(8 bit)二进制文件，字符流(按字符)文本文件</p>
<p>按数据流的流向不同：输入流，输出流</p>
<p>按流的角色不同：节点流，处理流&#x2F;包装流</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220515222537824.png" alt="image-20220515222537824"></p>
<p>1）Java的IO流共涉及40多个类，都是从如上4个抽象基类派生的</p>
<p>2）由这四个类派生出来的子类名称都是以其父类名作为子类名后缀</p>
<h2 id="IO-流体系图"><a href="#IO-流体系图" class="headerlink" title="IO 流体系图"></a>IO 流体系图</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220516122221731.png" alt="image-20220516122221731"></p>
<p><strong>FileOutputSream</strong></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220516142451047.png" alt="image-20220516142451047"></p>
<p> <strong>FileReader 和 FileWriter</strong></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220516142644135.png" alt="image-20220516142644135"></p>
<p><strong>FileReader 相关方法：</strong></p>
<p>new FileReader(File&#x2F;String)</p>
<p>read：每次读取单个字符，返回该字符，如果到文件末尾返回-1</p>
<p>read(Char[])：批量读取多个字符到数组，返回读取到的字符数，如果到文件末尾返回-1</p>
<p>相关API：new String(char[])：将char[]转换成String</p>
<pre><code>             new String(char[], off, len)：将char[]的指定部分转换成String
</code></pre>
<p><strong>FileWriter 相关方法：</strong></p>
<p>new FileWriter(File&#x2F;String)：覆盖模式，相当于流的指针在首端</p>
<p>new FileWriter(File&#x2F;String, true)：追加模式，相当于流的指针在尾端</p>
<p>writer(int)：写入单个字符</p>
<p>writer(char[])：写入指定数组</p>
<p>writer(char[], off, len)：写入指定数组的指定部分</p>
<p>writer(string)：写入整个字符串</p>
<p>writer(string, off, len)：写入字符串的指定部分</p>
<p>FileWriter使用后，必须**关闭(close)或刷新(flush)**，否则写入不到指定文件！</p>
<h2 id="节点流和处理流"><a href="#节点流和处理流" class="headerlink" title="节点流和处理流"></a>节点流和处理流</h2><p>节点流：可以从一个特定的数据源读写数据，如：FileReader、FileWriter</p>
<p>处理流：是连接在已存在的流(节点流或处理流之上)，为程序提供更为强大的读写功能，也更加灵活，如：BufferedReader、BufferedWriter</p>
<p>区别和联系：</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220516145022746.png" alt="image-20220516145022746"></p>
<h2 id="处理流的优点"><a href="#处理流的优点" class="headerlink" title="处理流的优点"></a>处理流的优点</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220516145131925.png" alt="image-20220516145131925"></p>
<h2 id="处理流-BufferedReader和BufferWriter"><a href="#处理流-BufferedReader和BufferWriter" class="headerlink" title="处理流-BufferedReader和BufferWriter"></a>处理流-BufferedReader和BufferWriter</h2><p>属于字符流，是按照字符来读取数据的</p>
<p>关闭时处理流，只需要关闭外层流即可</p>
<h2 id="处理流-BufferedInputStream-和-BufferedOutputStream"><a href="#处理流-BufferedInputStream-和-BufferedOutputStream" class="headerlink" title="处理流-BufferedInputStream 和 BufferedOutputStream"></a>处理流-BufferedInputStream 和 BufferedOutputStream</h2><p>BufferedInputStream 是字节流，在创建 BufferedInputStream 时，会创建一个内部缓冲区数组</p>
<p><strong>BufferedInputStream–&gt;FilterInputStream–&gt;InputStream–&gt;Closeable(接口)</strong></p>
<p><strong>BufferedOutputStream–&gt;FilterOutputStream–&gt;OutputStream–&gt;Closeable和Flushable(接口)</strong></p>
<h2 id="对象流-ObjectInputStream-和-ObjectOutputStrea"><a href="#对象流-ObjectInputStream-和-ObjectOutputStrea" class="headerlink" title="对象流-ObjectInputStream 和 ObjectOutputStrea"></a>对象流-ObjectInputStream 和 ObjectOutputStrea</h2><h3 id="序列和反序列化"><a href="#序列和反序列化" class="headerlink" title="序列和反序列化"></a>序列和反序列化</h3><p>1）序列化就是在保存数据时，保存数据的值和数据类型。</p>
<p>​		将数据结构转换称为二进制数据流或者文本流的过程。序列化后的数据方便在网络上传输和在硬盘上存储。</p>
<p>2）反序列化就是在恢复数据时，恢复数据的值和数据类型</p>
<p>​		与序列化相反，是将二进制数据流或者文本流转换称为易于处理和阅读的数据结构的过程。</p>
<p>3）需要让某个对象支持序列化机制，则必须让其类是可序列化的，为了让某个类是可序列化的，该类必须实现如下两个接口之一：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Serializable <span class="comment">//这是一个标记接口，没有方法</span></span><br><span class="line">   Externalizable <span class="comment">//该接口有方法需要实现，因此一般实现Serializable接口</span></span><br><span class="line">   <span class="comment">//transient关键字的作用，在已实现序列化的类中，有的变量不需要保存在磁盘中，就要transient关键字修饰，如银行卡密码等，</span></span><br><span class="line">   <span class="comment">//就这个作用------在已序列化的类中使变量不序列化，通常一个类实现序列化方式是实现序列化接口 Serializable</span></span><br></pre></td></tr></table></figure>

<p>对象流功能：提供了对基本类型或对象类型的序列化和反序列化的方法 </p>
<p>​						ObjectOutputStream 提供 序列化功能 </p>
<p>​			   		 ObjectInputStream 提供 反序列化功能</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220516201954245.png" alt="image-20220516201954245">			</p>
<p>序列化数据和反序列化恢复数据</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220516201309591.png" alt="image-20220516201309591"></p>
<h2 id="标准输入输出流"><a href="#标准输入输出流" class="headerlink" title="标准输入输出流"></a>标准输入输出流</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220516201438597.png" alt="image-20220516201438597"></p>
<h2 id="转换流-InputStreamReader-和-OutputStreamWriter"><a href="#转换流-InputStreamReader-和-OutputStreamWriter" class="headerlink" title="转换流-InputStreamReader 和 OutputStreamWriter"></a>转换流-InputStreamReader 和 OutputStreamWriter</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220516201634261.png" alt="image-20220516201634261"></p>
<h2 id="打印流-PrintStream-和-PrintWriter"><a href="#打印流-PrintStream-和-PrintWriter" class="headerlink" title="打印流-PrintStream 和 PrintWriter"></a>打印流-PrintStream 和 PrintWriter</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220516201859470.png" alt="image-20220516201859470"></p>
<h1 id="反射-reflection"><a href="#反射-reflection" class="headerlink" title="反射(reflection)"></a>反射(reflection)</h1><p>需求：根据配置文件re.properties指定信息，创建对象并调用方法；即通过外部配置文件，在不修改源码的情况下来控制程序，也符合设计模式的<strong>ocp原则</strong>(<strong>开闭原则</strong>：不修改源码，扩容功能)</p>
<h2 id="反射机制"><a href="#反射机制" class="headerlink" title="反射机制"></a>反射机制</h2><p>1）反射机制允许程序在执行期间借助于Reflection API 获得任何类的内部信息(比如：成员变量、构造器，成员方法等)，并能操作对象的属性及方法。反射在设计模式和框架底层都会用到</p>
<p>2）加载完类之后，在堆中就产生了一个Class类型的对象(一个类只有一个Class对象)，这个对象包含了类的完整结构信息。通过这个对象得到类的结构。</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220517143914000.png" alt="image-20220517143914000"></p>
<p><strong>作用</strong></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220517144131916.png" alt="image-20220517144131916"></p>
<p><strong>反射相关的类</strong></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220517144239805.png" alt="image-20220517144239805"></p>
<h2 id="反射优点和缺点"><a href="#反射优点和缺点" class="headerlink" title="反射优点和缺点"></a>反射优点和缺点</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220517144349140.png" alt="image-20220517144349140"></p>
<h2 id="反射调用优化-关闭访问检查"><a href="#反射调用优化-关闭访问检查" class="headerlink" title="反射调用优化-关闭访问检查"></a>反射调用优化-关闭访问检查</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220517144438188.png" alt="image-20220517144438188"></p>
<h2 id="Class-类"><a href="#Class-类" class="headerlink" title="Class 类"></a>Class 类</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220517144528389.png" alt="image-20220517144528389"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220517144622172.png" alt="image-20220517144622172"></p>
<h3 id="Class-类的常用方法"><a href="#Class-类的常用方法" class="headerlink" title="Class 类的常用方法"></a>Class 类的常用方法</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220517144710973.png" alt="image-20220517144710973"></p>
<h3 id="获取-Class-类对象"><a href="#获取-Class-类对象" class="headerlink" title="获取 Class 类对象"></a>获取 Class 类对象</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220517144936294.png" alt="image-20220517144936294"></p>
<h3 id="哪些类型有-Class-对象"><a href="#哪些类型有-Class-对象" class="headerlink" title="哪些类型有 Class 对象"></a>哪些类型有 Class 对象</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220517145022485.png" alt="image-20220517145022485"></p>
<h2 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220517145152479.png" alt="image-20220517145152479"></p>
<h3 id="类加载时机"><a href="#类加载时机" class="headerlink" title="类加载时机"></a>类加载时机</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220517145228556.png" alt="image-20220517145228556"></p>
<h3 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220517145340270.png" alt="image-20220517145340270"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220517145413669.png" alt="image-20220517145413669"></p>
<h4 id="加载阶段"><a href="#加载阶段" class="headerlink" title="加载阶段"></a>加载阶段</h4><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220517145456333.png" alt="image-20220517145456333"></p>
<h4 id="验证阶段"><a href="#验证阶段" class="headerlink" title="验证阶段"></a>验证阶段</h4><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220517145557852.png" alt="image-20220517145557852"></p>
<h4 id="准备阶段"><a href="#准备阶段" class="headerlink" title="准备阶段"></a>准备阶段</h4><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220517145702581.png" alt="image-20220517145702581"></p>
<h4 id="解析阶段"><a href="#解析阶段" class="headerlink" title="解析阶段"></a>解析阶段</h4><p>虚拟机将常量池中的符号引用替换为直接引用的过程</p>
<h4 id="Initialization（初始化-阶段"><a href="#Initialization（初始化-阶段" class="headerlink" title="Initialization（初始化) 阶段"></a>Initialization（初始化) 阶段</h4><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220517145853355.png" alt="image-20220517145853355"></p>
<h2 id="通过反射获取类的结构信息"><a href="#通过反射获取类的结构信息" class="headerlink" title="通过反射获取类的结构信息"></a>通过反射获取类的结构信息</h2><h3 id="java-lang-Class类"><a href="#java-lang-Class类" class="headerlink" title="java.lang.Class类"></a>java.lang.Class类</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220517150019387.png" alt="image-20220517150019387"></p>
<h3 id="java-lang-reflect-Field-类"><a href="#java-lang-reflect-Field-类" class="headerlink" title="java.lang.reflect.Field 类"></a>java.lang.reflect.Field 类</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220517150106804.png" alt="image-20220517150106804"></p>
<h3 id="java-lang-reflect-Method-类"><a href="#java-lang-reflect-Method-类" class="headerlink" title="java.lang.reflect.Method 类"></a>java.lang.reflect.Method 类</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220517150208171.png" alt="image-20220517150208171"></p>
<h3 id="java-lang-reflect-Constructor-类"><a href="#java-lang-reflect-Constructor-类" class="headerlink" title="java.lang.reflect.Constructor 类"></a>java.lang.reflect.Constructor 类</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220517150233977.png" alt="image-20220517150233977"></p>
<h2 id="通过反射创建对象"><a href="#通过反射创建对象" class="headerlink" title="通过反射创建对象"></a>通过反射创建对象</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220517150326870.png" alt="image-20220517150326870"></p>
<h2 id="通过反射访问类中的成员"><a href="#通过反射访问类中的成员" class="headerlink" title="通过反射访问类中的成员"></a>通过反射访问类中的成员</h2><h3 id="访问属性"><a href="#访问属性" class="headerlink" title="访问属性"></a>访问属性</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220517150407163.png" alt="image-20220517150407163"></p>
<h3 id="访问方法"><a href="#访问方法" class="headerlink" title="访问方法"></a>访问方法</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220517150431898.png" alt="image-20220517150431898"></p>
<h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><p>处理文本的利器，是对字符串执行模式匹配的技术</p>
<p>一个正则表达式，就是用某种模式去匹配字符串的一个公式</p>
<p>注：在Java正则表达式中，两个\\代表其它语言中的一个\</p>
<h2 id="正则表达式底层实现"><a href="#正则表达式底层实现" class="headerlink" title="正则表达式底层实现"></a>正则表达式底层实现</h2><p>1）创建一个<strong>Pattern模式对象</strong>，即正则表达式对象；</p>
<p>2）创建一个<strong>matcher匹配器对象</strong>，按照pattern(模式)，到字符串中去匹配；</p>
<p>3）找到后，将子字符串的开始的索引记录到 matcher 对象的属性 grops[0]，把该子字符串的结束的索引+1 的值记录到 groups[1]；</p>
<p>4）同时记录 oldLast 的值为子字符串的结束的索引 +1 的值即 groups[1]，即下次执行 find 时，就从此开始匹配；</p>
<h3 id="matcher-group-0-分析"><a href="#matcher-group-0-分析" class="headerlink" title="matcher.group(0) 分析"></a>matcher.group(0) 分析</h3><p>根据 groups[0] 和 groups[1] 的记录的位置，从字符串中开始截取子字符串返回，就是 [groups[0], groups[1]) 包含groups[0] 但是不包</p>
<p>含索引为groups[1]的位置</p>
<p><strong>有分组</strong>：将子字符串的开始的索引记录到 matcher 对象的属性 grops[0]，把该子字符串的结束的索引+1 的值记录到 groups[1]</p>
<p>​				记录第一个分组匹配到的字符串 groups[2] ，groups[3]为开始和结束+1的索引值</p>
<pre><code>            记录第二个分组匹配到的字符串 groups[4]，groups[5]为开始和结束+1的索引值
</code></pre>
<p>​				如果有更多的分组以此类推</p>
<p>​				group(0) 表示匹配到的子字符串</p>
<p>​				group(1) 表示匹配到的子字符串的第一组字串 </p>
<p>​				group(2) 表示匹配到的子字符串的第二组字串</p>
<p><strong>matches</strong>方法：用于整体匹配，在验证输入的字符串是否满足条件使用，返回ture或false</p>
<h2 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h2><h3 id="mysql中的模糊查询"><a href="#mysql中的模糊查询" class="headerlink" title="mysql中的模糊查询"></a>mysql中的模糊查询</h3><p><code>%</code>: 匹配0个或者多个任意字符</p>
<p><code>_</code>: 匹配任意一个字符</p>
<h3 id="转义号"><a href="#转义号" class="headerlink" title="转义号"></a>转义号</h3><p>使用正则表达式去检索某些特殊字符的时候，需要用到转移符号</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220518220453765.png" alt="image-20220518220453765"></p>
<h3 id="限定符"><a href="#限定符" class="headerlink" title="限定符"></a>限定符</h3><p>用于指定其前面的字符和组合项连续出现多少次</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220518153708550.png" alt="image-20220518153708550"></p>
<h3 id="选择匹配符"><a href="#选择匹配符" class="headerlink" title="选择匹配符"></a>选择匹配符</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220518153639621.png" alt="image-20220518153639621"></p>
<h3 id="分组组合和反向引用符"><a href="#分组组合和反向引用符" class="headerlink" title="分组组合和反向引用符"></a>分组组合和反向引用符</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220518154036309.png" alt="image-20220518154036309"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220518154102247.png" alt="image-20220518154102247"></p>
<h3 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h3><h3 id="字符匹配符"><a href="#字符匹配符" class="headerlink" title="字符匹配符"></a>字符匹配符</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220518153246607.png" alt="image-20220518153246607"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220518153258920.png" alt="image-20220518153258920"></p>
<p>\s：匹配任何空白字符，包括空格、制表符、换页符等。与[\f\n\r\t\v]等效</p>
<p>\S：匹配任何非空白字符</p>
<h3 id="定位符"><a href="#定位符" class="headerlink" title="定位符"></a>定位符</h3><p>规定要匹配的字符串出现的位置，比如在字符串的开始还是在结束的位置</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220518153948293.png" alt="image-20220518153948293"></p>
<h2 id="常用类-1"><a href="#常用类-1" class="headerlink" title="常用类"></a>常用类</h2><h3 id="Pattern类"><a href="#Pattern类" class="headerlink" title="Pattern类"></a>Pattern类</h3><p>pattern对象是一个正则表达式对象，Pattern类没有公共构造方法，要创建一个Pattern对象，调用其公共静态方法，它返回一个Pattern对象，该方法接收一个正则表达式作为他的第一个参数</p>
<h3 id="Matcher类"><a href="#Matcher类" class="headerlink" title="Matcher类"></a>Matcher类</h3><p>是对输入字符串进行解释和匹配的引擎。与Pattern类一样，Matcher也没有公共构造方法，需要调用Pattern对象的matcher方法获得一个Mather对象</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220519153616879.png" alt="image-20220519153616879"></p>
<h3 id="PatternSyntaxException类"><a href="#PatternSyntaxException类" class="headerlink" title="PatternSyntaxException类"></a>PatternSyntaxException类</h3><p>非强制异常类，表示一个正则表达式模式中的语法错误0</p>
<h2 id="分组、捕获、反向引用"><a href="#分组、捕获、反向引用" class="headerlink" title="分组、捕获、反向引用"></a>分组、捕获、反向引用</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220519154550603.png" alt="image-20220519154550603">	</p>
<h1 id="Lamda-表达式"><a href="#Lamda-表达式" class="headerlink" title="Lamda 表达式"></a>Lamda 表达式</h1><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><p><strong>(args1, args2,…) -&gt; { <a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=express&spm=1001.2101.3001.7020">express</a> block }</strong></p>
<p>lamda表达式由两部分组成：<strong>参数和语句块</strong>，参数可以不写参数类型也可以写参数类型，如果写参数类型，必须与对应方法的参数类型一致，</p>
<p><strong>如果只有一个参数，可以省略小括号()<strong>；语句块中如果只有一条语句，</strong>可以省略大括号{ }和return关键字</strong>。</p>
<p><strong>lamda表达式只支持函数式接口，函数式接口就是只有一个抽象方法的接口</strong>，例如Runnable</p>
<p>避免匿名<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%86%85%E9%83%A8%E7%B1%BB&spm=1001.2101.3001.7020">内部类</a>定义过多</p>
<p>可以让你的代码看起来很简洁</p>
<p>去掉了一堆没有意义的代码，留下核心的逻辑</p>
<p>其实质属于<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B&spm=1001.2101.3001.7020">函数式编程</a>的概念</p>
<h1 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h1><h2 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h2><p>两个区域A和B，初始对象在A，继续存活的对象被转移到B。此为新生代最常用的算法</p>
<h2 id="标记清理算法"><a href="#标记清理算法" class="headerlink" title="标记清理算法"></a>标记清理算法</h2><p>一块区域，标记可达对象（可达性分析），然后回收不可达对象，会出现碎片，那么引出标记-整理算法：多了碎片整理，整理出更大的内存放更大的对象</p>
<p>两个概念：<strong>新生代和年老代</strong></p>
<p>新生代：初始对象，生命周期短的</p>
<p>永久代：长时间存在的对象</p>
<p>整个java的垃圾回收是新生代和年老代的协作，这种叫做分代回收。</p>
<p>Serial New收集器是针对新生代的收集器，采用的是复制算法</p>
<p>Parallel New（并行）收集器，新生代采用复制算法，老年代采用标记整理</p>
<p>Parallel Scavenge（并行）收集器，针对新生代，采用复制收集算法</p>
<p>Serial Old（串行）收集器，新生代采用复制，老年代采用标记整理</p>
<p>Parallel Old（并行）收集器，针对老年代，标记整理</p>
<p>CMS收集器，基于标记清理</p>
<p>G1收集器：整体上是基于标记 整理 ，局部采用复制</p>
<p><strong>综上：新生代基本采用复制算法，老年代采用标记整理算法。cms采用标记清理。</strong></p>
<h1 id="委托事件模型"><a href="#委托事件模型" class="headerlink" title="委托事件模型"></a>委托事件模型</h1><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/cac99c0f172b">https://www.jianshu.com/p/cac99c0f172b</a></p>
<h1 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h1><h2 id="网络的相关概念"><a href="#网络的相关概念" class="headerlink" title="网络的相关概念"></a>网络的相关概念</h2><h3 id="网络通信"><a href="#网络通信" class="headerlink" title="网络通信"></a>网络通信</h3><p>两台设备之间通过网络实现数据传输&#x2F;将数据通过网络从一台设备传输到另一台设备</p>
<p>java.net包下提供了一系列的类或接口，供程序员使用，完成网络通信</p>
<h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><p>两台或多台设备通过一定物理设备连接起来构成了网络</p>
<p>根据网络的覆盖范围进行分类：</p>
<p>1）局域网：覆盖范围小，仅仅覆盖一个教室或一个机房</p>
<p>2）城域网：覆盖范围较大，可以覆盖一个城市</p>
<p>3）广域网：覆盖范围最大，可以覆盖全国，甚至全球，万维网是广域网的代表</p>
<h3 id="ip-地址"><a href="#ip-地址" class="headerlink" title="ip 地址"></a>ip 地址</h3><p>用以标识网络中的每一台主机&#x2F;计算机</p>
<p>查看IP地址：ipconfig</p>
<p>ip地址的表示形式：点分十进制 xx.xx.xx.xx</p>
<p>每一个十进制数的范围：0-255</p>
<p>ip地址的组成：网络地址+主机地址</p>
<p>ipv4的网络地址资源有限，严重制约了互联网的应用和发展，ipv6的使用，不仅能解决网络地址资源数量的问题，而且也解决了多种接入设备连入互联网的障碍</p>
<h3 id="ipv4地址分类"><a href="#ipv4地址分类" class="headerlink" title="ipv4地址分类"></a>ipv4地址分类</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220519170200444.png" alt="image-20220519170200444"></p>
<h3 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h3><p>好处：为了方便记忆，解决记ip的困难</p>
<p>概念：将ip地址映射成域名，HTTP</p>
<p><strong>端口号：</strong>用于标识计算机上某个特定的网络程序</p>
<p>​				以整数形式，端口范围：0-65535[两个字节表示端口]</p>
<p>​				0-1024已经被占用，比如：ssh 22,  ftp 21,  smtp 25,  http 80</p>
<p>​				常见的网络程序端口号：tomcat:8080</p>
<p>​															mysql:3306</p>
<p>​															oracle:1521</p>
<p>​															sqlserver:1433</p>
<h3 id="网络通信协议"><a href="#网络通信协议" class="headerlink" title="网络通信协议"></a>网络通信协议</h3><p>TCP&#x2F;IP：传输控制协议，由网络层的IP协议和传输层的TCP协议组成</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220519172516839.png" alt="image-20220519172516839"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220519172535187.png" alt="image-20220519172535187"></p>
<h2 id="InetAddress-类"><a href="#InetAddress-类" class="headerlink" title="InetAddress 类"></a>InetAddress 类</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220519172610171.png" alt="image-20220519172610171"></p>
<h2 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220519172647626.png" alt="image-20220519172647626"></p>
<h2 id="TCP-网络通信编程"><a href="#TCP-网络通信编程" class="headerlink" title="TCP 网络通信编程"></a>TCP 网络通信编程</h2><p>基于客户端—服务端的网络通信</p>
<p>底层使用的是TCP&#x2F;IP协议</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220519172850090.png" alt="image-20220519172850090"></p>
<h3 id="netstat-指令"><a href="#netstat-指令" class="headerlink" title="netstat 指令"></a>netstat 指令</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220519172954362.png" alt="image-20220519172954362"></p>
<p>-Xms1G -Xmx2G -Xmn500M -XX:MaxPermSize&#x3D;64M -XX:+UseConcMarkSweepGC -XX:SurvivorRatio&#x3D;3,</p>
<p>-Xms：1G ， 就是说初始堆大小为1G<br>-Xmx：2G ， 就是说最大堆大小为2G<br>-Xmn：500M ，就是说年轻代大小是500M（包括一个Eden和两个Survivor）<br>-XX:MaxPermSize：64M ， 就是说设置持久代最大值为64M<br>-XX:+UseConcMarkSweepGC ， 就是说使用使用CMS内存收集算法<br>-XX:SurvivorRatio&#x3D;3 ， 就是说Eden区与Survivor区的大小比值为3：1：1</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-JVM：垃圾回收相关概念"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
	
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/07/24/JVM%EF%BC%9A%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"
    >垃圾回收相关概念</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/07/24/JVM%EF%BC%9A%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/" class="article-date">
  <time datetime="2022-07-24T02:40:12.000Z" itemprop="datePublished">2022-07-24</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/JVM/">JVM</a> / <a class="article-category-link" href="/categories/JVM/1-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/">1.内存与垃圾回收篇</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220724102106880.png" alt="image-20220724102106880"></p>
<ul>
<li><p>Java 和 C++语言的区别，就在于垃圾收集技术和内存动态分配上，C++语言没有垃圾收集技术，需要程序员手动的收集。</p>
</li>
<li><p>垃圾收集，不是Java语言的伴生产物。早在1960年，第一门开始使用内存动态分配和垃圾收集技术的Lisp语言诞生。</p>
</li>
<li><p>关于垃圾收集有三个经典问题：</p>
<ul>
<li>哪些内存需要回收？</li>
<li>什么时候回收？</li>
<li>如何回收？</li>
</ul>
</li>
<li><p>垃圾收集机制是Java的招牌能力，<strong>极大地提高了开发效率</strong>。如今，垃圾收集几乎成为现代语言的标配，即使经过如此长时间的发展，Java的垃圾收集机制仍然在不断的演进中，不同大小的设备、不同特征的应用场景，对垃圾收集提出了新的挑战，这当然也是面试的热点。</p>
</li>
</ul>
<h1 id="大厂面试题"><a href="#大厂面试题" class="headerlink" title="大厂面试题"></a>大厂面试题</h1><h2 id="蚂蚁金服"><a href="#蚂蚁金服" class="headerlink" title="蚂蚁金服"></a>蚂蚁金服</h2><ol>
<li>你知道哪几种垃圾回收器，各自的优缺点，重点讲一下CMS和G1？</li>
<li>JVM GC算法有哪些，目前的JDK版本采用什么回收算法？</li>
<li>G1回收器讲下回收过程GC是什么？为什么要有GC？</li>
<li>GC的两种判定方法？CMS收集器与G1收集器的特点</li>
</ol>
<h2 id="百度"><a href="#百度" class="headerlink" title="百度"></a>百度</h2><ol>
<li>说一下GC算法，分代回收说下</li>
<li>垃圾收集策略和算法</li>
</ol>
<h2 id="天猫"><a href="#天猫" class="headerlink" title="天猫"></a>天猫</h2><ol>
<li>JVM GC原理，JVM怎么回收内存</li>
<li>CMS特点，垃圾回收算法有哪些？各自的优缺点，他们共同的缺点是什么？</li>
</ol>
<h2 id="滴滴"><a href="#滴滴" class="headerlink" title="滴滴"></a>滴滴</h2><ol>
<li>Java的垃圾回收器都有哪些，说下G1的应用场景，平时你是如何搭配使用垃圾回收器的</li>
</ol>
<h2 id="京东"><a href="#京东" class="headerlink" title="京东"></a>京东</h2><ol>
<li>你知道哪几种垃圾收集器，各自的优缺点，重点讲下CMS和G1，</li>
<li>包括原理，流程，优缺点。垃圾回收算法的实现原理</li>
</ol>
<h2 id="阿里"><a href="#阿里" class="headerlink" title="阿里"></a>阿里</h2><ol>
<li>讲一讲垃圾回收算法。</li>
<li>什么情况下触发垃圾回收？</li>
<li>如何选择合适的垃圾收集算法？</li>
<li>JVM有哪三种垃圾回收器？</li>
</ol>
<h2 id="字节跳动"><a href="#字节跳动" class="headerlink" title="字节跳动"></a>字节跳动</h2><ol>
<li>常见的垃圾回收器算法有哪些，各有什么优劣？</li>
<li>System.gc()和Runtime.gc()会做什么事情？</li>
<li>Java GC机制？GC Roots有哪些？</li>
<li>Java对象的回收方式，回收算法。</li>
<li>CMS和G1了解么，CMS解决什么问题，说一下回收的过程。</li>
<li>CMS回收停顿了几次，为什么要停顿两次?</li>
</ol>
<h1 id="什么是垃圾？"><a href="#什么是垃圾？" class="headerlink" title="什么是垃圾？"></a>什么是垃圾？</h1><ol>
<li>垃圾是指<strong>在运行程序中没有任何指针指向的对象</strong>，这个对象就是需要被回收的垃圾。</li>
<li>外文：An object is considered garbage when it can no longer be reached from any pointer in the running program.</li>
<li>如果不及时对内存中的垃圾进行清理，那么，这些垃圾对象所占的内存空间会一直保留到应用程序结束，被保留的空间无法被其他对象使用。甚至可能导致内存溢出。</li>
</ol>
<p><strong>十几年前磁盘碎片整理的日子</strong></p>
<img src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_010/0002.jpg">

<h1 id="为什么需要GC？"><a href="#为什么需要GC？" class="headerlink" title="为什么需要GC？"></a>为什么需要GC？</h1><p><strong>想要学习GC，首先需要理解为什么需要GC？</strong></p>
<ol>
<li><p>对于高级语言来说，一个基本认知是如果不进行垃圾回收，<strong>内存迟早都会被消耗完</strong>，因为不断地分配内存空间而不进行回收，就好像不停地生产生活垃圾而从来不打扫一样。</p>
</li>
<li><p>除了释放没用的对象，垃圾回收也可以清除内存里的记录碎片。碎片整理将所占用的堆内存移到堆的一端，<strong>以便JVM将整理出的内存分配给新的对象</strong>。</p>
</li>
<li><p>随着应用程序所应付的业务越来越庞大、复杂，用户越来越多，<strong>没有GC就不能保证应用程序的正常进行</strong>。而经常造成STW的GC又跟不上实际的需求，所以才会不断地尝试对GC进行优化。</p>
</li>
</ol>
<h1 id="早期垃圾回收"><a href="#早期垃圾回收" class="headerlink" title="早期垃圾回收"></a>早期垃圾回收</h1><ol>
<li>在早期的C&#x2F;C++时代，垃圾回收基本上是手工进行的。开发人员可以使用new关键字进行内存申请，并使用delete关键字进行内存释放。比如以下代码：</li>
</ol>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MibBridge *pBridge= <span class="keyword">new</span> cmBaseGroupBridge（）；</span><br><span class="line"><span class="comment">//如果注册失败，使用Delete释放该对象所占内存区域</span></span><br><span class="line"><span class="keyword">if</span>（pBridge-&gt;Register（kDestroy）！=NO ERROR）</span><br><span class="line">	<span class="keyword">delete</span> pBridge；</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>这种方式可以灵活控制内存释放的时间，但是会给开发人员带来<strong>频繁申请和释放内存的管理负担</strong>。倘若有一处内存区间由于程序员编码的问题忘记被回收，那么就会产生<strong>内存泄漏</strong>，垃圾对象永远无法被清除，随着系统运行时间的不断增长，垃圾对象所耗内存可能持续上升，直到出现内存溢出并造成<strong>应用程序崩溃</strong>。</p>
</li>
<li><p>有了垃圾回收机制后，上述代码极有可能变成这样</p>
</li>
</ol>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MibBridge *pBridge=<span class="keyword">new</span> <span class="built_in">cmBaseGroupBridge</span>(); </span><br><span class="line">pBridge-&gt;<span class="built_in">Register</span>(kDestroy);</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>现在，除了Java以外，C#、Python、Ruby等语言都使用了自动垃圾回收的思想，也是未来发展趋势，可以说这种自动化的内存分配和垃圾回收方式已经成为了现代开发语言必备的标准。</li>
</ol>
<h1 id="Java-垃圾回收机制"><a href="#Java-垃圾回收机制" class="headerlink" title="Java 垃圾回收机制"></a>Java 垃圾回收机制</h1><h2 id="自动内存管理"><a href="#自动内存管理" class="headerlink" title="自动内存管理"></a>自动内存管理</h2><blockquote>
<p><strong>官网介绍</strong>：<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/toc.html">https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/toc.html</a></p>
</blockquote>
<p><strong>自动内存管理的优点</strong></p>
<ol>
<li><p>自动内存管理，无需开发人员手动参与内存的分配与回收，这样<strong>降低内存泄漏和内存溢出的风险</strong></p>
<ul>
<li>没有垃圾回收器，java也会和cpp一样，各种悬垂指针，野指针，泄露问题让你头疼不已。</li>
</ul>
</li>
<li><p>自动内存管理机制，将程序员从繁重的内存管理中释放出来，可以<strong>更专心地专注于业务开发</strong></p>
</li>
</ol>
<p><strong>关于自动内存管理的担忧</strong></p>
<ol>
<li>对于Java开发人员而言，自动内存管理就像是一个黑匣子，如果过度依赖于“自动”，那么这将会是一场灾难，最严重的就会<strong>弱化Java开发人员在程序出现内存溢出时定位问题和解决问题的能力</strong>。</li>
<li>此时，了解JVM的自动内存分配和内存回收原理就显得非常重要，只有在真正了解JVM是如何管理内存后，我们才能够在遇见OutofMemoryError时，快速地根据错误异常日志定位问题和解决问题。</li>
<li>当需要排查各种内存溢出、内存泄漏问题时，当垃圾收集成为系统达到更高并发量的瓶颈时，我们就必须对这些“自动化”的技术<strong>实施必要的监控和调节</strong>。</li>
</ol>
<h2 id="应该关心哪些区域的回收？"><a href="#应该关心哪些区域的回收？" class="headerlink" title="应该关心哪些区域的回收？"></a>应该关心哪些区域的回收？</h2><img src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_010/0003.png">

<ol>
<li><p>垃圾收集器可以对年轻代回收，也可以对老年代回收，甚至是全栈和方法区的回收，</p>
</li>
<li><p>其中，<strong>Java堆是垃圾收集器的工作重点</strong></p>
</li>
<li><p>从次数上讲：</p>
<ul>
<li><strong>频繁收集Young区</strong></li>
<li><strong>较少收集Old区</strong></li>
<li><strong>基本不收集Perm区（元空间）</strong></li>
</ul>
</li>
</ol>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-JVM：StringTable(字符串常量池)"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
	
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/07/23/JVM%EF%BC%9AStringTable(%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0)/"
    >StringTable(字符串常量池)</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/07/23/JVM%EF%BC%9AStringTable(%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0)/" class="article-date">
  <time datetime="2022-07-23T13:47:33.000Z" itemprop="datePublished">2022-07-23</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/JVM/">JVM</a> / <a class="article-category-link" href="/categories/JVM/1-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/">1.内存与垃圾回收篇</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="String的基本特性"><a href="#String的基本特性" class="headerlink" title="String的基本特性"></a>String的基本特性</h1><ul>
<li><p>String：字符串，使用一对 “” 引起来表示</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;atguigu&quot;</span> ;   			<span class="comment">// 字面量的定义方式</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span>  <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>);     <span class="comment">// new 对象的方式</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>String被声明为final的，不可被继承</p>
</li>
<li><p>String实现了Serializable接口：表示字符串是支持序列化的。实现了Comparable接口：表示String可以比较大小</p>
</li>
<li><p>String在jdk8及以前内部定义了<code>final char value[]</code>用于存储字符串数据。JDK9时改为<code>byte[]</code></p>
</li>
</ul>
<h1 id="为什么-JDK9-改变了-String-的结构"><a href="#为什么-JDK9-改变了-String-的结构" class="headerlink" title="为什么 JDK9 改变了 String 的结构"></a>为什么 JDK9 改变了 String 的结构</h1><blockquote>
<p> <strong>官方文档</strong>：<a target="_blank" rel="noopener" href="http://openjdk.java.net/jeps/254">http://openjdk.java.net/jeps/254</a></p>
</blockquote>
<p><strong>为什么改为 byte[] 存储？</strong></p>
<ol>
<li>String类的当前实现将字符存储在char数组中，每个字符使用两个字节(16位)。</li>
<li>从许多不同的应用程序收集的数据表明，字符串是堆使用的主要组成部分，而且大多数字符串对象只包含拉丁字符（Latin-1）。这些字符只需要一个字节的存储空间，因此这些字符串对象的内部char数组中有一半的空间将不会使用，产生了大量浪费。</li>
<li>之前 String 类使用 UTF-16 的 char[] 数组存储，现在改为 <strong>byte[] 数组外加一个编码标识存储</strong>。该编码表示如果你的字符是ISO-8859-1或者Latin-1，那么只需要一个字节存。如果你是其它字符集，比如UTF-8，你仍然用两个字节存</li>
<li>结论：String再也不用char[] 来存储了，改成了byte [] 加上编码标记，节约了一些空间</li>
<li>同时基于String的数据结构，例如StringBuffer和StringBuilder也同样做了修改</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 之前</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span> value[];</span><br><span class="line"><span class="comment">// 之后</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">byte</span>[] value</span><br></pre></td></tr></table></figure>

<h2 id="String-的基本特性"><a href="#String-的基本特性" class="headerlink" title="String 的基本特性"></a>String 的基本特性</h2><ul>
<li><p>String：代表不可变的字符序列。简称：不可变性。</p>
<ol>
<li>当对字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有的value进行赋值。</li>
<li>当对现有的字符串进行连接操作时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。</li>
<li>当调用String的replace()方法修改指定字符或字符串时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。</li>
</ol>
</li>
<li><p>通过字面量的方式（区别于new）给一个字符串赋值，此时的字符串值声明在字符串常量池中。</p>
</li>
</ul>
<p><strong>当对字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有的value进行赋值</strong></p>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;<span class="comment">//字面量定义的方式，&quot;abc&quot;存储在字符串常量池中</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">       s1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">       System.out.println(s1 == s2);<span class="comment">//判断地址：true  --&gt; false</span></span><br><span class="line"></span><br><span class="line">       System.out.println(s1);<span class="comment">//</span></span><br><span class="line">       System.out.println(s2);<span class="comment">//abc</span></span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>字节码指令</p>
<ul>
<li>取字符串 “abc” 时，使用的是同一个符号引用：#2</li>
<li>取字符串 “hello” 时，使用的是另一个符号引用：#3</li>
</ul>
<p><strong>当对现有的字符串进行连接操作时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">       <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">       s2 += <span class="string">&quot;def&quot;</span>;</span><br><span class="line">       System.out.println(s2);<span class="comment">//abcdef</span></span><br><span class="line">       System.out.println(s1);<span class="comment">//abc</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><strong>当调用string的replace()方法修改指定字符或字符串时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> s1.replace(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;m&#x27;</span>);</span><br><span class="line">    System.out.println(s1);<span class="comment">//abc</span></span><br><span class="line">    System.out.println(s2);<span class="comment">//mbc</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>一道笔试题</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringExer</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;good&quot;</span>);</span><br><span class="line">    <span class="type">char</span>[] ch = &#123;<span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;s&#x27;</span>, <span class="string">&#x27;t&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">change</span><span class="params">(String str, <span class="type">char</span> ch[])</span> &#123;</span><br><span class="line">        str = <span class="string">&quot;test ok&quot;</span>;</span><br><span class="line">        ch[<span class="number">0</span>] = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">StringExer</span> <span class="variable">ex</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringExer</span>();</span><br><span class="line">        ex.change(ex.str, ex.ch);</span><br><span class="line">        System.out.println(ex.str);<span class="comment">//good</span></span><br><span class="line">        System.out.println(ex.ch);<span class="comment">//best</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>str 的内容并没有变：“test ok” 位于字符串常量池中的另一个区域（地址），进行赋值操作并没有修改原来 str 指向的引用的内容</p>
<h2 id="String-的底层结构"><a href="#String-的底层结构" class="headerlink" title="String 的底层结构"></a>String 的底层结构</h2><p><strong>字符串常量池是不会存储相同内容的字符串的</strong></p>
<ol>
<li>String的String Pool（字符串常量池）是一个<strong>固定大小的Hashtable</strong>，默认值大小长度是<strong>1009</strong>。如果放进String Pool的String非常多，就会造成Hash冲突严重，从而导致链表会很长，而链表长了后直接会造成的影响就是当调用String.intern()方法时性能会大幅下降。</li>
<li>使用**-XX:StringTablesize**可设置StringTable的长度</li>
<li>在JDK6中StringTable是固定的，就是1009的长度，所以如果常量池中的字符串过多就会导致效率下降很快，StringTablesize设置没有要求</li>
<li>在<strong>JDK7</strong>中，StringTable的长度默认值是<strong>60013</strong>，StringTablesize设置没有要求</li>
<li>在<strong>JDK8</strong>中，StringTable的长度默认值是<strong>60013</strong>，StringTable可以设置的<strong>最小值为1009</strong></li>
</ol>
<img src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_009/0001.png">

<img src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_009/0002.png">

<p><strong>测试不同 StringTable 长度下，程序的性能</strong></p>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 产生10万个长度不超过10的字符串，包含a-z,A-Z</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenerateString</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span>  <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;words.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//1 - 10</span></span><br><span class="line">           <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> (<span class="type">int</span>)(Math.random() * (<span class="number">10</span> - <span class="number">1</span> + <span class="number">1</span>) + <span class="number">1</span>);</span><br><span class="line">            fw.write(getString(length) + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fw.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getString</span><span class="params">(<span class="type">int</span> length)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="comment">//65 - 90, 97-122</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> (<span class="type">int</span>)(Math.random() * (<span class="number">90</span> - <span class="number">65</span> + <span class="number">1</span>) + <span class="number">65</span>) + (<span class="type">int</span>)(Math.random() * <span class="number">2</span>) * <span class="number">32</span>;</span><br><span class="line">            str += (<span class="type">char</span>)num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringTest2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            br = <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;words.txt&quot;</span>));</span><br><span class="line">            <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">            String data;</span><br><span class="line">            <span class="keyword">while</span>((data = br.readLine()) != <span class="literal">null</span>)&#123;</span><br><span class="line">                data.intern(); <span class="comment">//如果字符串常量池中没有对应data的字符串的话，则在常量池中生成</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;花费的时间为：&quot;</span> + (end - start));<span class="comment">//1009:143ms  100009:47ms</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(br != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    br.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>-XX:StringTableSize&#x3D;1009 ：程序耗时 117ms</p>
</li>
<li><p>-XX:StringTableSize&#x3D;100009 ：程序耗时 47ms</p>
</li>
</ul>
<h1 id="String-的内存分配"><a href="#String-的内存分配" class="headerlink" title="String 的内存分配"></a>String 的内存分配</h1><ul>
<li><p>在Java语言中有8种基本数据类型和一种比较特殊的类型String。这些类型为了使它们在运行过程中速度更快、更节省内存，都提供了一种常量池的概念。</p>
</li>
<li><p>常量池就类似一个Java系统级别提供的缓存。8种基本数据类型的常量池都是系统协调的，String类型的常量池比较特殊。它的主要使用方法有两种。</p>
<ul>
<li>直接使用双引号声明出来的String对象会直接存储在常量池中。比如：<code>String info=&quot;atguigu.com&quot;;</code></li>
<li>如果不是用双引号声明的String对象，可以使用String提供的intern()方法。</li>
</ul>
</li>
<li><p>Java 6及以前，字符串常量池存放在永久代</p>
</li>
<li><p>Java 7中 Oracle的工程师对字符串池的逻辑做了很大的改变，即将字符串常量池的位置调整到Java堆内</p>
<ul>
<li>所有的字符串都保存在堆（Heap）中，和其他普通对象一样，这样可以让你在进行调优应用时仅需要调整堆大小就可以了。</li>
<li>字符串常量池概念原本使用得比较多，但是这个改动使得我们有足够的理由让我们重新考虑在Java 7中使用String.intern()。</li>
</ul>
</li>
<li><p>Java8元空间，<strong>字符串常量在堆</strong></p>
</li>
</ul>
<h2 id="StringTable-为什么要调整？"><a href="#StringTable-为什么要调整？" class="headerlink" title="StringTable 为什么要调整？"></a>StringTable 为什么要调整？</h2><blockquote>
<p><strong>官方文档</strong>:<a target="_blank" rel="noopener" href="https://www.oracle.com/java/technologies/javase/jdk7-relnotes.html#jdk7changes">https://www.oracle.com/java/technologies/javase/jdk7-relnotes.html#jdk7changes</a></p>
</blockquote>
<ol>
<li>为什么要调整位置？<ul>
<li>永久代的默认空间大小比较小</li>
<li>永久代垃圾回收频率低，大量的字符串无法及时回收，容易进行Full GC产生STW或者容易产生OOM：PermGen Space</li>
<li>堆中空间足够大，字符串可被及时回收</li>
</ul>
</li>
<li>在JDK 7中，interned字符串不再在Java堆的永久代中分配，而是在Java堆的主要部分（称为年轻代和年老代）中分配，与应用程序创建的其他对象一起分配。</li>
<li>此更改将导致驻留在主Java堆中的数据更多，驻留在永久生成中的数据更少，因此可能需要调整堆大小。</li>
</ol>
<p><strong>代码示例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * jdk6中：</span></span><br><span class="line"><span class="comment"> * -XX:PermSize=6m -XX:MaxPermSize=6m -Xms6m -Xmx6m</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * jdk8中：</span></span><br><span class="line"><span class="comment"> * -XX:MetaspaceSize=6m -XX:MaxMetaspaceSize=6m -Xms6m -Xmx6m</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringTest3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//使用Set保持着常量池引用，避免full gc回收常量池行为</span></span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;String&gt;();</span><br><span class="line">        <span class="comment">//在short可以取值的范围内足以让6MB的PermSize或heap产生OOM了。</span></span><br><span class="line">        <span class="type">short</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            set.add(String.valueOf(i++).intern());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：字符串真的在堆中（JDK8）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">	at java.util.HashMap.resize(HashMap.java:<span class="number">703</span>)</span><br><span class="line">	at java.util.HashMap.putVal(HashMap.java:<span class="number">662</span>)</span><br><span class="line">	at java.util.HashMap.put(HashMap.java:<span class="number">611</span>)</span><br><span class="line">	at java.util.HashSet.add(HashSet.java:<span class="number">219</span>)</span><br><span class="line">	at com.atguigu.java.StringTest3.main(StringTest3.java:<span class="number">22</span>)</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h1 id="String-的基本操作"><a href="#String-的基本操作" class="headerlink" title="String 的基本操作"></a>String 的基本操作</h1><ul>
<li>Java语言规范里要求完全相同的字符串字面量，应该包含同样的Unicode字符序列（包含同一份码点序列的常量），并且必须是指向同一个String类实例。</li>
</ul>
<h2 id="举例1"><a href="#举例1" class="headerlink" title="举例1"></a>举例1</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ysy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringTest4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println();<span class="comment">//2043</span></span><br><span class="line">        System.out.println(<span class="string">&quot;1&quot;</span>);<span class="comment">//2044</span></span><br><span class="line">        System.out.println(<span class="string">&quot;2&quot;</span>);<span class="comment">//2045</span></span><br><span class="line">        System.out.println(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;5&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;6&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;7&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;8&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;9&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;10&quot;</span>);<span class="comment">//2053</span></span><br><span class="line">        <span class="comment">//如下的字符串&quot;1&quot; 到 &quot;10&quot;不会再次加载</span></span><br><span class="line">        System.out.println(<span class="string">&quot;1&quot;</span>);<span class="comment">//2054</span></span><br><span class="line">        System.out.println(<span class="string">&quot;2&quot;</span>);<span class="comment">//2054</span></span><br><span class="line">        System.out.println(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;5&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;6&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;7&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;8&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;9&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;10&quot;</span>);<span class="comment">//2054</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析字符串常量池的变化</p>
<ol>
<li>程序启动时已经加载了 2043 个字符串常量</li>
<li>加载了一个换行符（println），所以多了一个</li>
<li>加载了字符串常量 “1”~“9”</li>
<li>加载字符串常量 “10”</li>
<li>之后的字符串”1” 到 “10”不会再次加载</li>
</ol>
<h2 id="举例2"><a href="#举例2" class="headerlink" title="举例2"></a>举例2</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//官方示例代码</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Memory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;<span class="comment">//line 1</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;<span class="comment">//line 2</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();<span class="comment">//line 3</span></span><br><span class="line">        <span class="type">Memory</span> <span class="variable">mem</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Memory</span>();<span class="comment">//line 4</span></span><br><span class="line">        mem.foo(obj);<span class="comment">//line 5</span></span><br><span class="line">    &#125;<span class="comment">//line 9</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">(Object param)</span> &#123;<span class="comment">//line 6</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> param.toString();<span class="comment">//line 7</span></span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;<span class="comment">//line 8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析运行时内存（foo() 方法是实例方法，其实图中少了一个 this 局部变量）</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220722210408721.png" alt="image-20220722210408721"></p>
<h1 id="字符串拼接操作"><a href="#字符串拼接操作" class="headerlink" title="字符串拼接操作"></a>字符串拼接操作</h1><h2 id="先说结论"><a href="#先说结论" class="headerlink" title="先说结论"></a>先说结论</h2><ol>
<li>常量与常量的拼接结果在常量池，原理是编译期优化</li>
<li>常量池中不会存在相同内容的变量</li>
<li>拼接前后，只要其中有一个是变量，结果就在堆中。变量拼接的原理是<strong>StringBuilder</strong></li>
<li>如果拼接的结果调用intern()方法，根据该字符串是否在常量池中存在，分为：<ul>
<li>如果存在，则返回字符串在常量池中的地址</li>
<li>如果字符串常量池中不存在该字符串，则在常量池中创建一份，并返回此对象的地址</li>
</ul>
</li>
</ol>
<p><strong>1、常量与常量的拼接结果在常量池，原理是编译期优化</strong></p>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span> + <span class="string">&quot;b&quot;</span> + <span class="string">&quot;c&quot;</span>;<span class="comment">//编译期优化：等同于&quot;abc&quot;</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>; <span class="comment">//&quot;abc&quot;一定是放在字符串常量池中，将此地址赋给s2</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 最终.java编译成.class,再执行.class</span></span><br><span class="line"><span class="comment">         * String s1 = &quot;abc&quot;;</span></span><br><span class="line"><span class="comment">         * String s2 = &quot;abc&quot;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    System.out.println(s1 == s2); <span class="comment">//true</span></span><br><span class="line">    System.out.println(s1.equals(s2)); <span class="comment">//true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从字节码指令看出：编译器做了优化，将 “a” + “b” + “c” 优化成了 “abc”</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> ldc #<span class="number">2</span> &lt;abc&gt;</span><br><span class="line"><span class="number">2</span> astore_1</span><br><span class="line"><span class="number">3</span> ldc #<span class="number">2</span> &lt;abc&gt;</span><br><span class="line"><span class="number">5</span> astore_2</span><br><span class="line"><span class="number">6</span> getstatic #<span class="number">3</span> &lt;java/lang/System.out&gt;</span><br><span class="line"><span class="number">9</span> aload_1</span><br><span class="line"><span class="number">10</span> aload_2</span><br><span class="line"><span class="number">11</span> if_acmpne <span class="number">18</span> (+<span class="number">7</span>)</span><br><span class="line"><span class="number">14</span> iconst_1</span><br><span class="line"><span class="number">15</span> goto <span class="number">19</span> (+<span class="number">4</span>)</span><br><span class="line"><span class="number">18</span> iconst_0</span><br><span class="line"><span class="number">19</span> invokevirtual #<span class="number">4</span> &lt;java/io/PrintStream.println&gt;</span><br><span class="line"><span class="number">22</span> getstatic #<span class="number">3</span> &lt;java/lang/System.out&gt;</span><br><span class="line"><span class="number">25</span> aload_1</span><br><span class="line"><span class="number">26</span> aload_2</span><br><span class="line"><span class="number">27</span> invokevirtual #<span class="number">5</span> &lt;java/lang/String.equals&gt;</span><br><span class="line"><span class="number">30</span> invokevirtual #<span class="number">4</span> &lt;java/io/PrintStream.println&gt;</span><br><span class="line"><span class="number">33</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<p>IDEA 反编译 class 文件后，来看这个问题</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220722211552511.png" alt="image-20220722211552511"></p>
<p><strong>2、拼接前后，只要其中有一个是变量，结果就在堆中</strong></p>
<p><strong>调用 intern() 方法，则主动将字符串对象存入字符串常量池中，并将其地址返回</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;javaEE&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;hadoop&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;javaEEhadoop&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">&quot;javaEE&quot;</span> + <span class="string">&quot;hadoop&quot;</span>;<span class="comment">//编译期优化</span></span><br><span class="line">    <span class="comment">//如果拼接符号的前后出现了变量，则相当于在堆空间中new String()，具体的内容为拼接的结果：javaEEhadoop</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> s1 + <span class="string">&quot;hadoop&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s6</span> <span class="operator">=</span> <span class="string">&quot;javaEE&quot;</span> + s2;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s7</span> <span class="operator">=</span> s1 + s2;</span><br><span class="line"></span><br><span class="line">    System.out.println(s3 == s4);<span class="comment">//true</span></span><br><span class="line">    System.out.println(s3 == s5);<span class="comment">//false</span></span><br><span class="line">    System.out.println(s3 == s6);<span class="comment">//false</span></span><br><span class="line">    System.out.println(s3 == s7);<span class="comment">//false</span></span><br><span class="line">    System.out.println(s5 == s6);<span class="comment">//false</span></span><br><span class="line">    System.out.println(s5 == s7);<span class="comment">//false</span></span><br><span class="line">    System.out.println(s6 == s7);<span class="comment">//false</span></span><br><span class="line">    <span class="comment">//intern():判断字符串常量池中是否存在javaEEhadoop值，如果存在，则返回常量池中javaEEhadoop的地址；</span></span><br><span class="line">    <span class="comment">//如果字符串常量池中不存在javaEEhadoop，则在常量池中加载一份javaEEhadoop，并返回次对象的地址。</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">s8</span> <span class="operator">=</span> s6.intern();</span><br><span class="line">    System.out.println(s3 == s8);<span class="comment">//true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从字节码角度来看：拼接前后有变量，都会使用到 StringBuilder 类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> ldc #<span class="number">6</span> &lt;javaEE&gt;</span><br><span class="line"><span class="number">2</span> astore_1</span><br><span class="line"><span class="number">3</span> ldc #<span class="number">7</span> &lt;hadoop&gt;</span><br><span class="line"><span class="number">5</span> astore_2</span><br><span class="line"><span class="number">6</span> ldc #<span class="number">8</span> &lt;javaEEhadoop&gt;</span><br><span class="line"><span class="number">8</span> astore_3</span><br><span class="line"><span class="number">9</span> ldc #<span class="number">8</span> &lt;javaEEhadoop&gt;</span><br><span class="line"><span class="number">11</span> astore <span class="number">4</span></span><br><span class="line"><span class="number">13</span> <span class="keyword">new</span> #<span class="number">9</span> &lt;java/lang/StringBuilder&gt;</span><br><span class="line"><span class="number">16</span> dup</span><br><span class="line"><span class="number">17</span> invokespecial #<span class="number">10</span> &lt;java/lang/StringBuilder.&lt;init&gt;&gt;</span><br><span class="line"><span class="number">20</span> aload_1</span><br><span class="line"><span class="number">21</span> invokevirtual #<span class="number">11</span> &lt;java/lang/StringBuilder.append&gt;</span><br><span class="line"><span class="number">24</span> ldc #<span class="number">7</span> &lt;hadoop&gt;</span><br><span class="line"><span class="number">26</span> invokevirtual #<span class="number">11</span> &lt;java/lang/StringBuilder.append&gt;</span><br><span class="line"><span class="number">29</span> invokevirtual #<span class="number">12</span> &lt;java/lang/StringBuilder.toString&gt;</span><br><span class="line"><span class="number">32</span> astore <span class="number">5</span></span><br><span class="line"><span class="number">34</span> <span class="keyword">new</span> #<span class="number">9</span> &lt;java/lang/StringBuilder&gt;</span><br><span class="line"><span class="number">37</span> dup</span><br><span class="line"><span class="number">38</span> invokespecial #<span class="number">10</span> &lt;java/lang/StringBuilder.&lt;init&gt;&gt;</span><br><span class="line"><span class="number">41</span> ldc #<span class="number">6</span> &lt;javaEE&gt;</span><br><span class="line"><span class="number">43</span> invokevirtual #<span class="number">11</span> &lt;java/lang/StringBuilder.append&gt;</span><br><span class="line"><span class="number">46</span> aload_2</span><br><span class="line"><span class="number">47</span> invokevirtual #<span class="number">11</span> &lt;java/lang/StringBuilder.append&gt;</span><br><span class="line"><span class="number">50</span> invokevirtual #<span class="number">12</span> &lt;java/lang/StringBuilder.toString&gt;</span><br><span class="line"><span class="number">53</span> astore <span class="number">6</span></span><br><span class="line"><span class="number">55</span> <span class="keyword">new</span> #<span class="number">9</span> &lt;java/lang/StringBuilder&gt;</span><br><span class="line"><span class="number">58</span> dup</span><br><span class="line"><span class="number">59</span> invokespecial #<span class="number">10</span> &lt;java/lang/StringBuilder.&lt;init&gt;&gt;</span><br><span class="line"><span class="number">62</span> aload_1</span><br><span class="line"><span class="number">63</span> invokevirtual #<span class="number">11</span> &lt;java/lang/StringBuilder.append&gt;</span><br><span class="line"><span class="number">66</span> aload_2</span><br><span class="line"><span class="number">67</span> invokevirtual #<span class="number">11</span> &lt;java/lang/StringBuilder.append&gt;</span><br><span class="line"><span class="number">70</span> invokevirtual #<span class="number">12</span> &lt;java/lang/StringBuilder.toString&gt;</span><br><span class="line"><span class="number">73</span> astore <span class="number">7</span></span><br><span class="line"><span class="number">75</span> getstatic #<span class="number">3</span> &lt;java/lang/System.out&gt;</span><br><span class="line"><span class="number">78</span> aload_3</span><br><span class="line"><span class="number">79</span> aload <span class="number">4</span></span><br><span class="line"><span class="number">81</span> if_acmpne <span class="number">88</span> (+<span class="number">7</span>)</span><br><span class="line"><span class="number">84</span> iconst_1</span><br><span class="line"><span class="number">85</span> goto <span class="number">89</span> (+<span class="number">4</span>)</span><br><span class="line"><span class="number">88</span> iconst_0</span><br><span class="line"><span class="number">89</span> invokevirtual #<span class="number">4</span> &lt;java/io/PrintStream.println&gt;</span><br><span class="line"><span class="number">92</span> getstatic #<span class="number">3</span> &lt;java/lang/System.out&gt;</span><br><span class="line"><span class="number">95</span> aload_3</span><br><span class="line"><span class="number">96</span> aload <span class="number">5</span></span><br><span class="line"><span class="number">98</span> if_acmpne <span class="number">105</span> (+<span class="number">7</span>)</span><br><span class="line"><span class="number">101</span> iconst_1</span><br><span class="line"><span class="number">102</span> goto <span class="number">106</span> (+<span class="number">4</span>)</span><br><span class="line"><span class="number">105</span> iconst_0</span><br><span class="line"><span class="number">106</span> invokevirtual #<span class="number">4</span> &lt;java/io/PrintStream.println&gt;</span><br><span class="line"><span class="number">109</span> getstatic #<span class="number">3</span> &lt;java/lang/System.out&gt;</span><br><span class="line"><span class="number">112</span> aload_3</span><br><span class="line"><span class="number">113</span> aload <span class="number">6</span></span><br><span class="line"><span class="number">115</span> if_acmpne <span class="number">122</span> (+<span class="number">7</span>)</span><br><span class="line"><span class="number">118</span> iconst_1</span><br><span class="line"><span class="number">119</span> goto <span class="number">123</span> (+<span class="number">4</span>)</span><br><span class="line"><span class="number">122</span> iconst_0</span><br><span class="line"><span class="number">123</span> invokevirtual #<span class="number">4</span> &lt;java/io/PrintStream.println&gt;</span><br><span class="line"><span class="number">126</span> getstatic #<span class="number">3</span> &lt;java/lang/System.out&gt;</span><br><span class="line"><span class="number">129</span> aload_3</span><br><span class="line"><span class="number">130</span> aload <span class="number">7</span></span><br><span class="line"><span class="number">132</span> if_acmpne <span class="number">139</span> (+<span class="number">7</span>)</span><br><span class="line"><span class="number">135</span> iconst_1</span><br><span class="line"><span class="number">136</span> goto <span class="number">140</span> (+<span class="number">4</span>)</span><br><span class="line"><span class="number">139</span> iconst_0</span><br><span class="line"><span class="number">140</span> invokevirtual #<span class="number">4</span> &lt;java/io/PrintStream.println&gt;</span><br><span class="line"><span class="number">143</span> getstatic #<span class="number">3</span> &lt;java/lang/System.out&gt;</span><br><span class="line"><span class="number">146</span> aload <span class="number">5</span></span><br><span class="line"><span class="number">148</span> aload <span class="number">6</span></span><br><span class="line"><span class="number">150</span> if_acmpne <span class="number">157</span> (+<span class="number">7</span>)</span><br><span class="line"><span class="number">153</span> iconst_1</span><br><span class="line"><span class="number">154</span> goto <span class="number">158</span> (+<span class="number">4</span>)</span><br><span class="line"><span class="number">157</span> iconst_0</span><br><span class="line"><span class="number">158</span> invokevirtual #<span class="number">4</span> &lt;java/io/PrintStream.println&gt;</span><br><span class="line"><span class="number">161</span> getstatic #<span class="number">3</span> &lt;java/lang/System.out&gt;</span><br><span class="line"><span class="number">164</span> aload <span class="number">5</span></span><br><span class="line"><span class="number">166</span> aload <span class="number">7</span></span><br><span class="line"><span class="number">168</span> if_acmpne <span class="number">175</span> (+<span class="number">7</span>)</span><br><span class="line"><span class="number">171</span> iconst_1</span><br><span class="line"><span class="number">172</span> goto <span class="number">176</span> (+<span class="number">4</span>)</span><br><span class="line"><span class="number">175</span> iconst_0</span><br><span class="line"><span class="number">176</span> invokevirtual #<span class="number">4</span> &lt;java/io/PrintStream.println&gt;</span><br><span class="line"><span class="number">179</span> getstatic #<span class="number">3</span> &lt;java/lang/System.out&gt;</span><br><span class="line"><span class="number">182</span> aload <span class="number">6</span></span><br><span class="line"><span class="number">184</span> aload <span class="number">7</span></span><br><span class="line"><span class="number">186</span> if_acmpne <span class="number">193</span> (+<span class="number">7</span>)</span><br><span class="line"><span class="number">189</span> iconst_1</span><br><span class="line"><span class="number">190</span> goto <span class="number">194</span> (+<span class="number">4</span>)</span><br><span class="line"><span class="number">193</span> iconst_0</span><br><span class="line"><span class="number">194</span> invokevirtual #<span class="number">4</span> &lt;java/io/PrintStream.println&gt;</span><br><span class="line"><span class="number">197</span> aload <span class="number">6</span></span><br><span class="line"><span class="number">199</span> invokevirtual #<span class="number">13</span> &lt;java/lang/String.intern&gt;</span><br><span class="line"><span class="number">202</span> astore <span class="number">8</span></span><br><span class="line"><span class="number">204</span> getstatic #<span class="number">3</span> &lt;java/lang/System.out&gt;</span><br><span class="line"><span class="number">207</span> aload_3</span><br><span class="line"><span class="number">208</span> aload <span class="number">8</span></span><br><span class="line"><span class="number">210</span> if_acmpne <span class="number">217</span> (+<span class="number">7</span>)</span><br><span class="line"><span class="number">213</span> iconst_1</span><br><span class="line"><span class="number">214</span> goto <span class="number">218</span> (+<span class="number">4</span>)</span><br><span class="line"><span class="number">217</span> iconst_0</span><br><span class="line"><span class="number">218</span> invokevirtual #<span class="number">4</span> &lt;java/io/PrintStream.println&gt;</span><br><span class="line"><span class="number">221</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<h2 id="字符串拼接的底层细节"><a href="#字符串拼接的底层细节" class="headerlink" title="字符串拼接的底层细节"></a>字符串拼接的底层细节</h2><p><strong>举例1</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;b&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        如下的s1 + s2 的执行细节：(变量s是我临时定义的）</span></span><br><span class="line"><span class="comment">        ① StringBuilder s = new StringBuilder();</span></span><br><span class="line"><span class="comment">        ② s.append(&quot;a&quot;)</span></span><br><span class="line"><span class="comment">        ③ s.append(&quot;b&quot;)</span></span><br><span class="line"><span class="comment">        ④ s.toString()  --&gt; 约等于 new String(&quot;ab&quot;)，但不等价</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        补充：在jdk5.0之后使用的是StringBuilder,在jdk5.0之前使用的是StringBuffer</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> s1 + s2;<span class="comment">//</span></span><br><span class="line">    System.out.println(s3 == s4);<span class="comment">//false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>字节码指令</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> ldc #<span class="number">14</span> &lt;a&gt;</span><br><span class="line"><span class="number">2</span> astore_1</span><br><span class="line"><span class="number">3</span> ldc #<span class="number">15</span> &lt;b&gt;</span><br><span class="line"><span class="number">5</span> astore_2</span><br><span class="line"><span class="number">6</span> ldc #<span class="number">16</span> &lt;ab&gt;</span><br><span class="line"><span class="number">8</span> astore_3</span><br><span class="line"><span class="number">9</span> <span class="keyword">new</span> #<span class="number">9</span> &lt;java/lang/StringBuilder&gt;</span><br><span class="line"><span class="number">12</span> dup</span><br><span class="line"><span class="number">13</span> invokespecial #<span class="number">10</span> &lt;java/lang/StringBuilder.&lt;init&gt;&gt;</span><br><span class="line"><span class="number">16</span> aload_1</span><br><span class="line"><span class="number">17</span> invokevirtual #<span class="number">11</span> &lt;java/lang/StringBuilder.append&gt;</span><br><span class="line"><span class="number">20</span> aload_2</span><br><span class="line"><span class="number">21</span> invokevirtual #<span class="number">11</span> &lt;java/lang/StringBuilder.append&gt;</span><br><span class="line"><span class="number">24</span> invokevirtual #<span class="number">12</span> &lt;java/lang/StringBuilder.toString&gt;</span><br><span class="line"><span class="number">27</span> astore <span class="number">4</span></span><br><span class="line"><span class="number">29</span> getstatic #<span class="number">3</span> &lt;java/lang/System.out&gt;</span><br><span class="line"><span class="number">32</span> aload_3</span><br><span class="line"><span class="number">33</span> aload <span class="number">4</span></span><br><span class="line"><span class="number">35</span> if_acmpne <span class="number">42</span> (+<span class="number">7</span>)</span><br><span class="line"><span class="number">38</span> iconst_1</span><br><span class="line"><span class="number">39</span> goto <span class="number">43</span> (+<span class="number">4</span>)</span><br><span class="line"><span class="number">42</span> iconst_0</span><br><span class="line"><span class="number">43</span> invokevirtual #<span class="number">4</span> &lt;java/io/PrintStream.println&gt;</span><br><span class="line"><span class="number">46</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<p><strong>举例2</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    1. 字符串拼接操作不一定使用的是StringBuilder!</span></span><br><span class="line"><span class="comment">       如果拼接符号左右两边都是字符串常量或常量引用，则仍然使用编译期优化，即非StringBuilder的方式。</span></span><br><span class="line"><span class="comment">    2. 针对于final修饰类、方法、基本数据类型、引用数据类型的量的结构时，能使用上final的时候建议使用上。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;b&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> s1 + s2;</span><br><span class="line">    System.out.println(s3 == s4);<span class="comment">//true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从字节码角度来看：为变量 s4 赋值时，直接使用 #16 符号引用，即字符串常量 “ab”</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> ldc #<span class="number">14</span> &lt;a&gt;</span><br><span class="line"><span class="number">2</span> astore_1</span><br><span class="line"><span class="number">3</span> ldc #<span class="number">15</span> &lt;b&gt;</span><br><span class="line"><span class="number">5</span> astore_2</span><br><span class="line"><span class="number">6</span> ldc #<span class="number">16</span> &lt;ab&gt;</span><br><span class="line"><span class="number">8</span> astore_3</span><br><span class="line"><span class="number">9</span> ldc #<span class="number">16</span> &lt;ab&gt;</span><br><span class="line"><span class="number">11</span> astore <span class="number">4</span></span><br><span class="line"><span class="number">13</span> getstatic #<span class="number">3</span> &lt;java/lang/System.out&gt;</span><br><span class="line"><span class="number">16</span> aload_3</span><br><span class="line"><span class="number">17</span> aload <span class="number">4</span></span><br><span class="line"><span class="number">19</span> if_acmpne <span class="number">26</span> (+<span class="number">7</span>)</span><br><span class="line"><span class="number">22</span> iconst_1</span><br><span class="line"><span class="number">23</span> goto <span class="number">27</span> (+<span class="number">4</span>)</span><br><span class="line"><span class="number">26</span> iconst_0</span><br><span class="line"><span class="number">27</span> invokevirtual #<span class="number">4</span> &lt;java/io/PrintStream.println&gt;</span><br><span class="line"><span class="number">30</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<p><strong>拼接操作与 append 操作的效率对比</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test6</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//        method1(100000);//4014</span></span><br><span class="line">    method2(<span class="number">100000</span>);<span class="comment">//7</span></span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;花费的时间为：&quot;</span> + (end - start));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">(<span class="type">int</span> highLevel)</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">src</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; highLevel;i++)&#123;</span><br><span class="line">        src = src + <span class="string">&quot;a&quot;</span>;<span class="comment">//每次循环都会创建一个StringBuilder、String</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//        System.out.println(src);</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">(<span class="type">int</span> highLevel)</span>&#123;</span><br><span class="line">    <span class="comment">//只需要创建一个StringBuilder</span></span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">src</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; highLevel; i++) &#123;</span><br><span class="line">        src.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//        System.out.println(src);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>体会执行效率：通过StringBuilder的append()的方式添加字符串的效率要远高于使用String的字符串拼接方式！</p>
</li>
<li><p>原因：</p>
<ol>
<li>StringBuilder的append()的方式：<ul>
<li>自始至终中只创建过一个StringBuilder的对象</li>
</ul>
</li>
<li>使用String的字符串拼接方式：<ul>
<li>创建过多个StringBuilder和String（调的toString方法）的对象，内存占用更大；</li>
<li>如果进行GC，需要花费额外的时间（在拼接的过程中产生的一些中间字符串可能永远也用不到，会产生大量垃圾字符串）。</li>
</ul>
</li>
</ol>
</li>
<li><p>改进的空间：</p>
<ul>
<li>在实际开发中，如果基本确定要前前后后添加的字符串长度不高于某个限定值highLevel的情况下，建议使用构造器实例化：</li>
<li><code>StringBuilder s = new StringBuilder(highLevel); //new char[highLevel]</code></li>
<li>这样可以避免频繁扩容</li>
</ul>
</li>
</ol>
<h1 id="intern-的使用"><a href="#intern-的使用" class="headerlink" title="intern() 的使用"></a>intern() 的使用</h1><h2 id="intern-方法的说明"><a href="#intern-方法的说明" class="headerlink" title="intern() 方法的说明"></a>intern() 方法的说明</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> String <span class="title function_">intern</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>intern是一个native方法，调用的是底层C的方法</p>
</li>
<li><p>字符串常量池最初是空的，由String类私有地维护。在调用intern方法时，如果池中已经包含了由**equals(object)**方法确定的与该字符串内容相等的字符串，则返回池中的字符串地址。否则，该字符串对象将被添加到池中，并返回对该字符串对象的地址。（这是源码里的大概翻译）</p>
</li>
<li><p>如果不是用双引号声明的String对象，可以使用String提供的intern方法：intern方法会从字符串常量池中查询当前字符串是否存在，若不存在就会将当前字符串放入常量池中。比如：</p>
<pre><code>String myInfo = new string(&quot;I love atguigu&quot;).intern();
</code></pre>
</li>
<li><p>也就是说，如果在任意字符串上调用String.intern方法，那么其返回结果所指向的那个类实例，必须和直接以常量形式出现的字符串实例完全相同。因此，下列表达式的值必定是true</p>
<pre><code>(&quot;a&quot;+&quot;b&quot;+&quot;c&quot;).intern()==&quot;abc&quot;
</code></pre>
</li>
<li><p>通俗点讲，Interned String就是确保字符串在内存里只有一份拷贝，这样可以节约内存空间，加快字符串操作任务的执行速度。注意，这个值会被存放在字符串内部池（String Intern Pool）</p>
</li>
</ol>
<h2 id="new-String-的说明"><a href="#new-String-的说明" class="headerlink" title="new String() 的说明"></a>new String() 的说明</h2><h3 id="new-String-“ab”-会创建几个对象？"><a href="#new-String-“ab”-会创建几个对象？" class="headerlink" title="new String(“ab”)会创建几个对象？"></a>new String(“ab”)会创建几个对象？</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 题目：</span></span><br><span class="line"><span class="comment"> * new String(&quot;ab&quot;)会创建几个对象？看字节码，就知道是两个。</span></span><br><span class="line"><span class="comment"> *     一个对象是：new关键字在堆空间创建的</span></span><br><span class="line"><span class="comment"> *     另一个对象是：字符串常量池中的对象&quot;ab&quot;。 字节码指令：ldc</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringNewTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;ab&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>字节码指令</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> <span class="keyword">new</span> #<span class="number">2</span> &lt;java/lang/String&gt;</span><br><span class="line"><span class="number">3</span> dup</span><br><span class="line"><span class="number">4</span> ldc #<span class="number">3</span> &lt;ab&gt;</span><br><span class="line"><span class="number">6</span> invokespecial #<span class="number">4</span> &lt;java/lang/String.&lt;init&gt;&gt;</span><br><span class="line"><span class="number">9</span> astore_1</span><br><span class="line"><span class="number">10</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<p><code>0 new #2 &lt;java/lang/String&gt;</code>：在堆中创建了一个 String 对象</p>
<p><code>4 ldc #3 &lt;ab&gt;</code> ：在字符串常量池中放入 “ab”（如果之前字符串常量池中没有 “ab” 的话）</p>
<h3 id="new-String-“a”-new-String-“b”-会创建几个对象？"><a href="#new-String-“a”-new-String-“b”-会创建几个对象？" class="headerlink" title="new String(“a”) + new String(“b”) 会创建几个对象？"></a>new String(“a”) + new String(“b”) 会创建几个对象？</h3><p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 思考：</span></span><br><span class="line"><span class="comment"> * new String(&quot;a&quot;) + new String(&quot;b&quot;)呢？</span></span><br><span class="line"><span class="comment"> *  对象1：new StringBuilder()</span></span><br><span class="line"><span class="comment"> *  对象2： new String(&quot;a&quot;)</span></span><br><span class="line"><span class="comment"> *  对象3： 常量池中的&quot;a&quot;</span></span><br><span class="line"><span class="comment"> *  对象4： new String(&quot;b&quot;)</span></span><br><span class="line"><span class="comment"> *  对象5： 常量池中的&quot;b&quot;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  深入剖析： StringBuilder的toString():</span></span><br><span class="line"><span class="comment"> *      对象6 ：new String(&quot;ab&quot;)</span></span><br><span class="line"><span class="comment"> *       强调一下，toString()的调用，在字符串常量池中，没有生成&quot;ab&quot;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringNewTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>字节码指令</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> <span class="keyword">new</span> #<span class="number">2</span> &lt;java/lang/StringBuilder&gt;</span><br><span class="line"><span class="number">3</span> dup</span><br><span class="line"><span class="number">4</span> invokespecial #<span class="number">3</span> &lt;java/lang/StringBuilder.&lt;init&gt;&gt;</span><br><span class="line"><span class="number">7</span> <span class="keyword">new</span> #<span class="number">4</span> &lt;java/lang/String&gt;</span><br><span class="line"><span class="number">10</span> dup</span><br><span class="line"><span class="number">11</span> ldc #<span class="number">5</span> &lt;a&gt;</span><br><span class="line"><span class="number">13</span> invokespecial #<span class="number">6</span> &lt;java/lang/String.&lt;init&gt;&gt;</span><br><span class="line"><span class="number">16</span> invokevirtual #<span class="number">7</span> &lt;java/lang/StringBuilder.append&gt;</span><br><span class="line"><span class="number">19</span> <span class="keyword">new</span> #<span class="number">4</span> &lt;java/lang/String&gt;</span><br><span class="line"><span class="number">22</span> dup</span><br><span class="line"><span class="number">23</span> ldc #<span class="number">8</span> &lt;b&gt;</span><br><span class="line"><span class="number">25</span> invokespecial #<span class="number">6</span> &lt;java/lang/String.&lt;init&gt;&gt;</span><br><span class="line"><span class="number">28</span> invokevirtual #<span class="number">7</span> &lt;java/lang/StringBuilder.append&gt;</span><br><span class="line"><span class="number">31</span> invokevirtual #<span class="number">9</span> &lt;java/lang/StringBuilder.toString&gt;</span><br><span class="line"><span class="number">34</span> astore_1</span><br><span class="line"><span class="number">35</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<p><strong>答案是4个或5个或6个</strong></p>
<p>字节码指令分析：</p>
<ol>
<li><code>0 new #2 &lt;java/lang/StringBuilder&gt;</code> ：拼接字符串会创建一个 StringBuilder 对象</li>
<li><code>7 new #4 &lt;java/lang/String&gt;</code> ：创建 String 对象，对应于 new String(“a”)</li>
<li><code>11 ldc #5 &lt;a&gt;</code> ：在字符串常量池中放入 “a”（如果之前字符串常量池中没有 “a” 的话）</li>
<li><code>19 new #4 &lt;java/lang/String&gt;</code> ：创建 String 对象，对应于 new String(“b”)</li>
<li><code>23 ldc #8 &lt;b&gt;</code> ：在字符串常量池中放入 “b”（如果之前字符串常量池中没有 “b” 的话）</li>
<li><code>31 invokevirtual #9 &lt;java/lang/StringBuilder.toString&gt;</code> ：调用 StringBuilder 的 toString() 方法，会生成一个 String 对象</li>
</ol>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220723102523806.png" alt="image-20220723102523806"></p>
<h2 id="有点难的面试题"><a href="#有点难的面试题" class="headerlink" title="有点难的面试题"></a>有点难的面试题</h2><blockquote>
<p><strong>有点难的面试题</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">**</span><br><span class="line"> * 如何保证变量s指向的是字符串常量池中的数据呢？</span><br><span class="line"> * 有两种方式：</span><br><span class="line"> * 方式一： <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;shkstart&quot;</span>;<span class="comment">//字面量定义的方式</span></span><br><span class="line"> * 方式二： 调用intern()</span><br><span class="line"> *         <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;shkstart&quot;</span>).intern();</span><br><span class="line"> *         <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;shkstart&quot;</span>).toString().intern();</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> 	<span class="title class_">StringIntern</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        s.intern();<span class="comment">//调用此方法之前，字符串常量池中已经存在了&quot;1&quot;</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;1&quot;</span>;</span><br><span class="line">        System.out.println(s == s2);<span class="comment">//jdk6：false   jdk7/8：false</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         1、s3变量记录的地址为：new String(&quot;11&quot;)</span></span><br><span class="line"><span class="comment">         2、经过上面的分析，我们已经知道执行完pos_1的代码，在堆中有了一个new String(&quot;11&quot;)</span></span><br><span class="line"><span class="comment">         这样的String对象。但是在字符串常量池中没有&quot;11&quot;</span></span><br><span class="line"><span class="comment">         3、接着执行s3.intern()，在字符串常量池中生成&quot;11&quot;</span></span><br><span class="line"><span class="comment">           3-1、在JDK6的版本中，字符串常量池还在永久代，所以直接在永久代生成&quot;11&quot;,也就有了新的地址</span></span><br><span class="line"><span class="comment">           3-2、而在JDK7的后续版本中，字符串常量池被移动到了堆中，此时堆里已经有new String（&quot;11&quot;）了</span></span><br><span class="line"><span class="comment">           出于节省空间的目的，直接将堆中的那个字符串的引用地址储存在字符串常量池中。没错，字符串常量池</span></span><br><span class="line"><span class="comment">           中存的是new String（&quot;11&quot;）在堆中的地址</span></span><br><span class="line"><span class="comment">         4、所以在JDK7后续版本中，s3和s4指向的完全是同一个地址。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;1&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;1&quot;</span>);<span class="comment">//pos_1</span></span><br><span class="line">	    s3.intern();</span><br><span class="line">        </span><br><span class="line">        <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">&quot;11&quot;</span>;<span class="comment">//s4变量记录的地址：使用的是上一行代码代码执行时，在常量池中生成的&quot;11&quot;的地址</span></span><br><span class="line">        System.out.println(s3 == s4);<span class="comment">//jdk6：false  jdk7/8：true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解释的已经比较清楚了，下面看一下内存图</p>
<p><strong>内存分析</strong></p>
<p>JDK6 ：正常眼光判断即可</p>
<ul>
<li>new String() 即在堆中</li>
<li>str.intern() 则把字符串放入常量池中</li>
</ul>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220723104223818.png" alt="image-20220723104223818"></p>
<p>JDK7及后续版本，<strong>注意大坑</strong></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220723104044519.png" alt="image-20220723104044519"></p>
<h3 id="面试题的拓展"><a href="#面试题的拓展" class="headerlink" title="面试题的拓展"></a>面试题的拓展</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * StringIntern.java中练习的拓展：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringIntern1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//执行完下一行代码以后，字符串常量池中，是否存在&quot;11&quot;呢？答案：不存在！！</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;1&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;1&quot;</span>);<span class="comment">//new String(&quot;11&quot;)</span></span><br><span class="line">        <span class="comment">//在字符串常量池中生成对象&quot;11&quot;，代码顺序换一下，实打实的在字符串常量池里有一个&quot;11&quot;对象</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">&quot;11&quot;</span>;  </span><br><span class="line">        <span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> s3.intern();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// s3 是堆中的 &quot;ab&quot; ，s4 是字符串常量池中的 &quot;ab&quot;</span></span><br><span class="line">        System.out.println(s3 == s4);<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// s5 是从字符串常量池中取回来的引用，当然和 s4 相等</span></span><br><span class="line">        System.out.println(s5 == s4);<span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结string的intern-的使用"><a href="#总结string的intern-的使用" class="headerlink" title="总结string的intern ( )的使用"></a>总结string的intern ( )的使用</h2><ul>
<li><p><strong>jdk1.6</strong>中，将这个字符串对象尝试放入串池。</p>
<ul>
<li>如果串池中有，则并不会放入。返回已有的串池中的对象的地址</li>
<li>如果没有，会把此对象复制一份，放入串池，并返回串池中的对象地址</li>
</ul>
</li>
<li><p><strong>Jdk1.7</strong>起，将这个字符串对象尝试放入串池。</p>
<ul>
<li>如果串池中有，则并不会放入。返回已有的串池中的对象的地址</li>
<li>如果没有则会把对象的引用地址复制一份，放入串池，并返回串池中的引用地址</li>
</ul>
</li>
</ul>
<h2 id="intern-方法的练习"><a href="#intern-方法的练习" class="headerlink" title="intern() 方法的练习"></a>intern() 方法的练习</h2><p><strong>练习 1</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringExer1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">x</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;b&quot;</span>);<span class="comment">//new String(&quot;ab&quot;)</span></span><br><span class="line">        <span class="comment">//在上一行代码执行完以后，字符串常量池中并没有&quot;ab&quot;</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		1、jdk6中：在字符串常量池（此时在永久代）中创建一个字符串&quot;ab&quot;</span></span><br><span class="line"><span class="comment">        2、jdk8中：字符串常量池（此时在堆中）中没有创建字符串&quot;ab&quot;,而是创建一个引用，指向new String(&quot;ab&quot;)，将此引用返回</span></span><br><span class="line"><span class="comment">        3、详解看上面</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> s.intern();</span><br><span class="line"></span><br><span class="line">        System.out.println(s2 == <span class="string">&quot;ab&quot;</span>);<span class="comment">//jdk6:true  jdk8:true</span></span><br><span class="line">        System.out.println(s == <span class="string">&quot;ab&quot;</span>);<span class="comment">//jdk6:false  jdk8:true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>JDK6</strong></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220723105458316.png" alt="image-20220723105458316"></p>
<p><strong>JDK7&#x2F;8</strong></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220723105738120.png" alt="image-20220723105738120"></p>
<p><strong>练习2</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringExer1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//加一行这个</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">x</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;b&quot;</span>);<span class="comment">//new String(&quot;ab&quot;)</span></span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> s.intern();</span><br><span class="line"></span><br><span class="line">        System.out.println(s2 == <span class="string">&quot;ab&quot;</span>);<span class="comment">//jdk6:true  jdk8:true</span></span><br><span class="line">        System.out.println(s == <span class="string">&quot;ab&quot;</span>);<span class="comment">//jdk6:false  jdk8:false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220723105951989.png" alt="image-20220723105951989"></p>
<p><strong>练习3</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringExer2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;ab&quot;</span>);<span class="comment">//执行完以后，会在字符串常量池中会生成&quot;ab&quot;</span></span><br><span class="line"></span><br><span class="line">        s1.intern();</span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">        System.out.println(s1 == s2);<span class="comment">//false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>验证</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringExer2</span> &#123;</span><br><span class="line">    <span class="comment">// 对象内存地址可以使用System.identityHashCode(object)方法获取</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;b&quot;</span>);<span class="comment">//执行完以后，不会在字符串常量池中会生成&quot;ab&quot;</span></span><br><span class="line">        System.out.println(System.identityHashCode(s1));</span><br><span class="line">        s1.intern();</span><br><span class="line">        System.out.println(System.identityHashCode(s1));</span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">        System.out.println(System.identityHashCode(s2));</span><br><span class="line">        System.out.println(s1 == s2); <span class="comment">// true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1836019240</span></span><br><span class="line"><span class="number">1836019240</span></span><br><span class="line"><span class="number">1836019240</span></span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h2 id="intern-的效率测试（空间角度）"><a href="#intern-的效率测试（空间角度）" class="headerlink" title="intern() 的效率测试（空间角度）"></a>intern() 的效率测试（空间角度）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用intern()测试执行效率：空间使用上</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 结论：对于程序中大量存在存在的字符串，尤其其中存在很多重复字符串时，使用intern()可以节省内存空间。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringIntern2</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_COUNT</span> <span class="operator">=</span> <span class="number">1000</span> * <span class="number">10000</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String[] arr = <span class="keyword">new</span> <span class="title class_">String</span>[MAX_COUNT];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Integer[] data = <span class="keyword">new</span> <span class="title class_">Integer</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; MAX_COUNT; i++) &#123;</span><br><span class="line"><span class="comment">//            arr[i] = new String(String.valueOf(data[i % data.length]));</span></span><br><span class="line">            arr[i] = <span class="keyword">new</span> <span class="title class_">String</span>(String.valueOf(data[i % data.length])).intern();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;花费的时间为：&quot;</span> + (end - start));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1、直接 new String ：由于每个 String 对象都是 new 出来的，所以程序需要维护大量存放在堆空间中的 String 实例，程序内存占用也会变高</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr[i] = <span class="keyword">new</span> <span class="title class_">String</span>(String.valueOf(data[i % data.length]));</span><br></pre></td></tr></table></figure>

<p>2、使用 intern() 方法：由于数组中字符串的引用都指向字符串常量池中的字符串，所以程序需要维护的 String 对象更少，内存占用也更低</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用了intern()方法使用了字符串常量池里的字符串，那么前面堆里的字符串便会被GC掉，这也是intern省内存的关键原因</span></span><br><span class="line">arr[i] = <span class="keyword">new</span> <span class="title class_">String</span>(String.valueOf(data[i % data.length])).intern();</span><br></pre></td></tr></table></figure>

<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220723212446075.png" alt="image-20220723212446075"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220723212724015.png" alt="image-20220723212724015"></p>
<p><strong>结论</strong>：</p>
<ol>
<li>对于程序中大量使用存在的字符串时，尤其存在很多已经重复的字符串时，使用intern()方法能够节省很大的内存空间。</li>
<li>大的网站平台，需要内存中存储大量的字符串。比如社交网站，很多人都存储：北京市、海淀区等信息。这时候如果字符串都调用intern() 方法，就会很明显降低内存的大小。</li>
</ol>
<h1 id="StringTable-的垃圾回收"><a href="#StringTable-的垃圾回收" class="headerlink" title="StringTable 的垃圾回收"></a>StringTable 的垃圾回收</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * String的垃圾回收:</span></span><br><span class="line"><span class="comment"> * -Xms15m -Xmx15m -XX:+PrintStringTableStatistics -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringGCTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">100000</span>; j++) &#123;</span><br><span class="line">            String.valueOf(j).intern();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<ul>
<li>在 PSYoungGen 区发生了垃圾回收</li>
<li>Number of entries 和 Number of literals 明显没有 100000</li>
<li>以上两点均说明 StringTable 区发生了垃圾回收</li>
</ul>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220723213540756.png" alt="image-20220723213540756"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220723213510885.png" alt="image-20220723213510885"></p>
<h1 id="G1-中的-String-去重操作"><a href="#G1-中的-String-去重操作" class="headerlink" title="G1 中的 String 去重操作"></a>G1 中的 String 去重操作</h1><blockquote>
<p><strong>官方文档</strong>：<a target="_blank" rel="noopener" href="http://openjdk.java.net/jeps/192">http://openjdk.java.net/jeps/192</a></p>
</blockquote>
<p><strong>String去重操作的背景</strong></p>
<blockquote>
<p>注意不是字符串常量池的去重操作，字符串常量池本身就没有重复的</p>
</blockquote>
<ol>
<li>背景：对许多Java应用（有大的也有小的）做的测试得出以下结果：<ul>
<li>堆存活数据集合里面String对象占了25%</li>
<li>堆存活数据集合里面重复的String对象有13.5%</li>
<li>String对象的平均长度是45</li>
</ul>
</li>
<li>许多大规模的Java应用的瓶颈在于内存，测试表明，在这些类型的应用里面，Java堆中存活的数据集合差不多25%是String对象。更进一步，这里面差不多一半String对象是重复的，重复的意思是说：<code>str1.equals(str2)= true</code>。堆上存在重复的String对象必然是一种内存的浪费。这个项目将在G1垃圾收集器中实现自动持续对重复的String对象进行去重，这样就能避免浪费内存。</li>
</ol>
<p><strong>String 去重的的实现</strong></p>
<ol>
<li>当垃圾收集器工作的时候，会访问堆上存活的对象。对每一个访问的对象都会检查是否是候选的要去重的String对象。</li>
<li>如果是，把这个对象的一个引用插入到队列中等待后续的处理。一个去重的线程在后台运行，处理这个队列。处理队列的一个元素意味着从队列删除这个元素，然后尝试去重它引用的String对象。</li>
<li>使用一个Hashtable来记录所有的被String对象使用的不重复的char数组。当去重的时候，会查这个Hashtable，来看堆上是否已经存在一个一模一样的char数组。</li>
<li>如果存在，String对象会被调整引用那个数组，释放对原来的数组的引用，最终会被垃圾收集器回收掉。</li>
<li>如果查找失败，char数组会被插入到Hashtable，这样以后的时候就可以共享这个数组了。</li>
</ol>
<p><strong>命令行选项</strong></p>
<ol>
<li><strong>UseStringDeduplication(bool)</strong> ：开启String去重，默认是不开启的，需要手动开启。</li>
<li><strong>PrintStringDeduplicationStatistics(bool)</strong> ：打印详细的去重统计信息</li>
<li><strong>stringDeduplicationAgeThreshold(uintx)</strong> ：达到这个年龄的String对象被认为是去重的候选对象</li>
</ol>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-数据结构与算法：递归"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
	
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/07/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%9A%E9%80%92%E5%BD%92/"
    >递归</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/07/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%9A%E9%80%92%E5%BD%92/" class="article-date">
  <time datetime="2022-07-21T12:06:22.000Z" itemprop="datePublished">2022-07-21</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a> / <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%80%92%E5%BD%92/">递归</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h1><ul>
<li>简单的说:递归就是<strong>方法自己调用自己</strong>,每次调用时传入不同的变量.递归有助于编程者解决复杂的问题,同时可以让代码变得简洁。</li>
</ul>
<h1 id="递归调用机制"><a href="#递归调用机制" class="headerlink" title="递归调用机制"></a>递归调用机制</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ysy.recursion;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RecursionTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        test(<span class="number">5</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> factorial(<span class="number">5</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;5! = &quot;</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印问题</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &gt; <span class="number">2</span>)&#123;</span><br><span class="line">            test(n - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;n=&quot;</span>+n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//阶乘</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">factorial</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> factorial(n - <span class="number">1</span>) * n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>调用规则</strong></p>
<ol>
<li>当程序执行到一个方法时,就会开辟一个独立的空间(栈)</li>
<li>每个空间的数据(局部变量)，是独立的.</li>
</ol>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220721202744711.png" alt="image-20220721202744711"></p>
<h1 id="递归能解决什么样的问题"><a href="#递归能解决什么样的问题" class="headerlink" title="递归能解决什么样的问题"></a>递归能解决什么样的问题</h1><ol>
<li>各种数学问题如: 8皇后问题、汉诺塔、阶乘问题、迷宫问题、球和篮子的问题(google编程大赛)</li>
<li>各种算法中也会使用到递归，比如快排、归并排序、二分查找、分治算法等.</li>
<li>将用栈解决的问题–&gt;第归代码比较简洁</li>
</ol>
<h1 id="递归需要遵守的重要规则"><a href="#递归需要遵守的重要规则" class="headerlink" title="递归需要遵守的重要规则"></a>递归需要遵守的重要规则</h1><ul>
<li>执行一个方法时，就创建一个新的受保护的独立空间(栈空间)</li>
<li>方法的局部变量是独立的，不会相互影响，比如n变量</li>
<li>如果方法中使用的是引用类型变量(比如数组)，就会共享该引用类型的数据.</li>
<li>递归必须<strong>向退出递归的条件逼近</strong>，否则就是无限递归,出现StackOverflowError，死循环了:)</li>
<li>当一个方法执行完毕，或者遇到 return，就会返回，<strong>遵守谁调用，就将结果返回给谁</strong>，同时当方法执行完毕或者返回时，该方法也就执行完毕</li>
</ul>
<h1 id="迷宫问题"><a href="#迷宫问题" class="headerlink" title="迷宫问题"></a>迷宫问题</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ysy.recursion;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MiGong</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建一个二维数组，模拟迷宫</span></span><br><span class="line">        <span class="comment">//地图</span></span><br><span class="line">        <span class="type">int</span>[][] map = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">8</span>][<span class="number">7</span>];</span><br><span class="line">        <span class="comment">//使用1表示墙</span></span><br><span class="line">        <span class="comment">//上下全部置为1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">7</span>; i++)&#123;</span><br><span class="line">            map[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">            map[<span class="number">7</span>][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//左右全部置为1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)&#123;</span><br><span class="line">            map[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            map[i][<span class="number">6</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//设置挡板，1表示</span></span><br><span class="line">        map[<span class="number">3</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        map[<span class="number">3</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出地图</span></span><br><span class="line">        System.out.println(<span class="string">&quot;地图的情况~&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">7</span>; j++) &#123;</span><br><span class="line">                System.out.print(map[i][j] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用递归回溯给小球找路</span></span><br><span class="line"><span class="comment">//        setWay(map, 1, 1);</span></span><br><span class="line">        setWay2(map, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出新的地图，小球走过，并标识的地图</span></span><br><span class="line">        System.out.println(<span class="string">&quot;小球走过，并标识地图的情况~&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">7</span>; j++) &#123;</span><br><span class="line">                System.out.print(map[i][j] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用递归回溯来给小球找路</span></span><br><span class="line">    <span class="comment">//说明</span></span><br><span class="line">    <span class="comment">//1.map表示地图</span></span><br><span class="line">    <span class="comment">//2.i,j表示从哪个位置开始找(1,1)</span></span><br><span class="line">    <span class="comment">//3.如果小球能到map[6][5]位置，则说明通路找到</span></span><br><span class="line">    <span class="comment">//4.约定：当map[i][j]=0表示该点没有走过，为1时表示不能走，为2时表示通路可以走，为3时表示该点已经走过，但是走不通</span></span><br><span class="line">    <span class="comment">//5.在走迷宫之前，需要确定一个策略：下--&gt;右--&gt;上--&gt;左，如果该点走不通，再回溯</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> map 表示地图</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i 从哪个位置开始找</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> j</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果找到通路，就返回true，否则返回false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">setWay</span><span class="params">(<span class="type">int</span>[][] map, <span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(map[<span class="number">6</span>][<span class="number">5</span>] == <span class="number">2</span>)&#123;<span class="comment">//通路找到</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(map[i][j] == <span class="number">0</span>)&#123;<span class="comment">//当前点未走过</span></span><br><span class="line">                <span class="comment">//按照策略下--&gt;右--&gt;上--&gt;左</span></span><br><span class="line">                map[i][j] = <span class="number">2</span>;<span class="comment">//假定该点可以走通</span></span><br><span class="line">                <span class="keyword">if</span>(setWay(map, i+<span class="number">1</span>, j))&#123;<span class="comment">//向下走</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(setWay(map, i, j+<span class="number">1</span>))&#123;<span class="comment">//向右走</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span>(setWay(map, i-<span class="number">1</span>, j))&#123;<span class="comment">//向上走</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(setWay(map, i, j-<span class="number">1</span>))&#123;<span class="comment">//向左走</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//说明该点是走不通的，是死路</span></span><br><span class="line">                    map[i][j] = <span class="number">3</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//如果map[i][j]!=0，可能是1，2，3</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//更改策略</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">setWay2</span><span class="params">(<span class="type">int</span>[][] map, <span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(map[<span class="number">6</span>][<span class="number">5</span>] == <span class="number">2</span>)&#123;<span class="comment">//通路找到</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(map[i][j] == <span class="number">0</span>)&#123;<span class="comment">//当前点未走过</span></span><br><span class="line">                <span class="comment">//按照策略上--&gt;右--&gt;下--&gt;左</span></span><br><span class="line">                map[i][j] = <span class="number">2</span>;<span class="comment">//假定该点可以走通</span></span><br><span class="line">                <span class="keyword">if</span>(setWay2(map, i-<span class="number">1</span>, j))&#123;<span class="comment">//向上走</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(setWay2(map, i, j+<span class="number">1</span>))&#123;<span class="comment">//向右走</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span>(setWay2(map, i+<span class="number">1</span>, j))&#123;<span class="comment">//向下走</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(setWay2(map, i, j-<span class="number">1</span>))&#123;<span class="comment">//向左走</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//说明该点是走不通的，是死路</span></span><br><span class="line">                    map[i][j] = <span class="number">3</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//如果map[i][j]!=0，可能是1，2，3</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="八皇后问题-回溯算法"><a href="#八皇后问题-回溯算法" class="headerlink" title="八皇后问题(回溯算法)"></a>八皇后问题(回溯算法)</h1> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-JVM：执行引擎"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
	
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/07/21/JVM%EF%BC%9A%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/"
    >执行引擎</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/07/21/JVM%EF%BC%9A%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/" class="article-date">
  <time datetime="2022-07-21T07:39:23.000Z" itemprop="datePublished">2022-07-21</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/JVM/">JVM</a> / <a class="article-category-link" href="/categories/JVM/1-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/">1.内存与垃圾回收篇</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220721141735654.png" alt="image-20220721141735654"></p>
<ul>
<li>执行引擎是Java虚拟机核心的组成部分之一。</li>
<li>“虚拟机”是一个相对于“物理机”的概念，这两种机器都有代码执行能力，其区别是物理机的执行引擎是直接建立在处理器、缓存、指令集和操作系统层面上的，而<strong>虚拟机的执行引擎则是由软件自行实现的</strong>，因此可以不受物理条件制约地定制指令集与执行引擎的结构体系，<strong>能够执行那些不被硬件直接支持的指令集格式</strong>。</li>
<li>JVM的主要任务是负责<strong>装载字节码到其内部</strong>，但字节码并不能够直接运行在操作系统之上，因为字节码指令并非等价于本地机器指令，它内部包含的仅仅只是一些能够被JVM所识别的字节码指令、符号表，以及其他辅助信息。</li>
<li>那么，如果想要让一个Java程序运行起来，执行引擎（Execution Engine）的任务就是<strong>将字节码指令解释&#x2F;编译为对应平台上的本地机器指令才可以</strong>。简单来说，JVM中的执行引擎充当了将高级语言翻译为机器语言的译者。</li>
</ul>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220721142132211.png" alt="image-20220721142132211"></p>
<p>1、前端编译：从Java程序员 –&gt; 字节码文件的这个过程叫前端编译</p>
<p>2、执行引擎这里有两种行为：一种是解释执行，一种是编译执行（这里的是后端编译）。</p>
<h2 id="执行引擎工作过程"><a href="#执行引擎工作过程" class="headerlink" title="执行引擎工作过程"></a>执行引擎工作过程</h2><blockquote>
<p><strong>执行引擎工作过程</strong></p>
</blockquote>
<ol>
<li>执行引擎在执行的过程中究竟需要执行什么样的字节码指令<strong>完全依赖于PC寄存器</strong>。</li>
<li>每当执行完一项指令操作后，PC寄存器就会更新下一条需要被执行的指令地址。</li>
<li>当然方法在执行的过程中，执行引擎有可能会通过存储在局部变量表中的对象引用准确定位到存储在Java堆区中的对象实例信息，以及通过对象头中的元数据指针定位到目标对象的类型信息。</li>
<li>从外观上来看，所有的Java虚拟机的执行引擎输入、处理、输出都是一致的：<strong>输入的是字节码二进制流，处理过程是字节码解析执行、即时编译的等效过程，输出的是执行结果。</strong></li>
</ol>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220721142528970.png" alt="image-20220721142528970"></p>
<h1 id="Java代码编译和执行过程"><a href="#Java代码编译和执行过程" class="headerlink" title="Java代码编译和执行过程"></a>Java代码编译和执行过程</h1><h2 id="解释执行和即时编译"><a href="#解释执行和即时编译" class="headerlink" title="解释执行和即时编译"></a>解释执行和即时编译</h2><p>大部分的程序代码转换成物理机的目标代码或虚拟机能执行的指令集之前，都需要经过下图中的各个步骤：</p>
<ol>
<li><p>前面橙色部分是编译生成生成字节码文件的过程（javac编译器来完成，也就是前端编译器），和JVM没有关系。</p>
</li>
<li><p>后面绿色（解释执行）和蓝色（即时编译）才是JVM需要考虑的过程</p>
</li>
</ol>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220721142859037.png" alt="image-20220721142859037"></p>
<ol start="3">
<li><p>javac编译器（前端编译器）流程图如下所示：</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220721143117609.png" alt="image-20220721143117609"></p>
</li>
<li><p>Java字节码的执行是由JVM执行引擎来完成，流程图如下所示</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220721143212431.png" alt="image-20220721143212431"></p>
</li>
</ol>
<h2 id="什么是解释器？什么是JIT编译器？"><a href="#什么是解释器？什么是JIT编译器？" class="headerlink" title="什么是解释器？什么是JIT编译器？"></a>什么是解释器？什么是JIT编译器？</h2><ol>
<li>解释器：当Java虚拟机启动时会根据预定义的规范对字节码采用<strong>逐行解释的方式执行</strong>，将每条字节码文件中的内容“翻译”为对应平台的本地机器指令执行。</li>
<li>JIT（Just In Time Compiler）编译器：就是虚拟机将源代码<strong>一次性直接</strong>编译成和本地机器平台相关的机器语言，<strong>但并不是马上执行</strong>。</li>
</ol>
<p><strong>为什么Java是半编译半解释型语言？</strong></p>
<ol>
<li>JDK1.0时代，将Java语言定位为“解释执行”还是比较准确的。再后来，Java也发展出可以直接生成本地代码的编译器。</li>
<li>现在JVM在执行Java代码的时候，通常都会将解释执行与编译执行二者结合起来进行。</li>
<li>JIT编译器将字节码翻译成本地代码后，就可以做一个缓存操作，存储在方法区的JIT 代码缓存中（执行效率更高了），并且在翻译成本地代码的过程中可以做优化。</li>
</ol>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220721143648433.png" alt="image-20220721143648433"></p>
<h1 id="机器码、指令、汇编语言"><a href="#机器码、指令、汇编语言" class="headerlink" title="机器码、指令、汇编语言"></a>机器码、指令、汇编语言</h1><h2 id="机器码"><a href="#机器码" class="headerlink" title="机器码"></a>机器码</h2><ul>
<li>各种用<strong>二进制编码</strong>方式表示的指令，叫做<strong>机器指令码</strong>。开始，人们就用它采编写程序，这就是机器语言。</li>
<li>机器语言虽然能够被计算机理解和接受，但和人们的语言差别太大，不易被人们理解和记忆，并且用它编程容易出差错。</li>
<li>用它编写的程序一经输入计算机，CPU直接读取运行，因此和其他语言编的程序相比，执行速度最快。</li>
<li>机器指令与CPU紧密相关，所以不同种类的CPU所对应的机器指令也就不同。</li>
</ul>
<h2 id="指令和指令集"><a href="#指令和指令集" class="headerlink" title="指令和指令集"></a>指令和指令集</h2><p><strong>指令</strong></p>
<ul>
<li>由于机器码是由0和1组成的二进制序列，可读性实在太差，于是人们发明了指令。</li>
<li>指令就是把机器码中特定的0和1序列，简化成对应的指令（一般为英文简写，如mov，inc等），可读性稍好</li>
<li>由于不同的硬件平台，执行同一个操作，对应的机器码可能不同，所以不同的硬件平台的同一种指令（比如mov），对应的机器码也可能不同。</li>
</ul>
<p><strong>指令集</strong></p>
<ul>
<li>不同的硬件平台，各自支持的指令，是有差别的。因此每个平台所支持的指令，称之为对应平台的指令集。</li>
<li>如常见的<ul>
<li>x86指令集，对应的是x86架构的平台</li>
<li>ARM指令集，对应的是ARM架构的平台</li>
</ul>
</li>
</ul>
<h2 id="汇编语言"><a href="#汇编语言" class="headerlink" title="汇编语言"></a>汇编语言</h2><ul>
<li>由于指令的可读性还是太差，于是人们又发明了汇编语言。</li>
<li>在汇编语言中，用<strong>助记符（Mnemonics）代替机器指令的操作码，用地址符号（Symbol）或标号（Label）代替指令或操作数的地址。</strong></li>
<li>在不同的硬件平台，汇编语言对应着不同的机器语言指令集，通过汇编过程转换成机器指令。<ul>
<li>由于计算机只认识指令码，所以用汇编语言编写的程序还<strong>必须翻译（汇编）成机器指令码，计算机才能识别和执行</strong>。</li>
</ul>
</li>
</ul>
<h2 id="高级语言"><a href="#高级语言" class="headerlink" title="高级语言"></a>高级语言</h2><ol>
<li><p>为了使计算机用户编程序更容易些，后来就出现了各种高级计算机语言。高级语言比机器语言、汇编语言更接近人的语言</p>
</li>
<li><p>当计算机执行高级语言编写的程序时，<strong>仍然需要把程序解释和编译成机器的指令码</strong>。完成这个过程的程序就叫做解释程序或编译程序。</p>
</li>
</ol>
<img src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_008/0008.png">



<h2 id="字节码"><a href="#字节码" class="headerlink" title="字节码"></a>字节码</h2><ul>
<li>字节码是一种<strong>中间状态（中间码）的二进制代码</strong>（文件），它比机器码更抽象，需要直译器转译后才能成为机器码</li>
<li>字节码主要为了实现特定软件运行和软件环境、<strong>与硬件环境无关</strong>。</li>
<li>字节码的实现方式是通过编译器和虚拟机器。编译器将源码编译成字节码，特定平台上的虚拟机器将字节码转译为可以直接执行的指令。</li>
<li>字节码典型的应用为：Java bytecode</li>
</ul>
<h2 id="C、C-源程序执行过程"><a href="#C、C-源程序执行过程" class="headerlink" title="C、C++源程序执行过程"></a>C、C++源程序执行过程</h2><p><strong>编译过程又可以分成两个阶段：编译和汇编。</strong></p>
<ol>
<li><p><strong>编译过程</strong>：是读取源程序（字符流），对之进行词法和语法的分析，将高级语言指令转换为功能等效的汇编代码</p>
</li>
<li><p><strong>汇编过程</strong>：实际上指把汇编语言代码翻译成目标机器指令的过程。</p>
</li>
</ol>
<img src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_008/0009.png">



<h1 id="解释器"><a href="#解释器" class="headerlink" title="解释器"></a>解释器</h1><h2 id="为什么要有解释器"><a href="#为什么要有解释器" class="headerlink" title="为什么要有解释器"></a>为什么要有解释器</h2><ul>
<li>JVM设计者们的初衷仅仅只是单纯地为了<strong>满足Java程序实现跨平台特性</strong>，因此避免采用静态编译的方式由高级语言直接生成本地机器指令，从而诞生了实现解释器在运行时采用逐行解释字节码执行程序的想法（也就是产生了一个中间产品<strong>字节码</strong>）。</li>
<li>解释器真正意义上所承担的角色就是一个运行时“翻译者”，将字节码文件中的内容“翻译”为对应平台的本地机器指令执行。</li>
<li>当一条字节码指令被解释执行完成后，接着再根据PC寄存器中记录的下一条需要被执行的字节码指令执行解释操作。</li>
</ul>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220721144823505.png" alt="image-20220721144823505"></p>
<h2 id="解释器的分类"><a href="#解释器的分类" class="headerlink" title="解释器的分类"></a>解释器的分类</h2><ol>
<li>在Java的发展历史里，一共有两套解释执行器，即古老的<strong>字节码解释器</strong>、现在普遍使用的<strong>模板解释器</strong>。<ul>
<li>字节码解释器在执行时通过<strong>纯软件代码</strong>模拟字节码的执行，效率非常低下。</li>
<li>而模板解释器将<strong>每一条字节码和一个模板函数相关联</strong>，模板函数中直接产生这条字节码执行时的机器码，从而很大程度上提高了解释器的性能。</li>
</ul>
</li>
<li>在HotSpot VM中，解释器主要由<strong>Interpreter模块和Code模块</strong>构成。<ul>
<li>Interpreter模块：实现了解释器的核心功能</li>
<li>Code模块：用于管理HotSpot VM在运行时生成的本地机器指令</li>
</ul>
</li>
</ol>
<h2 id="解释器的现状"><a href="#解释器的现状" class="headerlink" title="解释器的现状"></a>解释器的现状</h2><ul>
<li>由于解释器在设计和实现上非常简单，因此除了Java语言之外，还有许多高级语言同样也是基于解释器执行的，比如Python、Perl、Ruby等。但是在今天，<strong>基于解释器执行已经沦落为低效的代名词</strong>，并且时常被一些C&#x2F;C++程序员所调侃。</li>
<li>为了解决这个问题，JVM平台支持一种叫作即时编译的技术。即时编译的目的是避免函数被解释执行，而是<strong>将整个函数体编译成为机器码，每次函数执行时，只执行编译后的机器码即可</strong>，这种方式可以使执行效率大幅度提升。</li>
<li>不过无论如何，基于解释器的执行模式仍然为中间语言的发展做出了不可磨灭的贡献。</li>
</ul>
<h1 id="JIT编译器"><a href="#JIT编译器" class="headerlink" title="JIT编译器"></a>JIT编译器</h1><h2 id="Java-代码执行的分类"><a href="#Java-代码执行的分类" class="headerlink" title="Java 代码执行的分类"></a>Java 代码执行的分类</h2><ul>
<li>第一种是<strong>将源代码编译成字节码文件，然后在运行时通过解释器将字节码文件转为机器码执行</strong></li>
<li>第二种是<strong>编译执行（直接编译成机器码）</strong>。现代虚拟机为了提高执行效率，会使用即时编译技术（JIT，Just In Time）将方法编译成机器码后再执行</li>
<li>HotSpot VM是目前市面上高性能虚拟机的代表作之一。<strong>它采用解释器与即时编译器并存的架构</strong>。在Java虚拟机运行时，解释器和即时编译器能够相互协作，各自取长补短，尽力去选择最合适的方式来权衡编译本地代码的时间和直接解释执行代码的时间。</li>
<li>在今天，Java程序的运行性能早已脱胎换骨，已经达到了可以和C&#x2F;C++ 程序一较高下的地步。</li>
</ul>
<h2 id="为啥我们还需要解释器呢？"><a href="#为啥我们还需要解释器呢？" class="headerlink" title="为啥我们还需要解释器呢？"></a>为啥我们还需要解释器呢？</h2><ul>
<li>有些开发人员会感觉到诧异，既然HotSpot VM中已经内置JIT编译器了，那么为什么还需要再使用解释器来“拖累”程序的执行性能呢？比如JRockit VM内部就不包含解释器，字节码全部都依靠即时编译器编译后执行。</li>
<li>JRockit虚拟机是砍掉了解释器，也就是只采及时编译器。那是因为呢JRockit只部署在服务器上，一般已经有时间让他进行指令编译的过程了，对于响应来说要求不高，等及时编译器的编译完成后，就会提供更好的性能</li>
</ul>
<p><strong>首先明确两点：</strong></p>
<ol>
<li>当程序启动后，解释器可以马上发挥作用，<strong>响应速度快</strong>，省去编译的时间，立即执行。</li>
<li>编译器要想发挥作用，把代码编译成本地代码，<strong>需要一定的执行时间</strong>，但编译为本地代码后，执行效率高。</li>
</ol>
<p><strong>所以：</strong></p>
<ol>
<li>尽管JRockit VM中程序的执行性能会非常高效，但程序在启动时必然需要花费更长的时间来进行编译。对于服务端应用来说，启动时间并非是关注重点，但对于那些看中启动时间的应用场景而言，或许就需要采用解释器与即时编译器并存的架构来换取一个平衡点。</li>
<li>在此模式下，<code>在Java虚拟器启动时，解释器可以首先发挥作用，而不必等待即时编译器全部编译完成后再执行，这样可以省去许多不必要的编译时间。随着时间的推移，编译器发挥作用，把越来越多的代码编译成本地代码，获得更高的执行效率。</code></li>
<li>同时，解释执行在编译器进行激进优化不成立的时候，作为编译器的“逃生门”（后备方案）。</li>
<li>当虚拟机启动的时候，<strong>解释器可以首先发挥作用</strong>，而不必等待即时编译器全部编译完成再执行，这样可以<strong>省去许多不必要的编译时间</strong>。随着程序运行时间的推移，即时编译器逐渐发挥作用，根据热点探测功能，<strong>将有价值的字节码编译为本地机器指令</strong>，以换取更高的程序执行效率。</li>
</ol>
<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><ul>
<li>注意解释执行与编译执行在线上环境微妙的辩证关系。<strong>机器在热机状态（已经运行了一段时间叫热机状态）可以承受的负载要大于冷机状态（刚启动的时候叫冷机状态）</strong>。如果以热机状态时的流量进行切流，可能使处于冷机状态的服务器因无法承载流量而假死。</li>
<li>在生产环境发布过程中，以分批的方式进行发布，根据机器数量划分成多个批次，每个批次的机器数至多占到整个集群的1&#x2F;8。曾经有这样的故障案例：某程序员在发布平台进行分批发布，在输入发布总批数时，误填写成分为两批发布。如果是热机状态，在正常情况下一半的机器可以勉强承载流量，但由于刚启动的JVM均是解释执行，还没有进行热点代码统计和JIT动态编译，导致机器启动之后，当前1&#x2F;2发布成功的服务器马上全部宕机，此故障说明了JIT的存在。—<strong>阿里团队</strong></li>
</ul>
<img src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_008/0011.png">



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JITTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            list.add(<span class="string">&quot;让天下没有难学的技术&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过 JVisualVM 查看 JIT 编译器执行的编译次数</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220721150828106.png" alt="image-20220721150828106"></p>
<h2 id="JIT编译器相关概念"><a href="#JIT编译器相关概念" class="headerlink" title="JIT编译器相关概念"></a>JIT编译器相关概念</h2><ul>
<li>Java 语言的“编译期”其实是一段“不确定”的操作过程，因为它可能是指一个<strong>前端编译器</strong>（其实叫“编译器的前端”更准确一些）把.java文件转变成.class文件的过程。</li>
<li>也可能是指虚拟机的<strong>后端运行期编译器</strong>（<strong>JIT编译器</strong>，Just In Time Compiler）把字节码转变成机器码的过程。</li>
<li>还可能是指使用<strong>静态提前编译器</strong>（AOT编译器，Ahead of Time Compiler）直接把.java文件编译成本地机器代码的过程。（可能是后续发展的趋势）</li>
</ul>
<p><strong>典型的编译器：</strong></p>
<ul>
<li><strong>前端编译器</strong>：Sun的javac、Eclipse JDT中的增量式编译器（ECJ）。</li>
<li><strong>JIT编译器</strong>：HotSpot VM的C1、C2编译器。</li>
<li><strong>AOT 编译器</strong>：GNU Compiler for the Java（GCJ）、Excelsior JET。</li>
</ul>
<h2 id="热点代码及探测方式"><a href="#热点代码及探测方式" class="headerlink" title="热点代码及探测方式"></a>热点代码及探测方式</h2><ul>
<li>当然是否需要启动JIT编译器将字节码直接编译为对应平台的本地机器指令，则需要根据代码被调用<strong>执行的频率</strong>而定。</li>
<li>关于那些需要被编译为本地代码的字节码，也被称之为<strong>“热点代码”</strong>，JIT编译器在运行时会针对那些频繁被调用的“热点代码”做出<strong>深度优化</strong>，将其直接编译为对应平台的本地机器指令，以此提升Java程序的执行性能。</li>
<li><strong>一个被多次调用的方法，或者是一个方法体内部循环次数较多的循环体都可以被称之为“热点代码”</strong>，因此都可以通过JIT编译器编译为本地机器指令。由于这种编译方式发生在方法的执行过程中，因此也被称之为<strong>栈上替换</strong>，或简称为**OSR (On StackReplacement)**编译。</li>
<li>一个方法究竟要被调用多少次，或者一个循环体究竟需要执行多少次循环才可以达到这个标准？必然需要一个明确的阈值，JIT编译器才会将这些“热点代码”编译为本地机器指令执行。这里主要依靠热点探测功能。</li>
<li><strong>目前HotSpot VM所采用的热点探测方式是基于计数器的热点探测</strong>。</li>
<li>采用基于计数器的热点探测，HotSpot VM将会为每一个方法都建立2个不同类型的计数器，分别为<strong>方法调用计数器（Invocation Counter）和回边计数器（Back Edge Counter）</strong>。<ul>
<li>方法调用计数器用于统计方法的调用次数</li>
<li>回边计数器则用于统计循环体执行的循环次数</li>
</ul>
</li>
</ul>
<h3 id="方法调用计数器"><a href="#方法调用计数器" class="headerlink" title="方法调用计数器"></a>方法调用计数器</h3><ul>
<li>这个计数器就用于统计方法被调用的次数，它的默认阀值在Client模式下是1500次，在Server模式下是10000次。超过这个阈值，就会触发JIT编译。</li>
<li>这个阀值可以通过虚拟机参数 <strong>-XX:CompileThreshold</strong> 来人为设定。</li>
<li>当一个方法被调用时，会先检查该方法是否存在被JIT编译过的版本<ul>
<li>如果存在，则优先使用编译后的本地代码来执行</li>
<li>如果不存在已被编译过的版本，则将此方法的调用计数器值加1，然后判断方法调用计数器与回边计数器值之和是否超过方法调用计数器的阀值。<ul>
<li>如果已超过阈值，那么将会向即时编译器提交一个该方法的代码编译请求。</li>
<li>如果未超过阈值，则使用解释器对字节码文件解释执行</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220721151551767.png" alt="image-20220721151551767"></p>
<h3 id="热度衰减"><a href="#热度衰减" class="headerlink" title="热度衰减"></a>热度衰减</h3><ul>
<li>如果不做任何设置，方法调用计数器统计的并不是方法被调用的绝对次数，而是一个相对的执行频率，即<strong>一段时间之内方法被调用的次数</strong>。当<strong>超过一定的时间限度</strong>，如果方法的调用次数仍然不足以让它提交给即时编译器编译，那这个方法的调用计数器就会被<strong>减少一半</strong>，这个过程称为方法调用计数器<strong>热度的衰减</strong>（Counter Decay），而这段时间就称为此方法统计的<strong>半衰周期</strong>（Counter Half Life Time）（半衰周期是化学中的概念，比如出土的文物通过查看C60来获得文物的年龄）</li>
<li>进行热度衰减的动作是在虚拟机进行垃圾收集时顺便进行的，可以使用虚拟机参数 <strong>-XX:-UseCounterDecay</strong> 来关闭热度衰减，让方法计数器统计方法调用的绝对次数，这样的话，只要系统运行时间足够长，绝大部分方法都会被编译成本地代码。</li>
<li>另外，可以使用 <strong>-XX:CounterHalfLifeTime</strong> 参数设置半衰周期的时间，单位是秒。</li>
</ul>
<h3 id="回边计数器"><a href="#回边计数器" class="headerlink" title="回边计数器"></a>回边计数器</h3><ul>
<li>它的作用是<strong>统计一个方法中循环体代码执行的次数</strong>，在字节码中遇到控制流向后跳转的指令称为“回边”（Back Edge）。显然，建立回边计数器统计的目的就是为了触发OSR编译。</li>
</ul>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220721152056647.png" alt="image-20220721152056647"></p>
<h2 id="HotSpotVM设置程序执行方法"><a href="#HotSpotVM设置程序执行方法" class="headerlink" title="HotSpotVM设置程序执行方法"></a>HotSpotVM设置程序执行方法</h2><p>默认情况下HotSpot VM是采用解释器与即时编译器并存的架构，当然开发人员可以根据具体的应用场景，通过命令显式地为Java虚拟机指定在运行时到底是完全采用解释器执行，还是完全采用即时编译器执行。如下所示：</p>
<ol>
<li><code>-Xint</code>：完全采用解释器模式执行程序；</li>
<li><code>-Xcomp</code>：完全采用即时编译器模式执行程序。如果即时编译出现问题，解释器会介入执行</li>
<li><code>-Xmixed</code>：采用解释器+即时编译器的混合模式共同执行程序。</li>
</ol>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220721152331452.png" alt="image-20220721152331452"></p>
<p><strong>代码测试</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试解释器模式和JIT编译模式</span></span><br><span class="line"><span class="comment"> *  -Xint  : 5102ms</span></span><br><span class="line"><span class="comment"> *  -Xcomp : 704ms</span></span><br><span class="line"><span class="comment"> *  -Xmixed : 816ms</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IntCompTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        testPrimeNumber(<span class="number">1000000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;花费的时间为：&quot;</span> + (end - start));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testPrimeNumber</span><span class="params">(<span class="type">int</span> count)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            <span class="comment">//计算100以内的质数</span></span><br><span class="line">            label:<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">2</span>;j &lt;= <span class="number">100</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">2</span>;k &lt;= Math.sqrt(j);k++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(j % k == <span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="keyword">continue</span> label;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//System.out.println(j);</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结论：只用解释器执行是真的慢</p>
<h2 id="HotSpotVM-JIT-分类"><a href="#HotSpotVM-JIT-分类" class="headerlink" title="HotSpotVM JIT 分类"></a>HotSpotVM JIT 分类</h2><p>在HotSpot VM中内嵌有两个JIT编译器，分别为<strong>Client Compiler和Server Compiler</strong>，但大多数情况下我们简称为C1编译器 和 C2编译器。开发人员可以通过如下命令显式指定Java虚拟机在运行时到底使用哪一种即时编译器，如下所示：</p>
<ol>
<li>-client：指定Java虚拟机运行在Client模式下，并使用C1编译器；<ul>
<li>C1编译器会对字节码进行<strong>简单和可靠的优化，耗时短</strong>，以达到更快的编译速度。</li>
</ul>
</li>
<li>-server：指定Java虚拟机运行在server模式下，并使用C2编译器。<ul>
<li>C2进行<strong>耗时较长的优化，以及激进优化</strong>，但优化的代码执行效率更高。（使用C++）</li>
</ul>
</li>
</ol>
<h3 id="C1和C2编译器不同的优化策略"><a href="#C1和C2编译器不同的优化策略" class="headerlink" title="C1和C2编译器不同的优化策略"></a>C1和C2编译器不同的优化策略</h3><ul>
<li><p>在不同的编译器上有不同的优化策略，C1编译器上主要有<strong>方法内联，去虚拟化、元余消除</strong>。</p>
<ul>
<li><strong>方法内联</strong>：将引用的函数代码编译到引用点处，这样可以减少栈帧的生成，减少参数传递以及跳转过程</li>
<li><strong>去虚拟化</strong>：对唯一的实现樊进行内联</li>
<li><strong>冗余消除</strong>：在运行期间把一些不会执行的代码折叠掉</li>
</ul>
</li>
<li><p>C2的优化主要是在全局层面，逃逸分析是优化的基础。基于逃逸分析在C2上有如下几种优化：</p>
<ul>
<li><strong>标量替换</strong>：用标量值代替聚合对象的属性值</li>
<li><strong>栈上分配</strong>：对于未逃逸的对象分配对象在栈而不是堆</li>
<li><strong>同步消除</strong>：清除同步操作，通常指synchronized</li>
</ul>
</li>
</ul>
<blockquote>
<p>也就是说之前的逃逸分析，只有在C2（server模式下）才会触发。那是否说明C1就用不了了？</p>
</blockquote>
<h3 id="分层编译策略"><a href="#分层编译策略" class="headerlink" title="分层编译策略"></a>分层编译策略</h3><ul>
<li>分层编译（Tiered Compilation）策略：程序解释执行（不开启性能监控）可以触发C1编译，将字节码编译成机器码，可以进行简单优化，也可以加上性能监控，C2编译会根据性能监控信息进行激进优化。</li>
<li>不过在Java7版本之后，一旦开发人员在程序中显式指定命令 <strong>-server</strong> 时，默认将会开启分层编译策略，由C1编译器和C2编译器相互协作共同来执行编译任务。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>一般来讲，JIT编译出来的机器码性能比解释器解释执行的性能高</li>
<li>C2编译器启动时长比C1慢，系统稳定执行以后，C2编译器执行速度远快于C1编译器</li>
</ul>
<h2 id="Graal-编译器"><a href="#Graal-编译器" class="headerlink" title="Graal 编译器"></a>Graal 编译器</h2><ul>
<li><p>自JDK10起，HotSpot又加入了一个全新的即时编译器：Graal编译器</p>
</li>
<li><p>编译效果短短几年时间就追平了G2编译器，未来可期（对应还出现了Graal虚拟机，是有可能替代Hotspot的虚拟机的）</p>
</li>
<li><p>目前，带着实验状态标签，需要使用开关参数去激活才能使用</p>
<p><strong>-XX:+UnlockExperimentalvMOptions  -XX:+UseJVMCICompiler</strong></p>
</li>
</ul>
<h2 id="AOT编译器"><a href="#AOT编译器" class="headerlink" title="AOT编译器"></a>AOT编译器</h2><ul>
<li>jdk9引入了AoT编译器（静态提前编译器，Ahead of Time Compiler），<strong>与JIT并列</strong></li>
<li>Java9引入了<strong>实验性AOT编译工具jaotc</strong>。它借助了Graal编译器，将所输入的Java类文件转换为机器码，并存放至生成的动态共享库之中。</li>
<li>所谓AOT编译，是与即时编译相对立的一个概念。我们知道，即时编译指的是<strong>在程序的运行过程中</strong>，将字节码转换为可在硬件上直接运行的机器码，并部署至托管环境中的过程。而AOT编译指的则是，<strong>在程序运行之前</strong>，便将字节码转换为机器码的过程。</li>
<li>.java -&gt; .class -&gt; (使用jaotc) -&gt; .so</li>
</ul>
<p><strong>AOT编译器编译器的优缺点</strong></p>
<p><strong>最大的好处：</strong></p>
<ul>
<li>Java虚拟机加载已经预编译成二进制库，可以直接执行。不必等待即时编译器的预热，减少Java应用给人带来“第一次运行慢” 的不良体验</li>
</ul>
<p><strong>缺点：</strong></p>
<ol>
<li>破坏了 java “ 一次编译，到处运行”，必须为每个不同的硬件，OS编译对应的发行包</li>
<li><strong>降低了Java链接过程的动态性</strong>，加载的代码在编译器就必须全部已知。</li>
<li>还需要继续优化中，最初只支持Linux X64 java base</li>
</ol>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-JVM：直接内存(DirectMemory)"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
	
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/07/20/JVM%EF%BC%9A%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98(DirectMemory)/"
    >直接内存（Direct Memory）</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/07/20/JVM%EF%BC%9A%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98(DirectMemory)/" class="article-date">
  <time datetime="2022-07-20T06:22:57.000Z" itemprop="datePublished">2022-07-20</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/JVM/">JVM</a> / <a class="article-category-link" href="/categories/JVM/1-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/">1.内存与垃圾回收篇</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><ul>
<li><p>在jdk8的时候引入了元空间，而元空间使用的就是直接内存。</p>
</li>
<li><p>直接内存不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域。</p>
</li>
<li><p>直接内存是在Java堆外的、直接向系统申请的内存区间。</p>
</li>
<li><p>来源于NIO(其实在jdk1.4引入NIO时就有了操作本地内存的概念，后来在jdk1.7时引入了NIO2)，通过存在堆中的DirectByteBuffer操作Native内存</p>
</li>
<li><p>通常，<strong>访问直接内存的速度会优于Java堆</strong>。即读写性能高。</p>
<ul>
<li>因此出于性能考虑，读写频繁的场合可能会考虑使用直接内存。</li>
<li>Java的NIO库允许Java程序使用直接内存，用于数据缓冲区</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  IO                  NIO (New IO / Non-Blocking IO)</span></span><br><span class="line"><span class="comment"> *  byte[] / char[]     Buffer</span></span><br><span class="line"><span class="comment"> *  Stream              Channel</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 查看直接内存的占用与释放</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BufferTest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">BUFFER</span> <span class="operator">=</span> <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">1024</span>;<span class="comment">//1GB</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">//直接分配本地内存空间</span></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.allocateDirect(BUFFER);</span><br><span class="line">        System.out.println(<span class="string">&quot;直接内存分配完毕，请求指示！&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        scanner.next();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;直接内存开始释放！&quot;</span>);</span><br><span class="line">        byteBuffer = <span class="literal">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        scanner.next();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接占用了1G的本地内存</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220720164700347.png" alt="image-20220720164700347"></p>
<p> 当控制台输入”释放内存”后，占用内存明显减少</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220720164913719.png" alt="image-20220720164913719"></p>
<h1 id="BIO与NIO"><a href="#BIO与NIO" class="headerlink" title="BIO与NIO"></a>BIO与NIO</h1><h2 id="非直接缓存区（BIO）"><a href="#非直接缓存区（BIO）" class="headerlink" title="非直接缓存区（BIO）"></a>非直接缓存区（BIO）</h2><ul>
<li>原来采用BIO的架构，在读写本地文件时，我们需要从用户态切换成内核态<img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/2073658-20210308165244606-163178566.png" alt="img"></li>
</ul>
<h2 id="直接缓冲区（NIO）"><a href="#直接缓冲区（NIO）" class="headerlink" title="直接缓冲区（NIO）"></a>直接缓冲区（NIO）</h2><ul>
<li>NIO 直接操作物理磁盘，省去了中间过程</li>
</ul>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/2073658-20210308165422888-1665701747.png" alt="img"></p>
<p>如何理解上面的内容：我们的java程序，想要操作本地磁盘，首先命令会到用户地址空间(jvm中)，然后这个jvm映射会到内核地址空间(这个应该是操作系统提供的映射物理磁盘的)，最终到物理磁盘。而NIO直接操作一个映射文件，是java程序直接到物理磁盘的。</p>
<h1 id="直接内存与OOM"><a href="#直接内存与OOM" class="headerlink" title="直接内存与OOM"></a>直接内存与OOM</h1><ul>
<li>直接内存也可能导致OutofMemoryError异常</li>
<li>由于直接内存在Java堆外，因此它的大小不会直接受限于-Xmx指定的最大堆大小，但是系统内存是有限的，Java堆和直接内存的总和依然受限于操作系统能给出的最大内存。</li>
<li>直接内存的缺点为：<ul>
<li>分配回收成本较高</li>
<li>不受JVM内存回收管理</li>
</ul>
</li>
<li>直接内存大小可以通过<strong>MaxDirectMemorySize</strong>设置</li>
<li>如果不指定，默认与堆的最大值-Xmx参数值一致</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本地内存的OOM:  OutOfMemoryError: Direct buffer memory</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BufferTest2</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">BUFFER</span> <span class="operator">=</span> <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">20</span>;<span class="comment">//20MB</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;ByteBuffer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>)&#123;  <span class="comment">// 不断使用</span></span><br><span class="line">                <span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.allocateDirect(BUFFER);   <span class="comment">// 使用本地内存</span></span><br><span class="line">                list.add(byteBuffer);</span><br><span class="line">                count++;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(count);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">181</span></span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.OutOfMemoryError: Direct buffer memory</span><br><span class="line">	at java.nio.Bits.reserveMemory(Bits.java:<span class="number">694</span>)</span><br><span class="line">	at java.nio.DirectByteBuffer.&lt;init&gt;(DirectByteBuffer.java:<span class="number">123</span>)</span><br><span class="line">	at java.nio.ByteBuffer.allocateDirect(ByteBuffer.java:<span class="number">311</span>)</span><br><span class="line">	at com.ysy.methodarea.BufferTest2.main(BufferTest2.java:<span class="number">19</span>)</span><br></pre></td></tr></table></figure>

 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-JVM：对象实例化、内存布局与访问定位"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
	
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/07/19/JVM%EF%BC%9A%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BE%8B%E5%8C%96%E3%80%81%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E4%B8%8E%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D/"
    >对象实例化、内存布局与访问定位</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/07/19/JVM%EF%BC%9A%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BE%8B%E5%8C%96%E3%80%81%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E4%B8%8E%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D/" class="article-date">
  <time datetime="2022-07-19T11:25:23.000Z" itemprop="datePublished">2022-07-19</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/JVM/">JVM</a> / <a class="article-category-link" href="/categories/JVM/1-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/">1.内存与垃圾回收篇</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="对象的实例化"><a href="#对象的实例化" class="headerlink" title="对象的实例化"></a>对象的实例化</h1><p><strong>大厂面试题</strong></p>
<p>美团：</p>
<ol>
<li>对象在<code>JVM</code>中是怎么存储的？</li>
<li>对象头信息里面有哪些东西？</li>
</ol>
<p>蚂蚁金服：</p>
<p>二面：<code>java</code>对象头里有什么</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220719184456324.png" alt="image-20220719184456324"></p>
<h2 id="对象创建的方式"><a href="#对象创建的方式" class="headerlink" title="对象创建的方式"></a>对象创建的方式</h2><ol>
<li>new：最常见的方式、单例类中调用getInstance的静态类方法，XxxBuilder&#x2F;XxxFactory的静态方法</li>
<li>Class的newInstance方法：在JDK9里面被标记为过时的方法，因为只能调用空参构造器，并且<strong>权限必须为 public</strong></li>
<li>Constructor的newInstance(Xxxx)：反射的方式，可以调用空参的，或者带参的构造器</li>
<li>使用clone()：不调用任何的构造器，要求当前的类需要<strong>实现Cloneable接口中的clone方法</strong></li>
<li>使用序列化：从文件中，从网络中获取一个对象的二进制流，序列化一般用于Socket的网络传输</li>
<li>第三方库 Objenesis</li>
</ol>
<h2 id="对象创建的步骤"><a href="#对象创建的步骤" class="headerlink" title="对象创建的步骤"></a>对象创建的步骤</h2><blockquote>
<p><strong>从字节码看待对象的创建过程</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObjectTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(java.lang.String[])</span>;</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">2</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: <span class="keyword">new</span>           #<span class="number">2</span>                  <span class="comment">// class java/lang/Object</span></span><br><span class="line">         <span class="number">3</span>: dup           </span><br><span class="line">         <span class="number">4</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">         <span class="number">7</span>: astore_1</span><br><span class="line">         <span class="number">8</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">9</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">10</span>: <span class="number">8</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">9</span>     <span class="number">0</span>  args   [Ljava/lang/String;</span><br><span class="line">            <span class="number">8</span>       <span class="number">1</span>     <span class="number">1</span>   obj   Ljava/lang/Object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>1、判断对象对应的类是否加载、链接、初始化</strong></p>
<ol>
<li>虚拟机遇到一条new指令，首先去检查这个指令的参数能否在Metaspace的常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载，解析和初始化。（即判断类元信息是否存在）。</li>
<li>如果该类没有加载，那么在双亲委派模式下，使用当前类加载器以<strong>ClassLoader + 包名 + 类名为key进行查找对应的.class文件</strong>，如果没有找到文件，则抛出ClassNotFoundException异常，如果找到，则进行类加载，并生成对应的Class对象。</li>
</ol>
<p><strong>2、为对象分配内存</strong></p>
<ol>
<li>首先计算对象占用空间的大小，接着在堆中划分一块内存给新对象。如果实例成员变量是引用变量，仅分配引用变量空间即可，即4个字节大小</li>
<li><strong>如果内存规整：采用指针碰撞分配内存</strong><ul>
<li>意思是所有用过的内存在一边，空闲的内存放另外一边，中间放着一个指针作为分界点的指示器，分配内存就仅仅是把指针往空闲内存那边挪动一段与对象大小相等的距离罢了。</li>
<li>如果垃圾收集器选择的是Serial ，ParNew这种基于压缩算法的，虚拟机采用这种分配方式。一般使用带Compact（整理）过程的收集器时，使用指针碰撞。</li>
<li>标记压缩（整理）算法会整理内存碎片，堆内存一存对象，另一边为空闲区域</li>
</ul>
</li>
<li>如果内存不规整<ul>
<li>如果内存不是规整的，已使用的内存和未使用的内存相互交错，那么虚拟机将采用的是<strong>空闲列表</strong>来为对象分配内存。</li>
<li>意思是虚拟机维护了一个列表，记录上哪些内存块是可用的，再分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的内容。这种分配方式成为了 “空闲列表（Free List）”</li>
<li>选择哪种分配方式由Java堆是否规整所决定，而<strong>Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定</strong></li>
<li>标记清除算法清理过后的堆内存，就会存在很多内存碎片。</li>
</ul>
</li>
</ol>
<p><strong>3、处理并发问题</strong></p>
<ol>
<li>采用CAS+失败重试、区域加锁保证更新的原子性</li>
<li>每个线程预先分配TLAB - 通过设置 <strong>-XX:+UseTLAB</strong> 参数来设置（区域加锁机制）</li>
<li>在Eden区给每个线程分配一块区域</li>
</ol>
<p><strong>4、初始化分配到的空间(属性的默认初始化)</strong></p>
<ul>
<li>所有属性设置默认值，保证对象实例字段在不赋值可以直接使用</li>
<li>给对象属性赋值的顺序：<ol>
<li>属性的默认值初始化</li>
<li>显示初始化&#x2F;代码块初始化（并列关系，谁先谁后看代码编写的顺序）</li>
<li>构造器初始化</li>
</ol>
</li>
</ul>
<p><strong>5、设置对象的对象头</strong></p>
<ul>
<li>将<strong>对象的所属类（即类的元数据信息）、对象的HashCode和对象的GC信息、锁信息</strong>等数据存储在对象的对象头中。这个过程的具体设置方式取决于JVM实现。</li>
</ul>
<p><strong>6、执行init方法进行初始化(属性的显示初始化)</strong></p>
<ol>
<li><p>在Java程序的视角看来，初始化才正式开始。初始化成员变量，执行实例化代码块，调用类的构造方法，并把堆内对象的首地址赋值给引用变量</p>
</li>
<li><p>因此一般来说（由字节码中跟随invokespecial指令所决定），new指令之后会接着就是执行init方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完成创建出来。</p>
</li>
</ol>
<blockquote>
<p><strong>从字节码角度看 init 方法</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试对象实例化的过程</span></span><br><span class="line"><span class="comment"> *  ① 加载类元信息 - ② 为对象分配内存 - ③ 处理并发问题  - ④ 属性的默认初始化（零值初始化）</span></span><br><span class="line"><span class="comment"> *  - ⑤ 设置对象头的信息 - ⑥ 属性的显式初始化、代码块中初始化、构造器中初始化</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  给对象的属性赋值的操作：</span></span><br><span class="line"><span class="comment"> *  ① 属性的默认初始化 - ② 显式初始化 / ③ 代码块中初始化 - ④ 构造器中初始化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Customer</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> <span class="number">1001</span>;</span><br><span class="line">    String name;</span><br><span class="line">    Account acct;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        name = <span class="string">&quot;匿名客户&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Customer</span><span class="params">()</span>&#123;</span><br><span class="line">        acct = <span class="keyword">new</span> <span class="title class_">Account</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Customer类的字节码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">0</span> aload_0</span><br><span class="line"> <span class="number">1</span> invokespecial #<span class="number">1</span> &lt;java/lang/Object.&lt;init&gt;&gt;</span><br><span class="line"> <span class="number">4</span> aload_0</span><br><span class="line"> <span class="number">5</span> sipush <span class="number">1001</span></span><br><span class="line"> <span class="number">8</span> putfield #<span class="number">2</span> &lt;com/atguigu/java/Customer.id&gt;</span><br><span class="line"><span class="number">11</span> aload_0</span><br><span class="line"><span class="number">12</span> ldc #<span class="number">3</span> &lt;匿名客户&gt;</span><br><span class="line"><span class="number">14</span> putfield #<span class="number">4</span> &lt;com/atguigu/java/Customer.name&gt;</span><br><span class="line"><span class="number">17</span> aload_0</span><br><span class="line"><span class="number">18</span> <span class="keyword">new</span> #<span class="number">5</span> &lt;com/atguigu/java/Account&gt;</span><br><span class="line"><span class="number">21</span> dup</span><br><span class="line"><span class="number">22</span> invokespecial #<span class="number">6</span> &lt;com/atguigu/java/Account.&lt;init&gt;&gt;</span><br><span class="line"><span class="number">25</span> putfield #<span class="number">7</span> &lt;com/atguigu/java/Customer.acct&gt;</span><br><span class="line"><span class="number">28</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<ul>
<li>init() 方法的字节码指令：<ul>
<li>属性的默认值初始化：<code>id = 1001;</code></li>
<li>显示初始化&#x2F;代码块初始化：<code>name = &quot;匿名客户&quot;;</code></li>
<li>构造器初始化：<code>acct = new Account();</code></li>
</ul>
</li>
</ul>
<h1 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h1><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220719191231499.png" alt="image-20220719191231499"></p>
<blockquote>
<p><strong>内存布局总结</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Customer</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> <span class="number">1001</span>;</span><br><span class="line">    String name;</span><br><span class="line">    Account acct;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        name = <span class="string">&quot;匿名客户&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Customer</span><span class="params">()</span>&#123;</span><br><span class="line">        acct = <span class="keyword">new</span> <span class="title class_">Account</span>();</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Customer</span> <span class="variable">cust</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Customer</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>图解内存布局</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220719191603723.png" alt="image-20220719191603723"></p>
<h1 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h1><p><strong>JVM是如何通过栈帧中的对象引用访问到其内部的对象实例呢？</strong></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220719191940370.png" alt="image-20220719191940370"></p>
<p>定位，<strong>通过栈上reference访问</strong></p>
<p><strong>对象的两种访问方式：句柄访问和直接指针</strong></p>
<ul>
<li><strong>句柄访问</strong></li>
</ul>
<ol>
<li>缺点：在堆空间中开辟了一块空间作为句柄池，句柄池本身也会占用空间；通过两次指针访问才能访问到堆中的对象，效率低</li>
<li>优点：reference中存储稳定句柄地址，对象被移动（垃圾收集时移动对象很普遍）时只会改变句柄中实例数据指针即可，reference本身不需要被修改</li>
</ol>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220719192112050.png" alt="image-20220719192112050"></p>
<ul>
<li><strong>直接指针（HotSpot采用）</strong></li>
</ul>
<ol>
<li>优点：直接指针是局部变量表中的引用，直接指向堆中的实例，在对象实例中有类型指针，指向的是方法区中的对象类型数据</li>
<li>缺点：对象被移动（垃圾收集时移动对象很普遍）时需要修改 reference 的值</li>
</ol>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220719192138715.png" alt="image-20220719192138715"></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-JVM：方法区"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
	
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/07/19/JVM%EF%BC%9A%E6%96%B9%E6%B3%95%E5%8C%BA/"
    >方法区</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/07/19/JVM%EF%BC%9A%E6%96%B9%E6%B3%95%E5%8C%BA/" class="article-date">
  <time datetime="2022-07-19T07:56:03.000Z" itemprop="datePublished">2022-07-19</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/JVM/">JVM</a> / <a class="article-category-link" href="/categories/JVM/1-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/">1.内存与垃圾回收篇</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="栈、堆、方法区的交互关系"><a href="#栈、堆、方法区的交互关系" class="headerlink" title="栈、堆、方法区的交互关系"></a>栈、堆、方法区的交互关系</h1><p><strong>从线程共享与否的角度来看</strong></p>
<p>ThreadLocal：如何保证多个线程在并发环境下的安全性？典型场景就是数据库连接管理，以及会话管理。</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220717145145582.png" alt="image-20220717145145582"></p>
<p><strong>栈、堆、方法区的交互关系</strong></p>
<p><strong>下面涉及了对象的访问定位</strong></p>
<ol>
<li>Person 类的 .class 信息存放在方法区中</li>
<li>person 变量存放在 Java 栈的局部变量表中</li>
<li>真正的 person 对象存放在 Java 堆中</li>
<li>在 person 对象中，有个指针指向方法区中的 person 类型数据，表明这个 person 对象是用方法区中的 Person 类 new 出来的</li>
</ol>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220717145450730.png" alt="image-20220717145450730"></p>
<h1 id="方法区的理解"><a href="#方法区的理解" class="headerlink" title="方法区的理解"></a>方法区的理解</h1><blockquote>
<p><strong>官方文档</strong>：<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5.4">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5.4</a></p>
</blockquote>
<h2 id="方法区在哪里？"><a href="#方法区在哪里？" class="headerlink" title="方法区在哪里？"></a>方法区在哪里？</h2><ol>
<li>《Java虚拟机规范》中明确说明：尽管所有的方法区在逻辑上是属于堆的一部分，但一些简单的实现可能不会选择去进行垃圾收集或者进行压缩。但对于HotSpotJVM而言，方法区还有一个别名叫做Non-Heap（非堆），目的就是要和堆分开。</li>
<li>所以，<strong>方法区可以看作是一块独立于Java堆的内存空间</strong>。</li>
</ol>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220717150314133.png" alt="image-20220717150314133"></p>
<h2 id="方法区的基本理解"><a href="#方法区的基本理解" class="headerlink" title="方法区的基本理解"></a>方法区的基本理解</h2><p><strong>方法区主要存放的是 Class，而堆中主要存放的是实例化的对象</strong></p>
<ol>
<li>方法区（Method Area）与Java堆一样，是各个线程共享的内存区域。多个线程同时加载同一个类时，只能有一个线程能加载该类，其他线程只能等待该线程加载完毕，然后直接使用该类，即类只能加载一次。</li>
<li>方法区在JVM启动的时候被创建，并且它的实际的物理内存空间中和Java堆区一样都可以是不连续的。</li>
<li>方法区的大小，跟堆空间一样，可以选择固定大小或者可扩展。</li>
<li>方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机同样会抛出内存溢出错误：<code>java.lang.OutofMemoryError:PermGen space</code>或者<code>java.lang.OutOfMemoryError:Metaspace</code><ul>
<li>加载大量的第三方的jar包</li>
<li>Tomcat部署的工程过多（30~50个）</li>
<li>大量动态的生成反射类</li>
</ul>
</li>
<li>关闭JVM就会释放这个区域的内存</li>
</ol>
<p><strong>代码举例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodAreaDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;start...&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;end...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单的程序，加载了1600多个类</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220717151239529.png" alt="image-20220717151239529"></p>
<h2 id="HotSpot中方法区的演进"><a href="#HotSpot中方法区的演进" class="headerlink" title="HotSpot中方法区的演进"></a>HotSpot中方法区的演进</h2><ol>
<li>在 JDK7 及以前，习惯上把方法区，称为永久代。JDK8开始，使用元空间取代了永久代。我们可以将方法区类比为Java中的接口，将永久代或元空间类比为Java中具体的实现类</li>
<li>本质上，方法区和永久代并不等价。仅是对Hotspot而言的可以看作等价。《Java虚拟机规范》对如何实现方法区，不做统一要求。例如：BEAJRockit &#x2F; IBM J9 中不存在永久代的概念。<ul>
<li>现在来看，当年使用永久代，不是好的idea。导致Java程序更容易OOm（超过** **上限）</li>
</ul>
</li>
<li>而到了JDK8，终于完全废弃了永久代的概念，改用与JRockit、J9一样在本地内存中实现的元空间（Metaspace）来代替</li>
<li>元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代最大的区别在于：<strong>元空间不在虚拟机设置的内存中，而是使用本地内存</strong>。</li>
<li>永久代、元空间二者并不只是名字变了，内部结构也调整了</li>
<li>根据《Java虚拟机规范》的规定，如果方法区无法满足新的内存分配需求时，将抛出OOM异常</li>
</ol>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220718151943873.png" alt="image-20220718151943873"></p>
<h1 id="设置方法区大小与-OOM"><a href="#设置方法区大小与-OOM" class="headerlink" title="设置方法区大小与 OOM"></a>设置方法区大小与 OOM</h1><p>方法区的大小不必是固定的，JVM可以根据应用的需要动态调整。</p>
<h2 id="JDK7及以前-永久代"><a href="#JDK7及以前-永久代" class="headerlink" title="JDK7及以前(永久代)"></a>JDK7及以前(永久代)</h2><ol>
<li>通过**-XX:Permsize<strong>来设置永久代初始分配空间。</strong>默认值是20.75M**</li>
<li><strong>-XX:MaxPermsize</strong>来设定永久代最大可分配空间。<strong>32位机器默认是64M，64位机器模式是82M</strong></li>
<li>当JVM加载的类信息容量超过了这个值，会报异常OutofMemoryError:PermGen space。</li>
</ol>
<img src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_006/0006.png">

<h2 id="JDK8及以后-元空间"><a href="#JDK8及以后-元空间" class="headerlink" title="JDK8及以后(元空间)"></a>JDK8及以后(元空间)</h2><blockquote>
<p><strong>JDK8 版本设置元空间大小</strong></p>
</blockquote>
<ol>
<li><p>元数据区大小可以使用参数 <strong>-XX:MetaspaceSize</strong> 和 <strong>-XX:MaxMetaspaceSize</strong> 指定</p>
</li>
<li><p>默认值依赖于平台，<strong>Windows下，-XX:MetaspaceSize 约为21M，-XX:MaxMetaspaceSize的值是-1，即没有限制</strong>。</p>
</li>
<li><p>与永久代不同，如果不指定大小，默认情况下，虚拟机会耗尽所有的可用系统内存。如果元数据区发生溢出，虚拟机一样会抛出异常OutOfMemoryError:Metaspace</p>
</li>
<li><p>-XX:MetaspaceSize：设置初始的元空间大小。对于一个 64位 的服务器端 JVM 来说，其默认的 -XX:MetaspaceSize值为21MB。这就是初始的高水位线，一旦触及这个水位线，Full GC将会被触发并卸载没用的类（即这些类对应的类加载器不再存活），然后这个高水位线将会重置。新的高水位线的值取决于GC后释放了多少元空间。如果释放的空间不足，那么在不超过MaxMetaspaceSize时，适当提高该值。如果释放空间过多，则适当降低该值。</p>
</li>
<li><p>如果初始化的高水位线设置过低，上述高水位线调整情况会发生很多次。通过垃圾回收器的日志可以观察到Full GC多次调用。为了避免频繁地GC，<strong>建议将-XX:MetaspaceSize设置为一个相对较高的值</strong>。</p>
</li>
</ol>
<h2 id="方法区OOM"><a href="#方法区OOM" class="headerlink" title="方法区OOM"></a>方法区OOM</h2><p>举例：</p>
<p>代码：OOMTest 类继承 ClassLoader 类，获得 defineClass() 方法，可自己进行类的加载</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * jdk6/7中：</span></span><br><span class="line"><span class="comment"> * -XX:PermSize=10m -XX:MaxPermSize=10m</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * jdk8中：</span></span><br><span class="line"><span class="comment"> * -XX:MetaspaceSize=10m -XX:MaxMetaspaceSize=10m</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OOMTest</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">OOMTest</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OOMTest</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">                <span class="comment">//创建ClassWriter对象，用于生成类的二进制字节码</span></span><br><span class="line">                <span class="type">ClassWriter</span> <span class="variable">classWriter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassWriter</span>(<span class="number">0</span>);</span><br><span class="line">                <span class="comment">//指明版本号，修饰符，类名，包名，父类，接口</span></span><br><span class="line">                classWriter.visit(Opcodes.V1_8, Opcodes.ACC_PUBLIC, <span class="string">&quot;Class&quot;</span> + i, <span class="literal">null</span>, <span class="string">&quot;java/lang/Object&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">                <span class="comment">//返回byte[]</span></span><br><span class="line">                <span class="type">byte</span>[] code = classWriter.toByteArray();</span><br><span class="line">                <span class="comment">//类的加载</span></span><br><span class="line">                test.defineClass(<span class="string">&quot;Class&quot;</span> + i, code, <span class="number">0</span>, code.length);<span class="comment">//Class对象</span></span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>不设置元空间的上限</strong></p>
<p>使用默认的 JVM 参数，元空间不设置上限</p>
<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10000</span></span><br></pre></td></tr></table></figure>

<p><strong>设置元空间的上限</strong></p>
<p>JVM 参数</p>
<p>-XX:MetaspaceSize&#x3D;10m -XX:MaxMetaspaceSize&#x3D;10m</p>
<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3331</span></span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.OutOfMemoryError: Compressed <span class="keyword">class</span> <span class="title class_">space</span></span><br><span class="line">	at java.lang.ClassLoader.defineClass1(Native Method)</span><br><span class="line">	at java.lang.ClassLoader.defineClass(ClassLoader.java:<span class="number">763</span>)</span><br><span class="line">	at java.lang.ClassLoader.defineClass(ClassLoader.java:<span class="number">642</span>)</span><br><span class="line">	at com.ysy.methodarea.OOMTest.main(OOMTest.java:<span class="number">29</span>)</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h3 id="如何解决OOM"><a href="#如何解决OOM" class="headerlink" title="如何解决OOM"></a>如何解决OOM</h3><ol>
<li>要解决<strong>OOM异常或heap space的异常</strong>，一般的手段是首先通过内存映像分析工具（如Ec1ipse Memory Analyzer）对dump出来的堆转储快照进行分析，重点是确认内存中的对象是否是必要的，也就是要先分清楚到底是出现了<strong>内存泄漏（Memory Leak）还是内存溢出（Memory Overflow）</strong></li>
<li><strong>内存泄漏</strong>就是有大量的引用指向某些对象，但是这些对象以后不会使用了，但是因为它们还和<strong>GC ROOT</strong>有关联，所以导致以后这些对象也不会被回收，这就是内存泄漏的问题</li>
<li>如果是内存泄漏，可进一步通过工具查看泄漏对象到<strong>GC Roots</strong>的引用链。于是就能找到泄漏对象是通过怎样的路径与<strong>GC Roots</strong>相关联并导致垃圾收集器无法自动回收它们的。掌握了泄漏对象的类型信息，以及<strong>GC Roots</strong>引用链的信息，就可以比较准确地定位出泄漏代码的位置。</li>
<li>如果不存在内存泄漏，换句话说就是内存中的对象确实都还必须存活着，那就应当检查虚拟机的堆参数（**-Xmx与-Xms**），与机器物理内存对比看是否还可以调大，从代码上检查是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少程序运行期的内存消耗。</li>
</ol>
<h1 id="方法区的内部结构"><a href="#方法区的内部结构" class="headerlink" title="方法区的内部结构"></a>方法区的内部结构</h1><h2 id="方法区存储什么？"><a href="#方法区存储什么？" class="headerlink" title="方法区存储什么？"></a>方法区存储什么？</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220719133159128.png" alt="image-20220719133159128"></p>
<ul>
<li>《深入理解Java虚拟机》书中对方法区（Method Area）存储内容描述如下：它用于存储已被虚拟机加载的<strong>类型信息、常量、静态变量、即时编译器编译后的代码缓存</strong>等。</li>
</ul>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220719133402240.png" alt="image-20220719133402240"></p>
<p><strong>类型信息</strong></p>
<p>对每个加载的类型（类class、接口interface、枚举enum、注解annotation），JVM必须在方法区中存储以下类型信息：</p>
<ol>
<li>这个类型的完整有效名称（全名&#x3D;包名.类名）</li>
<li>这个类型直接父类的完整有效名（对于interface或是java.lang.Object，都没有父类）</li>
<li>这个类型的修饰符（public，abstract，final的某个子集）</li>
<li>这个类型直接接口的一个有序列表</li>
</ol>
<p><strong>域（Field）信息</strong></p>
<blockquote>
<p>也就是我们常说的成员变量，域信息是比较官方的称呼</p>
</blockquote>
<ol>
<li><p>JVM必须在方法区中保存类型的所有域的相关信息以及域的声明顺序。</p>
</li>
<li><p>域的相关信息包括：域名称，域类型，域修饰符（public，private，protected，static，final，volatile，transient的某个子集）</p>
</li>
</ol>
<p><strong>方法（Method）信息</strong></p>
<p>JVM必须保存所有方法的以下信息，同域信息一样包括声明顺序：</p>
<ol>
<li>方法名称</li>
<li>方法的返回类型（包括 void 返回类型），void 在 Java 中对应的为 void.class</li>
<li>方法参数的数量和类型（按顺序）</li>
<li>方法的修饰符（public，private，protected，static，final，synchronized，native，abstract的一个子集）</li>
<li>方法的字节码（bytecodes）、操作数栈、局部变量表及大小（abstract和native方法除外）</li>
<li>异常表（abstract和native方法除外），异常表记录每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引</li>
</ol>
<p><strong>举例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试方法区的内部构成</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodInnerStrucTest</span> <span class="keyword">extends</span> <span class="title class_">Object</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;String&gt;,Serializable &#123;</span><br><span class="line">    <span class="comment">//属性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;测试方法的内部结构&quot;</span>;</span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="comment">//方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;count = &quot;</span> + count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">test2</span><span class="params">(<span class="type">int</span> cal)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line">            result = value / cal;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(String o)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>javap -v -p MethodInnerStrucTest.class &gt; test.txt</code></p>
<ul>
<li>反编译字节码文件，并输出值文本文件中，便于查看。参数 -p 确保能查看 private 权限类型的字段或方法</li>
</ul>
<p>字节码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br></pre></td><td class="code"><pre><span class="line">Classfile /D:/JavaProjects/jvm/out/production/jvm02/com/ysy/methodarea/MethodInnerStrucTest.<span class="keyword">class</span></span><br><span class="line">  <span class="title class_">Last</span> modified <span class="number">2022</span>-<span class="number">7</span>-<span class="number">19</span>; size <span class="number">1630</span> bytes</span><br><span class="line">  MD5 checksum 7f8bc6364c6d3121721810737a6d4d24</span><br><span class="line">  Compiled from <span class="string">&quot;MethodInnerStrucTest.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">com</span>.ysy.methodarea.MethodInnerStrucTest <span class="keyword">extends</span> <span class="title class_">java</span>.lang.Object <span class="keyword">implements</span> <span class="title class_">java</span>.lang.Comparable&lt;java.lang.String&gt;, java.io.Serializable</span><br><span class="line">  minor version: <span class="number">0</span></span><br><span class="line">  major version: <span class="number">52</span></span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #<span class="number">1</span> = Methodref          #<span class="number">18.</span>#<span class="number">52</span>        <span class="comment">// java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">   #<span class="number">2</span> = Fieldref           #<span class="number">17.</span>#<span class="number">53</span>        <span class="comment">// com/ysy/methodarea/MethodInnerStrucTest.num:I</span></span><br><span class="line">   #<span class="number">3</span> = Fieldref           #<span class="number">54.</span>#<span class="number">55</span>        <span class="comment">// java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">   #<span class="number">4</span> = Class              #<span class="number">56</span>            <span class="comment">// java/lang/StringBuilder</span></span><br><span class="line">   #<span class="number">5</span> = Methodref          #<span class="number">4.</span>#<span class="number">52</span>         <span class="comment">// java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">   #<span class="number">6</span> = String             #<span class="number">57</span>            <span class="comment">// count =</span></span><br><span class="line">   #<span class="number">7</span> = Methodref          #<span class="number">4.</span>#<span class="number">58</span>         <span class="comment">// java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span></span><br><span class="line">   #<span class="number">8</span> = Methodref          #<span class="number">4.</span>#<span class="number">59</span>         <span class="comment">// java/lang/StringBuilder.append:(I)Ljava/lang/StringBuilder;</span></span><br><span class="line">   #<span class="number">9</span> = Methodref          #<span class="number">4.</span>#<span class="number">60</span>         <span class="comment">// java/lang/StringBuilder.toString:()Ljava/lang/String;</span></span><br><span class="line">  #<span class="number">10</span> = Methodref          #<span class="number">61.</span>#<span class="number">62</span>        <span class="comment">// java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">  #<span class="number">11</span> = Class              #<span class="number">63</span>            <span class="comment">// java/lang/Exception</span></span><br><span class="line">  #<span class="number">12</span> = Methodref          #<span class="number">11.</span>#<span class="number">64</span>        <span class="comment">// java/lang/Exception.printStackTrace:()V</span></span><br><span class="line">  #<span class="number">13</span> = Class              #<span class="number">65</span>            <span class="comment">// java/lang/String</span></span><br><span class="line">  #<span class="number">14</span> = Methodref          #<span class="number">17.</span>#<span class="number">66</span>        <span class="comment">// com/ysy/methodarea/MethodInnerStrucTest.compareTo:(Ljava/lang/String;)I</span></span><br><span class="line">  #<span class="number">15</span> = String             #<span class="number">67</span>            <span class="comment">// 测试方法的内部结构</span></span><br><span class="line">  #<span class="number">16</span> = Fieldref           #<span class="number">17.</span>#<span class="number">68</span>        <span class="comment">// com/ysy/methodarea/MethodInnerStrucTest.str:Ljava/lang/String;</span></span><br><span class="line">  #<span class="number">17</span> = Class              #<span class="number">69</span>            <span class="comment">// com/ysy/methodarea/MethodInnerStrucTest</span></span><br><span class="line">  #<span class="number">18</span> = Class              #<span class="number">70</span>            <span class="comment">// java/lang/Object</span></span><br><span class="line">  #<span class="number">19</span> = Class              #<span class="number">71</span>            <span class="comment">// java/lang/Comparable</span></span><br><span class="line">  #<span class="number">20</span> = Class              #<span class="number">72</span>            <span class="comment">// java/io/Serializable</span></span><br><span class="line">  #<span class="number">21</span> = Utf8               num</span><br><span class="line">  #<span class="number">22</span> = Utf8               I</span><br><span class="line">  #<span class="number">23</span> = Utf8               str</span><br><span class="line">  #<span class="number">24</span> = Utf8               Ljava/lang/String;</span><br><span class="line">  #<span class="number">25</span> = Utf8               &lt;init&gt;</span><br><span class="line">  #<span class="number">26</span> = Utf8               ()V</span><br><span class="line">  #<span class="number">27</span> = Utf8               Code</span><br><span class="line">  #<span class="number">28</span> = Utf8               LineNumberTable</span><br><span class="line">  #<span class="number">29</span> = Utf8               LocalVariableTable</span><br><span class="line">  #<span class="number">30</span> = Utf8               <span class="built_in">this</span></span><br><span class="line">  #<span class="number">31</span> = Utf8               Lcom/ysy/methodarea/MethodInnerStrucTest;</span><br><span class="line">  #<span class="number">32</span> = Utf8               test1</span><br><span class="line">  #<span class="number">33</span> = Utf8               count</span><br><span class="line">  #<span class="number">34</span> = Utf8               test2</span><br><span class="line">  #<span class="number">35</span> = Utf8               (I)I</span><br><span class="line">  #<span class="number">36</span> = Utf8               value</span><br><span class="line">  #<span class="number">37</span> = Utf8               e</span><br><span class="line">  #<span class="number">38</span> = Utf8               Ljava/lang/Exception;</span><br><span class="line">  #<span class="number">39</span> = Utf8               cal</span><br><span class="line">  #<span class="number">40</span> = Utf8               result</span><br><span class="line">  #<span class="number">41</span> = Utf8               StackMapTable</span><br><span class="line">  #<span class="number">42</span> = Class              #<span class="number">63</span>            <span class="comment">// java/lang/Exception</span></span><br><span class="line">  #<span class="number">43</span> = Utf8               compareTo</span><br><span class="line">  #<span class="number">44</span> = Utf8               (Ljava/lang/String;)I</span><br><span class="line">  #<span class="number">45</span> = Utf8               o</span><br><span class="line">  #<span class="number">46</span> = Utf8               (Ljava/lang/Object;)I</span><br><span class="line">  #<span class="number">47</span> = Utf8               &lt;clinit&gt;</span><br><span class="line">  #<span class="number">48</span> = Utf8               Signature</span><br><span class="line">  #<span class="number">49</span> = Utf8               Ljava/lang/Object;Ljava/lang/Comparable&lt;Ljava/lang/String;&gt;;Ljava/io/Serializable;</span><br><span class="line">  #<span class="number">50</span> = Utf8               SourceFile</span><br><span class="line">  #<span class="number">51</span> = Utf8               MethodInnerStrucTest.java</span><br><span class="line">  #<span class="number">52</span> = NameAndType        #<span class="number">25</span>:#<span class="number">26</span>        <span class="comment">// &quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">  #<span class="number">53</span> = NameAndType        #<span class="number">21</span>:#<span class="number">22</span>        <span class="comment">// num:I</span></span><br><span class="line">  #<span class="number">54</span> = Class              #<span class="number">73</span>            <span class="comment">// java/lang/System</span></span><br><span class="line">  #<span class="number">55</span> = NameAndType        #<span class="number">74</span>:#<span class="number">75</span>        <span class="comment">// out:Ljava/io/PrintStream;</span></span><br><span class="line">  #<span class="number">56</span> = Utf8               java/lang/StringBuilder</span><br><span class="line">  #<span class="number">57</span> = <span class="type">Utf8</span>               <span class="variable">count</span> <span class="operator">=</span></span><br><span class="line">  #<span class="number">58</span> = NameAndType        #<span class="number">76</span>:#<span class="number">77</span>        <span class="comment">// append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span></span><br><span class="line">  #<span class="number">59</span> = NameAndType        #<span class="number">76</span>:#<span class="number">78</span>        <span class="comment">// append:(I)Ljava/lang/StringBuilder;</span></span><br><span class="line">  #<span class="number">60</span> = NameAndType        #<span class="number">79</span>:#<span class="number">80</span>        <span class="comment">// toString:()Ljava/lang/String;</span></span><br><span class="line">  #<span class="number">61</span> = Class              #<span class="number">81</span>            <span class="comment">// java/io/PrintStream</span></span><br><span class="line">  #<span class="number">62</span> = NameAndType        #<span class="number">82</span>:#<span class="number">83</span>        <span class="comment">// println:(Ljava/lang/String;)V</span></span><br><span class="line">  #<span class="number">63</span> = Utf8               java/lang/Exception</span><br><span class="line">  #<span class="number">64</span> = NameAndType        #<span class="number">84</span>:#<span class="number">26</span>        <span class="comment">// printStackTrace:()V</span></span><br><span class="line">  #<span class="number">65</span> = Utf8               java/lang/String</span><br><span class="line">  #<span class="number">66</span> = NameAndType        #<span class="number">43</span>:#<span class="number">44</span>        <span class="comment">// compareTo:(Ljava/lang/String;)I</span></span><br><span class="line">  #<span class="number">67</span> = Utf8               测试方法的内部结构</span><br><span class="line">  #<span class="number">68</span> = NameAndType        #<span class="number">23</span>:#<span class="number">24</span>        <span class="comment">// str:Ljava/lang/String;</span></span><br><span class="line">  #<span class="number">69</span> = Utf8               com/ysy/methodarea/MethodInnerStrucTest</span><br><span class="line">  #<span class="number">70</span> = Utf8               java/lang/Object</span><br><span class="line">  #<span class="number">71</span> = Utf8               java/lang/Comparable</span><br><span class="line">  #<span class="number">72</span> = Utf8               java/io/Serializable</span><br><span class="line">  #<span class="number">73</span> = Utf8               java/lang/System</span><br><span class="line">  #<span class="number">74</span> = Utf8               out</span><br><span class="line">  #<span class="number">75</span> = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #<span class="number">76</span> = Utf8               append</span><br><span class="line">  #<span class="number">77</span> = Utf8               (Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">  #<span class="number">78</span> = Utf8               (I)Ljava/lang/StringBuilder;</span><br><span class="line">  #<span class="number">79</span> = Utf8               toString</span><br><span class="line">  #<span class="number">80</span> = Utf8               ()Ljava/lang/String;</span><br><span class="line">  #<span class="number">81</span> = Utf8               java/io/PrintStream</span><br><span class="line">  #<span class="number">82</span> = Utf8               println</span><br><span class="line">  #<span class="number">83</span> = Utf8               (Ljava/lang/String;)V</span><br><span class="line">  #<span class="number">84</span> = Utf8               printStackTrace</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> num;</span><br><span class="line">    descriptor: I</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> java.lang.String str;</span><br><span class="line">    descriptor: Ljava/lang/String;</span><br><span class="line">    flags: ACC_PRIVATE, ACC_STATIC</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> com.ysy.methodarea.MethodInnerStrucTest();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">         <span class="number">4</span>: aload_0</span><br><span class="line">         <span class="number">5</span>: bipush        <span class="number">10</span></span><br><span class="line">         <span class="number">7</span>: putfield      #<span class="number">2</span>                  <span class="comment">// Field num:I</span></span><br><span class="line">        <span class="number">10</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">7</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">9</span>: <span class="number">4</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>      <span class="number">11</span>     <span class="number">0</span>  <span class="built_in">this</span>   Lcom/ysy/methodarea/MethodInnerStrucTest;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">3</span>, locals=<span class="number">2</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: bipush        <span class="number">20</span></span><br><span class="line">         <span class="number">2</span>: istore_1</span><br><span class="line">         <span class="number">3</span>: getstatic     #<span class="number">3</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">         <span class="number">6</span>: <span class="keyword">new</span>           #<span class="number">4</span>                  <span class="comment">// class java/lang/StringBuilder</span></span><br><span class="line">         <span class="number">9</span>: dup</span><br><span class="line">        <span class="number">10</span>: invokespecial #<span class="number">5</span>                  <span class="comment">// Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">        <span class="number">13</span>: ldc           #<span class="number">6</span>                  <span class="comment">// String count =</span></span><br><span class="line">        <span class="number">15</span>: invokevirtual #<span class="number">7</span>                  <span class="comment">// Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span></span><br><span class="line">        <span class="number">18</span>: iload_1</span><br><span class="line">        <span class="number">19</span>: invokevirtual #<span class="number">8</span>                  <span class="comment">// Method java/lang/StringBuilder.append:(I)Ljava/lang/StringBuilder;</span></span><br><span class="line">        <span class="number">22</span>: invokevirtual #<span class="number">9</span>                  <span class="comment">// Method java/lang/StringBuilder.toString:()Ljava/lang/String;</span></span><br><span class="line">        <span class="number">25</span>: invokevirtual #<span class="number">10</span>                 <span class="comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">        <span class="number">28</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">14</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">15</span>: <span class="number">3</span></span><br><span class="line">        line <span class="number">16</span>: <span class="number">28</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>      <span class="number">29</span>     <span class="number">0</span>  <span class="built_in">this</span>   Lcom/ysy/methodarea/MethodInnerStrucTest;</span><br><span class="line">            <span class="number">3</span>      <span class="number">26</span>     <span class="number">1</span> count   I</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">test2</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line">    descriptor: (I)I</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">3</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: iconst_0</span><br><span class="line">         <span class="number">1</span>: istore_1</span><br><span class="line">         <span class="number">2</span>: bipush        <span class="number">30</span></span><br><span class="line">         <span class="number">4</span>: istore_2</span><br><span class="line">         <span class="number">5</span>: iload_2</span><br><span class="line">         <span class="number">6</span>: iload_0</span><br><span class="line">         <span class="number">7</span>: idiv</span><br><span class="line">         <span class="number">8</span>: istore_1</span><br><span class="line">         <span class="number">9</span>: goto          <span class="number">17</span></span><br><span class="line">        <span class="number">12</span>: astore_2</span><br><span class="line">        <span class="number">13</span>: aload_2</span><br><span class="line">        <span class="number">14</span>: invokevirtual #<span class="number">12</span>                 <span class="comment">// Method java/lang/Exception.printStackTrace:()V</span></span><br><span class="line">        <span class="number">17</span>: iload_1</span><br><span class="line">        <span class="number">18</span>: ireturn</span><br><span class="line">      Exception table:</span><br><span class="line">         from    to  target type</span><br><span class="line">             <span class="number">2</span>     <span class="number">9</span>    <span class="number">12</span>   Class java/lang/Exception</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">18</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">20</span>: <span class="number">2</span></span><br><span class="line">        line <span class="number">21</span>: <span class="number">5</span></span><br><span class="line">        line <span class="number">24</span>: <span class="number">9</span></span><br><span class="line">        line <span class="number">22</span>: <span class="number">12</span></span><br><span class="line">        line <span class="number">23</span>: <span class="number">13</span></span><br><span class="line">        line <span class="number">25</span>: <span class="number">17</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">5</span>       <span class="number">4</span>     <span class="number">2</span> value   I</span><br><span class="line">           <span class="number">13</span>       <span class="number">4</span>     <span class="number">2</span>     e   Ljava/lang/Exception;</span><br><span class="line">            <span class="number">0</span>      <span class="number">19</span>     <span class="number">0</span>   cal   I</span><br><span class="line">            <span class="number">2</span>      <span class="number">17</span>     <span class="number">1</span> result   I</span><br><span class="line">      StackMapTable: number_of_entries = <span class="number">2</span></span><br><span class="line">        frame_type = <span class="number">255</span> <span class="comment">/* full_frame */</span></span><br><span class="line">          offset_delta = <span class="number">12</span></span><br><span class="line">          locals = [ <span class="type">int</span>, <span class="type">int</span> ]</span><br><span class="line">          stack = [ <span class="keyword">class</span> <span class="title class_">java</span>/lang/Exception ]</span><br><span class="line">        frame_type = <span class="number">4</span> <span class="comment">/* same */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(java.lang.String)</span>;</span><br><span class="line">    descriptor: (Ljava/lang/String;)I</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">2</span>, args_size=<span class="number">2</span></span><br><span class="line">         <span class="number">0</span>: iconst_0</span><br><span class="line">         <span class="number">1</span>: ireturn</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">30</span>: <span class="number">0</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">2</span>     <span class="number">0</span>  <span class="built_in">this</span>   Lcom/ysy/methodarea/MethodInnerStrucTest;</span><br><span class="line">            <span class="number">0</span>       <span class="number">2</span>     <span class="number">1</span>     o   Ljava/lang/String;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(java.lang.Object)</span>;</span><br><span class="line">    descriptor: (Ljava/lang/Object;)I</span><br><span class="line">    flags: ACC_PUBLIC, ACC_BRIDGE, ACC_SYNTHETIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">2</span>, args_size=<span class="number">2</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="number">1</span>: aload_1</span><br><span class="line">         <span class="number">2</span>: checkcast     #<span class="number">13</span>                 <span class="comment">// class java/lang/String</span></span><br><span class="line">         <span class="number">5</span>: invokevirtual #<span class="number">14</span>                 <span class="comment">// Method compareTo:(Ljava/lang/String;)I</span></span><br><span class="line">         <span class="number">8</span>: ireturn</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">7</span>: <span class="number">0</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">9</span>     <span class="number">0</span>  <span class="built_in">this</span>   Lcom/ysy/methodarea/MethodInnerStrucTest;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> &#123;&#125;;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">0</span>, args_size=<span class="number">0</span></span><br><span class="line">         <span class="number">0</span>: ldc           #<span class="number">15</span>                 <span class="comment">// String 测试方法的内部结构</span></span><br><span class="line">         <span class="number">2</span>: putstatic     #<span class="number">16</span>                 <span class="comment">// Field str:Ljava/lang/String;</span></span><br><span class="line">         <span class="number">5</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">10</span>: <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">Signature: #<span class="number">49</span>                          <span class="comment">// Ljava/lang/Object;Ljava/lang/Comparable&lt;Ljava/lang/String;&gt;;Ljava/io/Serializable;</span></span><br><span class="line">SourceFile: <span class="string">&quot;MethodInnerStrucTest.java&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>类型信息</strong></p>
<p>在运行时方法区中，类信息中记录了哪个加载器加载了该类，同时类加载器也记录了它加载了哪些类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类型信息      </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">com</span>.atguigu.java.MethodInnerStrucTest <span class="keyword">extends</span> <span class="title class_">java</span>.lang.Object <span class="keyword">implements</span> <span class="title class_">java</span>.lang.Comparable&lt;java.lang.String&gt;, java.io.Serializable</span><br></pre></td></tr></table></figure>

<p><strong>域信息</strong></p>
<ol>
<li>descriptor: I 表示字段类型为 Integer</li>
<li>flags: ACC_PUBLIC 表示字段权限修饰符为 public</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//域信息</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> num;</span><br><span class="line">    descriptor: I</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> java.lang.String str;</span><br><span class="line">    descriptor: Ljava/lang/String;</span><br><span class="line">    flags: ACC_PRIVATE, ACC_STATIC</span><br></pre></td></tr></table></figure>

<p><strong>方法信息</strong></p>
<ol>
<li>descriptor: ()V 表示方法返回值类型为 void</li>
<li>flags: ACC_PUBLIC 表示方法权限修饰符为 public</li>
<li>stack&#x3D;3 表示操作数栈深度为 3</li>
<li>locals&#x3D;2 表示局部变量个数为 2 个（实例方法包含 this）</li>
<li>test1() 方法虽然没有参数，但是其 args_size&#x3D;1 ，这时因为将 this 作为了参数</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">3</span>, locals=<span class="number">2</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: bipush        <span class="number">20</span></span><br><span class="line">         <span class="number">2</span>: istore_1</span><br><span class="line">         <span class="number">3</span>: getstatic     #<span class="number">3</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">         <span class="number">6</span>: <span class="keyword">new</span>           #<span class="number">4</span>                  <span class="comment">// class java/lang/StringBuilder</span></span><br><span class="line">         <span class="number">9</span>: dup</span><br><span class="line">        <span class="number">10</span>: invokespecial #<span class="number">5</span>                  <span class="comment">// Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">        <span class="number">13</span>: ldc           #<span class="number">6</span>                  <span class="comment">// String count =</span></span><br><span class="line">        <span class="number">15</span>: invokevirtual #<span class="number">7</span>                  <span class="comment">// Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span></span><br><span class="line">        <span class="number">18</span>: iload_1</span><br><span class="line">        <span class="number">19</span>: invokevirtual #<span class="number">8</span>                  <span class="comment">// Method java/lang/StringBuilder.append:(I)Ljava/lang/StringBuilder;</span></span><br><span class="line">        <span class="number">22</span>: invokevirtual #<span class="number">9</span>                  <span class="comment">// Method java/lang/StringBuilder.toString:()Ljava/lang/String;</span></span><br><span class="line">        <span class="number">25</span>: invokevirtual #<span class="number">10</span>                 <span class="comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">        <span class="number">28</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">17</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">18</span>: <span class="number">3</span></span><br><span class="line">        line <span class="number">19</span>: <span class="number">28</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>      <span class="number">29</span>     <span class="number">0</span>  <span class="built_in">this</span>   Lcom/atguigu/java/MethodInnerStrucTest;</span><br><span class="line">            <span class="number">3</span>      <span class="number">26</span>     <span class="number">1</span> count   I</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="non-final-类型的类变量"><a href="#non-final-类型的类变量" class="headerlink" title="non-final 类型的类变量"></a>non-final 类型的类变量</h2><ol>
<li><p>静态变量和类关联在一起，随着类的加载而加载，他们成为类数据在逻辑上的一部分</p>
</li>
<li><p>类变量被类的所有实例共享，即使没有类实例时，你也可以访问它</p>
</li>
</ol>
<p><strong>举例</strong></p>
<ol>
<li>如下代码所示，即使我们把order设置为null，也不会出现空指针异常</li>
<li>这更加表明了 static 类型的字段和方法随着类的加载而加载，并不属于特定的类实例</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodAreaTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        order.hello();</span><br><span class="line">        System.out.println(order.count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Order</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello!</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<h3 id="全局常量：static-final"><a href="#全局常量：static-final" class="headerlink" title="全局常量：static final"></a>全局常量：static final</h3><ol>
<li><p>全局常量就是使用 static final 进行修饰</p>
</li>
<li><p>被声明为final的类变量的处理方法则不同，每个全局常量在编译的时候就会被分配了。</p>
</li>
</ol>
<p>查看上面代码，这部分的字节码指令</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Order</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> count;</span><br><span class="line">    descriptor: I</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> number;</span><br><span class="line">    descriptor: I</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC, ACC_FINAL</span><br><span class="line">    ConstantValue: <span class="type">int</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>可以发现 staitc和final同时修饰的number 的值在编译上的时候已经写死在字节码文件中了。</p>
<h2 id="运行时常量池-VS-常量池"><a href="#运行时常量池-VS-常量池" class="headerlink" title="运行时常量池 VS 常量池"></a>运行时常量池 VS 常量池</h2><blockquote>
<p><strong>官方文档</strong>：<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html</a></p>
</blockquote>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220719135454903.png" alt="image-20220719135454903"></p>
<ol>
<li>方法区，内部包含了运行时常量池</li>
<li>字节码文件，内部包含了常量池。（之前的字节码文件中已经看到了很多Constant pool的东西，这个就是常量池）</li>
<li>要弄清楚方法区，需要理解清楚ClassFile，因为加载类的信息都在方法区。</li>
<li>要弄清楚方法区的运行时常量池，需要理解清楚ClassFile中的常量池。</li>
</ol>
<h3 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h3><ol>
<li>一个有效的字节码文件中除了包含<strong>类的版本信息、字段、方法以及接口</strong>等描述符信息外。还包含一项信息就是<strong>常量池表</strong>（<strong>Constant Pool Table</strong>），包括各种字面量和对类型、域和方法的符号引用。</li>
<li>字面量： 10 ， “我是某某”这种数字和字符串都是字面量</li>
</ol>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220719135817127.png" alt="image-20220719135817127"></p>
<p><strong>为什么需要常量池？</strong></p>
<ul>
<li>一个java源文件中的类、接口，编译后产生一个字节码文件。而Java中的字节码需要数据支持，通常这种数据会很大以至于不能直接存到字节码里，换另一种方式，可以存到常量池。这个字节码包含了指向常量池的引用。在动态链接的时候会用到运行时常量池。</li>
</ul>
<p>比如：如下的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ol>
<li>虽然上述代码只有194字节，但是里面却使用了String、System、PrintStream及Object等结构。</li>
<li>比如说我们这个文件中有6个地方用到了”hello”这个字符串，如果不用常量池，就需要在6个地方全写一遍，造成臃肿。我们可以将”hello”等所需用到的结构信息记录在常量池中，并通过<strong>引用的方式</strong>，来加载、调用所需的结构</li>
<li>这里的代码量其实很少了，如果代码多的话，引用的结构将会更多，这里就需要用到常量池了。</li>
</ol>
<img src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_006/0011.png">

<p><strong>常量池中有啥？</strong></p>
<ol>
<li>数量值</li>
<li>字符串值</li>
<li>类引用</li>
<li>字段引用</li>
<li>方法引用</li>
</ol>
<p>MethodInnerStrucTest 的 test1方法的字节码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">0</span> bipush <span class="number">20</span></span><br><span class="line"> <span class="number">2</span> istore_1</span><br><span class="line"> <span class="number">3</span> getstatic #<span class="number">3</span> &lt;java/lang/System.out&gt;</span><br><span class="line"> <span class="number">6</span> <span class="keyword">new</span> #<span class="number">4</span> &lt;java/lang/StringBuilder&gt;</span><br><span class="line"> <span class="number">9</span> dup</span><br><span class="line"><span class="number">10</span> invokespecial #<span class="number">5</span> &lt;java/lang/StringBuilder.&lt;init&gt;&gt;</span><br><span class="line"><span class="number">13</span> ldc #<span class="number">6</span> &lt;count = &gt;</span><br><span class="line"><span class="number">15</span> invokevirtual #<span class="number">7</span> &lt;java/lang/StringBuilder.append&gt;</span><br><span class="line"><span class="number">18</span> iload_1</span><br><span class="line"><span class="number">19</span> invokevirtual #<span class="number">8</span> &lt;java/lang/StringBuilder.append&gt;</span><br><span class="line"><span class="number">22</span> invokevirtual #<span class="number">9</span> &lt;java/lang/StringBuilder.toString&gt;</span><br><span class="line"><span class="number">25</span> invokevirtual #<span class="number">10</span> &lt;java/io/PrintStream.println&gt;</span><br><span class="line"><span class="number">28</span> <span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<p>1、#3，#5等等这些带# 的，都是引用了常量池。</p>
<p><strong>常量池总结</strong></p>
<p>常量池、可以看做是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等类型。</p>
<h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><ol>
<li><p>运行时常量池（Runtime Constant Pool）是方法区的一部分。</p>
</li>
<li><p>常量池表（Constant Pool Table）是Class字节码文件的一部分，用于存放编译期生成的各种字面量与符号引用，<strong>这部分内容将在类加载后存放到方法区的运行时常量池中</strong>。（运行时常量池就是常量池在程序运行时的称呼）</p>
</li>
<li><p>运行时常量池，在加载类和接口到虚拟机后，就会创建对应的运行时常量池。</p>
</li>
<li><p>JVM为每个已加载的类型（类或接口）都维护一个常量池。池中的数据项像数组项一样，是<strong>通过索引访问</strong>的。</p>
</li>
<li><p>运行时常量池中包含多种不同的常量，包括编译期就已经明确的数值字面量，也包括到运行期解析后才能够获得的方法或者字段引用。<strong>此时不再是常量池中的符号地址了，这里换为真实地址</strong>。</p>
<ul>
<li>运行时常量池，相对于Class文件常量池的另一重要特征是：<strong>具备动态性</strong>。</li>
</ul>
</li>
<li><p>运行时常量池类似于传统编程语言中的符号表（symbol table），但是它所包含的数据却比符号表要更加丰富一些。</p>
</li>
<li><p>当创建类或接口的运行时常量池时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大值，则JVM会抛OutofMemoryError异常。</p>
</li>
</ol>
<h1 id="方法区的使用举例"><a href="#方法区的使用举例" class="headerlink" title="方法区的使用举例"></a>方法区的使用举例</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodAreaDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">500</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> x / y;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">50</span>;</span><br><span class="line">        System.out.println(a + b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>字节码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">Classfile /D:/JavaProjects/jvm/out/production/jvm02/com/ysy/methodarea/MethodAreaDemo.<span class="keyword">class</span></span><br><span class="line">  <span class="title class_">Last</span> modified <span class="number">2022</span>-<span class="number">7</span>-<span class="number">19</span>; size <span class="number">642</span> bytes</span><br><span class="line">  MD5 checksum db32eed8d47a557ade3b6d5d481463be</span><br><span class="line">  Compiled from <span class="string">&quot;MethodAreaDemo.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">com</span>.ysy.methodarea.MethodAreaDemo</span><br><span class="line">  minor version: <span class="number">0</span></span><br><span class="line">  major version: <span class="number">52</span></span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #<span class="number">1</span> = Methodref          #<span class="number">5.</span>#<span class="number">24</span>         <span class="comment">// java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">   #<span class="number">2</span> = Fieldref           #<span class="number">25.</span>#<span class="number">26</span>        <span class="comment">// java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">   #<span class="number">3</span> = Methodref          #<span class="number">27.</span>#<span class="number">28</span>        <span class="comment">// java/io/PrintStream.println:(I)V</span></span><br><span class="line">   #<span class="number">4</span> = Class              #<span class="number">29</span>            <span class="comment">// com/ysy/methodarea/MethodAreaDemo</span></span><br><span class="line">   #<span class="number">5</span> = Class              #<span class="number">30</span>            <span class="comment">// java/lang/Object</span></span><br><span class="line">   #<span class="number">6</span> = Utf8               &lt;init&gt;</span><br><span class="line">   #<span class="number">7</span> = Utf8               ()V</span><br><span class="line">   #<span class="number">8</span> = Utf8               Code</span><br><span class="line">   #<span class="number">9</span> = Utf8               LineNumberTable</span><br><span class="line">  #<span class="number">10</span> = Utf8               LocalVariableTable</span><br><span class="line">  #<span class="number">11</span> = Utf8               <span class="built_in">this</span></span><br><span class="line">  #<span class="number">12</span> = Utf8               Lcom/ysy/methodarea/MethodAreaDemo;</span><br><span class="line">  #<span class="number">13</span> = Utf8               main</span><br><span class="line">  #<span class="number">14</span> = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">  #<span class="number">15</span> = Utf8               args</span><br><span class="line">  #<span class="number">16</span> = Utf8               [Ljava/lang/String;</span><br><span class="line">  #<span class="number">17</span> = Utf8               x</span><br><span class="line">  #<span class="number">18</span> = Utf8               I</span><br><span class="line">  #<span class="number">19</span> = Utf8               y</span><br><span class="line">  #<span class="number">20</span> = Utf8               a</span><br><span class="line">  #<span class="number">21</span> = Utf8               b</span><br><span class="line">  #<span class="number">22</span> = Utf8               SourceFile</span><br><span class="line">  #<span class="number">23</span> = Utf8               MethodAreaDemo.java</span><br><span class="line">  #<span class="number">24</span> = NameAndType        #<span class="number">6</span>:#<span class="number">7</span>          <span class="comment">// &quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">  #<span class="number">25</span> = Class              #<span class="number">31</span>            <span class="comment">// java/lang/System</span></span><br><span class="line">  #<span class="number">26</span> = NameAndType        #<span class="number">32</span>:#<span class="number">33</span>        <span class="comment">// out:Ljava/io/PrintStream;</span></span><br><span class="line">  #<span class="number">27</span> = Class              #<span class="number">34</span>            <span class="comment">// java/io/PrintStream</span></span><br><span class="line">  #<span class="number">28</span> = NameAndType        #<span class="number">35</span>:#<span class="number">36</span>        <span class="comment">// println:(I)V</span></span><br><span class="line">  #<span class="number">29</span> = Utf8               com/ysy/methodarea/MethodAreaDemo</span><br><span class="line">  #<span class="number">30</span> = Utf8               java/lang/Object</span><br><span class="line">  #<span class="number">31</span> = Utf8               java/lang/System</span><br><span class="line">  #<span class="number">32</span> = Utf8               out</span><br><span class="line">  #<span class="number">33</span> = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #<span class="number">34</span> = Utf8               java/io/PrintStream</span><br><span class="line">  #<span class="number">35</span> = Utf8               println</span><br><span class="line">  #<span class="number">36</span> = Utf8               (I)V</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> com.ysy.methodarea.MethodAreaDemo();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">         <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">3</span>: <span class="number">0</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">5</span>     <span class="number">0</span>  <span class="built_in">this</span>   Lcom/ysy/methodarea/MethodAreaDemo;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(java.lang.String[])</span>;</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">3</span>, locals=<span class="number">5</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: sipush        <span class="number">500</span></span><br><span class="line">         <span class="number">3</span>: istore_1</span><br><span class="line">         <span class="number">4</span>: bipush        <span class="number">100</span></span><br><span class="line">         <span class="number">6</span>: istore_2</span><br><span class="line">         <span class="number">7</span>: iload_1</span><br><span class="line">         <span class="number">8</span>: iload_2</span><br><span class="line">         <span class="number">9</span>: idiv</span><br><span class="line">        <span class="number">10</span>: istore_3</span><br><span class="line">        <span class="number">11</span>: bipush        <span class="number">50</span></span><br><span class="line">        <span class="number">13</span>: istore        <span class="number">4</span></span><br><span class="line">        <span class="number">15</span>: getstatic     #<span class="number">2</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">        <span class="number">18</span>: iload_3</span><br><span class="line">        <span class="number">19</span>: iload         <span class="number">4</span></span><br><span class="line">        <span class="number">21</span>: iadd</span><br><span class="line">        <span class="number">22</span>: invokevirtual #<span class="number">3</span>                  <span class="comment">// Method java/io/PrintStream.println:(I)V</span></span><br><span class="line">        <span class="number">25</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">5</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">6</span>: <span class="number">4</span></span><br><span class="line">        line <span class="number">7</span>: <span class="number">7</span></span><br><span class="line">        line <span class="number">8</span>: <span class="number">11</span></span><br><span class="line">        line <span class="number">9</span>: <span class="number">15</span></span><br><span class="line">        line <span class="number">10</span>: <span class="number">25</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>      <span class="number">26</span>     <span class="number">0</span>  args   [Ljava/lang/String;</span><br><span class="line">            <span class="number">4</span>      <span class="number">22</span>     <span class="number">1</span>     x   I</span><br><span class="line">            <span class="number">7</span>      <span class="number">19</span>     <span class="number">2</span>     y   I</span><br><span class="line">           <span class="number">11</span>      <span class="number">15</span>     <span class="number">3</span>     a   I</span><br><span class="line">           <span class="number">15</span>      <span class="number">11</span>     <span class="number">4</span>     b   I</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: <span class="string">&quot;MethodAreaDemo.java&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="图解字节码指令执行流程"><a href="#图解字节码指令执行流程" class="headerlink" title="图解字节码指令执行流程"></a>图解字节码指令执行流程</h3><p>1、初始状态</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220719141526151.png" alt="image-20220719141526151"></p>
<p>2、首先将操作数500压入操作数栈中</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220719141655132.png"></p>
<p>3、然后操作数 500 从操作数栈中取出，存储到局部变量表中索引为 1 的位置</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220719141740626.png"></p>
<p>4、</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220719141900727.png" alt="image-20220719141900727"></p>
<p>5、</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220719141922429.png" alt="image-20220719141922429"></p>
<p>6、</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220719142000240.png" alt="image-20220719142000240"></p>
<p>7、</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220719142024493.png" alt="image-20220719142024493"></p>
<p>8、</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220719142158460.png" alt="image-20220719142158460"></p>
<p>9、</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220719142216996.png" alt="image-20220719142216996"></p>
<p>10、</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220719142237318.png" alt="image-20220719142237318"></p>
<p>11、图片写错了是#25和#26（获得System类）</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220719142324555.png" alt="image-20220719142324555"></p>
<p>12、</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220719142527219.png" alt="image-20220719142527219"></p>
<p>13、</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220719142558500.png" alt="image-20220719142558500"></p>
<p>15、执行加法运算后，将计算结果放在操作数栈顶</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220719142635557.png" alt="image-20220719142635557"></p>
<p>16、就是真正的打印</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220719142613281.png" alt="image-20220719142613281"></p>
<p>17、</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220719142813644.png" alt="image-20220719142813644"></p>
<p><strong>符号引用 –&gt; 直接引用</strong></p>
<ol>
<li>上面代码调用 System.out.println() 方法时，首先需要看看 System 类有没有加载，再看看 PrintStream 类有没有加载</li>
<li>如果没有加载，则执行加载，执行时，将常量池中的符号引用（字面量）转换为运行时常量池的直接引用（真正的地址值）</li>
</ol>
<h1 id="方法区演进细节"><a href="#方法区演进细节" class="headerlink" title="方法区演进细节"></a>方法区演进细节</h1><h2 id="永久代演进过程"><a href="#永久代演进过程" class="headerlink" title="永久代演进过程"></a>永久代演进过程</h2><ol>
<li><p>首先明确：<strong>只有Hotspot才有永久代</strong>。BEA JRockit、IBMJ9等来说，是不存在永久代的概念的。原则上如何实现方法区属于虚拟机实现细节，不受《Java虚拟机规范》管束，并不要求统一</p>
</li>
<li><p>Hotspot中方法区的变化：</p>
</li>
</ol>
<table>
<thead>
<tr>
<th>JDK1.6及以前</th>
<th align="left">有永久代（permanent generation），静态变量存储在永久代上</th>
</tr>
</thead>
<tbody><tr>
<td>JDK1.7</td>
<td align="left">有永久代，但已经逐步 “去永久代”，<strong>字符串常量池，静态变量移除，保存在堆中</strong></td>
</tr>
<tr>
<td>JDK1.8</td>
<td align="left">无永久代，类型信息，字段，方法，常量保存在本地内存的元空间，但字符串常量池、静态变量仍然在堆中。</td>
</tr>
</tbody></table>
<p><strong>JDK6</strong></p>
<p>方法区由永久代实现，使用 JVM 虚拟机内存（虚拟的内存）</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220719151237691.png" alt="image-20220719151237691"></p>
<p><strong>JDK7</strong></p>
<p>方法区由永久代实现，使用 JVM 虚拟机内存</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220719151316363.png" alt="image-20220719151316363"></p>
<p><strong>JDK8</strong></p>
<p>方法区由元空间实现，使用物理机本地内存</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220719151340845.png" alt="image-20220719151340845"></p>
<h3 id="永久代为什么要被元空间替代？"><a href="#永久代为什么要被元空间替代？" class="headerlink" title="永久代为什么要被元空间替代？"></a>永久代为什么要被元空间替代？</h3><blockquote>
<p><strong>官方文档</strong>：<a target="_blank" rel="noopener" href="http://openjdk.java.net/jeps/122">http://openjdk.java.net/jeps/122</a></p>
</blockquote>
<ol>
<li>随着Java8的到来，HotSpot VM中再也见不到永久代了。但是这并不意味着类的元数据信息也消失了。这些数据被移到了一个与堆不相连的本地内存区域，这个区域叫做元空间（Metaspace）。</li>
<li>由于类的元数据分配在本地内存中，元空间的最大可分配空间就是系统可用内存空间。</li>
<li>这项改动是很有必要的，原因有：<ol>
<li><strong>为永久代设置空间大小是很难确定的。</strong>在某些场景下，如果动态加载类过多，容易产生Perm区的OOM。比如某个实际Web工程中，因为功能点比较多，在运行过程中，要不断动态加载很多类，经常出现致命错误。<code>Exception in thread &#39;dubbo client x.x connector&#39; java.lang.OutOfMemoryError:PermGen space</code>而元空间和永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。 因此，默认情况下，元空间的大小仅受本地内存限制。</li>
<li><strong>对永久代进行调优是很困难的。</strong>方法区的垃圾收集主要回收两部分内容：<strong>常量池中废弃的常量和不再用的类型</strong>，方法区的调优主要是为了降低<strong>Full GC</strong><ol>
<li>有些人认为方法区（如HotSpot虚拟机中的元空间或者永久代）是没有垃圾收集行为的，其实不然。《Java虚拟机规范》对方法区的约束是非常宽松的，提到过可以不要求虚拟机在方法区中实现垃圾收集。事实上也确实有未实现或未能完整实现方法区类型卸载的收集器存在（如JDK11时期的ZGC收集器就不支持类卸载）。</li>
<li>一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻**。但是这部分区域的回收有时又确实是必要的。以前Sun公司的Bug列表中，曾出现过的若干个严重的Bug就是由于低版本的HotSpot虚拟机对此区域未完全回收而导致内存泄漏。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="字符串常量池"><a href="#字符串常量池" class="headerlink" title="字符串常量池"></a>字符串常量池</h2><p><strong>字符串常量池 StringTable 为什么要调整位置？</strong></p>
<ul>
<li><p>JDK7中将StringTable放到了堆空间中。因为永久代的回收效率很低，在Full GC的时候才会执行永久代的垃圾回收，而Full GC是老年代的空间不足、永久代不足时才会触发。</p>
</li>
<li><p>这就导致StringTable回收效率不高，而我们开发中会有大量的字符串被创建，回收效率低，导致永久代内存不足。放到堆里，能及时回收内存。</p>
</li>
</ul>
<h2 id="静态变量放在哪里"><a href="#静态变量放在哪里" class="headerlink" title="静态变量放在哪里"></a>静态变量放在哪里</h2><h3 id="对象实体在哪里放着？"><a href="#对象实体在哪里放着？" class="headerlink" title="对象实体在哪里放着？"></a>对象实体在哪里放着？</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 结论：</span></span><br><span class="line"><span class="comment"> * 1、静态引用对应的对象实体(也就是这个new byte[1024 * 1024 * 100])始终都存在堆空间，</span></span><br><span class="line"><span class="comment"> * 2、只是那个变量(相当于下面的arr变量名)在JDK6,JDK7,JDK8存放位置中有所变化</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * jdk7：</span></span><br><span class="line"><span class="comment"> * -Xms200m -Xmx200m -XX:PermSize=300m -XX:MaxPermSize=300m -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment"> * jdk 8：</span></span><br><span class="line"><span class="comment"> * -Xms200m -Xmx200m -XX:MetaspaceSize=300m -XX:MaxMetaspaceSize=300m -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticFieldTest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">byte</span>[] arr = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">100</span>];<span class="comment">//100MB</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(StaticFieldTest.arr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JDK6环境下</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220719153501056.png" alt="image-20220719153501056"></p>
<p>JDK7环境下</p>
<img src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_006/0032.png">

<p>JDK8环境</p>
<img src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_006/0033.png">

<h3 id="变量-名-存放在哪里？"><a href="#变量-名-存放在哪里？" class="headerlink" title="变量(名)存放在哪里？"></a>变量(名)存放在哪里？</h3><p>这个问题需要用JHSDB工具来进行分析，这个工具是JDK9开始自带的(JDK9以前没有)，在bin目录下可以找到</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.java1;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 《深入理解Java虚拟机》中的案例：</span></span><br><span class="line"><span class="comment"> * staticObj、instanceObj、localObj存放在哪里？</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticObjTest</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="type">ObjectHolder</span> <span class="variable">staticObj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectHolder</span>();</span><br><span class="line">        <span class="type">ObjectHolder</span> <span class="variable">instanceObj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectHolder</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">ObjectHolder</span> <span class="variable">localObj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectHolder</span>();</span><br><span class="line">            System.out.println(<span class="string">&quot;done&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ObjectHolder</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StaticObjTest</span>.Test();</span><br><span class="line">        test.foo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>JDK6环境下</strong></p>
<p>1、staticObj随着Test的类型信息存放在方法区</p>
<p>2、instanceObj随着Test的对象实例存放在Java堆</p>
<p>3、localObject则是存放在foo()方法栈帧的局部变量表中。</p>
<p>4、测试发现：三个对象的数据在内存中的地址都落在Eden区范围内，所以结论：<strong>只要是对象实例必然会在Java堆中分配</strong>。</p>
<img src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_006/0034.png">

<blockquote>
<p>1、0x00007f32c7800000(Eden区的起始地址)    —-   0x00007f32c7b50000(Eden区的终止地址)  </p>
<p>2、可以发现三个变量都在这个范围内</p>
<p>3、所以可以得到上面结论</p>
</blockquote>
<p>5、接着，找到了一个引用该staticObj对象的地方，是在一个java.lang.Class的实例里，并且给出了这个实例的地址，通过Inspector查看该对象实例，可以清楚看到这确实是一个java.lang.Class类型的对象实例，里面有一个名为staticobj的实例字段：</p>
<img src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_006/0035.png">

<p>从《Java虚拟机规范》所定义的概念模型来看，所有Class相关的信息都应该存放在方法区之中，但方法区该如何实现，《Java虚拟机规范》并未做出规定，这就成了一件允许不同虚拟机自己灵活把握的事情。JDK7及其以后版本的HotSpot虚拟机选择把静态变量与类型在Java语言一端的映射Class对象存放在一起，<strong>存储于Java堆之中</strong>，从我们的实验中也明确验证了这一点</p>
<h1 id="方法区的垃圾回收"><a href="#方法区的垃圾回收" class="headerlink" title="方法区的垃圾回收"></a>方法区的垃圾回收</h1><ol>
<li><p>有些人认为方法区（如Hotspot虚拟机中的元空间或者永久代）是没有垃圾收集行为的，其实不然。《Java虚拟机规范》对方法区的约束是非常宽松的，提到过可以不要求虚拟机在方法区中实现垃圾收集。事实上也确实有未实现或未能完整实现方法区<strong>类型卸载</strong>的收集器存在（如JDK11时期的ZGC收集器就不支持类卸载）。</p>
</li>
<li><p>一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻。但是这部分区域的回收有时又确实是必要的。以前sun公司的Bug列表中，曾出现过的若干个严重的Bug就是由于低版本的HotSpot虚拟机对此区域未完全回收而导致内存泄漏。</p>
</li>
<li><p>方法区的垃圾收集主要回收两部分内容：<strong>常量池中废弃的常量和不再使用的类型</strong>。</p>
</li>
<li><p>先来说说方法区内常量池之中主要存放的两大类常量：字面量和符号引用。字面量比较接近Java语言层次的常量概念，如文本字符串、被声明为final的常量值等。而符号引用则属于编译原理方面的概念，包括下面三类常量：</p>
<ul>
<li>类和接口的全限定名</li>
<li>字段的名称和描述符</li>
<li>方法的名称和描述符</li>
</ul>
</li>
<li><p>HotSpot虚拟机对常量池的回收策略是很明确的，只要常量池中的常量没有被任何地方引用，就可以被回收。</p>
</li>
<li><p>回收废弃常量与回收Java堆中的对象非常类似。（关于常量的回收比较简单，重点是类的回收）</p>
</li>
</ol>
<p>下面也称作<strong>类卸载</strong></p>
<p>1、判定一个常量是否“废弃”还是相对简单，而要判定一个类型是否属于“不再被使用的类”的条件就比较苛刻了。需要同时满足下面三个条件：</p>
<ul>
<li><p>该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例。</p>
</li>
<li><p>加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如OSGi、JSP的重加载等，否则通常是很难达成的。</p>
</li>
<li><p>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</p>
</li>
</ul>
<p>2、Java虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是“被允许”，而并不是和对象一样，没有引用了就必然会回收。关于是否要对类型进行回收，HotSpot虚拟机提供了<code>-Xnoclassgc</code>参数进行控制，还可以使用<code>-verbose:class</code> 以及 <code>-XX：+TraceClass-Loading</code>、<code>-XX：+TraceClassUnLoading</code>查看类加载和卸载信息</p>
<p>3、在大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及OSGi这类频繁自定义类加载器的场景中，通常都需要Java虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压力。</p>
<h1 id="运行时数据区总结"><a href="#运行时数据区总结" class="headerlink" title="运行时数据区总结"></a>运行时数据区总结</h1><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220719155003196.png" alt="image-20220719155003196"></p>
<h1 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h1><ol>
<li>百度<ul>
<li>三面：说一下JVM内存模型吧，有哪些区？分别干什么的？</li>
</ul>
</li>
<li>蚂蚁金服：<ul>
<li>Java8的内存分代改进</li>
<li>JVM内存分哪几个区，每个区的作用是什么？</li>
<li>一面：JVM内存分布&#x2F;内存结构？栈和堆的区别？堆的结构？为什么两个survivor区？</li>
<li>二面：Eden和survior的比例分配</li>
</ul>
</li>
<li>小米：<ul>
<li>jvm内存分区，为什么要有新生代和老年代</li>
</ul>
</li>
<li>字节跳动：<ul>
<li>二面：Java的内存分区</li>
<li>二面：讲讲vm运行时数据库区</li>
<li>什么时候对象会进入老年代？</li>
</ul>
</li>
<li>京东：<ul>
<li>JVM的内存结构，Eden和Survivor比例。</li>
<li>JVM内存为什么要分成新生代，老年代，持久代。新生代中为什么要分为Eden和survivor。</li>
</ul>
</li>
<li>天猫：<ul>
<li>一面：Jvm内存模型以及分区，需要详细到每个区放什么。</li>
<li>一面：JVM的内存模型，Java8做了什么改</li>
</ul>
</li>
<li>拼多多：<ul>
<li>JVM内存分哪几个区，每个区的作用是什么？</li>
</ul>
</li>
<li>美团：<ul>
<li>java内存分配</li>
<li>jvm的永久代中会发生垃圾回收吗？</li>
<li>一面：jvm内存分区，为什么要有新生代和老年代？</li>
</ul>
</li>
</ol>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-数据结构与算法：栈"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
	
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/07/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%9A%E6%A0%88/"
    >栈</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/07/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%9A%E6%A0%88/" class="article-date">
  <time datetime="2022-07-18T11:21:06.000Z" itemprop="datePublished">2022-07-18</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a> / <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%88/">栈</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h1><ul>
<li>栈的英文为(stack)</li>
<li>栈是一个<strong>先入后出</strong>(FILO-First In Last Out)的有序列表。</li>
<li>栈(stack)是限制线性表中元素的插入和删除<strong>只能在线性表的同一端</strong>进行的一种特殊线性表。允许插入和删除的一端，为变化的一端，称为栈顶(Top)，另一端为固定的一端，称为栈底(Bottom)。</li>
<li>根据栈的定义可知，最先放入栈中元素在栈底，最后放入的元素在栈顶，而删除元素刚好相反，最后放入的元素最先删除，最先放入的元素最后删除</li>
<li>图解方式说明**出栈(pop)<strong>和</strong>入栈(push)**的概念</li>
</ul>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220718192957959.png" alt="出栈入栈操作"></p>
<h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><ul>
<li>子程序的调用:在跳往子程序前，会先将下个指令的地址存到堆栈中，直到子程序执行完后再将地址取出，以回到原来的程序中。</li>
<li>处理递归调用:和子程序的调用类似，只是除了储存下一个指令的地址外，也将参数、区域变量等数据存入堆栈中。</li>
<li>表达式的转换[中缀表达式转后缀表达式]与求值(实际解决)。</li>
<li>二叉树的遍历。</li>
<li>图形的深度优先(depth一 first)搜索法。</li>
</ul>
<h1 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h1><ul>
<li><p>用数组模拟栈的使用，由于栈是一种有序列表，当然可以使用数组的结构来储存栈的数据内容，下面我们就用数组模拟栈的出栈，入栈等操作。</p>
</li>
<li><p><strong>思路分析</strong></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220718193728413.png" alt="image-20220718193728413"></p>
<ol>
<li>使用数组来模拟栈</li>
<li>定义一个<strong>top</strong>来表示栈顶，<strong>初始化为 -1</strong></li>
<li>入柱的操作：当有数据加入到栈时，<strong>top++；</strong>   <strong>stack[top] &#x3D;data；</strong></li>
<li>出栈的操作：<strong>int value &#x3D; stack[top]；  top–；   return value；</strong></li>
</ol>
</li>
<li><p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ysy.stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayStackDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//测试栈</span></span><br><span class="line">        <span class="type">ArrayStack</span> <span class="variable">stack</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayStack</span>(<span class="number">4</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">loop</span> <span class="operator">=</span> <span class="literal">true</span>;<span class="comment">//控制是否退出菜单</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span> (loop)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;show: 表示显示栈&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;exit: 表示退出栈&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;push: 表示入栈&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;pop: 表示出栈&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;请输入你的选择~&quot;</span>);</span><br><span class="line">            key = sc.next();</span><br><span class="line">            <span class="keyword">switch</span> (key)&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;show&quot;</span>:</span><br><span class="line">                    stack.list();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;push&quot;</span>:</span><br><span class="line">                    System.out.println(<span class="string">&quot;请输入一个数~&quot;</span>);</span><br><span class="line">                    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">                    stack.push(i);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;pop&quot;</span>:</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                        System.out.printf(<span class="string">&quot;出栈的数据是%d\n&quot;</span>, res);</span><br><span class="line"></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;exit&quot;</span>:</span><br><span class="line">                    sc.close();</span><br><span class="line">                    loop = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;程序已退出&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个ArrayStack,模拟出栈入栈操作</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayStack</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> maxSize;<span class="comment">//栈大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] stack;<span class="comment">//定义一个数组用来模拟栈</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">top</span> <span class="operator">=</span> -<span class="number">1</span>;<span class="comment">//定义一个**top**来表示栈顶，初始化为 -1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayStack</span><span class="params">(<span class="type">int</span> maxSize)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.maxSize = maxSize;</span><br><span class="line">        stack = <span class="keyword">new</span> <span class="title class_">int</span>[maxSize];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断栈满</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">return</span> <span class="variable">top</span> <span class="operator">=</span>= maxSize - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断栈空</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">return</span> <span class="variable">top</span> <span class="operator">=</span>= - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//入栈</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> value)</span>&#123;</span><br><span class="line">        <span class="comment">//判断栈是否满</span></span><br><span class="line">        <span class="keyword">if</span>(isFull())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;栈满&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        top++;</span><br><span class="line">        stack[top] = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//出栈</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//判断栈是否空</span></span><br><span class="line">        <span class="keyword">if</span>(isEmpty())&#123;</span><br><span class="line">            <span class="comment">//抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;栈空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> stack[top];</span><br><span class="line">        top--;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历栈，从栈顶开始</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">list</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isEmpty())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;栈空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> top; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;stack[%d]=%d\n&quot;</span>, i, stack[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="栈实现综合计算器-中缀表达式"><a href="#栈实现综合计算器-中缀表达式" class="headerlink" title="栈实现综合计算器(中缀表达式)"></a>栈实现综合计算器(中缀表达式)</h1><ul>
<li>就是最常见的运算表达式，如：(3 + 4) × 5 - 6</li>
<li>中缀表达式求值对计算机来说不好操作，因此在计算时往往转换为后缀表达式</li>
</ul>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220718202450431.png" alt="image-20220718202450431"></p>
<ul>
<li><p>请问:计算机底层是如何运算得到结果的? 注意不是简单的把算式列出运算,因为我们看这个算式7×2×2-5+1-5×3-3，但是计算机怎么理解这个算式的(对计算机而言，它接收到的就是一个字符串)，我们讨论的是这个问题</p>
</li>
<li><p><strong>思路分析</strong></p>
<ol>
<li><p>通过一个index值《索引》,来遍历我们的表达式</p>
</li>
<li><p>如果我们发现是一个数字,就直接入数栈</p>
<ul>
<li>当处理多位数时，需要向表达式的index后再看一位，如果是数就进行扫描，如果是符号才入栈</li>
</ul>
</li>
<li><p>如果发现扫描到是一个符号,就分如下情况</p>
<ul>
<li><p>如果发现当前的符号栈为空，就直接入栈</p>
</li>
<li><p>如果符号栈有操作符，就进行比较,如果<strong>当前的操作符的优先级小于或者等于栈中的操作符</strong>，就需要<strong>从数栈中pop出两个数,在从符号栈中pop出一个符号，进行运算，将得到结果，入数栈，然后将当前的操作符入符号栈</strong>，<strong>如果当前的操作符的优先级大于栈中的操作符,就直接入符号栈.</strong></p>
</li>
</ul>
</li>
<li><p>当表达式扫描完毕,就顺序的从数栈和符号栈中pop出相应的数和符号，并运行.</p>
</li>
<li><p>最后在数栈只有一个数字,就是表达式的结果</p>
</li>
</ol>
</li>
<li><p><strong>代码实现</strong></p>
</li>
</ul>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ysy.stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 一位数的加减乘除运算</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Calculator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//完成表达式的运算</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">expression</span> <span class="operator">=</span> <span class="string">&quot;70+2*6-4&quot;</span>;</span><br><span class="line">        <span class="comment">//创建两个栈：数栈和符号栈</span></span><br><span class="line">        <span class="type">ArrayStack2</span> <span class="variable">numStack</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayStack2</span>(<span class="number">10</span>);</span><br><span class="line">        <span class="type">ArrayStack2</span> <span class="variable">operStack</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayStack2</span>(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">//定义需要的相关变量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//用于扫描</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">oper</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> <span class="string">&#x27; &#x27;</span>;<span class="comment">//将每次扫描后的char保存到ch</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">keepNum</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;<span class="comment">//用于拼接多位数</span></span><br><span class="line">        <span class="comment">//开始while循环的扫描expression</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="comment">//依次得到expression的每个字符</span></span><br><span class="line">            ch = expression.substring(index, index+<span class="number">1</span>).charAt(<span class="number">0</span>);</span><br><span class="line">            <span class="comment">//判断是否是符号，然后做相应的处理</span></span><br><span class="line">            <span class="keyword">if</span>(operStack.isOper(ch))&#123;<span class="comment">//如果是运算符</span></span><br><span class="line">                <span class="comment">//判断符号栈是否为空</span></span><br><span class="line">                <span class="keyword">if</span>(!operStack.isEmpty())&#123;</span><br><span class="line">                    <span class="comment">// 如果符号栈有操作符，就进行比较,如果当前的操作符的优先级小于或者等于栈中的操作符，就需要从数栈中pop出两个数,</span></span><br><span class="line">                    <span class="comment">// 在从符号栈中pop出一个符号，进行运算，将得到结果，入数栈，然后将当前的操作符入符号栈，</span></span><br><span class="line">                    <span class="keyword">if</span>(operStack.priority(ch) &lt;= operStack.priority(operStack.peek()))&#123;</span><br><span class="line">                        num1 = numStack.pop();</span><br><span class="line">                        num2 = numStack.pop();</span><br><span class="line">                        oper = operStack.pop();</span><br><span class="line">                        res = numStack.cal(num1, num2, oper);</span><br><span class="line">                        <span class="comment">//把运算的结果入数栈</span></span><br><span class="line">                        numStack.push(res);</span><br><span class="line">                        <span class="comment">//将当前的操作符入符号栈</span></span><br><span class="line">                        operStack.push(ch);</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 如果当前的操作符的优先级大于栈中的操作符,就直接入符号栈.</span></span><br><span class="line">                        operStack.push(ch);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//如果发现当前的符号栈为空，就直接入栈</span></span><br><span class="line">                    operStack.push(ch);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//如果我们发现是一个数字,就直接入数栈</span></span><br><span class="line">                <span class="comment">//numStack.push(ch - 48);</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//处理多位数</span></span><br><span class="line">                keepNum += ch;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//如果ch已经是expression的最后一位，就直接入栈</span></span><br><span class="line">                <span class="keyword">if</span>(index == expression.length() - <span class="number">1</span>)&#123;</span><br><span class="line">                    numStack.push(Integer.parseInt(keepNum));</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//当处理多位数时，需要向expression表达式的index后再看一位，如果是数就进行扫描，如果是符号才入栈</span></span><br><span class="line">                    <span class="keyword">if</span>(operStack.isOper(expression.substring(index+<span class="number">1</span>, index+<span class="number">2</span>).charAt(<span class="number">0</span>)))&#123;</span><br><span class="line">                        <span class="comment">//后一位是运算符</span></span><br><span class="line">                        numStack.push(Integer.parseInt(keepNum));</span><br><span class="line">                        <span class="comment">//清空keepNum</span></span><br><span class="line">                        keepNum = <span class="string">&quot;&quot;</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//index+1，并判断是否扫描到expression的最后</span></span><br><span class="line">            index++;</span><br><span class="line">            <span class="keyword">if</span>(index &gt;= expression.length())&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当表达式扫描完毕,就顺序的从数栈和符号栈中pop出相应的数和符号，并运行</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="comment">//如果符号栈为空，则数栈中只有一个数-&gt;结果</span></span><br><span class="line">            <span class="keyword">if</span>(operStack.isEmpty())&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            num1 = numStack.pop();</span><br><span class="line">            num2 = numStack.pop();</span><br><span class="line">            oper = operStack.pop();</span><br><span class="line">            res = numStack.cal(num1, num2, oper);</span><br><span class="line">            numStack.push(res);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.printf(<span class="string">&quot;表达式 %s = %d&quot;</span>, expression, numStack.pop());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个ArrayStack,模拟出栈入栈操作</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayStack2</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> maxSize;<span class="comment">//栈大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] stack;<span class="comment">//定义一个数组用来模拟栈</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">top</span> <span class="operator">=</span> -<span class="number">1</span>;<span class="comment">//定义一个**top**来表示栈顶，初始化为 -1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayStack2</span><span class="params">(<span class="type">int</span> maxSize)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.maxSize = maxSize;</span><br><span class="line">        stack = <span class="keyword">new</span> <span class="title class_">int</span>[maxSize];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回当前栈顶的值，不是pop</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack[top];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断栈满</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">return</span> <span class="variable">top</span> <span class="operator">=</span>= maxSize - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断栈空</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">return</span> <span class="variable">top</span> <span class="operator">=</span>= - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//入栈</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> value)</span>&#123;</span><br><span class="line">        <span class="comment">//判断栈是否满</span></span><br><span class="line">        <span class="keyword">if</span>(isFull())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;栈满&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        top++;</span><br><span class="line">        stack[top] = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//出栈</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//判断栈是否空</span></span><br><span class="line">        <span class="keyword">if</span>(isEmpty())&#123;</span><br><span class="line">            <span class="comment">//抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;栈空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> stack[top];</span><br><span class="line">        top--;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历栈，从栈顶开始</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">list</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(isEmpty())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;栈空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> top; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;stack[%d]=%d\n&quot;</span>, i, stack[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回运算符的优先级，优先级由程序员确定，使用数字表示，数字越大，优先级越大</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">priority</span><span class="params">(<span class="type">int</span> oper)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(oper == <span class="string">&#x27;*&#x27;</span> || oper == <span class="string">&#x27;/&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(oper == <span class="string">&#x27;+&#x27;</span> || oper == <span class="string">&#x27;-&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">return</span> -<span class="number">1</span>;<span class="comment">//假设目前的表达式只有+, -, *, /</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断是否是运算符</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isOper</span><span class="params">(<span class="type">char</span> val)</span>&#123;</span><br><span class="line">        <span class="type">return</span> <span class="variable">val</span> <span class="operator">=</span>= <span class="string">&#x27;+&#x27;</span> || val == <span class="string">&#x27;-&#x27;</span> || val == <span class="string">&#x27;*&#x27;</span> || val == <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">cal</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2, <span class="type">int</span> oper)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//用于存储计算结果</span></span><br><span class="line">        <span class="keyword">switch</span> (oper) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                res = num1 + num2;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                res = num2 - num1;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                res = num1 * num2;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">                res = num2 / num1;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="前缀表达式-波兰表达式"><a href="#前缀表达式-波兰表达式" class="headerlink" title="前缀表达式(波兰表达式)"></a>前缀表达式(波兰表达式)</h1><ul>
<li>前缀表达式的运算符位于操作数之前</li>
<li>前缀表达式的计算机求值<ul>
<li>从右至左扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算（栈顶元素和次顶元素)，并将结果入栈;重复上述过程直到表达式最左端，最后运算得出的值即为表达式的结果</li>
<li>例如：<code>(3 + 4) × 5 - 6</code> 对应的前缀表达式为 <code>- × + 3 4 5 6</code>，求值步骤如下<ol>
<li>从右至左扫描，将6、5、4、3压入堆栈</li>
<li>遇到 + 运算符，因此弹出3和4(3为栈顶元素，4为次顶元素），计算出 3 + 4 的值，得7, 再将7入栈</li>
<li>接下来是 × 运算符，因此弹出7和5，计算出7 × 5 &#x3D; 35，将35入栈</li>
<li>最后是 - 运算符，计算出35 - 6的值，即29，由此得出最终结果</li>
</ol>
</li>
</ul>
</li>
</ul>
<h1 id="后缀表达式-逆波兰表达式"><a href="#后缀表达式-逆波兰表达式" class="headerlink" title="后缀表达式(逆波兰表达式)"></a>后缀表达式(逆波兰表达式)</h1><ul>
<li><p>后缀表达式的运算符位于操作数之后</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220720200654526.png" alt="image-20220720200654526"></p>
</li>
<li><p>后缀表达式的计算机求值</p>
<ul>
<li>从左至右扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算（次顶元素和栈顶元素〉，并将结果入栈;重复上述过程直到表达式最右端，最后运算得出的值即为表达式的结果</li>
<li>例如：<code>(3 + 4) × 5 - 6</code> 对应的后缀表达式就是 <code>3 4 + 5 × 6 -</code>，求值步骤如下<ol>
<li>从左至右扫描，将3和4压入堆栈;</li>
<li>遇到 + 运算符，因此弹出4和3(4为栈顶元素，3为次顶元素），计算出3+4的值，得7，再将7入栈;</li>
<li>将5入栈;</li>
<li>接下来是 × 运算符，因此弹出5和7，计算出7×5&#x3D;35，将35入栈;</li>
<li>将6入栈;</li>
<li>最后是 - 运算符，计算出35-6的值，即29，由此得出最终结果</li>
</ol>
</li>
</ul>
</li>
</ul>
<h1 id="逆波兰计算器"><a href="#逆波兰计算器" class="headerlink" title="逆波兰计算器"></a>逆波兰计算器</h1><ul>
<li>输入一个逆波兰表达式，使用栈计算其结果</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ysy.stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PolandNotation</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//先定义一个逆波兰表达式</span></span><br><span class="line">        <span class="comment">//(3 + 4) × 5 - 6 对应的后缀表达式就是 3 4 + 5 × 6 -</span></span><br><span class="line">        <span class="comment">//为了方便，逆波兰表达式中的数字和符号使用空格隔开</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">suffixExpression</span> <span class="operator">=</span> <span class="string">&quot;3 4 + 5 * 6 -&quot;</span>;</span><br><span class="line">        <span class="comment">//思路</span></span><br><span class="line">        <span class="comment">//1.先将suffixExpression=&gt;放到ArrayList中</span></span><br><span class="line">        <span class="comment">//2.将ArrayList传递给一个方法，遍历ArrayList，配合栈运算</span></span><br><span class="line">        List&lt;String&gt; rpnList = getListString(suffixExpression);</span><br><span class="line">        System.out.println(rpnList);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> calculate(rpnList);</span><br><span class="line">        System.out.println(<span class="string">&quot;(3 + 4) × 5 - 6 = &quot;</span> + res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//一个逆波兰表达式，依次将数据和运算符 放入到ArrayList中</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">getListString</span><span class="params">(String suffixExpression)</span>&#123;</span><br><span class="line">        <span class="comment">//将suffixExpression分割</span></span><br><span class="line">        String[] split = suffixExpression.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String s : split) &#123;</span><br><span class="line">            list.add(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//完成对逆波兰表达式的运算</span></span><br><span class="line">    <span class="comment">/*1. 从左至右扫描，将3和4压入堆栈;</span></span><br><span class="line"><span class="comment">        2. 遇到 + 运算符，因此弹出4和3(4为栈顶元素，3为次顶元素），计算出3+4的值，得7，再将7入栈;</span></span><br><span class="line"><span class="comment">        3. 将5入栈;</span></span><br><span class="line"><span class="comment">        4. 接下来是 × 运算符，因此弹出5和7，计算出7×5=35，将35入栈;</span></span><br><span class="line"><span class="comment">        5. 将6入栈;</span></span><br><span class="line"><span class="comment">        6. 最后是 - 运算符，计算出35-6的值，即29，由此得出最终结果*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">calculate</span><span class="params">(List&lt;String&gt; ls)</span>&#123;</span><br><span class="line">        <span class="comment">//创建栈，只需要一个</span></span><br><span class="line">        Stack&lt;String&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//遍历ls</span></span><br><span class="line">        <span class="keyword">for</span> (String item : ls) &#123;</span><br><span class="line">            <span class="comment">//正则表达式取值</span></span><br><span class="line">            <span class="keyword">if</span>(item.matches(<span class="string">&quot;\\d+&quot;</span>))&#123;<span class="comment">//匹配的是多位数</span></span><br><span class="line">                <span class="comment">//入栈</span></span><br><span class="line">                stack.push(item);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//pop出两个数，并运算，再入栈</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> Integer.parseInt(stack.pop());</span><br><span class="line">                <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> Integer.parseInt(stack.pop());</span><br><span class="line">                <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(item.equals(<span class="string">&quot;+&quot;</span>))&#123;</span><br><span class="line">                    res = num1 + num2;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(item.equals(<span class="string">&quot;-&quot;</span>))&#123;</span><br><span class="line">                    res = num1 - num2;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(item.equals(<span class="string">&quot;*&quot;</span>))&#123;</span><br><span class="line">                    res = num1 * num2;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(item.equals(<span class="string">&quot;/&quot;</span>))&#123;</span><br><span class="line">                    res = num1 / num2;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;运算符有误&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//把res入栈</span></span><br><span class="line">                stack.push(res + <span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后留在stack中的数据是运算结果</span></span><br><span class="line">        <span class="keyword">return</span> Integer.parseInt(stack.pop());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="中缀表达式转后缀表达式"><a href="#中缀表达式转后缀表达式" class="headerlink" title="中缀表达式转后缀表达式"></a>中缀表达式转后缀表达式</h1><ul>
<li><p><strong>思路</strong></p>
<ol>
<li>初始化两个栈:运算符栈s1和储存中间结果的栈s2;</li>
<li>从左至右扫描中缀表达式;</li>
<li>遇到操作数时，将其压s2;</li>
<li>遇到运算符时，比较其与s1栈顶运算符的优先级:<ol>
<li>如果s1为空，或栈顶运算符为左括号“(”，则直接将此运算符入栈;</li>
<li>否则，若优先级比栈顶运算符的高，也将运算符压入s1;</li>
<li>否则，将s1栈顶的运算符弹出并压入到s2中，再次转到(4.1)与s1中新的栈顶运算符相比较;</li>
</ol>
</li>
<li>遇到括号时:<ol>
<li>如果是左括号“(”，则直接压入s1</li>
<li>如果是右括号“)”，则依次弹出s1栈顶的运算符，并压入s2，直到遇到左括号为止，此时将这一对括号丢弃</li>
</ol>
</li>
<li>重复步骤2至5，直到表达式的最右边</li>
<li>将s1中剩余的运算符依次弹出并压入s2</li>
<li>依次弹出s2中的元素并输出，结果的逆序即为中缀表达式对应的后缀表达式</li>
</ol>
</li>
<li><p><strong>实例</strong></p>
<ul>
<li><p>将中缀表达式 <code>1 + ((2 + 3) × 4) - 5</code> 转换为后缀表达式的过程如下</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220720210413100.png" alt="image-20220720210413100"></p>
</li>
</ul>
</li>
<li><p><strong>代码实现</strong></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ysy.stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InfixToSuffix</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//完成将中缀表达式转换为后缀表达式</span></span><br><span class="line">        <span class="comment">//1 + ((2 + 3) × 4) - 5 =》1 2 3 + 4 * + 5 -</span></span><br><span class="line">        <span class="comment">//直接对str进行操作，不方便，因此 先将中缀表达式转为对应的ArrayList</span></span><br><span class="line">        <span class="comment">//将得到的中缀表达式对应的List =&gt; 后缀表达式对应的List</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">expression</span> <span class="operator">=</span> <span class="string">&quot;1+((2+3)*4)-5&quot;</span>;</span><br><span class="line">        List&lt;String&gt; infixExpressionList = toInfixExpressionList(expression);</span><br><span class="line">        System.out.println(<span class="string">&quot;中缀表达式对应的List：&quot;</span> + infixExpressionList);<span class="comment">//[1, +, (, (, 2, +, 3, ), ×, 4, ), -, 5]</span></span><br><span class="line">        List&lt;String&gt; suffixExpressionList = parseSuffixExpressionList(infixExpressionList);</span><br><span class="line">        System.out.println(<span class="string">&quot;后缀表达式对应的List：&quot;</span> + suffixExpressionList);</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> calculate(suffixExpressionList);</span><br><span class="line">        System.out.println(<span class="string">&quot;1 + ((2 + 3) × 4) - 5 = &quot;</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将得到的中缀表达式对应的List =&gt; 后缀表达式对应的List</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">parseSuffixExpressionList</span><span class="params">(List&lt;String&gt; ls)</span>&#123;</span><br><span class="line">        <span class="comment">//定义两个栈</span></span><br><span class="line">        Stack&lt;String&gt; s1 = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;String&gt;();<span class="comment">//符号栈</span></span><br><span class="line">        <span class="comment">//因为s2在整个转换过程中没有pop操作，且后面还要逆序输出，因此直接使用List&lt;String&gt;代替</span></span><br><span class="line">        List&lt;String&gt; s2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//遍历ls</span></span><br><span class="line">        <span class="keyword">for</span> (String item : ls) &#123;</span><br><span class="line">            <span class="comment">//如果是一个数，就加入到s2</span></span><br><span class="line">            <span class="keyword">if</span>(item.matches(<span class="string">&quot;\\d+&quot;</span>))&#123;</span><br><span class="line">                s2.add(item);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(item.equals(<span class="string">&quot;(&quot;</span>))&#123;</span><br><span class="line">                s1.push(item);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(item.equals(<span class="string">&quot;)&quot;</span>))&#123;</span><br><span class="line">                <span class="comment">//如果是右括号“)”，则依次弹出s1栈顶的运算符，并压入s2，直到遇到左括号为止，此时将这一对括号丢弃</span></span><br><span class="line">                <span class="keyword">while</span> (!s1.peek().equals(<span class="string">&quot;(&quot;</span>))&#123;</span><br><span class="line">                    s2.add(s1.pop());</span><br><span class="line">                &#125;</span><br><span class="line">                s1.pop();<span class="comment">//!!!将 （ 弹出s1栈，消除小括号</span></span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//当item的优先级小于等于栈顶运算符，将s1栈顶的运算符弹出并压入到s2中，再次转到(4-1)与s1中新的栈顶运算符相比较</span></span><br><span class="line">                <span class="keyword">while</span> (s1.size() != <span class="number">0</span> &amp;&amp; Operation.getValue(s1.peek()) &gt;= Operation.getValue(item))&#123;</span><br><span class="line">                    s2.add(s1.pop());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//还需要将item压入栈中</span></span><br><span class="line">                s1.push(item);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将s1中剩余的运算符依次弹出并压入s2</span></span><br><span class="line">        <span class="keyword">while</span> (s1.size() != <span class="number">0</span>)&#123;</span><br><span class="line">            s2.add(s1.pop());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> s2;<span class="comment">//因为是存放到List，因此按顺序输出就是对应的后缀表达式对应的List</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将中缀表达式转成对应的list</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">toInfixExpressionList</span><span class="params">(String s)</span>&#123;</span><br><span class="line">        <span class="comment">//定义一个List，存放中缀表达式对应的内容</span></span><br><span class="line">        List&lt;String&gt; ls = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//指针，用来遍历中缀表达式的内容</span></span><br><span class="line">        String str;<span class="comment">//对多位数进行拼接</span></span><br><span class="line">        <span class="type">char</span> c;<span class="comment">//每遍历到一个字符，就放入c</span></span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            <span class="comment">//如果C是一个非数字，加入到ls</span></span><br><span class="line">            <span class="keyword">if</span>((c=s.charAt(i)) &lt; <span class="number">48</span> || (c=s.charAt(i)) &gt; <span class="number">57</span>)&#123;</span><br><span class="line">                ls.add(c + <span class="string">&quot;&quot;</span>);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//如果是一个数，需要考虑多位数问题</span></span><br><span class="line">                str = <span class="string">&quot;&quot;</span>;<span class="comment">//将str置空</span></span><br><span class="line">                <span class="keyword">while</span> (i &lt; s.length() &amp;&amp; (c=s.charAt(i)) &gt;= <span class="number">48</span> &amp;&amp; (c=s.charAt(i)) &lt;= <span class="number">57</span>)&#123;</span><br><span class="line">                    str += c;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                ls.add(str);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">while</span> (i &lt; s.length());</span><br><span class="line">        <span class="keyword">return</span> ls;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//一个逆波兰表达式，依次将数据和运算符 放入到ArrayList中</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">getListString</span><span class="params">(String suffixExpression)</span>&#123;</span><br><span class="line">        <span class="comment">//将suffixExpression分割</span></span><br><span class="line">        String[] split = suffixExpression.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String s : split) &#123;</span><br><span class="line">            list.add(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//完成对逆波兰表达式的运算</span></span><br><span class="line">    <span class="comment">/*1. 从左至右扫描，将3和4压入堆栈;</span></span><br><span class="line"><span class="comment">        2. 遇到 + 运算符，因此弹出4和3(4为栈顶元素，3为次顶元素），计算出3+4的值，得7，再将7入栈;</span></span><br><span class="line"><span class="comment">        3. 将5入栈;</span></span><br><span class="line"><span class="comment">        4. 接下来是 × 运算符，因此弹出5和7，计算出7×5=35，将35入栈;</span></span><br><span class="line"><span class="comment">        5. 将6入栈;</span></span><br><span class="line"><span class="comment">        6. 最后是 - 运算符，计算出35-6的值，即29，由此得出最终结果*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">calculate</span><span class="params">(List&lt;String&gt; ls)</span>&#123;</span><br><span class="line">        <span class="comment">//创建栈，只需要一个</span></span><br><span class="line">        Stack&lt;String&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//遍历ls</span></span><br><span class="line">        <span class="keyword">for</span> (String item : ls) &#123;</span><br><span class="line">            <span class="comment">//正则表达式取值</span></span><br><span class="line">            <span class="keyword">if</span>(item.matches(<span class="string">&quot;\\d+&quot;</span>))&#123;<span class="comment">//匹配的是多位数</span></span><br><span class="line">                <span class="comment">//入栈</span></span><br><span class="line">                stack.push(item);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//pop出两个数，并运算，再入栈</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> Integer.parseInt(stack.pop());</span><br><span class="line">                <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> Integer.parseInt(stack.pop());</span><br><span class="line">                <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(item.equals(<span class="string">&quot;+&quot;</span>))&#123;</span><br><span class="line">                    res = num1 + num2;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(item.equals(<span class="string">&quot;-&quot;</span>))&#123;</span><br><span class="line">                    res = num1 - num2;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(item.equals(<span class="string">&quot;*&quot;</span>))&#123;</span><br><span class="line">                    res = num1 * num2;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(item.equals(<span class="string">&quot;/&quot;</span>))&#123;</span><br><span class="line">                    res = num1 / num2;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;运算符有误&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//把res入栈</span></span><br><span class="line">                stack.push(res + <span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后留在stack中的数据是运算结果</span></span><br><span class="line">        <span class="keyword">return</span> Integer.parseInt(stack.pop());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//编写一个类Operation，返回一个运算符对应的优先级</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Operation</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">ADD</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">SUB</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MUL</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">DIV</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getValue</span><span class="params">(String operation)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">switch</span> (operation) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;+&quot;</span>:</span><br><span class="line">                result = ADD;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;-&quot;</span>:</span><br><span class="line">                result = SUB;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;*&quot;</span>:</span><br><span class="line">                result = MUL;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;/&quot;</span>:</span><br><span class="line">                result = DIV;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;不存在该运算符~&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-数据结构与算法：约瑟夫环"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
	
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/07/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%9A%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF/"
    >(单向环形链表)约瑟夫环</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/07/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%9A%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF/" class="article-date">
  <time datetime="2022-07-16T13:31:05.000Z" itemprop="datePublished">2022-07-16</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a> / <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/">链表</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h1><ul>
<li>Joseph(约瑟夫、约瑟夫环)问题<ul>
<li>设编号为1，2，… n的n个人围坐一圈，约定编号为k (&lt;&#x3D;k&lt;&#x3D;n)的人从1开始报数，数到m 的那个人出列,它的下一位又从1开始报数，数到m的那个人又出列，依次类推，直到所有人出列为止，由此产生一个出队编号的序列。</li>
</ul>
</li>
</ul>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220716213807128.png" alt="image-20220716213807128"></p>
<ul>
<li><p>提示</p>
<ul>
<li>用一个不带头结点的循环链表来处理Josephu问题:先构成一个有n个结点的单循环链表，然后由k结点起从1开始计数，计到m时，对应结点从链表中删除，然后再从被删除结点的下一个结点又从1开始计数，直到最后一个结点从链表中删除算法结束。</li>
</ul>
</li>
<li><p>Joseph问题–&gt;创建单向环形链表思路</p>
<ul>
<li><p>构建一个单向的环形链表思路</p>
<ol>
<li>先创建第一个节点,让 first 指向该节点,并形成环形</li>
<li>后面当我们每创建一个新的节点，就把该节点，加入到已有的环形链表中即可</li>
</ol>
</li>
<li><p>遍历环形链表</p>
<ol>
<li>先让一个辅助指针(变量)curBoy，指向first节点</li>
<li>然后通过一个while循环遍历该环形链表即可 <strong>curBoy.next &#x3D;&#x3D; first</strong> 结束</li>
</ol>
</li>
</ul>
</li>
<li><p>Joseph问题–&gt;小孩出圈思路</p>
<ul>
<li>根据用户的输入，生成一个小孩出圈的顺序：n &#x3D; 5 ,即有5个人；k &#x3D; 1,从第一个人开始报数；m &#x3D; 2,数2下<ol>
<li>需求创建一个<strong>辅助指针(变量) helper ,事先应该指向环形链表的最后这个节点</strong>.<br>补充:小孩报数前，先让first和 helper移动k-1次</li>
<li>当小孩报数时，让first和helper指针同时的移动 <strong>m -1</strong>次</li>
<li>这时就可以将first指向的小孩节点出圈<br><strong>first &#x3D; first.next</strong><br><strong>helper.next &#x3D;first</strong><br>原来first指向的节点就没有任何引用，就会被回收</li>
<li>出圈的顺序<br>2-&gt;4-&gt;1-&gt;5-&gt;3</li>
</ol>
</li>
</ul>
</li>
</ul>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ysy.linkedlist;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Joseph</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//测试构建环形链表，并遍历</span></span><br><span class="line">        <span class="type">CircleSingleLinkedList</span> <span class="variable">circleSingleLinkedList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CircleSingleLinkedList</span>();</span><br><span class="line">        circleSingleLinkedList.addBoy(<span class="number">5</span>);</span><br><span class="line">        circleSingleLinkedList.showBoy();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试小孩出圈</span></span><br><span class="line">        circleSingleLinkedList.countBoy(<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个环形的单向链表</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CircleSingleLinkedList</span>&#123;</span><br><span class="line">    <span class="comment">//创建一个first节点，当前没有编号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Boy</span> <span class="variable">first</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Boy</span>(-<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//添加小孩节点，构成一个环形的单向链表</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addBoy</span><span class="params">(<span class="type">int</span> nums)</span>&#123;</span><br><span class="line">        <span class="comment">//nums做一个校验</span></span><br><span class="line">        <span class="keyword">if</span>(nums &lt; <span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;nums值不正确&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Boy</span> <span class="variable">curBoy</span> <span class="operator">=</span> <span class="literal">null</span>;<span class="comment">//辅助指针，帮助构建环形链表</span></span><br><span class="line">        <span class="comment">//使用for循环创建环形链表</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= nums; i++)&#123;</span><br><span class="line">            <span class="comment">//根据编号创建小孩节点</span></span><br><span class="line">            <span class="type">Boy</span> <span class="variable">boy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Boy</span>(i);</span><br><span class="line">            <span class="comment">//如果i=1</span></span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">1</span>)&#123;</span><br><span class="line">                first = boy;</span><br><span class="line">                first.setNext(first);<span class="comment">//构成环</span></span><br><span class="line">                curBoy = first;<span class="comment">//让curBoy指向第一个节点</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                curBoy.setNext(boy);</span><br><span class="line">                boy.setNext(first);</span><br><span class="line">                curBoy = boy;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历当前环形链表</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showBoy</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//判断链表是否为空</span></span><br><span class="line">        <span class="keyword">if</span>(first == <span class="literal">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;没有任何小孩~&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//first不能动，使用辅助指针</span></span><br><span class="line">        <span class="type">Boy</span> <span class="variable">curBoy</span> <span class="operator">=</span> first;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;小孩的编号%d \n&quot;</span>, curBoy.getNumber());</span><br><span class="line">            <span class="keyword">if</span>(curBoy.getNext() == first)&#123;</span><br><span class="line">                <span class="comment">//遍历完毕</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            curBoy = curBoy.getNext();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据用户的输入，计算出小孩的出圈顺序</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> startNumber 表示从第几个小孩开始数数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> countNumber 表示数几下</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums 表示小孩个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">countBoy</span><span class="params">(<span class="type">int</span> startNumber, <span class="type">int</span> countNumber, <span class="type">int</span> nums)</span>&#123;</span><br><span class="line">        <span class="comment">//先对数据校验</span></span><br><span class="line">        <span class="keyword">if</span>(first == <span class="literal">null</span> || startNumber &lt; <span class="number">1</span> || startNumber &gt; nums)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;参数输入有误，请重新输入~&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//辅助指针first，帮助小孩出圈</span></span><br><span class="line">        <span class="type">Boy</span> <span class="variable">helper</span> <span class="operator">=</span> first;</span><br><span class="line">        <span class="comment">//创建辅助指针helper，事先指向环形链表的最后一个节点</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(helper.getNext() == first)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            helper = helper.getNext();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//小孩报数前，先让first和 helper移动k-1次</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span><span class="number">0</span>; j &lt; startNumber - <span class="number">1</span>; j++)&#123;</span><br><span class="line">            first = first.getNext();</span><br><span class="line">            helper = helper.getNext();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当小孩报数时，让first和helper指针同时的移动 m-1 次，然后出圈</span></span><br><span class="line">        <span class="comment">//循环操作，直到圈中只有一个小孩</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(helper == first)&#123;</span><br><span class="line">                <span class="comment">//只有一个小孩</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//让first和helper指针同时的移动 countNumber-1 次</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; countNumber - <span class="number">1</span>; j++)&#123;</span><br><span class="line">                first = first.getNext();</span><br><span class="line">                helper = helper.getNext();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//这时first指向的节点就是要出圈的小孩</span></span><br><span class="line">            System.out.printf(<span class="string">&quot;小孩%d出圈 \n&quot;</span>, first.getNumber());</span><br><span class="line">            <span class="comment">//小孩出圈</span></span><br><span class="line">            first = first.getNext();</span><br><span class="line">            helper.setNext(first);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.printf(<span class="string">&quot;最后留在圈中的小孩编号为%d \n&quot;</span>, first.getNumber());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个Boy类，表示一个节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Boy</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> number;<span class="comment">//编号</span></span><br><span class="line">    <span class="keyword">private</span> Boy next;<span class="comment">//指向下一个节点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Boy</span><span class="params">(<span class="type">int</span> number)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.number = number;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNumber</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> number;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNumber</span><span class="params">(<span class="type">int</span> number)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.number = number;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Boy <span class="title function_">getNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNext</span><span class="params">(Boy next)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
  </article>
  

  
  <nav class="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2022
        <i class="ri-heart-fill heart_icon"></i> Shiyu Yang
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="Healer"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>