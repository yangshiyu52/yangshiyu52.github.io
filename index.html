<!DOCTYPE html>


<html lang="en">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title> Healer</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    <link rel="alternate" href="/atom.xml" title="Healer" type="application/atom+xml">
</head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      
<section class="cover">
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover1.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">Healer</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.staticfile.org/typed.js/2.0.12/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['面朝大海，春暖花开', '愿你一生努力，一生被爱', '想要的都拥有，得不到的都释怀'],
        startDelay: 0,
        typeSpeed: 200,
        loop: true,
        backSpeed: 100,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  
  
  

<div class="notice" style="margin-top:50px">
    <i class="ri-heart-fill"></i>
    <div class="notice-content" id="broad"></div>
</div>
<script type="text/javascript">
    fetch('https://v1.hitokoto.cn')
        .then(response => response.json())
        .then(data => {
            document.getElementById("broad").innerHTML = data.hitokoto;
        })
        .catch(console.error)
</script>

<style>
    .notice {
        padding: 20px;
        border: 1px dashed #e6e6e6;
        color: #969696;
        position: relative;
        display: inline-block;
        width: 100%;
        background: #fbfbfb50;
        border-radius: 10px;
    }

    .notice i {
        float: left;
        color: #999;
        font-size: 16px;
        padding-right: 10px;
        vertical-align: middle;
        margin-top: -2px;
    }

    .notice-content {
        display: initial;
        vertical-align: middle;
    }
</style>
  
  <article class="articles">
    
    
    
    
    <article
  id="post-JavaSE"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
	
		置顶
	
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/06/28/JavaSE/"
    >JavaSE
  <i class="article-topping">Sticky</i>
</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/06/28/JavaSE/" class="article-date">
  <time datetime="2022-06-28T05:58:06.000Z" itemprop="datePublished">2022-06-28</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/JavaSE/">JavaSE</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="Java-概述"><a href="#Java-概述" class="headerlink" title="Java 概述"></a>Java 概述</h1><h2 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h2><p>计算机执行某些操作或解决某个问题而编写的一系列有序指令的集合</p>
<h2 id="Java-重要特点"><a href="#Java-重要特点" class="headerlink" title="Java 重要特点"></a>Java 重要特点</h2><ol>
<li><p>Java 语言是<strong>面向对象</strong>的(oop)</p>
</li>
<li><p>Java 语言是<strong>健壮</strong>的。Java 的强类型机制、异常处理、垃圾的自动收集等是 Java 程序健壮性的重要保证 </p>
</li>
<li><p>Java 语言是<strong>跨平台性</strong>的。[即: 一个编译好的.class 文件可以在多个系统下运行，这种特性称为跨平台]</p>
</li>
<li><p>Java 语言是<strong>解释型</strong>的。</p>
</li>
</ol>
<p>​		<strong>解释性语言：javascript,PHP, java</strong> </p>
<p>​		<strong>编译性语言: c &#x2F; c++</strong> </p>
<p>​		区别是：解释性语言，编译后的代码，不能直接被机器执行,需要解释器来执行, 编译性语言, 编译后的代码, 可以直接被机器执行, c &#x2F;c+</p>
<h2 id="JDK，JRE介绍"><a href="#JDK，JRE介绍" class="headerlink" title="JDK，JRE介绍"></a>JDK，JRE介绍</h2><p>1）JDK 的全称(Java Development Kit Java 开发工具包)</p>
<pre><code>     **JDK = JRE + java 开发工具集 **   [java, javac,javadoc,javap,java编译工具等] 
</code></pre>
<p>​		JDK 是提供给 Java 开发人员使用的，其中包含了 java 的开发工具，也包括了 JRE。所以安装了 JDK，就不用在单独安装 JRE了</p>
<p>2）JRE(Java Runtime Environment Java 运行环境)</p>
<p>​		 <strong>JRE &#x3D; JVM + Java 的核心类库[类]</strong> </p>
<p>​		包括 Java 虚拟机(JVM Java Virtual Machine)和 Java 程序所需的核心类库等，如果想要运行一个开发好的 Java 程序， 计算机中只需要安装 JRE 即可。</p>
<h2 id="Java虚拟机-JVM"><a href="#Java虚拟机-JVM" class="headerlink" title="Java虚拟机-JVM"></a>Java虚拟机-JVM</h2><ol>
<li><p>JVM 是一个虚拟的计算机，具有指令集并使用不同的存储区域。负责执行指令，管理数据、内存、寄存器，<strong>包含在 JDK 中</strong>. </p>
</li>
<li><p>对于不同的平台，有不同的虚拟机。 </p>
</li>
<li><p>Java 虚拟机机制屏蔽了底层运行平台的差别，实现了“<strong>一次编译，到处运行”</strong></p>
</li>
</ol>
<h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><p>私有:java虚拟机栈，程序计数器，本地方法栈 共享:java堆，方法区</p>
<ol>
<li><p>栈： 一般存放基本数据类型(局部变量) </p>
</li>
<li><p>堆： 存放对象(Cat cat , 数组等) </p>
</li>
<li><p>方法区：常量池(常量，比如字符串)， 类加载信息</p>
</li>
</ol>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220511221502453.png" alt="image-20220511221502453"></p>
<h2 id="Java-转义字符"><a href="#Java-转义字符" class="headerlink" title="Java 转义字符"></a>Java 转义字符</h2><p>在控制台使用 <strong>tab</strong> 可补全命令</p>
<p>\t ：一个制表位，实现对齐的功能 </p>
<p>\n ：换行符 </p>
<p>\ \：一个\</p>
<p>\ &quot; :一个”</p>
<p>\ &#39; ：一个’ </p>
<p>\r :一个回车</p>
<p>\0:空字符</p>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>用于注解说明解释程序的文字，提高了代码的阅读性(可读性)</p>
<p>被注释的文字，不会被 JVM（java 虚拟机）解释执行</p>
<p> 多行注释里面不允许有多行注释嵌套</p>
<p>文档注释：javadoc -d 文件名 -author -version xx.java</p>
<h2 id="常用dos命令"><a href="#常用dos命令" class="headerlink" title="常用dos命令"></a>常用dos命令</h2><ol>
<li><p>查看当前目录是有什么内容：dir </p>
</li>
<li><p>切换到其他盘下：盘符号 + ：</p>
</li>
<li><p>切换到上一级：cd .. </p>
</li>
<li><p>切换到根目录：cd \ </p>
</li>
<li><p>查看指定的目录下所有的子级目录：tree</p>
</li>
<li><p>清屏：cls </p>
</li>
<li><p>退出：exit</p>
</li>
</ol>
<h2 id="成员方法传参机制"><a href="#成员方法传参机制" class="headerlink" title="成员方法传参机制"></a>成员方法传参机制</h2><p><strong>实参定义</strong></p>
<p>实参全称为实际参数，是在调用时传递给函数的参数。实参可以是常量、变量、表达式、函数等，无论实参是何种类型的量，在进行函数调用时，它们都必须具有确定的值，以便把这些值 传送给形参因此应预先用赋值，输入等办法使实参获得确定值。</p>
<p><strong>形参定义</strong></p>
<p>形参全称为形式参数，由于它不是实际存在变量，所以又称虚拟变量。是在定义函数名和函数体的时候使用的参数,目的是用来接收调用该函数时传入的参数.在调用函数时，实参将赋值给形参。因而，必须注意实参的个数，类型应与形参-一对应， 并且实参必须要有确定的值。</p>
<ol>
<li><p>基本数据类型，传递的是值（值拷贝），形参的改变不影响实参</p>
</li>
<li><p>引用数据类型,，传递的是地址（传递也是值，但是值是地址），可以通过形参影响实参</p>
</li>
</ol>
<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220517173202743.png" alt="image-20220517173202743"></p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220517173304401.png" alt="image-20220517173304401"></p>
<h3 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h3><p>默认int</p>
<p>计算机底层存储的都是<strong>补码</strong>，并以补码进行数据运算，显示的是原码</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220517173405866.png"></p>
<h3 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a>浮点类型</h3><p>默认float</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220517175012934.png" alt="image-20220517175012934"></p>
<ol>
<li><p>关于浮点数在机器中存放形式的简单说明，浮点数&#x3D;符号位+指数位+尾数位 </p>
</li>
<li><p>尾数部分可能丢失，造成精度损失(小数都是近似值)</p>
</li>
</ol>
<h3 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h3><p>字符类型可以表示单个字符,字符类型是 char，char 是两个字节(可以存放汉字)，多个字符用字符串 String</p>
<p>字符型存储到计算机中，是对应的ASCII码值</p>
<h3 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h3><p>只允许取值true和false，无null，占一个字节</p>
<h2 id="基本数据类型转换"><a href="#基本数据类型转换" class="headerlink" title="基本数据类型转换"></a>基本数据类型转换</h2><p>自动类型转换：进行赋值或运算时，精度小的类型自动转换为精度大的数据类型(byte–&gt;short–&gt;int–&gt;long–&gt;float–&gt;double)(char–&gt;int–&gt;long–&gt;float–&gt;double)</p>
<p>​							byte, short 和 char 之间不会相互自动转换，但可以计算，在计算时首先转换成int类型</p>
<p>强制类型转换：将容量大的数据类型转换成容量小的数据类型</p>
<p>​							使用时要加上强制转换符()，但可能造成精度降低或溢出</p>
<p>基本数据类型和String类型的转换：基本–&gt;String：将基本数据类型的值+””</p>
<p>​															 String–&gt;基本：通过基本类型的包装类调用parseXXX方法</p>
<h2 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220517191425976.png" alt="image-20220517191425976"></p>
<p>Unicode：将世界上所有的符号都纳入其中，每个符号都给予一个独一无二的编码，使用Unicode没有乱码问题</p>
<h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220517193700932.png" alt="image-20220517193700932"></p>
<h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><p>1）基本赋值运算符   int a &#x3D; 10;</p>
<p>2）复合赋值运算符 +&#x3D; ，-&#x3D; ，*&#x3D; ， &#x2F;&#x3D; ，%&#x3D; 等</p>
<p>复合赋值运算符会进行类型转换。例如：b +&#x3D; 2; &#x2F;&#x2F; 等价 b &#x3D; (byte)(b+2)</p>
<h2 id="关系运算符-比较运算符"><a href="#关系运算符-比较运算符" class="headerlink" title="关系运算符(比较运算符)"></a>关系运算符(比较运算符)</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220517193743927.png" alt="image-20220517193743927"></p>
<h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><ol>
<li><p>短路与 &amp;&amp; ， 短路或 ||，取反 ! </p>
</li>
<li><p>逻辑与 &amp;，逻辑或 |，^ 逻辑异或</p>
</li>
</ol>
<h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220517195010581.png" alt="image-20220517195010581"></p>
<ol>
<li><p>算术右移 &gt;&gt;：低位溢出,符号位不变,并用符号位补溢出的高位 int a&#x3D;1&gt;&gt;2; &#x2F;&#x2F;1 &#x3D;&gt; 00000001 &#x3D;&gt; 00000000 本质 1&#x2F;2&#x2F;2&#x3D;0</p>
</li>
<li><p>算术左移 &lt;&lt;: 符号位不变,低位补 0 int c&#x3D;1&lt;&lt;2; &#x2F;&#x2F;1 &#x3D;&gt; 00000001 &#x3D;&gt; 00000100 本质 1 * 2 * 2 &#x3D; 4</p>
</li>
<li><blockquote>
<blockquote>
<blockquote>
<p> 逻辑右移也叫无符号右移,运算规则是: 低位溢出，高位补 0</p>
</blockquote>
</blockquote>
</blockquote>
</li>
</ol>
<h2 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h2><p>条件表达式 ? 表达式 1: 表达式 2; </p>
<p>运算规则：1）如果条件表达式为 true，运算后的结果是表达式 1； </p>
<p>​					2）如果条件表达式为 false，运算后的结果是表达式 2；</p>
<h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><p>1）由26个英文字母大小写，0-9，_或$组成</p>
<p>2）数字不能开头</p>
<p>3）不可以使用关键字和保留字，但能包含关键字和保留字</p>
<p>4）不能包含空格</p>
<h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><p><strong>都小写</strong></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220517194602552.png" alt="image-20220517194602552"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220517194633358.png" alt="image-20220517194633358"></p>
<p><strong>volatile与synchronized的区别：</strong></p>
<p>volatile本质是在告诉jvm当前变量在寄存器中的值是不确定的,需要从主存中读取,synchronized则是锁定当前变量,只有当前线程可以访问该变量,其他线程被阻塞住</p>
<p>volatile仅能使用在变量级别,synchronized则可以使用在变量,方法.</p>
<p>volatile仅能实现变量的修改可见性,但不具备原子特性,而synchronized则可以保证变量的修改可见性和原子性.</p>
<p>volatile不会造成线程的阻塞,而synchronized可能会造成线程的阻塞.</p>
<p>volatile标记的变量不会被编译器优化,而synchronized标记的变量可以被编译器优化.</p>
<p>synchronized很强大，既可以保证可见性，又可以保证原子性，而volatile不能保证原子性！</p>
<h2 id="保留字"><a href="#保留字" class="headerlink" title="保留字"></a>保留字</h2><p>Java 保留字：现有 Java 版本尚未使用，但以后版本可能会作为关键字使用。自己命名标识符时要避免使用这些保留字 byValue、cast、future、 generic、inner、 operator、 outer、 rest、 var 、 goto</p>
<h2 id="原码、反码、补码"><a href="#原码、反码、补码" class="headerlink" title="原码、反码、补码"></a>原码、反码、补码</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220517194927173.png" alt="image-20220517194927173"></p>
<h1 id="程序控制结构"><a href="#程序控制结构" class="headerlink" title="程序控制结构"></a>程序控制结构</h1><p>switch(表达式)中表达式的返回值必须是：byte, short, int, char, enum, String</p>
<p>break 语句用于终止某个语句块的执行，一般使用在 switch 或者循环[for, while, do-while]中</p>
<p>continue 语句用于结束本次循环，继续执行下一次循环，出现在多层嵌套的循环语句体中时，可以通过标签指明要跳过的是哪一层循环 </p>
<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>存放多个同一类型的数据，是一种<strong>引用类型</strong>数据</p>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>动态初始化：数据类型 数组名[] &#x3D; new  数据类型[大小] 例：int a[] &#x3D; new int[5]</p>
<p>​						数据类型 数组名[]；数组名 &#x3D; new  数据类型[大小] </p>
<p>​						数据类型 数组名[[]][[][] &#x3D; new  数据类型[大小] [大小]</p>
<p>​						数据类型 数组名[[]][[][] &#x3D; new  数据类型[大小] []</p>
<p>静态初始化：数据类型 数组名[] &#x3D; {元素值，元素值, … }</p>
<h2 id="数组细节"><a href="#数组细节" class="headerlink" title="数组细节"></a>数组细节</h2><p>1）数组是多个相同类型数据的组合</p>
<p>2）数组创建后，如果没有赋值，有默认值</p>
<p>​		int 0，short 0, byte 0, long 0, float 0.0,double 0.0，char \u0000，boolean false，String null</p>
<p>3）数组属于引用类型，数组型数据是对象(Object)</p>
<h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>1）区分相同名字的类</p>
<p>2）当类很多时，可以更好的管理类</p>
<p>3）控制访问范围</p>
<h3 id="常用的包"><a href="#常用的包" class="headerlink" title="常用的包"></a>常用的包</h3><ol>
<li><p>java.lang.* &#x2F;&#x2F;lang 包是基本包，默认引入，不需要再引入. </p>
</li>
<li><p>java.util.* &#x2F;&#x2F;util 包，系统提供的工具包, 工具类，使用 Scanner </p>
</li>
<li><p>java.net.* &#x2F;&#x2F;网络包，网络开发 </p>
</li>
<li><p>java.awt.* &#x2F;&#x2F;是做 java的界面开发，GUI</p>
</li>
</ol>
<h2 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h2><p>java 提供四种访问控制修饰符号，用于控制方法和属性(成员变量)的访问权限（范围）</p>
<ol>
<li><p>公开级别:用 <strong>public</strong> 修饰,对外公开 </p>
</li>
<li><p>受保护级别:用 <strong>protected</strong> 修饰,对子类和同一个包中的类公开</p>
</li>
<li><p>默认级别:没有修饰符号,向同一个包的类公开</p>
</li>
<li><p>私有级别:用 <strong>private</strong> 修饰,只有类本身可以访问,不对外公开</p>
</li>
</ol>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>修饰符可以修饰类中的属性，成员方法以及类</p>
<p>只有默认的和public才能修饰类</p>
<h1 id="OOP"><a href="#OOP" class="headerlink" title="OOP"></a>OOP</h1><h2 id="面向对象编程三大特征"><a href="#面向对象编程三大特征" class="headerlink" title="面向对象编程三大特征"></a>面向对象编程三大特征</h2><p>封装、继承和多态</p>
<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>把抽象出的数据[属性]和对数据的操作[方法]封装在一起，数据被保护在内部，程序的其他部分只能通过被授权的操作[方法]，才能对数据进行操作</p>
<ol>
<li><p>将属性进行私有化private</p>
</li>
<li><p>提供一个公共的set方法，用户对数据进行赋值</p>
</li>
<li><p>提供一个公共的get方法，用于获取属性的值</p>
</li>
</ol>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>继承可以解决代码复用,让我们的编程更加靠近人类思维.当多个类存在相同的属性(变量)和方法时,可以从这些类中抽象出父类,在父类中定义这些相同的属性和方法，所有的子类不需要重新定义这些属性和方法，只需要通过 extends 来声明继承父类即可。</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220503220735855.png" alt="image-20220503220735855"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220503220812342.png" alt="image-20220503220812342"></p>
<p>继承的深入讨论&#x2F;细节问题</p>
<ol>
<li><p>子类继承了所有的属性和方法，非私有的属性和方法可以在子类直接访问, 但是私有属性和方法不能在子类直接访 问，要通过父类提供公共的方法去访问</p>
</li>
<li><p>子类必须调用父类的构造器， 完成父类的初始化 </p>
</li>
<li><p>当创建子类对象时，不管使用子类的哪个构造器，默认情况下总会去调用父类的无参构造器，如果父类没有提供无参构造器，则必须在子类的构造器中用super</p>
<p>  去指定使用父类的哪个构造器完成对父类的初始化工作，否则，编译不会通过</p>
</li>
<li><p>如果希望指定去调用父类的某个构造器，则显式的调用一下 : super(参数列表)</p>
</li>
<li><p>super 在使用时，必须放在构造器第一行(super只能在构造器中使用) </p>
</li>
<li><p>super() 和 this() 都只能放在构造器第一行，因此这两个方法不能共存在一个构造器</p>
</li>
<li><p>java 所有类都是 Object 类的子类, Object 是所有类的基类. </p>
</li>
<li><p>父类构造器的调用不限于直接父类！将一直往上追溯直到 Object 类(顶级父类) </p>
</li>
<li><p>子类最多只能继承一个父类(指直接继承)，即 java 中是单继承机制。 思考：如何让 A 类继承 B 类和 C 类？ 【A 继承 B， B 继承 C】 </p>
</li>
<li><p>不能滥用继承，子类和父类之间必须满足 <strong>is-a</strong> 的逻辑</p>
</li>
</ol>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>方法或对象具有多种形态。是面向对象的第三大特征，多态是建立在封装和继承基础之上的。</p>
<ol>
<li>方法的多态：重写和重载就体现多态</li>
</ol>
<p>2）<strong>对象的多态</strong></p>
<p>a.一个对象的编译类型和运行类型可以不一致</p>
<p>b.编译类型在定义对象时就确定了，不能改变</p>
<p>c.运行类型可以改变</p>
<p><strong>d.编译看左，运行看右</strong></p>
<h4 id="多态的注意事项"><a href="#多态的注意事项" class="headerlink" title="多态的注意事项"></a>多态的注意事项</h4><p>多态的<strong>前提</strong>是：两个对象(类)存在继承关系</p>
<p><strong>多态的向上转型</strong></p>
<p>​		本质：父类引用指向子类对象</p>
<p>​		语法：父类类型 引用名 &#x3D; new 子类类型()；</p>
<p>​		特点：<strong>编译看左，运行看右</strong></p>
<p>​					可以调用父类中的所有成员</p>
<p>​					不能调用子类中的特有成员</p>
<p>​					最终运行效果看子类的具体实现</p>
<p><strong>多态的向下转型</strong></p>
<p>​		语法：子类类型 引用名 &#x3D; (子类类型) 父类引用；</p>
<p>​		特点：只能强转父类的引用，不能强转父类的对象</p>
<p>​					要求父类的引用必须指向的是当前目标类型的对象</p>
<p>​					向下转型后可以调用子类类型中的所有成员</p>
<p><strong>instanceOf</strong> 比较操作符，用于判断对象的运行类型是否为 XX 类型或 XX 类型的子类型</p>
<h4 id="java-的动态绑定机制"><a href="#java-的动态绑定机制" class="headerlink" title="java 的动态绑定机制"></a>java 的动态绑定机制</h4><p>1）当调用对象方法的时候，该方法会与该对象的内存地址&#x2F;运行类型绑定</p>
<p>2）当调用对象属性的时候，没有动态绑定机制，哪里声明，哪里使用</p>
<h2 id="super-关键字"><a href="#super-关键字" class="headerlink" title="super 关键字"></a>super 关键字</h2><p>super代表父类的引用，用于访问父类的属性、方法、构造器。</p>
<h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>1）访问父类的属性，但不能访问父类的private属性  例：super.属性名</p>
<p>2）访问父类的方法，但不能访问父类的private方法  例：super.方法名(参数列表)</p>
<p>3）访问父类的构造器 例：super(参数列表) 只能放在构造器的第一句，只能出现一句</p>
<h3 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h3><p>1）调用父类的构造器（分工明确，父类属性由父类初始化，子类属性由子类初始化）</p>
<p>2）当子类中有和父类中的成员（属性和方法）重名时，为了访问父类的成员，必须通过super</p>
<p>3）super的访问不限于直接父类，如果爷爷类有和本类中有同名的成员，也可以使用super去访问爷爷类的成员；</p>
<p>​		如果多个基类中都有相同的成员，则super访问遵循就近原则</p>
<h3 id="super与this的比较"><a href="#super与this的比较" class="headerlink" title="super与this的比较"></a>super与this的比较</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220505145216027.png" alt="image-20220505145216027"></p>
<h2 id="方法重写-x2F-覆盖-override"><a href="#方法重写-x2F-覆盖-override" class="headerlink" title="方法重写&#x2F;覆盖(override)"></a>方法重写&#x2F;覆盖(override)</h2><p>子类中有一个方法，和父类的某个方法的名称、返回值类型、参数一样</p>
<h3 id="重写与重载的区别"><a href="#重写与重载的区别" class="headerlink" title="重写与重载的区别"></a>重写与重载的区别</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220505145536052.png" alt="image-20220505145536052"></p>
<h2 id="Object-类"><a href="#Object-类" class="headerlink" title="Object 类"></a>Object 类</h2><p><img src="https://uploadfiles.nowcoder.com/images/20200717/257056865_1594996230591_77654A637F366FC03F9C293582926971" alt="img"></p>
<p><img src="https://uploadfiles.nowcoder.com/images/20190412/242025553_1555068065653_1F768A0737B2E9FBB49649C7465CBFCE" alt="img"></p>
<h3 id="equals方法"><a href="#equals方法" class="headerlink" title="equals方法"></a>equals方法</h3><h4 id="x3D-x3D-和-equals比较"><a href="#x3D-x3D-和-equals比较" class="headerlink" title="&#x3D;&#x3D;和 equals比较"></a>&#x3D;&#x3D;和 equals比较</h4><p>&#x3D;&#x3D;是一个比较运算符</p>
<p>1）&#x3D;&#x3D;：既可以判断基本类型，又可以判断引用类型</p>
<p>2）&#x3D;&#x3D;：如果判断基本类型，判断的是<strong>值</strong>是否相等</p>
<p>3）&#x3D;&#x3D;：如果判断引用类型，判断的是**地址值 **是否相等</p>
<p>4）equals：是Object类中的方法，只能判断引用类型，默认判断的是地址值是否相等，子类中往往重写该方法，用于判断<strong>内容</strong>是否相等（例：Integer, String）</p>
<h3 id="hashCode方法"><a href="#hashCode方法" class="headerlink" title="hashCode方法"></a>hashCode方法</h3><ol>
<li><p>返回对象的哈希码值，提高具有哈希结构的容器的效率！ </p>
</li>
<li><p>两个引用，如果指向的是同一个对象，则哈希值肯定是一样的！ </p>
</li>
<li><p>两个引用，如果指向的是不同对象，则哈希值是不一样的 </p>
</li>
<li><p>哈希值主要根据地址号来的！不能完全将哈希值等价于地址</p>
</li>
</ol>
<h3 id="toString-方法"><a href="#toString-方法" class="headerlink" title="toString 方法"></a>toString 方法</h3><ol>
<li>基本介绍</li>
</ol>
<p>​	默认返回：全类名+@+哈希值的十六进制</p>
<p>​	子类往往重写 toString 方法，用于返回对象的属性信息 </p>
<ol start="2">
<li><p>重写 toString 方法，打印对象或拼接对象时，都会自动调用该对象的 toString 形式</p>
</li>
<li><p>当直接输出一个对象时，toString 方法会被默认的调用</p>
</li>
</ol>
<h3 id="finalize-方法"><a href="#finalize-方法" class="headerlink" title="finalize 方法"></a>finalize 方法</h3><ol>
<li><p>当对象被回收时，系统自动调用该对象的 finalize 方法。子类可以重写该方法，做一些释放资源的操作</p>
</li>
<li><p>什么时候被回收：当某个对象没有任何引用时，则 jvm 就认为这个对象是一个垃圾对象，就会使用垃圾回收机制来销毁该对象，在销</p>
</li>
</ol>
<p>​		毁该对象前，会先调用finalize 方法。 </p>
<ol start="3">
<li>垃圾回收机制的调用，是由系统来决定(即有自己的 GC 算法), 也可以通过 System.gc() 主动触发垃圾回收机制</li>
</ol>
<h2 id="类变量和类方法（静态变量和静态方法）"><a href="#类变量和类方法（静态变量和静态方法）" class="headerlink" title="类变量和类方法（静态变量和静态方法）"></a>类变量和类方法（静态变量和静态方法）</h2><h3 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h3><p>​	特点：会被本类的所有的对象实例共享，随着类的加载而创建，可以直接通过类名调用</p>
<p>​	<strong>内存布局</strong>：在堆的永久生成区域中</p>
<p>​	定义：访问修饰符 static 数据类型 变量名；</p>
<p>​	访问：类名.变量名[前提：满足访问修饰符的访问权限和范围]</p>
<p>​	生命周期：随类的加载开始，随类的消亡而销毁</p>
<h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>​	特点：不创建实例，也可以调用，可通过类名调用；不允许使用与对象有关的关键字，<strong>this、super</strong></p>
<p>​	定义：访问修饰符 static 数据返回类型 方法名(){}</p>
<p><strong>静态方法，只能访问静态的成员，非静态方法，可以访问静态成员和非静态成员</strong></p>
<h2 id="main方法"><a href="#main方法" class="headerlink" title="main方法"></a>main方法</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220505162645471.png" alt="image-20220505162645471"></p>
<p>在main方法中，可以直接调用main方法所在类的静态方法或静态属性</p>
<p>但是，不能直接访问该类中的非静态成员，必须创建该类的一个实例对象后，才能通过这个对象去访问类中的非静态成员</p>
<h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><p>又称初始化块，属于类中的成员，类似于方法，将逻辑语句封装在方法体中，通过{}包围起来</p>
<p>但和方法不同，没有方法名，没有返回，没有参数，只有方法体，而且不能通过对象或类显示调用，而是加载类时，或创建对象时隐式调用</p>
<p>两类：静态代码块和普通&#x2F;非静态代码块</p>
<p>相当于另一种形式的构造器，可以做初始化操作</p>
<h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><p>1）静态代码块随着类的加载而执行，并且只会执行一次</p>
<p>2）<strong>类加载时间</strong></p>
<p>​		a.创建对象实例时(new)</p>
<p>​		b.创建子类对象实例，父类也会被加载</p>
<p>​		c.使用类的静态成员时</p>
<p>3）普通代码块，在创建对象实例时，会被隐式的调用</p>
<p>​		<strong>创建一次，调用一次</strong></p>
<p>4）创建对象时，类的调用顺序</p>
<p>​		a.调用静态代码块和静态属性初始化(优先级一样，按定义顺序调用)</p>
<p>​		b.调用普通代码块和普通属性初始化(优先级一样，按定义顺序调用)</p>
<p>​		c.调用构造方法</p>
<p>5）子父类的调用顺序</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220505172401550.png" alt="image-20220505172401550"></p>
<h2 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h2><p>设计模式是在大量的实践中总结和理论化之后优化的代码结构、编程风格、以及解决问题的思考方式。</p>
<p>单例设计模式：采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法</p>
<p>方式：1）饿汉式；2）懒汉式</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220506133052141.png" alt="image-20220506133052141"></p>
<ol>
<li>将构造器私有化</li>
<li>在类的内部直接创建对象(该对象是 static) </li>
<li>提供一个公共的 static 方法，返回对象</li>
</ol>
<h2 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h2><p><strong>可以修饰类、属性、方法和局部变量，不能修饰构造器</strong></p>
<p>1）被final修饰的类，不能被继承，但可以实例化</p>
<p>2）被final修饰的方法，不能被子类重写</p>
<p>3）被final修饰的局部变量或类中的某个属性，又叫常量，不能被修改</p>
<p>4）final修饰的属性在定义时，<strong>必须赋初值</strong>，赋值可以在以下位置：</p>
<p>​		a.定义时 b.在构造器中 c.在代码块中</p>
<p>5）如果final修饰的属性是静态的，则初始化的位置只能是a.定义时 b.在静态代码块中，不能在构造器中赋值</p>
<p>6）如果一个类已经是final类，就没有必要再将方法修饰成final方法</p>
<p>7）final和static往往搭配使用，效率更高，<strong>不会导致类加载</strong>，底层编译器做了优化处理</p>
<p>8）包装类，String类都是final类</p>
<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>当父类的一些方法不能确定时，可以用abstract关键字来修饰该方法，这个方法就是抽象方法，用abstract来修饰该类就是抽象类</p>
<p>1）抽象类不能被实例化</p>
<p>2）abstract只能修饰类和方法，不能修饰属性和其它的</p>
<p>3）抽象类的本质还是类，可以有任意成员，例如：非抽象方法、构造器、静态属性等</p>
<p>4）抽象方法不能有主体，即不能实现</p>
<p>5）一个类继承了抽象类，则它必须实现抽象类的所有抽象方法</p>
<p>6）<strong>抽象方法不能使用private、final和static来修饰，因为这些关键字都是和重写相违背的</strong></p>
<p>关于抽象类</p>
<p><strong>JDK 1.8以前</strong>，抽象类的方法默认访问权限为<strong>protected</strong></p>
<p><strong>JDK 1.8时</strong>，抽象类的方法默认访问权限变为<strong>default</strong></p>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>给出一些没有实现的方法，封装在一起，到某个类要使用的时候，再根据具体情况把这些方法写出来</p>
<p>接口体现了程序设计的多态和高内聚低耦合的设计思想</p>
<p>JDK7.0中接口是更加抽象的抽象类，抽象类里的方法可以有方法体，接口里的方法都没有方法体</p>
<p>JDK8.0后接口类可以有静态方法、默认方法，也就是说接口中可以有方法的具体实现</p>
<p><strong>接口中的属性，只能是final的，而且是public static final修饰符，必须初始化</strong></p>
<p>接口不能继承其他的类，但是可以继承多个接口</p>
<p><strong>接口的修饰符只能是public和默认，这点和类的修饰符一样</strong></p>
<p><strong>like-a</strong>的关系</p>
<p>关于接口</p>
<p><strong>JDK 1.8以前</strong>，接口中的方法必须是<strong>public</strong>的</p>
<p><strong>JDK 1.8时</strong>，接口中的方法可以是<strong>public</strong>的，也可以是<strong>default</strong>的</p>
<p><strong>JDK 1.9时</strong>，接口中的方法可以是<strong>private</strong>的</p>
<p><strong>高内聚低耦合</strong>，是<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/25279">软件工程</a>中的概念，是判断软件设计好坏的标准，主要用于程序的<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/2262089">面向对象</a>的设计，主要看类的内聚性是否高，<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E8%80%A6%E5%90%88%E5%BA%A6/2603938">耦合度</a>是否低。目的是使程序模块的可重用性、移植性大大增强。通常程序结构中各模块的内聚程度越高，模块间的耦合程度就越低。内聚是从功能角度来度量模块内的联系，一个好的内聚模块应当恰好做一件事，它描述的是模块内的功能联系；耦合是软件结构中各模块之间相互连接的一种<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%BA%A6%E9%87%8F/34036">度量</a>，耦合强弱取决于模块间接口的复杂程度、进入或访问一个模块的点以及通过接口的数据。</p>
<h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><p>类的五大成员：<strong>属性、方法、构造器、代码块、内部类</strong></p>
<p>类在局部位置(方法中&#x2F;代码块)：<strong>局部内部类、匿名内部类</strong></p>
<p>类在成员位置：<strong>成员内部类、静态内部类</strong></p>
<p>特点：可以直接访问私有属性，并且可以体现类与类之间的包含关系</p>
<h3 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220506150105202.png" alt="image-20220506150105202"></p>
<h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220506150255497.png" alt="image-20220506150255497"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220506150420023.png" alt="image-20220506150420023"></p>
<h3 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220506150551210.png" alt="image-20220506150551210"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220506150620993.png" alt="image-20220506150620993"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220506150656265.png" alt="image-20220506150656265"></p>
<h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220506150811300.png" alt="image-20220506150811300"></p>
<h2 id="枚举-enum"><a href="#枚举-enum" class="headerlink" title="枚举(enum)"></a>枚举(enum)</h2><p>枚举是一组常量的集合</p>
<p>枚举是一种特殊的类，里面包含一组有限的特定的对象</p>
<h3 id="自定义类实现枚举"><a href="#自定义类实现枚举" class="headerlink" title="自定义类实现枚举"></a>自定义类实现枚举</h3><p>可以提供getXxx方法，不需要提供setXxx方法，防止属性被修改，因为枚举对象通常为只读</p>
<p>对枚举对象&#x2F;属性使用final+static共同修饰，实现底层优化</p>
<p>枚举对象名全部大写</p>
<p>将构造器私有化，目的防止直接 new</p>
<p>本类内部创建一组对象</p>
<p>对外暴露对象（通过为对象添加 public final static修饰符）</p>
<h3 id="enum-关键字实现枚举"><a href="#enum-关键字实现枚举" class="headerlink" title="enum 关键字实现枚举"></a>enum 关键字实现枚举</h3><p>使用关键字 enum 替代 class</p>
<p> enum 关键字开发一个枚举类时，默认会<strong>继承 Enum 类</strong>, 而且是一个 final 类</p>
<p>public static final Season SPRING &#x3D; new Season(“春天”, “温暖”) 直接使用  SPRING(“春天”, “温暖”)    解读：<strong>常量名(实参列表)</strong></p>
<p>如果有多个常量(对象)， 使用<strong>逗号</strong>间隔，<strong>分号</strong>结尾</p>
<p>enum 来实现枚举，要求将定义常量对象，写在前面</p>
<p>如果使用无参构造器创建 枚举对象，则实参列表和小括号都可以省略</p>
<h3 id="Enum-类"><a href="#Enum-类" class="headerlink" title="Enum 类"></a>Enum 类</h3><ol>
<li><p>toString：Enum 类已经重写过了，返回的是当前对象名,子类可以重写该方法，用于返回对象的属性信息 </p>
</li>
<li><p>name：返回当前对象名（常量名），子类中不能重写 </p>
</li>
<li><p>ordinal：返回当前对象的位置号，默认从 0 开始 </p>
</li>
<li><p>values：返回当前枚举类中所有的常量</p>
</li>
<li><p>valueOf：将字符串转换成枚举对象，要求字符串必须为已有的常量名，否则报异常！</p>
</li>
<li><p>compareTo：比较两个枚举常量，比较的就是编号！</p>
</li>
</ol>
<h3 id="enum-实现接口"><a href="#enum-实现接口" class="headerlink" title="enum 实现接口"></a>enum 实现接口</h3><ol>
<li><p>使用 enum 关键字后，就不能再继承其它类了，因为 enum 会隐式继承 Enum，而 Java 是单继承机制。</p>
</li>
<li><p>枚举类和普通类一样，可以实现接口，如下形式。 enum 类名 implements 接口 1，接口 2{}</p>
</li>
</ol>
<h2 id="注解-Annotation"><a href="#注解-Annotation" class="headerlink" title="注解(Annotation)"></a>注解(Annotation)</h2><ol>
<li><p>注解(Annotation)也被称为元数据(Metadata)，用于修饰解释包、类、方法、属性、构造器、局部变量等数据信息。 </p>
</li>
<li><p>和注释一样，注解不影响程序逻辑，但注解可以被编译或运行，相当于嵌入在代码中的补充信息。 </p>
</li>
<li><p>在 JavaSE 中，注解的使用目的比较简单，例如标记过时的功能，忽略警告等。在 JavaEE 中注解占据了更重要的角 色，例如用来配置应用程序的任何切面，代	替 java EE 旧版中所遗留的繁冗代码和 XML 配置等</p>
</li>
</ol>
<p>使用 Annotation 时要在其前面增加 @ 符号, 并把该 Annotation 当成一个修饰符使用。用于修饰它支持的程序元素</p>
<p>三个基本的 Annotation: </p>
<ol>
<li>@Override: 限定某个方法，是重写父类方法, 该注解只能用于方法</li>
</ol>
<p>​	如果写了@Override 注解，编译器就会去检查该方法是否真的重写了父类的 方法，如果的确重写了，则编译通过，如果没有构成重写，则编译错误</p>
<p>​	 @Override注解源码：@Target(ElementType.METHOD)，说明只能修饰方法，不能修饰其它类、包、和属性等</p>
<ol start="2">
<li>@Deprecated: 用于表示某个程序元素(类, 方法等)已过时，即不在推荐使用，但是仍然可以使用</li>
</ol>
<p>​	@Deprecated 注解类的源码：@Target(value&#x3D;{CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE}，说明可以修饰方法，</p>
<p>​	类，字段, 包, 参数等等</p>
<p>​	@Deprecated 可以做版本升级过渡使用</p>
<ol start="3">
<li>@SuppressWarnings: 抑制编译器警告，在{“”} 中，可以写入你希望抑制(不显示)警告信息</li>
</ol>
<p>​	@SuppressWarnings 源码：@Target({TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE})，通常我们可以放置具体的语句, 方法, 类</p>
<p>​	可以指定的警告类型有 </p>
<p>​	&#x2F;&#x2F;all，抑制所有警告</p>
<p>​	&#x2F;&#x2F;boxing，抑制与封装&#x2F;拆装作业相关的警告</p>
<p>​	&#x2F;&#x2F;cast，抑制与强制转型作业相关的警告 </p>
<p>​	&#x2F;&#x2F;dep-ann，抑制与淘汰注释相关的警告</p>
<p>​	&#x2F;&#x2F;deprecation，抑制与淘汰的相关警告</p>
<p>​	&#x2F;&#x2F;fallthrough，抑制与 switch 陈述式中遗漏 break 相关的警告</p>
<p>​	&#x2F;&#x2F;finally，抑制与未传回 finally 区块相关的警告 </p>
<p>​	hiding，抑制与隐藏变数的区域变数相关的警告</p>
<p>​	&#x2F;&#x2F;incomplete-switch，抑制与 switch 陈述式(enum case)中遗漏项目相关的警告  </p>
<p>​	&#x2F;&#x2F;javadoc，抑制与 javadoc 相关的警告</p>
<p>​	&#x2F;&#x2F;nls，抑制与非 nls 字串文字相关的警告</p>
<p>​	&#x2F;&#x2F;null，抑制与空值分析相关的警告 </p>
<p>​	&#x2F;&#x2F;rawtypes，抑制与使用 raw 类型相关的警告</p>
<p>​	&#x2F;&#x2F;resource，抑制与使用 Closeable 类型的资源相关的警告 </p>
<p>​	&#x2F;&#x2F;restriction，抑制与使用不建议或禁止参照相关的警告  </p>
<p>​	&#x2F;&#x2F;serial，抑制与可序列化的类别遗漏 serialVersionUID 栏位相关的警告 </p>
<p>​	&#x2F;&#x2F;static-access，抑制与静态存取不正确相关的警告</p>
<p>​	&#x2F;&#x2F;static-method，抑制与可能宣告为 static 的方法相关的警告</p>
<p>​	&#x2F;&#x2F;super，抑制与置换方法相关但不含 super 呼叫的警告</p>
<p>​	&#x2F;&#x2F;synthetic-access，抑制与内部类别的存取未最佳化相关的警告</p>
<p>​	&#x2F;&#x2F;sync-override，抑制因为置换同步方法而遗漏同步化的警告</p>
<p>​	&#x2F;&#x2F;unchecked，抑制与未检查的作业相关的警告</p>
<p>​	&#x2F;&#x2F;unqualified-field-access，抑制与栏位存取不合格相关的警告 </p>
<p>​	&#x2F;&#x2F;unused，抑制与未用的程式码及停用的程式码相关的警告</p>
<h2 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h2><p>JDK 的元 Annotation 用于修饰其他 Annotation</p>
<p>元注解的种类：</p>
<ol>
<li>Retention &#x2F;&#x2F;指定注解的作用范围，三种 SOURCE,CLASS,RUNTIME</li>
</ol>
<p>​	只能用于修饰一个 Annotation 定义, 用于指定该 Annotation 可以保留多长时间, @Rentention 包含一个 RetentionPolicy 类型的成员变量, 使用 @Rentention 	时必须为该 value</p>
<p>@Retention 的三种值 </p>
<p>a. RetentionPolicy.SOURCE: 编译器使用后，直接丢弃这种策略的注释 </p>
<p>b. RetentionPolicy.CLASS: 编译器将把注解记录在 class 文件中. 	当运行 Java 程序时, JVM 不会保留注解。 这是默认值</p>
<p>c. RetentionPolicy.RUNTIME:编译器将把注解记录在 class 文件中. 当运行 Java 程序时, JVM 会保留注解. 程序可以 通过反射获取该注解</p>
<ol start="2">
<li><p>Target &#x2F;&#x2F; 指定注解可以在哪些地方使用 </p>
</li>
<li><p>Documented &#x2F;&#x2F;指定该注解是否会在 javadoc 体现</p>
</li>
<li><p>Inherited &#x2F;&#x2F;子类会继承父类注解</p>
</li>
</ol>
<h2 id="异常-Exception"><a href="#异常-Exception" class="headerlink" title="异常-Exception"></a>异常-Exception</h2><p>java语言中，将程序执行中发生的不正常情况称为“异常”(开发过程中的语法错误和逻辑错误不是异常)</p>
<p>两类：Error—Java虚拟机无法解决的严重问题，如：JVM系统内部错误、资源耗尽等情况</p>
<p>​			Exception—其他因编程错误或偶然的外在因素导致的一般性问题，可以使用针对性的代码进行处理。例如：空指针访问、试图读取不存在的文件、网络连接中断等，分为：运行时异常(可以不做处理，默认就是throws的方式处理，若全处理可能会对程序的可读性和运行效率产生影响)和编译时异常(必须处置，否则代码不能通过编译)。</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220506214357718.png" alt="image-20220506214357718"></p>
<h3 id="常见的运行时异常"><a href="#常见的运行时异常" class="headerlink" title="常见的运行时异常"></a>常见的运行时异常</h3><ol>
<li>NullPointerException 空指针异常</li>
</ol>
<p>​	当应用程序试图在需要对象的地方使用 null 时，抛出该异常</p>
<ol start="2">
<li>ArithmeticException 数学运算异常</li>
</ol>
<p>​	当出现异常的运算条件时，抛出此异常。例如，一个整数“除以零”时，抛出此类的一个实例</p>
<ol start="3">
<li>ArrayIndexOutOfBoundsException 数组下标越界异常</li>
</ol>
<p>​	用非法索引访问数组时抛出的异常。如果索引为负或大于等于数组大小，则该索引为非法索引</p>
<ol start="4">
<li>ClassCastException 类型转换异常</li>
</ol>
<p>​	当试图将对象强制转换为不是实例的子类时，抛出该异常。</p>
<ol start="5">
<li>NumberFormatException 数字格式不正确异常</li>
</ol>
<p>​	当应用程序试图将字符串转换成一种数值类型，但该字符串不能转换为适当格式时，抛出该异常 &#x3D;&gt; 使用异常我们 可以确保输入是满足条件数字</p>
<h3 id="常见的编译时异常"><a href="#常见的编译时异常" class="headerlink" title="常见的编译时异常"></a>常见的编译时异常</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220506215045615.png" alt="image-20220506215045615"></p>
<h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220506215331954.png" alt="image-20220506215331954"></p>
<h4 id="try-catch-finally"><a href="#try-catch-finally" class="headerlink" title="try-catch-finally"></a>try-catch-finally</h4><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220506215507298.png" alt="image-20220506215507298"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220506215617489.png" alt="image-20220506215617489"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220506220317153.png" alt="image-20220506220317153"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220506215812627.png" alt="image-20220506215812627"></p>
<h4 id="throws"><a href="#throws" class="headerlink" title="throws"></a>throws</h4><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220506220018705.png" alt="image-20220506220018705"></p>
<h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><p>当程序中出现了某些错误，但该错误信息并没有在Throwable子类中描述处理，则可以自己设计异常类，用于描述该错误信息。</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220506220807103.png" alt="image-20220506220807103"></p>
<h3 id="throw-和-throws-的区别"><a href="#throw-和-throws-的区别" class="headerlink" title="throw 和 throws 的区别"></a>throw 和 throws 的区别</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220506221123112.png" alt="image-20220506221123112"></p>
<h1 id="常用类"><a href="#常用类" class="headerlink" title="常用类"></a>常用类</h1><h2 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h2><ol>
<li><p>针对八种基本数据类型相应的引用类型—包装类 </p>
</li>
<li><p>有了类的特点，就可以调用类中的方法。</p>
</li>
</ol>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220507143234839.png" alt="image-20220507143234839"></p>
<h3 id="装箱与拆箱"><a href="#装箱与拆箱" class="headerlink" title="装箱与拆箱"></a>装箱与拆箱</h3><p>包装类与基本数据类型之间的相互转换</p>
<p>JDK5.0以后(含5.0)有自动拆装箱</p>
<p>自动拆装箱底层调用的是<strong>valueOf方法</strong>，例如：Integer.valueOf();</p>
<h3 id="Integer-类和-Character-类的常用方法"><a href="#Integer-类和-Character-类的常用方法" class="headerlink" title="Integer 类和 Character 类的常用方法"></a>Integer 类和 Character 类的常用方法</h3><p>(Integer.MIN_VALUE); &#x2F;&#x2F;返回最小值</p>
<p>(Integer.MAX_VALUE);&#x2F;&#x2F;返回最大值</p>
<p>(Character.isDigit(‘a’));&#x2F;&#x2F;判断是不是数字</p>
<p>(Character.isLetter(‘a’));&#x2F;&#x2F;判断是不是字母 </p>
<p>(Character.isUpperCase(‘a’));&#x2F;&#x2F;判断是不是大写 </p>
<p>(Character.isLowerCase(‘a’));&#x2F;&#x2F;判断是不是小写 </p>
<p>(Character.isWhitespace(‘a’));&#x2F;&#x2F;判断是不是空格 </p>
<p>(Character.toUpperCase(‘a’));&#x2F;&#x2F;转成大写 </p>
<p>(Character.toLowerCase(‘A’));&#x2F;&#x2F;转成小写</p>
<h2 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h2><p>1）String对象用于保存字符串，也就是一组字符序列</p>
<p>2）字符串常量对象是用双引号括起的字符序列</p>
<p>3）字符串的字符使用的是Unicode字符编码，一个字符(不区分字母还是汉字)占两个字节</p>
<p>4）String 类实现了接口 Serializable【String 可以串行化:可以在网络传输】  接口 Comparable [String 对象可以比较大小]</p>
<p>5）String 是 final 类，不能被其他的类继承，代表不可变的字符序列</p>
<p>6）String 有属性 private final char value[]： 用于存放字符串内容 </p>
<p>7）一定要注意：value 是一个 final 类型， 不可以修改(需要功力)：即 value 不能指向新的地址，但是单个字符内容是可以变化</p>
<p>8）字符串是不可变的。一个字符串对象一旦被分配，其内容是不可变的</p>
<p>9）intern方法：最终返回的是常量池的地址(对象)</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220507145402726.png" alt="image-20220507145402726"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220507145435192.png" alt="image-20220507145435192"></p>
<p>10）String类是保存字符串常量的。每次更新都需要重新开辟空间，效率极低，因此Java设计者还提供了StringBuilder和StringBuffer来增强String的功能</p>
<h3 id="String类常用方法"><a href="#String类常用方法" class="headerlink" title="String类常用方法"></a>String类常用方法</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220507155349012.png" alt="image-20220507155349012"></p>
<p>1）toUpperCase 转换成大写</p>
<p>2）toLowerCase 转换成小写</p>
<p>3）concat 拼接字符串</p>
<p>4）replace 替换字符串中的字符</p>
<p>5）split 分割字符串, 对于某些分割字符，我们需要转义比如 | \\等</p>
<p>6）toCharArray 转换成字符数组</p>
<p>7）compareTo 比较两个字符串的大小，如果前者大，则返回正数，后者大，则返回负数，如果相等，返回 0</p>
<p>8）format 格式字符串(占位符有:%s 字符串 %c 字符 %d 整型 %.2f 浮点)</p>
<h2 id="StringBuffer类"><a href="#StringBuffer类" class="headerlink" title="StringBuffer类"></a>StringBuffer类</h2><p><strong>可变的字符序列</strong>，可以对字符串内容进行增删(**线程安全)**。</p>
<p>很多方法与String相同，但StringBuffer是可变长度的。</p>
<p>StringBuffer是一个<strong>容器</strong>。</p>
<p>StringBuffer 的直接父类 是 AbstractStringBuilder</p>
<p>StringBuffer 实现了 Serializable, 即 StringBuffer 的对象可以串行化</p>
<p>在父类中 AbstractStringBuilder 有属性 char[] value,不是 fina，该 value 数组存放字符串内容，引出存放在堆中的</p>
<p>StringBuffer 是一个 final 类，不能被继承</p>
<p>因为 StringBuffer 字符内容是存在 char[] value, 在变化(增加&#x2F;删除)时，不用每次都更换地址(即不是每次创建新对象)， 所以效率高于 String</p>
<h3 id="String与StringBuffer的转换"><a href="#String与StringBuffer的转换" class="headerlink" title="String与StringBuffer的转换"></a>String与StringBuffer的转换</h3><h4 id="String—-gt-StringBuffer"><a href="#String—-gt-StringBuffer" class="headerlink" title="String—&gt;StringBuffer"></a>String—&gt;StringBuffer</h4><p>1）使用构造器：StringBuffer stringBuffer &#x3D; new StringBuffer(str)</p>
<p>2）使用的是 append 方法：StringBuffer stringBuffer &#x3D; new StringBuffer(); stringBuffer &#x3D; stringBuffer.append(str)</p>
<h4 id="StringBuffer—-gt-String"><a href="#StringBuffer—-gt-String" class="headerlink" title="StringBuffer—&gt;String"></a>StringBuffer—&gt;String</h4><p>StringBuffer stringBuffer &#x3D; new StringBuffer(“韩顺平教育”);</p>
<p>1）使用 StringBuffer 提供的 toString 方法：String s &#x3D; stringBuffer.toString()</p>
<p>2）使用构造器：String s &#x3D; new String(stringBuffer)</p>
<h3 id="StringBuffer类常用方法"><a href="#StringBuffer类常用方法" class="headerlink" title="StringBuffer类常用方法"></a>StringBuffer类常用方法</h3><p>1）增：append</p>
<p>2）删：delete</p>
<p>3）改：replace</p>
<p>4）查：indexOf</p>
<p>5）插：insert</p>
<p>6）长度：length</p>
<h2 id="StringBuilder-类"><a href="#StringBuilder-类" class="headerlink" title="StringBuilder 类"></a>StringBuilder 类</h2><p>一个可变的字符序列。此类提供一个与StringBuffer兼容的API，但不保证同步(<strong>线程不安全</strong>)。</p>
<p>StringBuilder 的方法，没有做互斥的处理,即没有 synchronized 关键字,因此在单线程的情况下使用</p>
<p>该类用在字符串缓冲区被单个线程使用的时候，<strong>比StringBuffer要快</strong>。</p>
<p>在StringBuilder上的主要操作是append和insert方法，可重载这些方法，已接受任意类型的数据</p>
<p>StringBuilder 接父类 是 AbstractStringBuilder</p>
<p>StringBuilder 实现了 Serializable, 即 StringBuilder 的对象可以串行化</p>
<p>在父类中 AbstractStringBuilder 有属性 char[] value,不是 fina，该 value 数组存放字符串内容，引出存放在堆中的</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220507164322409.png" alt="image-20220507164322409"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220507164338156.png" alt="image-20220507164338156"></p>
<h3 id="String、StringBuffer-和-StringBuilder-的选择"><a href="#String、StringBuffer-和-StringBuilder-的选择" class="headerlink" title="String、StringBuffer 和 StringBuilder 的选择"></a>String、StringBuffer 和 StringBuilder 的选择</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220507164449875.png" alt="image-20220507164449875"></p>
<h2 id="Math-类"><a href="#Math-类" class="headerlink" title="Math 类"></a>Math 类</h2><p>Math 类包含用于执行基本数学运算的方法，如初等指数、对数、平方根和三角函数。均为静态方法</p>
<p>abs 绝对值</p>
<p>pow 求幂</p>
<p>ceil 向上取整，返回&gt;&#x3D;该参数的最小整数(转成 double)</p>
<p>floor 向下取整，返回&lt;&#x3D;该参数的最大整数(转成 double)</p>
<p>round 四舍五入</p>
<p>sqrt 求开方</p>
<p>random 求随机数  返回的是 0 &lt;&#x3D; x &lt; 1 之间的一个随机小数</p>
<h2 id="Arrays-类"><a href="#Arrays-类" class="headerlink" title="Arrays 类"></a>Arrays 类</h2><p>Arrays里面包含了一系列静态方法，用于管理或操作数组(例如排序和搜素)</p>
<p>1）toString 返回数组的字符串形式</p>
<p>2）sort 排序</p>
<p>3）binarySearch 通过二分搜索法进行查找，要求必须排好序</p>
<p>4）copyOf 数组元素的复制</p>
<p>5）fill 数组元素的填充</p>
<p>6）equals 比较两个数组元素内容是否完全一致</p>
<p>7）asList 将一组值转换成List</p>
<h2 id="System-类"><a href="#System-类" class="headerlink" title="System 类"></a>System 类</h2><p>1）exit 退出当前程序</p>
<p>2）arraycopy 复制数组元素，比较适合底层调用，一般使用Arrays.copyOf完成复制数组</p>
<p>3）currentTimeMillens 返回当前时间距离1970-1-1的毫秒数</p>
<p>4）gc 运行垃圾回收机制</p>
<p>5）fill 数组元素的填充</p>
<p>6）equals 比较两个数组元素内容是否完全一致</p>
<p>7）asList 将一组值转换成List</p>
<h2 id="BigInteger-和-BigDecimal-类"><a href="#BigInteger-和-BigDecimal-类" class="headerlink" title="BigInteger 和 BigDecimal 类"></a>BigInteger 和 BigDecimal 类</h2><p>BigInteger 适合保存比较大的整型</p>
<p>BigDecimal适合保存精度更高的浮点型</p>
<h3 id="常见方法"><a href="#常见方法" class="headerlink" title="常见方法"></a>常见方法</h3><p>1）add 加</p>
<p>2）subtract 减</p>
<p>3）multiply 乘</p>
<p>4）divide 除</p>
<h2 id="日期类"><a href="#日期类" class="headerlink" title="日期类"></a>日期类</h2><h3 id="第一代日期类"><a href="#第一代日期类" class="headerlink" title="第一代日期类"></a>第一代日期类</h3><p>1.Date：精确到毫秒，代表特定的瞬间</p>
<p>2.SimpleDateFormat：格式和解析日期的类</p>
<h3 id="第二代日期类"><a href="#第二代日期类" class="headerlink" title="第二代日期类"></a>第二代日期类</h3><p>Calendar类：抽象类，他为特定瞬间与一组诸如YEAR、MONTH、DAY_OF_MONTH、HOUR等日历字段之间的转换提供了一些方法，并为操作日历字段提供了一</p>
<p>些方法。</p>
<h3 id="第三代日期类"><a href="#第三代日期类" class="headerlink" title="第三代日期类"></a>第三代日期类</h3><p>LocalDate：只包含日期，可以获得日期字段</p>
<p>LocalTime：只包含时间，可以获得时间字段</p>
<p>LocalDateTime：包含日期+时间，可以获取日期和时间字段</p>
<h3 id="DateTimeFormatter-格式日期类"><a href="#DateTimeFormatter-格式日期类" class="headerlink" title="DateTimeFormatter 格式日期类"></a>DateTimeFormatter 格式日期类</h3><h3 id="Instant-时间戳"><a href="#Instant-时间戳" class="headerlink" title="Instant 时间戳"></a>Instant 时间戳</h3><h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><p>数组缺点：长度开始时必须指定，而且一旦指定，不能更改</p>
<p>​					保存的必须为同一类型的元素</p>
<p>​					使用数组进行增删改查比较麻烦</p>
<p>集合：可以<strong>动态保存</strong>任意多个对象</p>
<p>​			提供了一系列方便的操作对象的方法：add、remove、set、get等</p>
<p>​			使用集合添加、删除新元素简单</p>
<p>Java的集合类主要分为两大类</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220510195334921.png" alt="image-20220510195334921"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220510195351280.png" alt="image-20220510195351280"></p>
<p><img src="http://uploadfiles.nowcoder.com/images/20151109/403938_1447079573733_4F723777B74785B7A07A73C9792B8F6F" alt="img"></p>
<p>集合主要是两组(单列集合，双列集合)</p>
<p>Collection接口有两个重要的子接口List Set，他们的实现子类都是单列集合</p>
<p>Map接口的实现子类是双列集合，存放的是K-V</p>
<h2 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a>Collection接口</h2><p>Collection实现子类可以存放多个元素，每个元素可以是Object</p>
<p>有些实现子类可以存放重复元素，有些不可以</p>
<p>有些实现子类是有序的(List)，有些是无序的(Set)</p>
<p>Collection接口没有直接的实现子类，是通过他的子接口Set和List来实现的</p>
<h3 id="Collection-接口常用方法"><a href="#Collection-接口常用方法" class="headerlink" title="Collection 接口常用方法"></a>Collection 接口常用方法</h3><p>add:添加单个元素</p>
<p>remove:删除指定元素</p>
<p>contains:查找元素是否存在</p>
<p>size:获取元素个数</p>
<p>isEmpty:判断是否为空</p>
<p>clear:清空</p>
<p>addAll:添加多个元素</p>
<p>containsAll:查找多个元素是否都存在</p>
<p>removeAll：删除多个元素</p>
<h3 id="Collection-接口遍历元素"><a href="#Collection-接口遍历元素" class="headerlink" title="Collection 接口遍历元素"></a>Collection 接口遍历元素</h3><h4 id="Iterator-迭代器"><a href="#Iterator-迭代器" class="headerlink" title="Iterator(迭代器)"></a>Iterator(迭代器)</h4><p>所有实现了Collection接口的集合类都有一个iterator()方法，用以返回一个实现了Iterator接口的对象，即可以返回一个迭代器</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220510200811204.png" alt="image-20220510200811204"></p>
<h4 id="for-循环增强"><a href="#for-循环增强" class="headerlink" title="for 循环增强"></a>for 循环增强</h4><p>语法：for(元素类型 元素名：集合名或数组名){</p>
<p>​						访问元素</p>
<p>​			}</p>
<h2 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a>List接口</h2><p>Collection接口的子接口</p>
<p>List集合类中<strong>元素有序</strong>(添加顺序与取出顺序一致)、<strong>可重复</strong></p>
<p>List集合中的每个元素都有其对应的顺序索引，即支持索引</p>
<p>List容器中的元素都对应一个整数型的序号记载其在容器中的位置，可以根据序号存取容器中的元素</p>
<h3 id="List的遍历"><a href="#List的遍历" class="headerlink" title="List的遍历"></a>List的遍历</h3><p>使用iterator</p>
<p>增强for</p>
<p>普通for</p>
<h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><p>由数组实现数据存储</p>
<p>可以加入<strong>null</strong>，并且<strong>多个</strong></p>
<p>基本等同于<strong>Vector</strong>，除了**ArrayList是线程不安全的(执行效率高)**，多线程情况下，不建议使用ArrayList</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220510203244326.png" alt="image-20220510203244326"></p>
<h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h3><p>线程同步，即<strong>线程安全</strong>，Vector类的操作方法带有<strong>synchronized</strong></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220510204207739.png" alt="image-20220510204207739"></p>
<h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><p>底层实现了双向链表和双端队列的特点</p>
<p>可以添加任意元素(元素可以重复)，包括null</p>
<p>线程不安全，没有实现同步</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220510204439516.png" alt="image-20220510204439516"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220510204620749.png" alt="image-20220510204620749"></p>
<h2 id="Set接口"><a href="#Set接口" class="headerlink" title="Set接口"></a>Set接口</h2><p><strong>无序</strong>(添加和取出的顺序不一致)，没有索引</p>
<p><strong>不允许重复元素</strong>，最多只能包含一个null</p>
<h3 id="Set的遍历"><a href="#Set的遍历" class="headerlink" title="Set的遍历"></a>Set的遍历</h3><p>使用迭代器</p>
<p>增强for</p>
<p>不能使用索引的方式来获取</p>
<h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><p>底层是HashMap，HashMap的底层是数组+链表+红黑树</p>
<p>可以存放null值，但是只能有一个</p>
<p>不能有重复元素</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220510205506684.png" alt="image-20220510205506684"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220510205702116.png" alt="image-20220510205702116"></p>
<h3 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h3><p>HashSet的子类</p>
<p>底层是LinkedHashMap，底层维护了一个数组+双向链表</p>
<p>根据元素的hashCode值来决定元素的存储位置，同时使用链表维护元素的次序，这使元素看起来是以插入顺序保存的</p>
<p>不允许添加重复元素</p>
<h2 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h2><p><strong>Map与Collection并列存在</strong>，用于保存具有映射关系的数据：Key-Value</p>
<p>Key和Value可以是任何引用类型的数据，会封装到HashMap$Node对象中</p>
<p><strong>Key不允许重复</strong>，原因和HashSet一样</p>
<p><strong>Value可以重复</strong></p>
<p><strong>Key与Value可为null</strong></p>
<p>常用String类作为Map的Key</p>
<p>Key与Value存在<strong>单向一对一</strong>关系，即通过指定的Key总能找到对应的value</p>
<p>一对K-V是存放在一个HashMap$Node中的，Node实现了Entry接口，故也可说，一对k-v就是一个Entry</p>
<h3 id="Map接口常用方法"><a href="#Map接口常用方法" class="headerlink" title="Map接口常用方法"></a>Map接口常用方法</h3><p>put：添加数据，若key相等，则替换key对应的value值</p>
<p>remove：根据键删除映射关系</p>
<p>get：根据键获取值</p>
<p>size：获取元素个数</p>
<p>isEmpty：判断个数是否为 0</p>
<p>clear：清除 k-v</p>
<p>containsKey：查找键是否存在</p>
<h3 id="Map的遍历"><a href="#Map的遍历" class="headerlink" title="Map的遍历"></a>Map的遍历</h3><p>1）containsKey：查找键是否存在</p>
<p>2）KeySet：获取所有的键</p>
<p>3）entrySet：获取所有关系</p>
<p>4）values：获取所有的值</p>
<h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p>是Map接口使用频率最高的实现类</p>
<p>以<strong>key-value</strong>对的方式来存储数据(HashMap$Node类型)</p>
<p>key不能重复，但是值可以，允许使用null键和null值</p>
<p>如果添加相同的key，则会覆盖原来的key-value，等同于修改</p>
<p><strong>无序</strong>，与HashSet一样，不保证映射的顺序，因为底层是以hash表的方式来存储的</p>
<p>Hash没有实现同步，因此是<strong>线程不安全</strong>的，方法没有做同步互斥的操作，没有synchronized</p>
<p>扩容机制</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220512151107133.png" alt="image-20220512151107133"></p>
<h3 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h3><p>存放的元素是键值对：k-v</p>
<p>hashTable的键和值都<strong>不能为null</strong>，否则会抛出NullPointerException</p>
<p>hashTable使用方法基本与hashMap一样</p>
<p>**线程安全(synchronized)**，hashMap线程不安全</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220512151637502.png" alt="image-20220512151637502"></p>
<h3 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h3><p>继承HashTable类，并实现了Map接口，也是使用一种键值对的形式来保存数据</p>
<p>使用特点和HashTable类似</p>
<p>可用于从xxx.properties文件中，加载数据到Properties类对象，并进行读取和修改</p>
<p>专门用于读写配置文件的集合类，配置文件的格式：键&#x3D;值，键值对不需要有空格，值不需要用引号一起来，默认类型是String</p>
<p>常见方法：</p>
<p>1）load：加载配置文件的键值对到Properties对象</p>
<p>2）list：将数据显示到指定设备</p>
<p>3）getProperty(key)：根据键获取值</p>
<p>4）setProperty(key, value)：设置键值对到Properties对象</p>
<p>5）store：将Properties中的键值对存储到配置文件，在idea中，保存信息到配置文件，如果含有中文，会存储为unicode码</p>
<h2 id="集合实现类的选取"><a href="#集合实现类的选取" class="headerlink" title="集合实现类的选取"></a>集合实现类的选取</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220512152145730.png" alt="image-20220512152145730"></p>
<h2 id="Collections-工具类"><a href="#Collections-工具类" class="headerlink" title="Collections 工具类"></a>Collections 工具类</h2><p>操作Set、List、和Map等集合的工具类</p>
<p>提供了一系列<strong>静态方法</strong>对集合元素进行排序、查询和修改等操作</p>
<h3 id="排序操作"><a href="#排序操作" class="headerlink" title="排序操作"></a>排序操作</h3><p>reverse(List)：反转 List 中元素的顺序</p>
<p>shuffle(List)：对 List 集合元素进行随机排序</p>
<p>sort(List)：根据元素的自然顺序对指定 List 集合元素按升序排序</p>
<p>sort(List，Comparator)：根据指定的 Comparator 产生的顺序对 List 集合元素进行排序</p>
<p>swap(List，int， int)：将指定 list 集合中的 i 处元素和 j 处元素进行交换</p>
<h3 id="查找、替换"><a href="#查找、替换" class="headerlink" title="查找、替换"></a>查找、替换</h3><p>Object max(Collection)：根据元素的自然顺序，返回给定集合中的最大元素</p>
<p>Object max(Collection，Comparator)：根据 Comparator 指定的顺序，返回给定集合中的最大元素</p>
<p>int frequency(Collection，Object)：返回指定集合中指定元素的出现次数</p>
<p>void copy(List dest,List src)：将 src 中的内容复制到 dest 中</p>
<p>boolean replaceAll(List list，Object oldVal，Object newVal)：使用新值替换 List 对象的所有旧值</p>
<h1 id="泛型E"><a href="#泛型E" class="headerlink" title="泛型E"></a>泛型E</h1><p>传统方法不能对加入到集合中的数据类型进行约束(不安全)</p>
<p>遍历的时候需要进行类型转换，如果集合中的数据量较大，对效率有影响</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220512160747944.png" alt="image-20220512160747944"></p>
<p>作用：可以在类声明时通过一个标识表示类中某个属性的类型，或者是某个方法的返回值的类型，或者是参数类型。</p>
<p>泛型的声明：interface 接口<T>{}和class 类&lt;K,V&gt;{}</p>
<p>​						T、K、V不代表值，而是表示类型，只能是<strong>引用类型</strong></p>
<p>泛型的实例化：要在类名后面指定类型参数的值(类型)</p>
<p>在给泛型指定具体类型后，可以传入该类型或者子类类型</p>
<h2 id="自定义泛型类"><a href="#自定义泛型类" class="headerlink" title="自定义泛型类"></a>自定义泛型类</h2><p>class 类名&lt;T, R…&gt;{</p>
<p>​		成员</p>
<p>}</p>
<p>普通成员可以使用泛型，静态不可以</p>
<p>使用泛型的数组，不能初始化</p>
<p>静态方法中不能使用类的泛型</p>
<p>泛型类的类型，是在创建对象的时候确定的(因为创建对象时，需要指定确定类型</p>
<p>如果在创建对象时，没有指定类型，默认为Object</p>
<h2 id="自定义泛型接口"><a href="#自定义泛型接口" class="headerlink" title="自定义泛型接口"></a>自定义泛型接口</h2><p>interface 接口名&lt;T,R…&gt;{}</p>
<p>接口中，静态成员也不能使用泛型</p>
<p>泛型接口的类型，在继承接口或者实现接口时确定</p>
<p>没有指定类型，默认为Object</p>
<h2 id="自定义泛型方法"><a href="#自定义泛型方法" class="headerlink" title="自定义泛型方法"></a>自定义泛型方法</h2><p>修饰符 &lt;T,R&gt;返回类型 方法名(参数列表){}</p>
<p>泛型方法，可以定义在普通类中，也可以定义在泛型类中</p>
<p>泛型方法被调用时，类型会确定</p>
<h2 id="泛型的继承和通配符"><a href="#泛型的继承和通配符" class="headerlink" title="泛型的继承和通配符"></a>泛型的继承和通配符</h2><p>泛型不具备继承性</p>
<p>&lt; ? &gt;：支持任意泛型类型</p>
<p>&lt; ? extends A &gt;：支持A类以及A类的子类，规定了泛型的上限</p>
<p>&lt; ? super A &gt;：支持A类以及A类的父类，不限于直接父类，规定了泛型的下限</p>
<h2 id="JUnit"><a href="#JUnit" class="headerlink" title="JUnit"></a>JUnit</h2><p>一个类有很多功能代码需要测试，为了测试，就需要写入到main方法中，如果有多个功能代码测试，就需要来回注销，切换很麻烦</p>
<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>进程是指运行中的程序，比如我们使用QQ，就启动了一个进程，操作系统就会为该进程分配内存空间。当我们使用迅雷，又启动了一个进程，操作系统将为迅雷分配性的内存空间。</p>
<p>进程是程序的一次执行过程，或是正在运行的一个程序。是动态过程：有他自身的产生、存在和消亡的过程。</p>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>由进程创建，是进程的一个实体</p>
<p>一个进程可以拥有多个线程</p>
<p>单线程：同一时刻，只允许执行一个线程</p>
<p>多线程：同一时刻，可以执行多个线程，比如：一个QQ进程，可以同时打开多个聊天窗口，一个迅雷进程，可以同时下载多个文件</p>
<p>并发：同一时刻，多个任务交替执行，造成一种“貌似同时”的错觉，简单地说，单核CPU实现的多任务就是并发</p>
<p>并行：同一时刻，多个任务同时执行。多个CPU可以实现并行</p>
<h2 id="线程的基本使用"><a href="#线程的基本使用" class="headerlink" title="线程的基本使用"></a>线程的基本使用</h2><h3 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h3><p>1）继承Thread类，重写run方法</p>
<p>2）实现Runnable接口，实现run方法</p>
<p>​		java是单继承的，在某些情况下一个类可能已经继承了某个父类，这时再用继承Thread类方法来创建线程显然不可能了，需要new Thread()来使用start方法</p>
<p>​		实现Runnable接口方式更加适合多个线程共享一个资源情况，并且避免了单继承的限制，建议使用Runnable</p>
<p>3）线程池创建线程</p>
<h3 id="线程常用方法"><a href="#线程常用方法" class="headerlink" title="线程常用方法"></a>线程常用方法</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220514203110588.png" alt="image-20220514203110588"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220514203153934.png" alt="image-20220514203153934"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220514203305654.png" alt="image-20220514203305654"></p>
<p>用户线程：也叫工作线程，当线程的任务执行完成或通知方式结束</p>
<p>守护线程：一般是为工作线程服务的，当所有的用户线程结束，守护线程自动结束（常见的守护线程：垃圾回收机制）setDaemon()方法</p>
<h2 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h2><p>Thread.State枚举表示了线程的几种状态</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220514204340007.png" alt="image-20220514204340007"></p>
<p><img src="https://uploadfiles.nowcoder.com/images/20180316/8955099_1521189690989_0BB28C2A1ECCC47EC020E89E8A554BBC" alt="img"></p>
<p><strong>TCP客户端：</strong> </p>
<p>1.建立连接套接字，设置Ip和端口监听，socket()</p>
<p>2.建立连接 connect</p>
<p>3.write() 获取网络流对象 发送数据</p>
<p>4.read()获取网络流对象 接收数据</p>
<p>5.关闭套接字</p>
<p><strong>TCP服务器端：</strong></p>
<p>1.建立端口监听 socket()</p>
<p>2.绑定指定端口 bind()</p>
<p>3.listen 进行端口监听</p>
<p>4.accept() 阻塞式 直到有客户端访问</p>
<p>5.read()获取客户端发送数据</p>
<p>6.write()发送返回数据</p>
<p>7.close关闭端口监听</p>
<h2 id="线程的同步"><a href="#线程的同步" class="headerlink" title="线程的同步"></a>线程的同步</h2><h3 id="线程同步机制"><a href="#线程同步机制" class="headerlink" title="线程同步机制"></a>线程同步机制</h3><p> <strong>Synchronized</strong></p>
<p>在多线程编程，一些敏感数据不允许被多个线程同时访问，此时就使用同步访问技术，保证数据在任何同一时刻，最多有一个线程访问，以保证数据的完整性</p>
<p>线程同步：即当有一个线程在内存进行操作时，其他线程都不可以对这个内存地址进行操作，直到该线程完成操作，其他线程才能对该内存地址进行操作</p>
<h3 id="同步具体方法-Synchronized"><a href="#同步具体方法-Synchronized" class="headerlink" title="同步具体方法-Synchronized"></a>同步具体方法-Synchronized</h3><p>1）同步代码块，尽量使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(对象) &#123; <span class="comment">//得到对象的锁，才能操作同步代码块</span></span><br><span class="line">	<span class="comment">//需要被同步代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2）synchronized还可以放在方法声明中，表示整个方法为同步方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">m</span><span class="params">(String name)</span>&#123;</span><br><span class="line">    <span class="comment">//需要被同步的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><p>Java语言中，引入了对象互斥锁的概念，来保证共享数据操作的完整性</p>
<p>每个对象都对应于一个可称为”互斥锁“的标记，这个标记用来保证在任一时刻，只能有一个线程访问该对象</p>
<p>关键字synchronized来与对象的互斥锁联系。当某个对象用synchronized修饰时，表明该对象在任一时刻只能由一个线程访问</p>
<p>同步的局限性：导致程序的执行效率要降低</p>
<p>同步方法(非静态的)的锁可以是this，也可以是其他对象(要求是同一个对象)</p>
<p>同步方法(静态的)的锁为当前类本身</p>
<p>同步方法如果没有使用static修饰：默认锁对象为this，如果使用static修饰，默认锁对象为：当前类.class</p>
<p>要求多个线程的锁对象为同一个即可！</p>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>多个线程都占用了对方的锁资源，但不肯相让，导致了死锁，在编程是一定要避免死锁的发生</p>
<p>释放锁：当前线程的同步方法、同步代码块执行结束</p>
<p>​				当前线程在同步代码块、同步方法中遇到break、return</p>
<p>​				当前线程在同步代码块、同步方法中出现了未处理的Error或Exception，导致异常结束</p>
<p>​				当前线程在同步代码块、同步方法中执行了线程对象的wait()方法，当前线程暂停，并释放锁</p>
<p>不会释放锁：线程执行同步代码块或同步方法时，程序调用Thread.sleep()、Thread.yield()方法暂停当前线程的执行，不会释放锁</p>
<p>​						线程执行同步代码块时，其他线程调用了该线程的suspend()方法将该线程挂起</p>
<h1 id="IO-流"><a href="#IO-流" class="headerlink" title="IO 流"></a>IO 流</h1><h2 id="文件流"><a href="#文件流" class="headerlink" title="文件流"></a>文件流</h2><p>文件在程序中是以流的形式来操作的</p>
<p>流：数据在数据源(文件)和程序(内存)之间经历的路径</p>
<p>输入流：数据从数据源(文件)到程序(内存)的路径</p>
<p>输出流：数据从程序(内存)到数据源(文件)的路径</p>
<h2 id="常见的文件操作"><a href="#常见的文件操作" class="headerlink" title="常见的文件操作"></a>常见的文件操作</h2><p>创建文件相关构造器和方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">File</span>(String pathname)<span class="comment">//根据路径构建一个File对象</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">File</span>(File parent, String child)<span class="comment">//根据父目录文件+子路径构建一个File对象</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">File</span>(String parent, String child)<span class="comment">//根据父目录+子路径构建一个File对象</span></span><br><span class="line">    </span><br><span class="line">creatNewFile <span class="comment">//创建新文件</span></span><br></pre></td></tr></table></figure>

<p>获取文件的相关信息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">getNmae<span class="comment">//文件名字</span></span><br><span class="line">getAbsolutePath<span class="comment">//文件绝对路径</span></span><br><span class="line">getParent<span class="comment">//&quot;文件父级目录</span></span><br><span class="line">length<span class="comment">//文件大小(字节)</span></span><br><span class="line">exists<span class="comment">//文件是否存在</span></span><br><span class="line">isFile<span class="comment">//是不是一个文件</span></span><br><span class="line">isDirectory<span class="comment">//是不是一个目录</span></span><br></pre></td></tr></table></figure>

<p>目录的操作和文件删除</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">makdir<span class="comment">//创建一级目录</span></span><br><span class="line">mkdirs<span class="comment">//创建多级目录</span></span><br><span class="line">delete<span class="comment">//删除空目录或文件</span></span><br></pre></td></tr></table></figure>

<h2 id="IO-流原理及流的分类"><a href="#IO-流原理及流的分类" class="headerlink" title="IO 流原理及流的分类"></a>IO 流原理及流的分类</h2><p><strong>原理</strong></p>
<p>1）I&#x2F;O是Input&#x2F;Output的缩写，I&#x2F;O技术，用于处理数据传输</p>
<p>2）Java程序中，对于数据的输入&#x2F;输出操作以“流(stream)”的方式进行</p>
<p>3）java.io包下提供了各种“流”类和接口，用以获得不同种类的数据，并通过方法输入或输出数据</p>
<p>4）输入input：读取外部数据(磁盘、光盘等存储设备的数据)到程序(内存)中</p>
<p>5）输出output：将程序(内存)数据输出到磁盘、光盘等存储设备中</p>
<p><strong>分类</strong></p>
<p>按操作数据单位不同：字节流(8 bit)二进制文件，字符流(按字符)文本文件</p>
<p>按数据流的流向不同：输入流，输出流</p>
<p>按流的角色不同：节点流，处理流&#x2F;包装流</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220515222537824.png" alt="image-20220515222537824"></p>
<p>1）Java的IO流共涉及40多个类，都是从如上4个抽象基类派生的</p>
<p>2）由这四个类派生出来的子类名称都是以其父类名作为子类名后缀</p>
<h2 id="IO-流体系图"><a href="#IO-流体系图" class="headerlink" title="IO 流体系图"></a>IO 流体系图</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220516122221731.png" alt="image-20220516122221731"></p>
<p><strong>FileOutputSream</strong></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220516142451047.png" alt="image-20220516142451047"></p>
<p> <strong>FileReader 和 FileWriter</strong></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220516142644135.png" alt="image-20220516142644135"></p>
<p><strong>FileReader 相关方法：</strong></p>
<p>new FileReader(File&#x2F;String)</p>
<p>read：每次读取单个字符，返回该字符，如果到文件末尾返回-1</p>
<p>read(Char[])：批量读取多个字符到数组，返回读取到的字符数，如果到文件末尾返回-1</p>
<p>相关API：new String(char[])：将char[]转换成String</p>
<pre><code>             new String(char[], off, len)：将char[]的指定部分转换成String
</code></pre>
<p><strong>FileWriter 相关方法：</strong></p>
<p>new FileWriter(File&#x2F;String)：覆盖模式，相当于流的指针在首端</p>
<p>new FileWriter(File&#x2F;String, true)：追加模式，相当于流的指针在尾端</p>
<p>writer(int)：写入单个字符</p>
<p>writer(char[])：写入指定数组</p>
<p>writer(char[], off, len)：写入指定数组的指定部分</p>
<p>writer(string)：写入整个字符串</p>
<p>writer(string, off, len)：写入字符串的指定部分</p>
<p>FileWriter使用后，必须**关闭(close)或刷新(flush)**，否则写入不到指定文件！</p>
<h2 id="节点流和处理流"><a href="#节点流和处理流" class="headerlink" title="节点流和处理流"></a>节点流和处理流</h2><p>节点流：可以从一个特定的数据源读写数据，如：FileReader、FileWriter</p>
<p>处理流：是连接在已存在的流(节点流或处理流之上)，为程序提供更为强大的读写功能，也更加灵活，如：BufferedReader、BufferedWriter</p>
<p>区别和联系：</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220516145022746.png" alt="image-20220516145022746"></p>
<h2 id="处理流的优点"><a href="#处理流的优点" class="headerlink" title="处理流的优点"></a>处理流的优点</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220516145131925.png" alt="image-20220516145131925"></p>
<h2 id="处理流-BufferedReader和BufferWriter"><a href="#处理流-BufferedReader和BufferWriter" class="headerlink" title="处理流-BufferedReader和BufferWriter"></a>处理流-BufferedReader和BufferWriter</h2><p>属于字符流，是按照字符来读取数据的</p>
<p>关闭时处理流，只需要关闭外层流即可</p>
<h2 id="处理流-BufferedInputStream-和-BufferedOutputStream"><a href="#处理流-BufferedInputStream-和-BufferedOutputStream" class="headerlink" title="处理流-BufferedInputStream 和 BufferedOutputStream"></a>处理流-BufferedInputStream 和 BufferedOutputStream</h2><p>BufferedInputStream 是字节流，在创建 BufferedInputStream 时，会创建一个内部缓冲区数组</p>
<p><strong>BufferedInputStream–&gt;FilterInputStream–&gt;InputStream–&gt;Closeable(接口)</strong></p>
<p><strong>BufferedOutputStream–&gt;FilterOutputStream–&gt;OutputStream–&gt;Closeable和Flushable(接口)</strong></p>
<h2 id="对象流-ObjectInputStream-和-ObjectOutputStrea"><a href="#对象流-ObjectInputStream-和-ObjectOutputStrea" class="headerlink" title="对象流-ObjectInputStream 和 ObjectOutputStrea"></a>对象流-ObjectInputStream 和 ObjectOutputStrea</h2><h3 id="序列和反序列化"><a href="#序列和反序列化" class="headerlink" title="序列和反序列化"></a>序列和反序列化</h3><p>1）序列化就是在保存数据时，保存数据的值和数据类型。</p>
<p>​		将数据结构转换称为二进制数据流或者文本流的过程。序列化后的数据方便在网络上传输和在硬盘上存储。</p>
<p>2）反序列化就是在恢复数据时，恢复数据的值和数据类型</p>
<p>​		与序列化相反，是将二进制数据流或者文本流转换称为易于处理和阅读的数据结构的过程。</p>
<p>3）需要让某个对象支持序列化机制，则必须让其类是可序列化的，为了让某个类是可序列化的，该类必须实现如下两个接口之一：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Serializable <span class="comment">//这是一个标记接口，没有方法</span></span><br><span class="line">   Externalizable <span class="comment">//该接口有方法需要实现，因此一般实现Serializable接口</span></span><br><span class="line">   <span class="comment">//transient关键字的作用，在已实现序列化的类中，有的变量不需要保存在磁盘中，就要transient关键字修饰，如银行卡密码等，</span></span><br><span class="line">   <span class="comment">//就这个作用------在已序列化的类中使变量不序列化，通常一个类实现序列化方式是实现序列化接口 Serializable</span></span><br></pre></td></tr></table></figure>

<p>对象流功能：提供了对基本类型或对象类型的序列化和反序列化的方法 </p>
<p>​						ObjectOutputStream 提供 序列化功能 </p>
<p>​			   		 ObjectInputStream 提供 反序列化功能</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220516201954245.png" alt="image-20220516201954245">			</p>
<p>序列化数据和反序列化恢复数据</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220516201309591.png" alt="image-20220516201309591"></p>
<h2 id="标准输入输出流"><a href="#标准输入输出流" class="headerlink" title="标准输入输出流"></a>标准输入输出流</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220516201438597.png" alt="image-20220516201438597"></p>
<h2 id="转换流-InputStreamReader-和-OutputStreamWriter"><a href="#转换流-InputStreamReader-和-OutputStreamWriter" class="headerlink" title="转换流-InputStreamReader 和 OutputStreamWriter"></a>转换流-InputStreamReader 和 OutputStreamWriter</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220516201634261.png" alt="image-20220516201634261"></p>
<h2 id="打印流-PrintStream-和-PrintWriter"><a href="#打印流-PrintStream-和-PrintWriter" class="headerlink" title="打印流-PrintStream 和 PrintWriter"></a>打印流-PrintStream 和 PrintWriter</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220516201859470.png" alt="image-20220516201859470"></p>
<h1 id="反射-reflection"><a href="#反射-reflection" class="headerlink" title="反射(reflection)"></a>反射(reflection)</h1><p>需求：根据配置文件re.properties指定信息，创建对象并调用方法；即通过外部配置文件，在不修改源码的情况下来控制程序，也符合设计模式的<strong>ocp原则</strong>(<strong>开闭原则</strong>：不修改源码，扩容功能)</p>
<h2 id="反射机制"><a href="#反射机制" class="headerlink" title="反射机制"></a>反射机制</h2><p>1）反射机制允许程序在执行期间借助于Reflection API 获得任何类的内部信息(比如：成员变量、构造器，成员方法等)，并能操作对象的属性及方法。反射在设计模式和框架底层都会用到</p>
<p>2）加载完类之后，在堆中就产生了一个Class类型的对象(一个类只有一个Class对象)，这个对象包含了类的完整结构信息。通过这个对象得到类的结构。</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220517143914000.png" alt="image-20220517143914000"></p>
<p><strong>作用</strong></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220517144131916.png" alt="image-20220517144131916"></p>
<p><strong>反射相关的类</strong></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220517144239805.png" alt="image-20220517144239805"></p>
<h2 id="反射优点和缺点"><a href="#反射优点和缺点" class="headerlink" title="反射优点和缺点"></a>反射优点和缺点</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220517144349140.png" alt="image-20220517144349140"></p>
<h2 id="反射调用优化-关闭访问检查"><a href="#反射调用优化-关闭访问检查" class="headerlink" title="反射调用优化-关闭访问检查"></a>反射调用优化-关闭访问检查</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220517144438188.png" alt="image-20220517144438188"></p>
<h2 id="Class-类"><a href="#Class-类" class="headerlink" title="Class 类"></a>Class 类</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220517144528389.png" alt="image-20220517144528389"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220517144622172.png" alt="image-20220517144622172"></p>
<h3 id="Class-类的常用方法"><a href="#Class-类的常用方法" class="headerlink" title="Class 类的常用方法"></a>Class 类的常用方法</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220517144710973.png" alt="image-20220517144710973"></p>
<h3 id="获取-Class-类对象"><a href="#获取-Class-类对象" class="headerlink" title="获取 Class 类对象"></a>获取 Class 类对象</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220517144936294.png" alt="image-20220517144936294"></p>
<h3 id="哪些类型有-Class-对象"><a href="#哪些类型有-Class-对象" class="headerlink" title="哪些类型有 Class 对象"></a>哪些类型有 Class 对象</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220517145022485.png" alt="image-20220517145022485"></p>
<h2 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220517145152479.png" alt="image-20220517145152479"></p>
<h3 id="类加载时机"><a href="#类加载时机" class="headerlink" title="类加载时机"></a>类加载时机</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220517145228556.png" alt="image-20220517145228556"></p>
<h3 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220517145340270.png" alt="image-20220517145340270"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220517145413669.png" alt="image-20220517145413669"></p>
<h4 id="加载阶段"><a href="#加载阶段" class="headerlink" title="加载阶段"></a>加载阶段</h4><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220517145456333.png" alt="image-20220517145456333"></p>
<h4 id="验证阶段"><a href="#验证阶段" class="headerlink" title="验证阶段"></a>验证阶段</h4><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220517145557852.png" alt="image-20220517145557852"></p>
<h4 id="准备阶段"><a href="#准备阶段" class="headerlink" title="准备阶段"></a>准备阶段</h4><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220517145702581.png" alt="image-20220517145702581"></p>
<h4 id="解析阶段"><a href="#解析阶段" class="headerlink" title="解析阶段"></a>解析阶段</h4><p>虚拟机将常量池中的符号引用替换为直接引用的过程</p>
<h4 id="Initialization（初始化-阶段"><a href="#Initialization（初始化-阶段" class="headerlink" title="Initialization（初始化) 阶段"></a>Initialization（初始化) 阶段</h4><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220517145853355.png" alt="image-20220517145853355"></p>
<h2 id="通过反射获取类的结构信息"><a href="#通过反射获取类的结构信息" class="headerlink" title="通过反射获取类的结构信息"></a>通过反射获取类的结构信息</h2><h3 id="java-lang-Class类"><a href="#java-lang-Class类" class="headerlink" title="java.lang.Class类"></a>java.lang.Class类</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220517150019387.png" alt="image-20220517150019387"></p>
<h3 id="java-lang-reflect-Field-类"><a href="#java-lang-reflect-Field-类" class="headerlink" title="java.lang.reflect.Field 类"></a>java.lang.reflect.Field 类</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220517150106804.png" alt="image-20220517150106804"></p>
<h3 id="java-lang-reflect-Method-类"><a href="#java-lang-reflect-Method-类" class="headerlink" title="java.lang.reflect.Method 类"></a>java.lang.reflect.Method 类</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220517150208171.png" alt="image-20220517150208171"></p>
<h3 id="java-lang-reflect-Constructor-类"><a href="#java-lang-reflect-Constructor-类" class="headerlink" title="java.lang.reflect.Constructor 类"></a>java.lang.reflect.Constructor 类</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220517150233977.png" alt="image-20220517150233977"></p>
<h2 id="通过反射创建对象"><a href="#通过反射创建对象" class="headerlink" title="通过反射创建对象"></a>通过反射创建对象</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220517150326870.png" alt="image-20220517150326870"></p>
<h2 id="通过反射访问类中的成员"><a href="#通过反射访问类中的成员" class="headerlink" title="通过反射访问类中的成员"></a>通过反射访问类中的成员</h2><h3 id="访问属性"><a href="#访问属性" class="headerlink" title="访问属性"></a>访问属性</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220517150407163.png" alt="image-20220517150407163"></p>
<h3 id="访问方法"><a href="#访问方法" class="headerlink" title="访问方法"></a>访问方法</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220517150431898.png" alt="image-20220517150431898"></p>
<h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><p>处理文本的利器，是对字符串执行模式匹配的技术</p>
<p>一个正则表达式，就是用某种模式去匹配字符串的一个公式</p>
<p>注：在Java正则表达式中，两个\\代表其它语言中的一个\</p>
<h2 id="正则表达式底层实现"><a href="#正则表达式底层实现" class="headerlink" title="正则表达式底层实现"></a>正则表达式底层实现</h2><p>1）创建一个<strong>Pattern模式对象</strong>，即正则表达式对象；</p>
<p>2）创建一个<strong>matcher匹配器对象</strong>，按照pattern(模式)，到字符串中去匹配；</p>
<p>3）找到后，将子字符串的开始的索引记录到 matcher 对象的属性 grops[0]，把该子字符串的结束的索引+1 的值记录到 groups[1]；</p>
<p>4）同时记录 oldLast 的值为子字符串的结束的索引 +1 的值即 groups[1]，即下次执行 find 时，就从此开始匹配；</p>
<h3 id="matcher-group-0-分析"><a href="#matcher-group-0-分析" class="headerlink" title="matcher.group(0) 分析"></a>matcher.group(0) 分析</h3><p>根据 groups[0] 和 groups[1] 的记录的位置，从字符串中开始截取子字符串返回，就是 [groups[0], groups[1]) 包含groups[0] 但是不包</p>
<p>含索引为groups[1]的位置</p>
<p><strong>有分组</strong>：将子字符串的开始的索引记录到 matcher 对象的属性 grops[0]，把该子字符串的结束的索引+1 的值记录到 groups[1]</p>
<p>​				记录第一个分组匹配到的字符串 groups[2] ，groups[3]为开始和结束+1的索引值</p>
<pre><code>            记录第二个分组匹配到的字符串 groups[4]，groups[5]为开始和结束+1的索引值
</code></pre>
<p>​				如果有更多的分组以此类推</p>
<p>​				group(0) 表示匹配到的子字符串</p>
<p>​				group(1) 表示匹配到的子字符串的第一组字串 </p>
<p>​				group(2) 表示匹配到的子字符串的第二组字串</p>
<p><strong>matches</strong>方法：用于整体匹配，在验证输入的字符串是否满足条件使用，返回ture或false</p>
<h2 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h2><h3 id="mysql中的模糊查询"><a href="#mysql中的模糊查询" class="headerlink" title="mysql中的模糊查询"></a>mysql中的模糊查询</h3><p><code>%</code>: 匹配0个或者多个任意字符</p>
<p><code>_</code>: 匹配任意一个字符</p>
<h3 id="转义号"><a href="#转义号" class="headerlink" title="转义号"></a>转义号</h3><p>使用正则表达式去检索某些特殊字符的时候，需要用到转移符号</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220518220453765.png" alt="image-20220518220453765"></p>
<h3 id="限定符"><a href="#限定符" class="headerlink" title="限定符"></a>限定符</h3><p>用于指定其前面的字符和组合项连续出现多少次</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220518153708550.png" alt="image-20220518153708550"></p>
<h3 id="选择匹配符"><a href="#选择匹配符" class="headerlink" title="选择匹配符"></a>选择匹配符</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220518153639621.png" alt="image-20220518153639621"></p>
<h3 id="分组组合和反向引用符"><a href="#分组组合和反向引用符" class="headerlink" title="分组组合和反向引用符"></a>分组组合和反向引用符</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220518154036309.png" alt="image-20220518154036309"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220518154102247.png" alt="image-20220518154102247"></p>
<h3 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h3><h3 id="字符匹配符"><a href="#字符匹配符" class="headerlink" title="字符匹配符"></a>字符匹配符</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220518153246607.png" alt="image-20220518153246607"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220518153258920.png" alt="image-20220518153258920"></p>
<p>\s：匹配任何空白字符，包括空格、制表符、换页符等。与[\f\n\r\t\v]等效</p>
<p>\S：匹配任何非空白字符</p>
<h3 id="定位符"><a href="#定位符" class="headerlink" title="定位符"></a>定位符</h3><p>规定要匹配的字符串出现的位置，比如在字符串的开始还是在结束的位置</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220518153948293.png" alt="image-20220518153948293"></p>
<h2 id="常用类-1"><a href="#常用类-1" class="headerlink" title="常用类"></a>常用类</h2><h3 id="Pattern类"><a href="#Pattern类" class="headerlink" title="Pattern类"></a>Pattern类</h3><p>pattern对象是一个正则表达式对象，Pattern类没有公共构造方法，要创建一个Pattern对象，调用其公共静态方法，它返回一个Pattern对象，该方法接收一个正则表达式作为他的第一个参数</p>
<h3 id="Matcher类"><a href="#Matcher类" class="headerlink" title="Matcher类"></a>Matcher类</h3><p>是对输入字符串进行解释和匹配的引擎。与Pattern类一样，Matcher也没有公共构造方法，需要调用Pattern对象的matcher方法获得一个Mather对象</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220519153616879.png" alt="image-20220519153616879"></p>
<h3 id="PatternSyntaxException类"><a href="#PatternSyntaxException类" class="headerlink" title="PatternSyntaxException类"></a>PatternSyntaxException类</h3><p>非强制异常类，表示一个正则表达式模式中的语法错误0</p>
<h2 id="分组、捕获、反向引用"><a href="#分组、捕获、反向引用" class="headerlink" title="分组、捕获、反向引用"></a>分组、捕获、反向引用</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220519154550603.png" alt="image-20220519154550603">	</p>
<h1 id="Lamda-表达式"><a href="#Lamda-表达式" class="headerlink" title="Lamda 表达式"></a>Lamda 表达式</h1><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><p><strong>(args1, args2,…) -&gt; { <a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=express&spm=1001.2101.3001.7020">express</a> block }</strong></p>
<p>lamda表达式由两部分组成：<strong>参数和语句块</strong>，参数可以不写参数类型也可以写参数类型，如果写参数类型，必须与对应方法的参数类型一致，</p>
<p><strong>如果只有一个参数，可以省略小括号()<strong>；语句块中如果只有一条语句，</strong>可以省略大括号{ }和return关键字</strong>。</p>
<p><strong>lamda表达式只支持函数式接口，函数式接口就是只有一个抽象方法的接口</strong>，例如Runnable</p>
<p>避免匿名<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%86%85%E9%83%A8%E7%B1%BB&spm=1001.2101.3001.7020">内部类</a>定义过多</p>
<p>可以让你的代码看起来很简洁</p>
<p>去掉了一堆没有意义的代码，留下核心的逻辑</p>
<p>其实质属于<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B&spm=1001.2101.3001.7020">函数式编程</a>的概念</p>
<h1 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h1><h2 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h2><p>两个区域A和B，初始对象在A，继续存活的对象被转移到B。此为新生代最常用的算法</p>
<h2 id="标记清理算法"><a href="#标记清理算法" class="headerlink" title="标记清理算法"></a>标记清理算法</h2><p>一块区域，标记可达对象（可达性分析），然后回收不可达对象，会出现碎片，那么引出标记-整理算法：多了碎片整理，整理出更大的内存放更大的对象</p>
<p>两个概念：<strong>新生代和年老代</strong></p>
<p>新生代：初始对象，生命周期短的</p>
<p>永久代：长时间存在的对象</p>
<p>整个java的垃圾回收是新生代和年老代的协作，这种叫做分代回收。</p>
<p>Serial New收集器是针对新生代的收集器，采用的是复制算法</p>
<p>Parallel New（并行）收集器，新生代采用复制算法，老年代采用标记整理</p>
<p>Parallel Scavenge（并行）收集器，针对新生代，采用复制收集算法</p>
<p>Serial Old（串行）收集器，新生代采用复制，老年代采用标记整理</p>
<p>Parallel Old（并行）收集器，针对老年代，标记整理</p>
<p>CMS收集器，基于标记清理</p>
<p>G1收集器：整体上是基于标记 整理 ，局部采用复制</p>
<p><strong>综上：新生代基本采用复制算法，老年代采用标记整理算法。cms采用标记清理。</strong></p>
<h1 id="委托事件模型"><a href="#委托事件模型" class="headerlink" title="委托事件模型"></a>委托事件模型</h1><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/cac99c0f172b">https://www.jianshu.com/p/cac99c0f172b</a></p>
<h1 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h1><h2 id="网络的相关概念"><a href="#网络的相关概念" class="headerlink" title="网络的相关概念"></a>网络的相关概念</h2><h3 id="网络通信"><a href="#网络通信" class="headerlink" title="网络通信"></a>网络通信</h3><p>两台设备之间通过网络实现数据传输&#x2F;将数据通过网络从一台设备传输到另一台设备</p>
<p>java.net包下提供了一系列的类或接口，供程序员使用，完成网络通信</p>
<h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><p>两台或多台设备通过一定物理设备连接起来构成了网络</p>
<p>根据网络的覆盖范围进行分类：</p>
<p>1）局域网：覆盖范围小，仅仅覆盖一个教室或一个机房</p>
<p>2）城域网：覆盖范围较大，可以覆盖一个城市</p>
<p>3）广域网：覆盖范围最大，可以覆盖全国，甚至全球，万维网是广域网的代表</p>
<h3 id="ip-地址"><a href="#ip-地址" class="headerlink" title="ip 地址"></a>ip 地址</h3><p>用以标识网络中的每一台主机&#x2F;计算机</p>
<p>查看IP地址：ipconfig</p>
<p>ip地址的表示形式：点分十进制 xx.xx.xx.xx</p>
<p>每一个十进制数的范围：0-255</p>
<p>ip地址的组成：网络地址+主机地址</p>
<p>ipv4的网络地址资源有限，严重制约了互联网的应用和发展，ipv6的使用，不仅能解决网络地址资源数量的问题，而且也解决了多种接入设备连入互联网的障碍</p>
<h3 id="ipv4地址分类"><a href="#ipv4地址分类" class="headerlink" title="ipv4地址分类"></a>ipv4地址分类</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220519170200444.png" alt="image-20220519170200444"></p>
<h3 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h3><p>好处：为了方便记忆，解决记ip的困难</p>
<p>概念：将ip地址映射成域名，HTTP</p>
<p><strong>端口号：</strong>用于标识计算机上某个特定的网络程序</p>
<p>​				以整数形式，端口范围：0-65535[两个字节表示端口]</p>
<p>​				0-1024已经被占用，比如：ssh 22,  ftp 21,  smtp 25,  http 80</p>
<p>​				常见的网络程序端口号：tomcat:8080</p>
<p>​															mysql:3306</p>
<p>​															oracle:1521</p>
<p>​															sqlserver:1433</p>
<h3 id="网络通信协议"><a href="#网络通信协议" class="headerlink" title="网络通信协议"></a>网络通信协议</h3><p>TCP&#x2F;IP：传输控制协议，由网络层的IP协议和传输层的TCP协议组成</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220519172516839.png" alt="image-20220519172516839"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220519172535187.png" alt="image-20220519172535187"></p>
<h2 id="InetAddress-类"><a href="#InetAddress-类" class="headerlink" title="InetAddress 类"></a>InetAddress 类</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220519172610171.png" alt="image-20220519172610171"></p>
<h2 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220519172647626.png" alt="image-20220519172647626"></p>
<h2 id="TCP-网络通信编程"><a href="#TCP-网络通信编程" class="headerlink" title="TCP 网络通信编程"></a>TCP 网络通信编程</h2><p>基于客户端—服务端的网络通信</p>
<p>底层使用的是TCP&#x2F;IP协议</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220519172850090.png" alt="image-20220519172850090"></p>
<h3 id="netstat-指令"><a href="#netstat-指令" class="headerlink" title="netstat 指令"></a>netstat 指令</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220519172954362.png" alt="image-20220519172954362"></p>
<p>-Xms1G -Xmx2G -Xmn500M -XX:MaxPermSize&#x3D;64M -XX:+UseConcMarkSweepGC -XX:SurvivorRatio&#x3D;3,</p>
<p>-Xms：1G ， 就是说初始堆大小为1G<br>-Xmx：2G ， 就是说最大堆大小为2G<br>-Xmn：500M ，就是说年轻代大小是500M（包括一个Eden和两个Survivor）<br>-XX:MaxPermSize：64M ， 就是说设置持久代最大值为64M<br>-XX:+UseConcMarkSweepGC ， 就是说使用使用CMS内存收集算法<br>-XX:SurvivorRatio&#x3D;3 ， 就是说Eden区与Survivor区的大小比值为3：1：1</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-操作系统：进程同步、互斥"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
	
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/08/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%9A%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E3%80%81%E4%BA%92%E6%96%A5/"
    >进程同步、互斥</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/08/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%9A%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E3%80%81%E4%BA%92%E6%96%A5/" class="article-date">
  <time datetime="2022-08-08T12:11:49.000Z" itemprop="datePublished">2022-08-08</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">计算机基础知识</a> / <a class="article-category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="进程同步、互斥"><a href="#进程同步、互斥" class="headerlink" title="进程同步、互斥"></a>进程同步、互斥</h1><h2 id="进程异步"><a href="#进程异步" class="headerlink" title="进程异步"></a>进程异步</h2><p>各并发执行的进程以各自独立的、不可预知的速度向前推进</p>
<h2 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h2><ul>
<li><p>协调多个并发执行进程的工作先后次序</p>
</li>
<li><p>例如：进程通信中的管道通信</p>
<ul>
<li>读进程和写进程并发地运行，由于并发必然导致异步性，因此“写数据”和“读数据”两个操作执行的先后顺序是不确定的。而实际应用中，又必须按照“<strong>写数据→读数据</strong>”的顺序来执行的。</li>
<li>如何解决这种<strong>异步</strong>问题，就是“<strong>进程同步</strong>”所讨论的内容。</li>
</ul>
</li>
<li><p>同步亦称<strong>直接制约关系</strong>，它是指为完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上<strong>协调</strong>它们的<strong>工作次序</strong>而产生的制约关系。进程间的直接制约关系就是源于它们之间的相互合作。</p>
</li>
</ul>
<h2 id="进程互斥"><a href="#进程互斥" class="headerlink" title="进程互斥"></a>进程互斥</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220808202305888.png" alt="image-20220808202305888"></p>
<ul>
<li>我们把<strong>一个时间段内只允许一个进程使用的资源称为临界资源</strong>。许多物理设备（比如摄像头、打印机）都属于临界资源。此外还有许多变量、数据、内存缓冲区等都属于临界资源。</li>
<li>对临界资源的访问，必须<strong>互斥</strong>地进行。互斥，亦称<strong>间接制约关系</strong></li>
<li><strong>进程互斥</strong>指当一个进程访问某临界资源时，另一个想要访问该临界资源的进程必须等待。当前访问临界资源的进程访问结束，释放该资源之后，另一个进程才能去访问临界资源。</li>
</ul>
<h2 id="访问临界资源"><a href="#访问临界资源" class="headerlink" title="访问临界资源"></a>访问临界资源</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220808202529431.png" alt="image-20220808202529431"></p>
<ul>
<li><strong>临界区</strong>是进程中<strong>访问临界资源</strong>的代码</li>
<li><strong>进入区</strong>和<strong>退出区</strong>是<strong>负责实现互斥</strong>的代码段</li>
<li>临界区也可称为”临界段“</li>
</ul>
<p> <strong>访问临界资源（进程互斥）需要遵循的原则</strong></p>
<ol>
<li><p><strong>空闲让进</strong></p>
<p>临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区</p>
</li>
<li><p><strong>忙则等待</strong></p>
<p>当已有进程进入临界区时，其他试图进入临界区的进程必须等待</p>
</li>
<li><p><strong>有限等待</strong></p>
<p>对请求访问的进程，应保证能在有限时间内进入临界区 (保证不会饥饿)</p>
</li>
<li><p><strong>让权等待</strong></p>
<p>当进程不能进入临界区，应当立即释放处理机，防止进程忙等待 (不应该让他占用处理机 一直执行循环无法前进，应当得知无法进入临界区时不执行循环，直接切换进程)</p>
</li>
</ol>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220808203126849.png" alt="image-20220808203126849"></p>
<h1 id="进程互斥的软件实现方法"><a href="#进程互斥的软件实现方法" class="headerlink" title="进程互斥的软件实现方法"></a>进程互斥的软件实现方法</h1><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220808203349709.png" alt="image-20220808203349709"></p>
<h2 id="单标志法"><a href="#单标志法" class="headerlink" title="单标志法"></a>单标志法</h2><h3 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h3><p>一个进程<strong>访问完临界区后</strong>会把使用临界区的权限交给另一个进程，即<strong>每个进程进入临界区的权限只能被另一个进程赋予</strong></p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220808204043347.png" alt="image-20220808204043347"></p>
<ol>
<li>turn的初值为0，即刚开始只允许0号进程进入临界区。</li>
<li>若P1先上处理机运行，则会一直卡在⑤。直到P1的时间片用完，发生调度，切换P0上处理机运行。代码①不会卡住P0，P0可以正常访问临界区，在P0访问临界区期间即使切换回p1，P1依然会卡在⑤，只有P0在退出区将turn改为1后，P1才能进入临界区。</li>
<li>因此，该算法<code>可以实现”同一时刻最多只允许一个进程访问临界区“</code></li>
<li>如果此时允许进入临界区的进程是P0，而P0一直不访问临界区，那么此时虽然临界区空闲，但一直不允许P1访问，因此，单标志法存在的问题是：<strong>违背空闲让进原则</strong></li>
</ol>
<h2 id="双标志先检查"><a href="#双标志先检查" class="headerlink" title="双标志先检查"></a>双标志先检查</h2><h3 id="思想-1"><a href="#思想-1" class="headerlink" title="思想"></a>思想</h3><p>设置一个布尔数组flag[]，数组中各元素<strong>标记各进程是否想进入临界区</strong>，true表示想进入， false表示不想进入；每个进程在进入临界区之前先检查当前有没有别的进程想进入临界 区，如果没有，把自身对应的标志flag[i]改为true，之后开始访问临界区</p>
<h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220808204701062.png" alt="image-20220808204701062"></p>
<p>存在的问题：P0进程进入之后，在修改P0为true之前，切换到P1，P1检查无别的进程想进入临界区，故会将P1改为true，导致两个进程都为true，会同时访问临界区，<strong>违反了”忙则等待“原则</strong></p>
<p>原因：<strong>进入区</strong>的检查和上锁两个处理<strong>不是一气呵成的</strong>。检查后，上锁前可能发生进程切换</p>
<h2 id="双标志后检查"><a href="#双标志后检查" class="headerlink" title="双标志后检查"></a>双标志后检查</h2><h3 id="思想-2"><a href="#思想-2" class="headerlink" title="思想"></a>思想</h3><p>双标志先检查法的改版，<strong>先上锁后检查</strong>，谁想进谁直接将自身改为true，不关心其他进 程，改为true之后，再检查有没有其他进程想访问</p>
<h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220808205216016.png" alt="image-20220808205216016"></p>
<p>存在的问题：P0想进入，P0改为true，在检查之前切换到P1，P1想进入，改为true，导致两个进程都为true，违背了<strong>“空闲让进”和有限等待”</strong>，谁都无法访问临界区，<strong>产生饥饿现象</strong></p>
<p>原因：进入区的检查和上锁不是一气呵成的</p>
<h2 id="Peterson算法"><a href="#Peterson算法" class="headerlink" title="Peterson算法"></a>Peterson算法</h2><h3 id="思想-3"><a href="#思想-3" class="headerlink" title="思想"></a>思想</h3><p>双标志后检查法的改版，若两个进程都想进入临界区，可以<strong>主动让对方优先访问临界区</strong></p>
<h3 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220808205512859.png" alt="image-20220808205512859"></p>
<p>进入区做了三件事：1. 主动争取 2. 主动谦让 3. 检查对方</p>
<p>Peterson算法解决了空闲让进，忙则等待，有限等待三个原则，但<strong>未遵循让权等待原则</strong></p>
<h1 id="进程互斥的硬件实现方法"><a href="#进程互斥的硬件实现方法" class="headerlink" title="进程互斥的硬件实现方法"></a>进程互斥的硬件实现方法</h1><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220808210328910.png" alt="image-20220808210328910"></p>
<h2 id="中断屏蔽方法"><a href="#中断屏蔽方法" class="headerlink" title="中断屏蔽方法"></a>中断屏蔽方法</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>利用“开&#x2F;关中断指令”实现（与原语的实现思想相同，即在某进程开始访问临界区到结束访问为止都不允许被中断，也就不能发生进程切换，因此也不可能发生两个同时访问临界区的情况）</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220808210615415.png" alt="image-20220808210615415"></p>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：简单、高效 </p>
<p>缺点：<strong>不适用于多处理机</strong>；只适用于操作系统内核进程，<strong>不适用于用户进程</strong>（因为开&#x2F;关中断指令只能运行在内核态，这组指令如果能让用户随意使用会很危险）</p>
<h2 id="TestAndSet指令-TS指令"><a href="#TestAndSet指令-TS指令" class="headerlink" title="TestAndSet指令(TS指令)"></a>TestAndSet指令(TS指令)</h2><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>TSL 指令是用硬件实现的，执行的过程不允许被中断，只能一气呵成。</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220808210815379.png" alt="image-20220808210815379"></p>
<p>若刚开始 lock 是 false，则 TSL 返回的 old 值为 false，while 循环条件不满足，直接跳过循环，进入临界区。</p>
<p>若刚开始 lock 是 true，则执行 TLS 后 old 返回的值为 true，while 循环条件满足，会一直循环，直到当前访问临界区的进程在退出区进行“解锁”。 </p>
<h3 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h3><p>相比软件实现方法，TSL 指令把“上锁”和“检查”操作用硬件的方式变成了一气呵成的原子操作。 </p>
<p>优点：实现简单，无需像软件实现方法那样严格检查是否会有逻辑漏洞；适用于多处理机环境 </p>
<p>缺点：<strong>不满足“让权等待”原则</strong>，暂时无法进入临界区的进程会占用CPU并循环执行TSL指令，从而导致“忙等”。</p>
<h2 id="Swap指令"><a href="#Swap指令" class="headerlink" title="Swap指令"></a>Swap指令</h2><h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><p>Swap 指令是用硬件实现的，执行的过程不允许被中断，只能一气呵成。</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220808211326054.png" alt="image-20220808211326054"></p>
<p>逻辑上来看 Swap 和 TSL 并无太大区别，都是先记录下此时临界区是否已经被上锁（记录在 old 变量上），再将上锁标记 lock 设置为 true，最后检查 old，如果 old 为 false 则说明之前没有别的进程对临界区上锁，则可跳出循环，进入临界区。</p>
<h3 id="优缺点-2"><a href="#优缺点-2" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：实现简单，无需像软件实现方法那样严格检查是否会有逻辑漏洞；适用于多处理机环境 </p>
<p>缺点：<strong>不满足“让权等待”原则</strong>，暂时无法进入临界区的进程会占用CPU并循环执行TSL指令，从而导致“忙等”。</p>
<h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220808211841332.png" alt="image-20220808211841332"></p>
<h1 id="信号量机制"><a href="#信号量机制" class="headerlink" title="信号量机制"></a>信号量机制</h1><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220808212101299.png" alt="image-20220808212101299"></p>
<h2 id="出现原因"><a href="#出现原因" class="headerlink" title="出现原因"></a>出现原因</h2><p>进程互斥的四种软件实现方式（单标志法、双标志先检查、双标志后检查、Peterson算法） </p>
<p>进程互斥的三种硬件实现方式（中断屏蔽方法、TS&#x2F;TSL指令、Swap&#x2F;XCHG指令）</p>
<ol>
<li><p>在双标志先检查法中，<strong>进入区的“检查”、“上锁” 操作无法一气呵成</strong>，从而导致了两个进程有可能<strong>同时进入临界区</strong>的问题；</p>
</li>
<li><p>所有的解决方案<strong>都无法实现“让权等待”</strong></p>
</li>
</ol>
<p>1965年，荷兰学者Dijkstra提出了一种卓有成效的实现<strong>进程互斥、同步</strong>的方法——<strong>信号量机制</strong></p>
<h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><ul>
<li>用户进程可以通过使用操作系统提供的<strong>一对原语</strong>来对<strong>信号量</strong>进行操作，从而很方便的实现了进程互斥、进程同步。 </li>
<li><strong>信号量</strong>其实就是一个变量 ，可以用一个信号量来<strong>表示系统中某种资源的数量</strong>，比如：系统中只有一台打印机，就可以设置一个初值为 1 的信号量。 </li>
<li><strong>原语</strong>是一种特殊的程序段，其<strong>执行只能一气呵成，不可被中断</strong>。原语是由<strong>关中断&#x2F;开中断</strong>指令实现的。软件解决方案的主要问题是由“进入区的各种操作无法一气呵成”，因此如果能把进入区、退出区的操作都用“原语”实现，使这些操作能“一气呵成”就能避免问题。</li>
<li><strong>一对原语</strong>：<strong>wait(S)</strong> 原语和 <strong>signal(S)</strong> 原语，可以把原语理解为我们自己写的函数，函数名分别为 wait 和 signal，括号里的<strong>信号量 S</strong> 其实就是函数调用时传入的一个参数。</li>
<li>wait、signal 原语常<strong>简称为 P、V操作</strong>（来自荷兰语 proberen 和 verhogen）。</li>
</ul>
<h2 id="整型信号量"><a href="#整型信号量" class="headerlink" title="整型信号量"></a>整型信号量</h2><ul>
<li>用一个<strong>整数型的变量</strong>作为信号量，用来<strong>表示系统中某种资源的数量</strong>。</li>
<li>与普通整数变量的区别： 对信号量的操作只有三种， 即 <strong>初始化、P操作、V操作</strong></li>
</ul>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220808213217836.png" alt="image-20220808213217836"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220808213254429.png" alt="image-20220808213254429"></p>
<h2 id="记录型信号量"><a href="#记录型信号量" class="headerlink" title="记录型信号量"></a>记录型信号量</h2><p>整型信号量的缺陷是<strong>存在“忙等”问题</strong>，因此人们又提出了“记录型信号量”，即用记录型数据结构表示的信号量。</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220808213446149.png" alt="image-20220808213446149"><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220808213930158.png" alt="image-20220808213930158"></p>
<ul>
<li>中 wait(S)、signal(S) 也可以记为 P(S)、V(S)，这对原语可用于<strong>实现系统资源的“申请”和“释放”。</strong></li>
<li><strong>S.value 的初值</strong>表示<strong>系统中某种资源的数目</strong>。 </li>
<li>对信号量 S 的<strong>一次 P 操作</strong>意味着进程<strong>请求一个单位的该类资源</strong>，因此需要执行 S.value–，表示资源数减1，当 S.value &lt; 0 时表示该类资源已分配完毕，因此进程应<strong>调用 block 原语进行自我阻塞<strong>（当前运行的进程从</strong>运行态—&gt;阻塞态</strong>），主动放弃处理机，并插入该类资源的等待队列 S.L 中。可见，该机制<strong>遵循了“让权等待”原则</strong>，不会出现“忙等”现象。 </li>
<li>对信号量 S 的<strong>一次 V 操作</strong>意味着进程<strong>释放一个单位的该类资源</strong>，因此需要执行 S.value++，表示资源数加1，若加1后仍是 S.value &lt;&#x3D; 0，表示依然有进程在等待该类资源，因此应<strong>调用 wakeup 原语唤醒等待队列中的第一个进程<strong>（被唤醒进程从</strong>阻塞态—&gt;就绪态</strong>）。</li>
</ul>
<h2 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220808214501300.png" alt="image-20220808214501300"></p>
<h1 id="用信号量实现进程互斥、同步、前驱关系"><a href="#用信号量实现进程互斥、同步、前驱关系" class="headerlink" title="用信号量实现进程互斥、同步、前驱关系"></a>用信号量实现进程互斥、同步、前驱关系</h1><ul>
<li><strong>一个信号量对应一种资源</strong> </li>
<li>信号量的值 &#x3D; 这种资源的剩余数量（信号量的值如果小于0，说明此时有进程在等待这种资源）</li>
<li>P( S ) —— 申请一个资源S，<strong>如果资源不够就阻塞等待</strong></li>
<li>V( S ) —— 释放一个资源S，<strong>如果有进程在等待该资源，则唤醒一个进程</strong></li>
</ul>
<h2 id="进程互斥实现"><a href="#进程互斥实现" class="headerlink" title="进程互斥实现"></a>进程互斥实现</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220808214838619.png" alt="image-20220808214838619"></p>
<h2 id="进程同步实现"><a href="#进程同步实现" class="headerlink" title="进程同步实现"></a>进程同步实现</h2><p>进程同步：要让各并发进程按要求有序地推进。</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220808215133294.png" alt="image-20220808215133294"></p>
<h2 id="前驱关系实现"><a href="#前驱关系实现" class="headerlink" title="前驱关系实现"></a>前驱关系实现</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220808215509765.png" alt="image-20220808215509765"></p>
<h2 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220808215643943.png" alt="image-20220808215643943"></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-操作系统：处理机调度"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
	
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/08/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%9A%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6/"
    >处理机调度</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/08/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%9A%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6/" class="article-date">
  <time datetime="2022-08-08T07:10:15.000Z" itemprop="datePublished">2022-08-08</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">计算机基础知识</a> / <a class="article-category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="处理机调度的概念、层次"><a href="#处理机调度的概念、层次" class="headerlink" title="处理机调度的概念、层次"></a>处理机调度的概念、层次</h1><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220808151236283.png" alt="image-20220808151236283"></p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul>
<li>当有一堆任务要处理，但由于资源有限，这些事情没法同时处理。这就需要确定<strong>某种规则</strong>来<strong>决定</strong>处理这些任务的<strong>顺序</strong>，这就是“调度”研究的问题。 </li>
<li>在多道程序系统中，进程的数量往往是多于处理机的个数的，这样不可能同时并行地处理各个进程。<strong>处理机调度</strong>，就是从就绪队列中按照一定的算法选择一个进程并将处理机分配给它运行，以实现进程的并发执行。</li>
</ul>
<h2 id="处理机调度的三个层次"><a href="#处理机调度的三个层次" class="headerlink" title="处理机调度的三个层次"></a>处理机调度的三个层次</h2><h3 id="高级调度（作业调度）"><a href="#高级调度（作业调度）" class="headerlink" title="高级调度（作业调度）"></a>高级调度（作业调度）</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220808192157610.png" alt="image-20220808192157610"></p>
<ul>
<li>由于内存空间有限，有时无法将用户提交的作业全部放入内存，因此就需要确定某种规则来决定将作业调入内存的顺序。 </li>
<li><strong>高级调度（作业调度）</strong>。按一定的原则从外存上处于后备队列的作业中挑选一个（或多个）作业，给他们分配内存等必要资源，<strong>并建立相应的进程（建立PCB）</strong>，以使它（们）<strong>获得竞争处理机的权利</strong>。</li>
<li>高级调度是辅存（外存）与内存之间的调度。每个作业只调入一次，调出一次。<strong>作业调入时会建立相应的PCB，作业调出时才撤销PCB</strong>。高级调度主要是指调入的问题，因为只有调入的时机需要操作系统来确定，但调出的时机必然是作业运行结束才调出。</li>
</ul>
<h3 id="中级调度（内存调度）"><a href="#中级调度（内存调度）" class="headerlink" title="中级调度（内存调度）"></a>中级调度（内存调度）</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220808192322620.png" alt="image-20220808192322620"></p>
<ul>
<li>引入了虚拟存储技术之后，可将暂时不能运行的进程调至外存等待。等它重新具备了运行条件且内存又稍有空闲时，再重新调入内存。 </li>
<li>这么做的目的是为了<strong>提高内存利用率和系统吞吐量</strong>。 </li>
<li>暂时调到外存等待的进程状态为<strong>挂起状态</strong>。值得注意的是，<strong>PCB并不会一起调到外存，而是会常驻内存</strong>。PCB中会记录进程数据在外存中的存放位置，进程状态等信息，操作系统通过内存中的PCB来保持对各个进程的监控、管理。<strong>被挂起的进程PCB会被放到的挂起队列中</strong>。 </li>
<li><strong>中级调度（内存调度），就是要决定将哪个处于挂起状态的进程重新调入内存。</strong></li>
<li>一个进程可能会被多次调出、调入内存，因此<strong>中级调度发生的频率要比高级调度更高</strong>。</li>
</ul>
<h4 id="进程的挂起态与七状态模型"><a href="#进程的挂起态与七状态模型" class="headerlink" title="进程的挂起态与七状态模型"></a>进程的挂起态与七状态模型</h4><ul>
<li><p>暂时调到外存等待的进程状态为<strong>挂起状态</strong>（挂起态，suspend） </p>
</li>
<li><p>挂起态又可以进一步细分为<strong>就绪挂起、阻塞挂起</strong>两种状态</p>
</li>
<li><p>五状态模型—&gt;七状态模型</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220808192621967.png" alt="image-20220808192621967"></p>
<p><strong>注意</strong>：“挂起”和“阻塞”的区别，两种状态都是暂时不能获得CPU的服务，但挂起态是将进程映像调到外存去了，而阻塞态下进程映像还在内存中。 有的操作系统会把就绪挂起、阻塞挂起分为两个挂起队列，甚至会根据阻塞原因不同再把阻塞挂起进程进一步细分为多个队列。</p>
</li>
</ul>
<h3 id="低级调度（进程调度）"><a href="#低级调度（进程调度）" class="headerlink" title="低级调度（进程调度）"></a>低级调度（进程调度）</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220808192731046.png" alt="image-20220808192731046"></p>
<ul>
<li><strong>低级调度（进程调度）</strong>，其主要任务是按照某种方法和策略<strong>从就绪队列中选取一个进程</strong>，将处理机分配给它。 </li>
<li>进程调度是操作系统中<strong>最基本的一种调度</strong>，在一般的操作系统中都必须配置进程调度。 </li>
<li>进程调度的<strong>频率很高</strong>，一般几十毫秒一次。</li>
</ul>
<h3 id="三种调度的对比"><a href="#三种调度的对比" class="headerlink" title="三种调度的对比"></a>三种调度的对比</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220808192919564.png" alt="image-20220808192919564"></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220808164047195.png" alt="image-20220808164047195"></p>
<h1 id="进程调度的时机与调度方式"><a href="#进程调度的时机与调度方式" class="headerlink" title="进程调度的时机与调度方式"></a>进程调度的时机与调度方式</h1><h2 id="进程调度的时机"><a href="#进程调度的时机" class="headerlink" title="进程调度的时机"></a>进程调度的时机</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220808193037768.png" alt="image-20220808193037768"></p>
<blockquote>
<p><strong>临界资源</strong>：一个时间段内只允许一个进程使用的资源。各进程需要互斥地访问临界资源。 </p>
<p><strong>临界区</strong>：访问临界资源的那段代码。</p>
<p><strong>内核程序临界区</strong>一般是用来访问某种内核数据结构的，比如进程的就绪队列（由各就绪进程的PCB组成）</p>
<p>进程在操作系统内核程序临界区中不能进行调度与切换（√）</p>
<p>解析：内核程序临界区访问的临界资源如果不尽快释放的话，极有可能影响到操作系统内核的其他管理工作。因此在访问内核程序临界区期间不能进行调度与切换</p>
<p>进程处于临界区时不能进行处理机调度（×）</p>
<p>解析：普通临界区访问的临界资源不会直接影响操作系统内核的管理工作。因此在访问普通临界区时可以进行调度与切换。</p>
</blockquote>
<h2 id="进程调度的方式"><a href="#进程调度的方式" class="headerlink" title="进程调度的方式"></a>进程调度的方式</h2><h3 id="非剥夺调度方式"><a href="#非剥夺调度方式" class="headerlink" title="非剥夺调度方式"></a>非剥夺调度方式</h3><ul>
<li>又称<strong>非抢占方式</strong>。即，只<strong>允许进程主动放弃处理机</strong>。在运行过程中即便有更紧迫的任务到达，当前进程依然会继续使用处理机，直到该进程终止或主动要求进入阻塞态。</li>
<li>实现简单，系统开销小但是无法及时处理紧急任务，适合于早期的批处理系统</li>
</ul>
<h3 id="剥夺调度方式"><a href="#剥夺调度方式" class="headerlink" title="剥夺调度方式"></a>剥夺调度方式</h3><ul>
<li>又称<strong>抢占方式</strong>。当一个进程正在处理机上执行时，如果有一个<strong>更重要或更紧迫的进程需要使用处理机，则立即暂停正在执行的进程</strong>，将处理机分配给更重要紧迫的那个进程。</li>
<li>可以优先处理更紧急的进程，也可实现让各进程按时间片轮流执行的功能（通过时钟中断）。适合于分时操作系统、实时操作系统</li>
</ul>
<h2 id="进程的切换与过程"><a href="#进程的切换与过程" class="headerlink" title="进程的切换与过程"></a>进程的切换与过程</h2><p>“狭义的进程调度”与“进程切换”的区别： </p>
<ul>
<li><p><strong>狭义的进程调度</strong>指的是<strong>从就绪队列中选中一个要运行的进程</strong>。（这个进程可以是<strong>刚刚被暂停执行的进程</strong>，也可能是<strong>另一个进程</strong>，后一种情况就需要进程切换） </p>
</li>
<li><p><strong>进程切换</strong>是指一个进程让出处理机，由另一个进程占用处理机的过程。 </p>
</li>
<li><p><strong>广义的进程调度</strong>包含了选择一个进程和进程切换两个步骤。</p>
</li>
</ul>
<p>进程切换的过程主要完成了：</p>
<ol>
<li><p>对原来运行进程各种数据的保存</p>
</li>
<li><p>对新的进程各种数据的恢复（如：程序计数器、程序状态字、各种数据寄存器等处理机现场信息，这些信息一般保存在进程控制块）</p>
</li>
</ol>
<p>注意：<strong>进程切换是有代价的</strong>，因此如果<strong>过于频繁</strong>的进行进程<strong>调度、切换</strong>，必然会使<strong>整个系统的效率降低</strong>，使系统大部分时间都花在了进程切换上，而真正用于执行进程的时间减少。</p>
<h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220808182459003.png" alt="image-20220808182459003"></p>
<h1 id="调度算法的评价指标"><a href="#调度算法的评价指标" class="headerlink" title="调度算法的评价指标"></a>调度算法的评价指标</h1><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220808183003135.png" alt="image-20220808183003135"></p>
<h1 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h1><h2 id="先来先服务（FCFS-First-Come-First-Serve）"><a href="#先来先服务（FCFS-First-Come-First-Serve）" class="headerlink" title="先来先服务（FCFS, First Come First Serve）"></a>先来先服务（FCFS, First Come First Serve）</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220808194810823.png" alt="image-20220808194810823"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220808194840929.png" alt="image-20220808194840929"></p>
<h2 id="短作业优先（SJF-Shortest-Job-First）"><a href="#短作业优先（SJF-Shortest-Job-First）" class="headerlink" title="短作业优先（SJF, Shortest Job First）"></a>短作业优先（SJF, Shortest Job First）</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220808194954027.png" alt="image-20220808194954027"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220808195217511.png" alt="image-20220808195217511"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220808195323448.png" alt="image-20220808195323448"></p>
<p><strong>注意</strong>：</p>
<ul>
<li><strong>默认是非抢占式的</strong></li>
</ul>
<h2 id="高响应比优先（HRRN-Highest-Response-Ratio-Next）"><a href="#高响应比优先（HRRN-Highest-Response-Ratio-Next）" class="headerlink" title="高响应比优先（HRRN, Highest Response Ratio Next）"></a>高响应比优先（HRRN, Highest Response Ratio Next）</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220808195623462.png" alt="image-20220808195623462"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220808195639635.png" alt="image-20220808195639635"></p>
<h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220808195730956.png" alt="image-20220808195730956"></p>
<p><strong>注</strong>：这几种算法主要关心对用户的公平性、平均周转时间、平均等待时间等评价系统整体性能的指标，但是<strong>不关心“响应时间”</strong>，也并<strong>不区分任务的紧急程度</strong>，因此对于用户来说，交互性很糟糕。因此这三种算法一般适合用于<strong>早期的批处理系统</strong>，当然，FCFS算法也常结合其他的算法使用，在现在也扮演着很重要的角色。</p>
<h2 id="时间片轮转（RR）"><a href="#时间片轮转（RR）" class="headerlink" title="时间片轮转（RR）"></a>时间片轮转（RR）</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220808185854769.png" alt="image-20220808185854769"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220808185438210.png" alt="image-20220808185438210"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220808185506621.png" alt="image-20220808185506621"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220808185525659.png" alt="image-20220808185525659"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220808185942892.png" alt="image-20220808185942892"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220808185616448.png" alt="image-20220808185616448"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220808185701771.png" alt="image-20220808185701771"></p>
<p><strong>注意</strong></p>
<ul>
<li><p>每次选择上的处理机的进程都是排在就绪队列队头的进程</p>
</li>
<li><p>一个进程执行完会移动到就绪队列的尾部</p>
</li>
<li><p>一个进程时间片到，刚下处理机要移至就绪队列的尾部的同时有一个新进程到达就绪队列，则新进程先到达就绪队列的尾部</p>
</li>
<li><p>如果时间片太大，使得每个进程都可以在一个时间片内就完成，则时间斤轮转调度昇宏退化八尤木先服务调度算法，并且会增大进程响应时间。因此时间片不能太大。</p>
</li>
<li><p>另一方面，进程调度、切换是有时间代价的（保存、恢复运行坯境)，因此如果时间片太小，过于致进程切换过于频繁，系统会花大量的时间来处理进程切换，从导致头际用于进在执行的时间比例减少。可见时间片也不能太小。</p>
</li>
</ul>
<h2 id="优先级调度"><a href="#优先级调度" class="headerlink" title="优先级调度"></a>优先级调度</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220808190928540.png" alt="image-20220808190928540"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220808190253225.png" alt="image-20220808190253225"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220808190410056.png" alt="image-20220808190410056"></p>
<p><strong>补充</strong>:</p>
<ul>
<li>就绪队列未必只有一个，可以按照不同优先级来组织。另外，也可以把优先级高的进程排在更靠近队头的位置</li>
<li>根据优先级是否可以动态改变，可将优先级分为<strong>静态优先级和动态优先级</strong>两种</li>
<li><strong>静态优先级</strong>：创建进程时确定，之后一直不变。</li>
<li><strong>动态优先级</strong>：创建进程时有一个初始值，之后会根据情况动态地调整优先级。</li>
</ul>
<p><strong>如何合理地设置各类进程的优先级?</strong></p>
<p>通常:</p>
<ul>
<li>系统进程优先级<strong>高于</strong>用户进程</li>
<li>前台进程优先级<strong>高于</strong>后台进程</li>
<li>操作系统更<strong>偏好l&#x2F;O型进程（或称l&#x2F;O繁忙型进程)</strong><ul>
<li>I&#x2F;O设备和CPU可以并行工作。如果优先计I&#x2F;O繁忙型进程优先运行的话，则越有可能让l&#x2F;O设备尽早地投入工作，则资源利用率、系统吞吐量都会得到提升</li>
</ul>
</li>
</ul>
<p>注：与I&#x2F;O型进程相对的是计算型进程（或称CPU繁忙型进程)</p>
<p><strong>如果采用的是动态优先级，什么时候应该调整?</strong></p>
<ul>
<li>可以从追求公平、提升资源利用率等角度考虑</li>
<li>如果某进程在就绪队列中等待了很长时间，则可以适当提开其优先级</li>
<li>如果某进程占用处理机运行了很长时间，则可适当降低其优先级</li>
<li>如果发现一个进程频繁地进行l&#x2F;O操作，则可适当提升其优先级</li>
</ul>
<h2 id="多级反馈队列调度"><a href="#多级反馈队列调度" class="headerlink" title="多级反馈队列调度"></a>多级反馈队列调度</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220808191644049.png" alt="image-20220808191644049"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220808191458029.png" alt="image-20220808191458029"></p>
<h2 id="对比-1"><a href="#对比-1" class="headerlink" title="对比"></a>对比</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220808191742245.png" alt="image-20220808191742245"></p>
<p><strong>注</strong>：比起早期的批处理操作系统来说，由于计算机造价大幅降低，因此之后出现的交互式操作系统（包括分时操作系统、实时操作系统等）更注重系统的响应时间、公平性、平衡性等指标。而这几种算法恰好也能较好地满足<strong>交互式系统</strong>的需求。因此这三种算法适合用于交互式系统。(比如UNIX使用的就是多级反馈队列调度算法)</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-操作系统：进程与线程"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
	
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/08/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/"
    >进程与线程</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/08/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/" class="article-date">
  <time datetime="2022-08-06T11:18:25.000Z" itemprop="datePublished">2022-08-06</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">计算机基础知识</a> / <a class="article-category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220806192727406.png" alt="image-20220806192727406"></p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul>
<li><p>程序：是<strong>静态</strong>的，就是个存放在磁盘里的可执行文件，就是一系列的指令集合。 </p>
</li>
<li><p>进程（Process）：是<strong>动态</strong>的，是程序的一次执行过程</p>
</li>
<li><p>进程是进程实体的运行过程，是系统进行资源分配的一个基本单位</p>
</li>
</ul>
<h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220806192949432.png" alt="image-20220806192949432"></p>
<ul>
<li>PCB 是给操作系统用的。 </li>
<li>程序段、数据段是给进程自己用的。</li>
</ul>
<h3 id="PCB"><a href="#PCB" class="headerlink" title="PCB"></a>PCB</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220806193448092.png" alt="image-20220806193448092"></p>
<ul>
<li><p>程序段、数据段、PCB三部分组成了进程实体</p>
</li>
<li><p>当进程被创建时，操作系统会为该进程分配一个唯一的、不重复的“身份证号”—— PID（Process ID，进程ID）</p>
</li>
</ul>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220806193256006.png" alt="image-20220806193256006"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220806193336218.png" alt="image-20220806193336218"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220806193612001.png" alt="image-20220806193612001"></p>
<h2 id="组织"><a href="#组织" class="headerlink" title="组织"></a>组织</h2><ul>
<li>在一个系统中，通常有数十、数百乃至数千个PCB。为了能对他们加以有效的管理，应该用适当的方式把这些PCB组织起来。</li>
<li>进程的组成讨论的是一个进程内部由哪些部分构成的问题，而进程的组织讨论的是多个进程之间的组织方式问题</li>
</ul>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220806194816605.png" alt="image-20220806194816605"></p>
<h3 id="链接方式"><a href="#链接方式" class="headerlink" title="链接方式"></a>链接方式</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220806194716057.png" alt="image-20220806194716057"></p>
<h3 id="索引方式"><a href="#索引方式" class="headerlink" title="索引方式"></a>索引方式</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220806194747158.png" alt="image-20220806194747158"></p>
<h2 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220806194448453.png" alt="image-20220806194448453"></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/Snipaste_2022-08-06_19-17-58.png" alt="Snipaste_2022-08-06_19-17-58"></p>
<h1 id="进程状态及转换"><a href="#进程状态及转换" class="headerlink" title="进程状态及转换"></a>进程状态及转换</h1><h2 id="三种基本状态"><a href="#三种基本状态" class="headerlink" title="三种基本状态"></a>三种基本状态</h2><ul>
<li>进程是程序的一次执行。在这个执行过程中，有时进程正在被CPU处理，有时又需要等待CPU服务，可见，进程的状态是会有各种变化。为了方便对各个进程的管理，操作系统需要将进程合理地划分为几种状态。</li>
</ul>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/2021050614465518.png" alt="img"></p>
<p><strong>注意</strong>:单核处理机环境下，每时刻最多只有一个进程处于运行态。(双核环境下可以同时有两个进程处于运行态)</p>
<p>进程已经拥有了除处理机之外所有需要的资源，一旦获得处理机，即可立即进入运行态开始运行。即:万事俱备，只欠CPU</p>
<p>如:等待操作系统分配打印机、等待读磁盘操作的结果。CPU是计算机中最昂贵的部件，为了提高CPU的利用率，需要先将其他进程需要的资源分配到位，才能得到CPU的服务</p>
<h2 id="另外两种状态"><a href="#另外两种状态" class="headerlink" title="另外两种状态"></a>另外两种状态</h2><ul>
<li><p>操作系统需要完成创建进程。操作系统为该进程分配所需的内存空间等系统资源，并为其创建、初始化PCB (如:为进程分配PID)</p>
</li>
<li><p>进程运行结束(或者由于bug导致进程无法继续执行下去，比如数组越界错误)，需要撤销进程。</p>
<blockquote>
<p>操作系统需要完成撤销进程相关的工作。完成将分配给进程的资源回收，撤销进程PCB等工作</p>
</blockquote>
</li>
</ul>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/20210506144707756.png" alt="img"></p>
<h2 id="进程状态的转换"><a href="#进程状态的转换" class="headerlink" title="进程状态的转换"></a>进程状态的转换</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220806192443300.png" alt="image-20220806192443300"></p>
<h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220806192617241.png" alt="image-20220806192617241"></p>
<h1 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h1><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220808140542016.png" alt="image-20220808140542016"></p>
<h2 id="什么是进程控制"><a href="#什么是进程控制" class="headerlink" title="什么是进程控制"></a>什么是进程控制</h2><ul>
<li>进程控制就是要<strong>实现进程状态的转换</strong></li>
</ul>
<h2 id="如何实现进程控制"><a href="#如何实现进程控制" class="headerlink" title="如何实现进程控制"></a>如何实现进程控制</h2><ul>
<li>原语是一种特殊的程序，它的执行具有<strong>原子性</strong>。也就是说，这段程序的运行必须<strong>一气呵成</strong>，不可中断。</li>
<li>为何进程控制（状态转换）的过程要“一气呵成”？<ul>
<li>如果不能“一气呵成”，就有可能导致操作系统中的某些关键数据结构信息不统一的情况， 这会影响操作系统进行别的管理工作。比如：将一个进程从阻塞 队列添加到就绪队列时，修改阻塞队列中此进程的状态为就绪态之后，应当将其从阻塞队列移 至就绪队列，如果不是一气呵成，可能出现状态为就绪态，但仍处于阻塞队列的情况。</li>
</ul>
</li>
</ul>
<h2 id="如何实现原语的“原子性”"><a href="#如何实现原语的“原子性”" class="headerlink" title="如何实现原语的“原子性”"></a>如何实现原语的“原子性”</h2><ul>
<li>用“<strong>关中断指令”和“开中断指令</strong>”这两个<strong>特权指令</strong>实现原子性</li>
</ul>
<p>  <img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220808141341956.png" alt="image-20220808141341956"></p>
<ul>
<li>正常情况：CPU每执行完一条指令都会例行检查是否有中断信号需要处理，如果有， 则暂停运行当前这段程序，转而执行相应的中断处理程序。</li>
<li>CPU执行了<strong>关中断指令</strong>之后，就<strong>不再例行检查中断信号</strong>，直到执行<strong>开中断指令</strong>之后才会恢复检查。 这样，关中断、开中断 之间的这些指令序 列就是不可被中断的，这就实现了“原子性“</li>
</ul>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220808143256314.png" alt="image-20220808143256314"></p>
<h2 id="进程控制相关的原语"><a href="#进程控制相关的原语" class="headerlink" title="进程控制相关的原语"></a>进程控制相关的原语</h2><p>无论哪种原语实现进程控制，所要做的事情有三类：</p>
<ol>
<li><p>更新PCB中的信息</p>
<ul>
<li>所有的进程控制原语一定都会<strong>修改进程状态标志</strong></li>
<li>剥夺当前运行进程的CPU使用权必然需要<strong>保存其运行环境</strong></li>
<li>某进程开始运行前必然要<strong>恢复其之前的运行环境</strong></li>
</ul>
</li>
<li><p>将PCB插入到合适的队列</p>
</li>
<li><p>分配&#x2F;回收资源</p>
</li>
</ol>
<h3 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220808142005380.png" alt="image-20220808142005380"></p>
<h3 id="进程的终止"><a href="#进程的终止" class="headerlink" title="进程的终止"></a>进程的终止</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220808142117057.png" alt="image-20220808142117057"></p>
<h3 id="进程的阻塞和唤醒"><a href="#进程的阻塞和唤醒" class="headerlink" title="进程的阻塞和唤醒"></a>进程的阻塞和唤醒</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220808142200816.png" alt="image-20220808142200816"></p>
<h3 id="进程的切换"><a href="#进程的切换" class="headerlink" title="进程的切换"></a>进程的切换</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220808142308820.png" alt="image-20220808142308820"></p>
<h3 id="程序是如何运行的"><a href="#程序是如何运行的" class="headerlink" title="程序是如何运行的"></a>程序是如何运行的</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220808142423382.png" alt="image-20220808142423382"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220808142509573.png" alt="image-20220808142509573"></p>
<blockquote>
<p>问题：执行完指令2后，另一个进程开始上CPU运行。 之后还怎么切换回之前的进程？？？？</p>
<p>注意：另一个进程在运行过程中也会使用各个寄存器</p>
</blockquote>
<p>解决办法：在进程切换时先<strong>在PCB中保存这个进程的运行环境</strong>（保存一些必要的寄存器信息），如：PSW：xxxxx，PC：指令4的地址，通用寄存器：2。当原来的进程再次投入运行时，可以通过PCB恢复它的运行环境</p>
<h2 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220808143148091.png" alt="image-20220808143148091"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220808133646367.png" alt="image-20220808133646367"></p>
<h1 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h1><h2 id="什么是进程通信"><a href="#什么是进程通信" class="headerlink" title="什么是进程通信"></a>什么是进程通信</h2><ul>
<li>进程通信就是指<strong>进程之间的信息交换</strong>。 </li>
<li>进程是分配系统资源的单位（包括内存地址空间），因此各进程拥有的<strong>内存地址空间相互独立</strong>。 </li>
<li>为了保证安全，<strong>一个进程不能直接访问另一个进程的地址空间</strong>。 但是进程之间的信息交换又是必须实现的。为了保证进程间的安全通信，操作系统提供了一些方法。</li>
</ul>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220808143558825.png" alt="image-20220808143558825"></p>
<h2 id="进程通信的方法"><a href="#进程通信的方法" class="headerlink" title="进程通信的方法"></a>进程通信的方法</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220808143421017.png" alt="image-20220808143421017"></p>
<h3 id="共享存储"><a href="#共享存储" class="headerlink" title="共享存储"></a>共享存储</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220808143756732.png" alt="image-20220808143756732"></p>
<ul>
<li>两个进程对共享空间的<strong>访问</strong>必须是<strong>互斥</strong>的（互斥访问通过操 作系统提供的工具实现）。 </li>
<li>操作系统只负责提供共享空间和同步互斥工具（如P、V操作）</li>
<li><strong>基于数据结构的共享</strong>：比如共享空间里只能放一个长度为10的数组。这种共享方式速度慢、限制多，是一种低级通信方式 </li>
<li><strong>基于存储区的共享</strong>：在内存中画出一块共享存储区，数据的形式、存放位置都由进程控制， 而不是操作系统。相比之下，这种共享方式速度更快，是一种高级通信方式。</li>
</ul>
<h3 id="管道通信"><a href="#管道通信" class="headerlink" title="管道通信"></a>管道通信</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220808143927646.png" alt="image-20220808143927646"></p>
<ol>
<li><p>管道只能采用<strong>半双工通信</strong>，某一时间段内只能实现单向的传输。如果要实现双向同时通信，则需要设置两个管道。</p>
</li>
<li><p>各进程要<strong>互斥</strong>地访问管道。</p>
</li>
<li><p>数据以字符流的形式写入管道，当<strong>管道写满</strong>时，<strong>写进程</strong>的write()系统调用将被<strong>阻塞</strong>，等待读进程将数据取走。当读进程将数据全部取走后，<strong>管道变空</strong>，此时<strong>读进程</strong>的read()系统调用将被<strong>阻塞</strong>。</p>
</li>
<li><p><strong>如果没写满，就不允许读。如果没读空，就不允许写</strong>。</p>
</li>
<li><p>数据一旦被读出，就从管道中被抛弃，这就意味着<strong>读进程最多只能有一个</strong>，否则可能会有读错数据的情况。</p>
</li>
</ol>
<h3 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a>消息传递</h3><ul>
<li>进程间的数据交换以<strong>格式化的消息（Message）</strong>为单位。进程通过操作系统提供的“发送消息&#x2F;接收消息”两个<strong>原语</strong>进行数据交换。</li>
</ul>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220808144256924.png" alt="image-20220808144256924"></p>
<h2 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220808144420304.png" alt="image-20220808144420304"></p>
<h1 id="线程、多线程"><a href="#线程、多线程" class="headerlink" title="线程、多线程"></a>线程、多线程</h1><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220808134955750.png" alt="image-20220808134955750"></p>
<h2 id="什么是线程"><a href="#什么是线程" class="headerlink" title="什么是线程"></a>什么是线程</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220808144751311.png" alt="image-20220808144751311"></p>
<h2 id="线程的特性和优点"><a href="#线程的特性和优点" class="headerlink" title="线程的特性和优点"></a>线程的特性和优点</h2><ul>
<li>进程间并发，开销很大；线程间并发，开销更小 </li>
<li><strong>引入线程机制后，并发带来的系统开销降低，系统并发性提升</strong> </li>
<li>当切换进程时，需要保存&#x2F;恢复进程运行 环境，还需要切换内 存地址空间（更新快表、更新缓存）</li>
<li>同一进程内的各个线程间并发，不需要切换进程运行环 境和内存地址空间，省时省力</li>
<li>注意：从属于不同进程的线程间切换，也会导致进程的切换！开销也大！</li>
<li>从属同一进程的各个线程共享进程拥有的资源。</li>
<li><strong>引入线程前</strong>，<strong>进程</strong>既是<strong>资源分配</strong>的基本单位，也是<strong>调度</strong>的基本单位。</li>
<li><strong>引入线程后</strong>，<strong>进程</strong>是<strong>资源分配</strong>的基本单位，<strong>线程</strong>是<strong>调度</strong>的基本单位。</li>
<li>线程也有运行态、就绪态、阻塞态 </li>
<li>在<strong>多CPU环境</strong>下，<strong>各个线程</strong>也可以分派到不同的CPU上<strong>并行</strong>地执行。 </li>
<li>引入线程后，进程是资源分配的基本单位。而<strong>线程几乎不拥有资源</strong>，只拥有极少量的资源（线程控制块TCB、寄存器信息、堆栈等）</li>
<li>传统的进程是程序 执行流的最小单位；引入线程后，线程成为了程序执行流的最小单位</li>
</ul>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220808135349863.png" alt="image-20220808135349863"></p>
<h2 id="为什么要引入线程"><a href="#为什么要引入线程" class="headerlink" title="为什么要引入线程"></a>为什么要引入线程</h2><ul>
<li>可以把线程理解为“轻量级进程”。 </li>
<li>线程是一个基本的CPU执行单元，也是程序执行流的最小单位。 </li>
<li>引入线程之后，不仅是进程之间可以并发，进程内的各线程之间也可以并发，从而进一步提升了系统的并发度，使得一个进程内也可以并发处理各种任务（如QQ视频、文字聊天、传文件） </li>
<li>引入线程后，进程只作为除CPU之外的系统资源的分配单元（如打印机、内存地址空间等都是分配给进程的）。 </li>
<li>线程则作为处理机的分配单元。</li>
</ul>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220808135303093.png" alt="image-20220808135303093"></p>
<h2 id="线程的实现方式"><a href="#线程的实现方式" class="headerlink" title="线程的实现方式"></a>线程的实现方式</h2><h3 id="用户级线程（User-Level-Thread-ULT）"><a href="#用户级线程（User-Level-Thread-ULT）" class="headerlink" title="用户级线程（User-Level Thread, ULT）"></a>用户级线程（User-Level Thread, ULT）</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220808145931303.png" alt="image-20220808145931303"></p>
<ul>
<li>用户级线程由应用程序通过线程库实现。</li>
<li>所有的<strong>线程管理工作</strong>都由<strong>应用程序</strong>负责（包括线程切换） </li>
<li>用户级线程中，<strong>线程切换</strong>可以在<strong>用户态</strong>下即可完成，无需操作系统干预。 </li>
<li>在用户看来，是有多个线程。但是在操作系统内核看来，并意识不到线程的存在。（用户级线程对用户不透明，对操作系统透明） </li>
<li>可以这样理解，<strong>“用户级线程”</strong>就是<strong>“从用户视角看能看到的线程”</strong></li>
</ul>
<h3 id="内核级线程（Kernel-Level-Thread-KLT）"><a href="#内核级线程（Kernel-Level-Thread-KLT）" class="headerlink" title="内核级线程（Kernel-Level Thread, KLT）"></a>内核级线程（Kernel-Level Thread, KLT）</h3><ul>
<li>又称“内核支持的线程”</li>
</ul>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220808150138453.png" alt="image-20220808150138453"></p>
<ul>
<li>内核级<strong>线程的管理工作</strong>由<strong>操作系统内核</strong>完成。线程调度、切换等工作都由内核负责，因此，<strong>内核级线程的切换</strong>必然需要在<strong>核心态</strong>下才能完成。 </li>
<li>可以这样理解，<strong>“内核级线程”</strong>就是<strong>“从操作系统内核视角看能看到的线程”</strong></li>
</ul>
<h3 id="组合方式"><a href="#组合方式" class="headerlink" title="组合方式"></a>组合方式</h3><ul>
<li>在同时支持用户级线程和内核级线程的系统中，可采用二者组合的方式：将n个用户级线程映射到m个内核级线程上（ <strong>n &gt;&#x3D; m</strong>）</li>
</ul>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220808150332003.png" alt="image-20220808150332003"></p>
<ul>
<li><code>重点重点重点</code>： 操作系统只“看得见”内核级线程，因此<strong>只有内核级线程才是处理机分配的单位</strong>。</li>
<li>例如：上边这个模型中，该进程由两个内核级线程，三个用户级 线程，在用户看来，这个进程中有三个线程。但即使该进程在一 个4核处理机的计算机上运行，也最多只能被分配到两个核，最多只能有两个用户线程并行执行。</li>
</ul>
<h2 id="多线程模型"><a href="#多线程模型" class="headerlink" title="多线程模型"></a>多线程模型</h2><p>在同时支持用户级线程和内核级线程的系统中，由几个用户级线程映射到几个内核级线程的问题引出了“多线程模型”问题。</p>
<h3 id="多对一"><a href="#多对一" class="headerlink" title="多对一"></a>多对一</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220808150542770.png" alt="image-20220808150542770"></p>
<ul>
<li><strong>多对一模型</strong>：多个用户及线程映射到一个内核级线程。每个用户进程只对应一个内核级线程。 </li>
<li><strong>优点</strong>：用户级线程的切换在用户空间即可完成，不需要切换到核心态，<strong>线程管理的系统开销小，效率高</strong> </li>
<li><strong>缺点</strong>：当一个用户级线程被阻塞后，整个进程都会被阻塞，<strong>并发度不高</strong>。多个线程不可在多核处理机上并行运行</li>
</ul>
<h3 id="一对一"><a href="#一对一" class="headerlink" title="一对一"></a>一对一</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220808150704659.png" alt="image-20220808150704659"></p>
<ul>
<li><strong>一对一模型</strong>：一个用户及线程映射到一个内核级线程。每个用户进程有与用户级线程同数量的内核级线程。 </li>
<li><strong>优点</strong>：当一个线程被阻塞后，别的线程还可以继续执行，<strong>并发能力强</strong>。多线程可在多核处理机上并行执行。 </li>
<li><strong>缺点</strong>：一个用户进程会占用多个内核级线程， 线程切换由操作系统内核完成，需要切换到核心态，因此<strong>线程管理的成本高，开销大</strong>。</li>
</ul>
<h3 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h3><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220808150827052.png" alt="image-20220808150827052"></p>
<ul>
<li><strong>多对多模型</strong>：n 用户及线程映射到 m 个内核级线程（n &gt;&#x3D; m）。每个用户进程对应 m 个内核级线程。 </li>
<li>克服了多对一模型并发度不高的缺点，又克服了一对一模型中一个用户进程占用太多内核级线程，开销太大的缺点。</li>
</ul>
<h2 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220808140355244.png" alt="image-20220808140355244"></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-操作系统：概念"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
	
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/08/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%9A%E6%A6%82%E5%BF%B5/"
    >概念</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/08/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%9A%E6%A6%82%E5%BF%B5/" class="article-date">
  <time datetime="2022-08-06T08:11:57.000Z" itemprop="datePublished">2022-08-06</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">计算机基础知识</a> / <a class="article-category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="操作系统的概念、功能"><a href="#操作系统的概念、功能" class="headerlink" title="操作系统的概念、功能"></a>操作系统的概念、功能</h1><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220806161631109.png" alt="image-20220806161631109"></p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul>
<li><p>系统资源的管理者：控制和<strong>管理</strong>整个计算机系统的<strong>硬件和软件</strong>资源，并合理地组织调度计算机的工作和资源的分配</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220806161651753.png" alt="image-20220806161651753"></p>
</li>
<li><p>向上层提供简便易用的服务：<strong>提供给用户和其他软件方便的接口和环境</strong></p>
</li>
<li><p>最接近硬件的一层软件：是计算机系统中最基本的<strong>系统软件</strong></p>
</li>
</ul>
<h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><ul>
<li><p>系统资源的管理者</p>
<p>执行一个程序之前<strong>需要将该程序放到内存中</strong>才能被CPU处理</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220806161816691.png" alt="image-20220806161816691"></p>
</li>
<li><p>向上层提供简便易用的服务</p>
<ul>
<li><p><strong>封装思想</strong>：操作系统把硬件封装成简便易用的服务，使得用户无需关心底层硬件的原理， 只需要对操作系统发出指令即可使用计算机</p>
</li>
<li><p><strong>GUI</strong>：图形化用户接口（Graphical	User	Interface） ，用户可以使用形象的图形界面进行操作，而不再需要记忆复杂的命令、参数。</p>
</li>
<li><p><strong>联机命令接口</strong>：交互式命令接口，用户说一句， 系统跟着做一句</p>
</li>
<li><p><strong>脱机命令接口</strong>：批处理命令接口，用户说一堆， 系统跟着做一堆</p>
</li>
<li><p><strong>程序接口</strong>：可以在程序中进行系统调用使用程序接口，普通用户不能直接使用程序接口，只能通过程序代码间接使用，比如：</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220806162535866.png" alt="程序接口"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220806162656997.png" alt="向上层提供方便易用的服务"></p>
</li>
</ul>
</li>
<li><p>最接近硬件的一层软件：</p>
<p>操作系统对硬件机器的扩展：将CPU、内存、硬盘等硬件合理的组织起来，让各种硬件能 够相互配合，实现更多复杂的功能</p>
</li>
</ul>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220806162912117.png" alt="操作系统概念、功能"></p>
<h1 id="操作系统的特征"><a href="#操作系统的特征" class="headerlink" title="操作系统的特征"></a>操作系统的特征</h1><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220806163048558.png" alt="操作系统的特征"></p>
<h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><p>指多个事件在<strong>同一时间间隔内发生</strong>，这些事件在宏观上是同时发生的，在微观上是交替发生的</p>
<p>操作系统的并发性指计算机系统中“同时”运行着多个程序，这些程序宏观上看是同时运行着的，而微观上看是交替运行的。 操作系统就是伴随着“多道程序技术”而出现的。因此，操作系统和程序并发是一起诞生的</p>
<p><strong>注意</strong>：</p>
<ol>
<li>与并行区分，<strong>并行</strong>指的是多个事件在<strong>同一时刻同时发生</strong></li>
<li><strong>单核CPU</strong>同一时刻只能执行<strong>一个程序</strong>，各个程序只能<strong>并发</strong>执行</li>
<li><strong>多核CPU</strong>同一时刻可以同时执行<strong>多个程序</strong>，多个程序可以<strong>并行</strong>执行</li>
</ol>
<h2 id="共享"><a href="#共享" class="headerlink" title="共享"></a>共享</h2><p>共享即资源共享，是指系统中的资源可供内存中多个并发执行的进程共同使用。</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220806163519018.png" alt="资源共享方式"></p>
<p>所谓的“同时”往往是宏观上的，而在微观上，这些进程可能是交替地对该资源进行访问的（即分时共享） </p>
<p><strong>生活实例</strong> </p>
<p>互斥共享方式：使用QQ和微信视频。同一时间段内摄像头只能分配给其中一个进程。 </p>
<p>同时共享方式：使用QQ发送文件A，同时使用微信发送文件B。宏观上看，两边都在同时读取并发送文件， </p>
<p>说明两个进程都在访问硬盘资源，从中读取数据。微观上看，两个进程是交替着访问硬盘的。</p>
<h3 id="并发与共享的关系"><a href="#并发与共享的关系" class="headerlink" title="并发与共享的关系"></a>并发与共享的关系</h3><p><strong>并发性</strong>指计算机系统中同时存在着多个运行着的程序。 </p>
<p><strong>共享性</strong>是指系统中的资源可供内存中多个并发执行的进程共同使用。</p>
<p><strong>实例</strong></p>
<p>使用QQ发送文件A，同时使用微信发送文件B。</p>
<ol>
<li>两个进程正在并发执行（并发性），如果失去并发性，则系统中只有一个程序正在运行，则共享性失去存在的意义</li>
<li>需要共享地访问硬盘资源（共享性），如果失去共享性，则QQ和微信不能同时访问硬盘资源，就无法实现同时发送文件，也就无法并发</li>
</ol>
<h2 id="虚拟"><a href="#虚拟" class="headerlink" title="虚拟"></a>虚拟</h2><p>虚拟是指把一个物理上的实体变为若干个逻辑上的对应物。物理实体（前者）是实际存在的，而逻辑上对应物（后者）是用户感受到的。</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220806164003431.png" alt="虚拟技术"></p>
<p>虚拟存储器技术：用户只有4G运行内存，但可以运行总内存大于4G的多个软件</p>
<p>虚拟处理器技术：单核CPU可以同时运行多个程序 (微观上交替)</p>
<p>显然，如果失去了并发性，则一个时间段内系统中只需运行一道程序，那么就失去了实现虚拟性的意义了。因此，<strong>没有并发性，就谈不上虚拟性</strong></p>
<h2 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h2><ul>
<li>异步是指，在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底的， 而是走走停停，以不可预知的速度向前推进，这就是进程的异步性。</li>
<li>如果失去了并发性，即系统只能串行地运行各个程序，那么每个程序的执行会 一贯到底。<strong>只有系统拥有并发性，才有可能导致异步性。</strong></li>
</ul>
<h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220806164258243.png" alt="操作系统的特征"></p>
<h1 id="操作系统的发展与分类"><a href="#操作系统的发展与分类" class="headerlink" title="操作系统的发展与分类"></a>操作系统的发展与分类</h1><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220806164402757.png" alt="操作系统的发展与分类"></p>
<h2 id="手工操作阶段"><a href="#手工操作阶段" class="headerlink" title="手工操作阶段"></a>手工操作阶段</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220806164557530.png" alt="image-20220806164557530"></p>
<p>主要缺点：用户独占全机、人机速度矛盾导致资源利用率极低</p>
<h2 id="单道批处理系统"><a href="#单道批处理系统" class="headerlink" title="单道批处理系统"></a>单道批处理系统</h2><p>引入脱机输入&#x2F;输出技术（用外围机+磁带完成），并由监督程序负责控制作业的输入、输出</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220806164632429.png" alt="image-20220806164632429"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220806164706687.png" alt="image-20220806164706687"></p>
<p>主要优点：缓解了一定程度的人机速度矛盾，资源利用率有所提升。 </p>
<p>主要缺点：<strong>内存中仅能有一道程序运行</strong>，只有 该程序运行结束之后才能调入下一道程序。<strong>CPU有大量的时间是在空闲等待I&#x2F;O完成</strong>。资源 利用率依然很低。</p>
<h2 id="多道批处理系统"><a href="#多道批处理系统" class="headerlink" title="多道批处理系统"></a>多道批处理系统</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220806164919195.png" alt="image-20220806164919195"></p>
<p>主要优点：多道程序<strong>并发</strong>执行，<strong>共享</strong>计算机资源。<strong>资源利用率大幅提升</strong>，CPU和其他资源更能保持“忙碌”状态，系统吞吐量增大。 </p>
<p>主要缺点：用户响应时间长，<strong>没有人机交互功能</strong>（用户提交自己的作业之后就只能等待计算机处理完成，中间不能控制自己的作业 </p>
<p>执行。eg：无法调试程序&#x2F;无法在程序运行过 程中输入一些参数）</p>
<h2 id="分时操作系统"><a href="#分时操作系统" class="headerlink" title="分时操作系统"></a>分时操作系统</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220806165023577.png" alt="image-20220806165023577"></p>
<p>分时操作系统：计算机以<strong>时间片</strong>为单位<strong>轮流为各个用户&#x2F;作业服务</strong>，各个用户可通过终端与计算机进行交互。 </p>
<p>主要优点：用户请求可以被即时响应，<strong>解决了人机交互问题</strong>。允许多个用户同时使用一台计算机，并且用户对计算机的操作相互独立，感受不到别人的存在。 </p>
<p>主要缺点：<strong>不能优先处理一些紧急任务</strong>。操作系统对各个用户&#x2F;作业都是完全公平的，循环地为每个用户&#x2F; 作业服务一个时间片，不区分任务的紧急性。</p>
<h2 id="实时操作系统"><a href="#实时操作系统" class="headerlink" title="实时操作系统"></a>实时操作系统</h2><p>主要优点：能够优先响应一些紧急任务，某些紧急任务不需时间片排队。 </p>
<p>在实时操作系统的控制下，计算机系统接收到外部信号后及时进行处理，并且<strong>要在严格的时限内处理完事件</strong>。实时操作系统的主要特点是<strong>及时性和可靠性</strong></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220806165216654.png" alt="image-20220806165216654"></p>
<h2 id="其他几种操作系统"><a href="#其他几种操作系统" class="headerlink" title="其他几种操作系统"></a>其他几种操作系统</h2><ul>
<li><strong>网络操作系统</strong>：是伴随着计算机网络的发展而诞生的，能把网络中各个计算机有机地结合起来，实现数据传送等功能，<strong>实现网络中各种资源的共享（如文件共享）和各台计算机之间的通信。</strong>（如：Windows NT 就是一种典型的网络操作系统，网站服务器就可以使用） </li>
<li><strong>分布式操作系统</strong>：主要特点是<strong>分布性和并行性</strong>。系统中的各台计算机地位相同，<strong>任何工作都可以分布在这些计算机上，由它们并行、协同完成这个任务。</strong> </li>
<li><strong>个人计算机操作系统</strong>：如 Windows XP、MacOS，方便个人使用。</li>
</ul>
<h2 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h2><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220806165424426.png" alt="image-20220806165424426"></p>
<h1 id="操作系统的运行机制、体系结构"><a href="#操作系统的运行机制、体系结构" class="headerlink" title="操作系统的运行机制、体系结构"></a>操作系统的运行机制、体系结构</h1><ul>
<li><p>指令：指的是处理器(CPU)能识别、执行的最基本命令</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/20200913123618988.png" alt="img"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/2020091312362421.png" alt="两种指令"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/2020091312364170.png" alt="两种处理器状态"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/2020091312364927.png" alt="两种程序"></p>
</li>
</ul>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220806171845507.png" alt="image-20220806171845507"></p>
<ul>
<li><p>内核：内核是计算机上的底层软件，是操作系统最基本、最核心的部分。实现内核功能的程序是<strong>内核程序</strong></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220806171143805.png" alt="image-20220806171143805"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220806171218224.png" alt="image-20220806171218224"></p>
<p><strong>注意：</strong> </p>
<p><strong>操作系统内核需要运行在内核态</strong> </p>
<p><strong>操作系统的非内核功能运行在用户态</strong></p>
</li>
</ul>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220806171637306.png" alt="image-20220806171637306"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220806172249338.png" alt="image-20220806172249338"></p>
<h1 id="中断和异常"><a href="#中断和异常" class="headerlink" title="中断和异常"></a>中断和异常</h1><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220806172332250.png" alt="image-20220806172332250"></p>
<ul>
<li>CPU 上会运行两种程序，一种是<strong>操作系统内核程序</strong>，一种是<strong>应用程序</strong>。在合适的情况下，操作系统内核会把CPU的使用权主动让给应用程序，“中断”是<strong>让操作系统内核夺回CPU使用权的唯一途径</strong></li>
<li>“中断”会使CPU由用户态变为内核态，使操作系统重新夺回对CPU的控制权</li>
<li><strong>内核态—&gt;用户态</strong>：执行一条<strong>特权指令</strong>——<strong>修改PSW</strong>的标志位为“用户态”，这个动作意味着操作系统将主动让出CPU使用权 </li>
<li><strong>用户态—&gt;内核态</strong>：由<strong>“中断”</strong>引发，<strong>硬件自动完成变态过程</strong>，触发中断信号意味着操作系统将强行夺回CPU的使用权</li>
</ul>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220806172705391.png" alt="image-20220806172705391"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220806172755699.png" alt="image-20220806172755699"></p>
<ul>
<li><p><strong>不同的中断信号，需要用不同的中断处理程序来处理。</strong>当CPU检测到中断信号后，会根据中断信号的类型去查询“<strong>中断向量表</strong>”，以此来找到相应的中断处理程序在内存中的存放位置。</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220806173055778.png" alt="image-20220806173055778"></p>
</li>
</ul>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/Snipaste_2022-08-06_16-10-28.png" alt="Snipaste_2022-08-06_16-10-28"></p>
<h1 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h1><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220806174228278.png" alt="image-20220806174228278"></p>
<ul>
<li><p>操作系统作为用户和计算机硬件之间的接口，需要向上提供一些简单易用的服务。主要包括命令接口和程序接口。其中，程序接口由一组<strong>系统调用</strong>组成。</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220806174344900.png" alt="image-20220806174344900"></p>
</li>
<li><p>“系统调用”是操作系统提供给应用程序（程序员&#x2F;编程人员）使用的接口，可以理解为一种可供应用程序调用的特殊函数，<strong>应用程序可以通过系统调用来请求获得操作系统内核的服务</strong></p>
</li>
</ul>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220806174446993.png" alt="image-20220806174446993"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220806174507152.png" alt="image-20220806174507152"></p>
<ul>
<li>应用程序通过<strong>系统调用</strong>请求操作系统的服务。而系统中的各种共享资源都由操作系统内核统一掌管，因此<strong>凡是与共享资源有关的操作（如存储分配、I&#x2F;O操作、文件管理等），都必须通过系统调用的方式向操作系统内核提出服务请求</strong>，由操作系统内核代为完成。这样<strong>可以保证系统的稳定性和安全性</strong>，防止用户进行非法操作。</li>
</ul>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220806174609798.png" alt="image-20220806174609798"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220806173929506.png" alt="image-20220806173929506"></p>
<ul>
<li>传递系统调用参数—&gt;执行陷入指令（<strong>用户态</strong>）—&gt;执行相应的内请求核程序处理系统调用（<strong>核心态</strong>）—&gt;返回应用程序 </li>
<li>注意<ol>
<li><strong>陷入指令</strong>是在<strong>用户态</strong>执行的，执行陷入指令之后立即引发一个<strong>内中断</strong>，使CPU<strong>进入核心态</strong></li>
<li><strong>发出系统调用请求</strong>是在<strong>用户态</strong>，而<strong>对系统调用的相应处理在核心态</strong>下进行</li>
</ol>
</li>
</ul>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220806174206287.png" alt="image-20220806174206287"></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-数据库：mysql索引"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
	
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/08/05/%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%9Amysql%E7%B4%A2%E5%BC%95/"
    >mysql索引</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/08/05/%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%9Amysql%E7%B4%A2%E5%BC%95/" class="article-date">
  <time datetime="2022-08-05T10:53:26.000Z" itemprop="datePublished">2022-08-05</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a> / <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/">mysql</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h1><h2 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h2><p>程序和数据的访问都有聚集成群的倾向，在一个时间段内，仅使用其中一小部分，称为<strong>空间局部性</strong></p>
<p>最经访问过的程序代码和数据，很快又被访问的可能性很大，称为<strong>时间局部性</strong></p>
<h2 id="磁盘预读"><a href="#磁盘预读" class="headerlink" title="磁盘预读"></a>磁盘预读</h2><ul>
<li>预读的长度一般为页（page）的整数倍</li>
<li>页是存储器的逻辑块，操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，页大小通常为4K），主存和磁盘以页为单位交换数据</li>
<li>考虑到磁盘IO是非常高昂的操作，计算机操作系统做了一些优化，<strong>当一次IO时，不光把当前磁盘地址的数据，而是把相邻的数据也都读取到内存缓冲区内</strong>，因为局部预读性原理告诉我们，当计算机访问一个地址的数据的时候，与其相邻的数据也会很快被访问到。每一次IO读取的数据我们称之为一页(page)。具体一页有多大数据跟操作系统有关，一般为4k或8k，也就是我们读取一页内的数据时候，实际上才发生了一次IO，这个理论对于索引的数据结构设计非常有帮助。</li>
</ul>
<h1 id="索引概述"><a href="#索引概述" class="headerlink" title="索引概述"></a>索引概述</h1><ul>
<li><p>MySql官方对索引的定义为：<strong>索引是帮助MySql高效获取数据的数据结构</strong>。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用数据，这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引。</p>
</li>
<li><p>索引存储在文件系统中</p>
</li>
<li><p>索引的文件存储形式与存储引擎有关</p>
</li>
<li><p>索引文件的结构：B+树</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/mysql%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%80%89%E6%8B%A9.jpg" alt="mysql数据结构选择"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/mysql%E7%B4%A2%E5%BC%95%E7%B3%BB%E7%BB%9F.jpg" alt="mysql索引系统"></p>
</li>
</ul>
<h1 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a>索引的分类</h1><p>通过给字段添加索引可以提高数据的读取速度，提高项目的并发能力和抗压能力</p>
<ul>
<li><p>普通索引</p>
<ul>
<li><p>基本的索引类型，值可以为空，没有唯一性的限制</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-- 创建索引的第一种方式</span><br><span class="line">CREATE INDEX idx_nickname ON account(nickname); </span><br><span class="line"></span><br><span class="line">-- 创建索引的第二种方式(不常用)</span><br><span class="line">ALTER TABLE account ADD INDEX idx_nickname1(nickname);</span><br><span class="line"></span><br><span class="line">-- 创建索引的第三种方式</span><br><span class="line">CREATE TABLE u1(nickname VARCHAR(64),age TINYINT UNSIGNED,KEY idx_nickname(nickname));</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>主键索引</p>
<ul>
<li><p>一种唯一性索引，但它必须指定为PRIMARY KEY，每个表只能有一个主键</p>
</li>
<li><p>主键索引的列的数据非空,唯一的</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 声明为主键的列就是自动添加主键索引</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> u1(id <span class="type">INT</span> ,nickname <span class="type">VARCHAR</span>(<span class="number">64</span>),age TINYINT UNSIGNED,<span class="keyword">PRIMARY</span> KEY(id));</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>唯一索引</p>
<ul>
<li><p>索引列的值都只能出现一次，即值必须唯一，值可以为空</p>
</li>
<li><p>如果一列被约束为<code>UNIQUE</code>,则在这一列默认添加唯一索引</p>
</li>
<li><p>添加唯一索引的列可以为<code>NULL</code>值,这也是和主键索引,不同的地方</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建索引的第一种方式</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> INDEX uk_nickname <span class="keyword">ON</span> u1(nickname); </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建表时创建唯一索引</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> u1 (</span><br><span class="line">  id <span class="type">INT</span>,</span><br><span class="line">  nickname <span class="type">VARCHAR</span> (<span class="number">64</span>) ,</span><br><span class="line">  age TINYINT UNSIGNED,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (id),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY uk_nickname(nickname) </span><br><span class="line">) ;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>全文索引</p>
<blockquote>
<p>全文索引,通过建立<code>倒排索引</code>,可以提高数据的检索效率,解决判断字段中 <code>是否包含</code> 的问题;</p>
</blockquote>
<ul>
<li><p>索引类型为FULLTEXT。全文索引在varchar、char、text类型的列上创建</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 我们已经给nickname字段添加了普通索引</span></span><br><span class="line"><span class="comment">-- 会使用索引</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> account <span class="keyword">WHERE</span> nickname<span class="operator">=</span><span class="string">&#x27;小明&#x27;</span>;</span><br><span class="line"><span class="comment">-- 会使用索引</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> account <span class="keyword">WHERE</span> nickname <span class="keyword">LIKE</span> <span class="string">&#x27;小明%&#x27;</span>;</span><br><span class="line"><span class="comment">-- 不会使用索引</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> account <span class="keyword">WHERE</span> nickname <span class="keyword">LIKE</span> <span class="string">&#x27;%小明%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>不使用到索引我们如果进行大规模数据检索时,效率会大大的降低,所以前面我们说过 <code>我们只在简单业务或者数据量小的时候才考虑使用like关键字</code>;</p>
<blockquote>
<p>全文索引注意的地方:</p>
</blockquote>
<ul>
<li><p>mysql5.6以前,只有<code>MYISAM</code>存储引擎支持全文索引</p>
</li>
<li><p>在5.6中<code>INNODB</code>存储引擎加入了对全文索引的支持,<strong>但是只支持英文的全文索引,不支持中文的全文索引</strong></p>
</li>
<li><p><strong>在5.7.6中,mysql内置了<code>ngram</code>分词器,用来支持中文;</strong></p>
</li>
</ul>
<blockquote>
<p>配置ngram分词的最小长度:      </p>
</blockquote>
<p>默认长度为2,当然我们也可以设置成1,但是设置成1的话就会浪费大量的空间,不是很好,<code>mysql建议我们配置为2</code>;</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">ngram分词器对分词最小长度(也就是说分词器,分词的时候最小也是两个词一分)</span></span><br><span class="line">[mysqld]</span><br><span class="line">ft_min_word_len=2</span><br></pre></td></tr></table></figure>

<blockquote>
<p>创建全文索引</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建索引的第一种方式</span></span><br><span class="line"><span class="keyword">CREATE</span> FULLTEXT INDEX ft_nickname <span class="keyword">ON</span> account(nickname) <span class="keyword">WITH</span> PARSER ngram ; </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建索引的第二种方式(不常用)</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> account <span class="keyword">ADD</span> FULLTEXT INDEX ft_nickname(nickname) <span class="keyword">WITH</span> PARSER ngram;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建索引的第三种方式</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> u1(nickname <span class="type">VARCHAR</span>(<span class="number">64</span>),age TINYINT UNSIGNED,FULLTEXT KEY ft_nickname(nickname) <span class="keyword">WITH</span> PARSER ngram );</span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用全文索引</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> account <span class="keyword">WHERE</span> <span class="keyword">MATCH</span>(nickname) AGAINST(&quot;你觉得华为笔记本合小米手机哪个好&quot;);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>match</code>中的字段和创建全文建索引时的字段<strong>必须一致</strong>;</li>
</ul>
<blockquote>
<p>全文索引的检索流程</p>
</blockquote>
<p>用户输入词—&gt;sql执行引擎—&gt;<code>ngram</code>分词器对用户输入的词进行分词(配置了最小的分词个数)—&gt;把分词器分的词依次的去倒排索引中去查找,找出相应的记录返回;</p>
</li>
</ul>
</li>
<li><p>组合索引</p>
<ul>
<li><p>多列值组成一个索引，专门用于组合搜索</p>
</li>
<li><p><strong>包含多个字段的索引</strong>称为组合索引;</p>
<blockquote>
<p>组合索引包含</p>
</blockquote>
<ul>
<li>组合普通索引</li>
<li>组合主键索引</li>
<li>组合唯一索引</li>
<li>组合全文索引</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建复合索引时必须指定索引的名称,不能省略</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX mu_title_content <span class="keyword">ON</span> article(title,content,publish_time);</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> article <span class="keyword">WHERE</span> title <span class="keyword">LIKE</span> <span class="string">&#x27;小米%&#x27;</span>; <span class="comment">-- 使用到索引</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> article <span class="keyword">WHERE</span> title <span class="keyword">LIKE</span> <span class="string">&#x27;小米%&#x27;</span> <span class="keyword">AND</span> content <span class="keyword">LIKE</span> <span class="string">&#x27;小米%&#x27;</span>; <span class="comment">-- 使用了索引</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> article <span class="keyword">WHERE</span>  content <span class="keyword">LIKE</span> <span class="string">&#x27;小米%&#x27;</span>; <span class="comment">-- 没有索引</span></span><br></pre></td></tr></table></figure>

<p><strong>建议多列索引的列不要超过2个列</strong></p>
<ul>
<li><p>以上这个复合索引相当于建立了这3个索引</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(title),(title,content),(title,content,publish_time)</span><br></pre></td></tr></table></figure>
</li>
<li><p>多列索引遵循<strong>最左前缀</strong>的原则</p>
</li>
<li><p>多列索引在创建的时候,如果其中有字段时<code>TEXT</code>或<code>BLOB</code>类型,就必须指定索引的长度;</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="MySQL存储引擎"><a href="#MySQL存储引擎" class="headerlink" title="MySQL存储引擎"></a>MySQL存储引擎</h1><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">MyISAM</th>
<th align="center">InnoDB</th>
</tr>
</thead>
<tbody><tr>
<td align="center">索引类型</td>
<td align="center">非聚簇索引</td>
<td align="center">聚簇索引</td>
</tr>
<tr>
<td align="center">支持事务</td>
<td align="center">否</td>
<td align="center">是</td>
</tr>
<tr>
<td align="center">支持表锁</td>
<td align="center">是</td>
<td align="center">是</td>
</tr>
<tr>
<td align="center">支持行锁</td>
<td align="center">否</td>
<td align="center">是</td>
</tr>
<tr>
<td align="center">支持外键</td>
<td align="center">否</td>
<td align="center">是</td>
</tr>
<tr>
<td align="center">支持全文索引</td>
<td align="center">是</td>
<td align="center">是</td>
</tr>
<tr>
<td align="center">适合操作类型</td>
<td align="center">大量select</td>
<td align="center">大量insert、delete、updata</td>
</tr>
</tbody></table>
<h1 id="索引优化-基本知识"><a href="#索引优化-基本知识" class="headerlink" title="索引优化-基本知识"></a>索引优化-基本知识</h1><p><strong>原因</strong>：</p>
<ul>
<li>索引在MySQL中也叫做“键”，是存储引擎用于快速找到记录的一种数据结构。索引对于良好的性能非常关键，尤其是当表中的数据量越来越大时，索引对于性能的影响愈发重要。索引优化应该是对查询性能优化最有效的手段了。索引能够轻易将查询性能提高好几个数量级。索引相当于字典的音序表，如果要查某个字，如果不使用音序表，则需要从几百页中逐页去查。</li>
</ul>
<p><strong>优点</strong>：</p>
<ul>
<li>使用主键索引或者唯一索引,可以保证数据库中的表的数据是唯一</li>
<li><strong>通过建立索引可以大大的提高数据检索的效率,减少表扫描的行数(避免进行全表扫描)</strong></li>
<li>我们在进行多表连接的时候,可以使用索引加速表之间的连接</li>
</ul>
<hr>
<p><strong>缺点</strong>：</p>
<ul>
<li>在创建索引和维护索引时都需要耗费时间;</li>
<li>索引文件会占用物理存储空间,除了表的数据占用一部分空间,索引文件也会占用一部分空间;</li>
<li><strong>设置为<code>text</code>和<code>blob</code>类型的字段强烈不建议添加索引</strong></li>
</ul>
<h1 id="索引优化-联合索引"><a href="#索引优化-联合索引" class="headerlink" title="索引优化-联合索引"></a>索引优化-联合索引</h1><p><strong>回表</strong>：</p>
<ul>
<li>在InnoDB存储引擎下，二级索引查询到的索引列，如果需要查找所有列的数据，则需要到主键索引里面去取出数据。这个过程就称为回表。因为行的数据都是存在主键B+tree的叶子节点里面，二级索引的B+树叶子节点都是存放的(索引列,主键)。</li>
</ul>
<p><strong>覆盖索引</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">select * from s1 where id=123;</span><br><span class="line">该sql命中了索引，但未覆盖索引。</span><br><span class="line">利用id=123到索引的数据结构中定位到该id在硬盘中的位置，或者说再数据表中的位置。</span><br><span class="line">但是我们select的字段为*，除了id以外还需要其他字段，这就意味着，我们通过索引结构取到id还不够，</span><br><span class="line">还需要利用该id再去找到该id所在行的其他字段值，这是需要时间的，很明显，如果我们只select id，</span><br><span class="line">就减去了这份苦恼，如下</span><br><span class="line">select id from s1 where id=123;</span><br><span class="line">这条就是覆盖索引了，命中索引，且从索引的数据结构直接就取到了id在硬盘的地址，速度很快</span><br></pre></td></tr></table></figure>

<p><strong>最左匹配</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">create index ix_name_email on s1(name,email,)</span><br><span class="line">- 最左前缀匹配：必须按照从左到右的顺序匹配</span><br><span class="line">select * from s1 where name=&#x27;egon&#x27;; #可以</span><br><span class="line">select * from s1 where name=&#x27;egon&#x27; and email=&#x27;asdf&#x27;; #可以</span><br><span class="line">select * from s1 where email=&#x27;alex@oldboy.com&#x27;; #不可以</span><br><span class="line">select * from s1 where email=&#x27;asdf&#x27; and  name=&#x27;egon&#x27;; #可以</span><br><span class="line">mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，</span><br><span class="line">比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，</span><br><span class="line">d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。</span><br></pre></td></tr></table></figure>

<p><strong>索引下推</strong>：</p>
<ul>
<li><p>索引条件下推(Index Condition Pushdown),简称ICP。MySQL5.6新添加，用于优化数据的查询。</p>
</li>
<li><p>当你不使用ICP,通过使用非主键索引（普通索引or二级索引）进行查询，存储引擎通过索引检索数据，然后返回给MySQL服务器，服务器再判断是否符合条件。</p>
</li>
<li><p>使用ICP，当存在索引的列做为判断条件时，MySQL服务器将这一部分判断条件传递给存储引擎，然后存储引擎通过判断索引是否符合MySQL服务器传递的条件，只有当索引符合条件时才会将数据检索出来返回给MySQL服务器。</p>
</li>
<li><p>示例</p>
<ul>
<li><p>当我们创建一个用户表(userinfo),其中有字段：id,name,age,addr。我们将name,age建立联合索引。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当我们执行：select * from userinfo where name like &quot;ming%&quot; and age=20;</span><br></pre></td></tr></table></figure>
</li>
<li><p>对于MySQL5.6之前：我们在索引内部首先通过name进行查找，在联合索引name,，age树形查询结果可能存在多个，然后再拿着id值去回表查询，整个过程需要回表多次。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi8xMC8xNmVlZDY2N2YzOGZkM2Vl?x-oss-process=image/format,png" alt="img"></p>
</li>
<li><p>对于MySQL5.6之后：我们是在索引内部就判断age是否等于20，对于不等于20跳过。因此在联合索引name,age索引树只匹配一个记录，此时拿着这个id去主键索引树种回表查询全部数据，整个过程就回一次表。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8xMi8xMC8xNmVlZDY2YWUwZDI2OThh?x-oss-process=image/format,png" alt="img"></p>
</li>
<li><p>如下：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/53e290c6646dca211a8f214e11bfe7b5.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当Extra值为：Using index condition.表示使用索引下推。</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过索引下推对于非主键索引进行优化，<strong>可有效减少回表次数</strong>，从而提高效率。</p>
</li>
<li><p>关闭索引下推命令</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> optimizer_switch=<span class="string">&#x27;index_condition_pushdown=off&#x27;</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h1 id="索引优化-聚簇索引与非聚簇索引"><a href="#索引优化-聚簇索引与非聚簇索引" class="headerlink" title="索引优化-聚簇索引与非聚簇索引"></a>索引优化-聚簇索引与非聚簇索引</h1><ul>
<li><p>聚簇(集)索引的叶子节点就是数据节点。</p>
</li>
<li><p>非聚簇(集)索引的叶子节点仍然是索引节点，只不过有指向对应数据块的指针。非聚簇(集)索引在innodb引擎中，又叫做二级索引，辅助索引等。</p>
</li>
<li><p>聚簇索引并不是一种单独的索引类型，而是一种数据存储方式。术语‘聚簇’表示数据行和相邻的键值聚簇的存储在一起。如下图，左侧的索引就是聚簇索引，因为数据行在磁盘的排列和索引排序保持一致。、</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/20210509163323414.png" alt="img"></p>
</li>
</ul>
<p><strong>聚集索引（聚簇索引）</strong></p>
<p>以 InnoDB 作为存储引擎的表，表中的数据都会有一个主键，即使你不创建主键，系统也会帮你创建一个隐式的主键。</p>
<p>这是因为 InnoDB 是把数据存放在 B+ 树中的，而 B+ 树的键值就是主键，在 B+ 树的叶子节点中，存储了表中所有的数据。</p>
<p>这种以主键作为 B+ 树索引的键值而构建的 B+ 树索引，我们称之为聚集索引。</p>
<p><strong>非聚集索引（非聚簇索引）</strong></p>
<p>以主键以外的列值作为键值构建的 B+树索引，我们称之为非聚集索引。</p>
<p><strong>非聚集索引与聚集索引的区别在于</strong></p>
<p>非聚集索引的叶子节点不存储表中的数据，而是存储该列对应的主键，想要查找数据我们还需要根据主键再去聚集索引中进行查找，这个再根据聚集索引查找数据的过程，我们称为回表。</p>
<p>明白了聚集索引和非聚集索引的定义，我们应该明白这样一句话：<strong>数据即索引，索引即数据</strong>。</p>
<p><strong>聚簇索引的好处</strong>：</p>
<p>按照聚簇索引排列顺序，查询显示一定范围数据的时候，由于数据都是紧密相连，数据库不用从多个数据块中提取数据，所以节省了大量的io操作。</p>
<p><strong>聚簇索引的限制</strong>：</p>
<p>对于mysql 数据库目前只有innodb 数据引擎支持聚簇索引，而Myisam 并不支持聚簇索引。由于数据物理存储排序方式只能有一种，所以每个Mysql 的表只能有一个聚簇索引。一般情况下就是该表的主键。</p>
<p>为了充分利用聚簇索引的聚簇的特性，所以innodb 表的主键列尽量选用有序的顺序id，而不建议用无序的id，比如uuid 这种。</p>
<h1 id="优化细节"><a href="#优化细节" class="headerlink" title="优化细节"></a>优化细节</h1><ol>
<li><p>对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。</p>
</li>
<li><p>应尽量避免在 where 子句中使用!&#x3D;或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描。</p>
</li>
<li><p>应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id from t where num is null </span><br></pre></td></tr></table></figure>

<p>可以在num上设置默认值0，确保表中num列没有null值，然后这样查询：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id from t where num=0 </span><br></pre></td></tr></table></figure>
</li>
<li><p>应尽量避免在 where 子句中使用 or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id from t where num=10 or num=20 </span><br></pre></td></tr></table></figure>

<p> 可以这样查询：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select id from t where num=10 </span><br><span class="line">union all </span><br><span class="line">select id from t where num=20 </span><br></pre></td></tr></table></figure>
</li>
<li><p>下面的查询也将导致全表扫描：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id from t where name like &#x27;%abc%&#x27; </span><br></pre></td></tr></table></figure>

<p>  若要提高效率，可以考虑全文检索。</p>
</li>
<li><p>in 和 not in 也要慎用，否则会导致全表扫描，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id from t where num in(1,2,3) </span><br></pre></td></tr></table></figure>

<p>对于连续的数值，能用 between 就不要用 in 了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id from t where num between 1 and 3 </span><br></pre></td></tr></table></figure>
</li>
<li><p>如果在 where 子句中使用参数，也会导致全表扫描。因为SQL只有在运行时才会解析局部变量，但优化程序不能将访问计划的选择推迟到运行时；它必须在编译时进行选择。然而，如果在编译时建立访问计划，变量的值还是未知的，因而无法作为索引选择的输入项。如下面语句将进行全表扫描：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id from t where num=@num </span><br></pre></td></tr></table></figure>

<p> 可以改为强制查询使用索引：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id from t with(index(索引名)) where num=@num </span><br></pre></td></tr></table></figure>
</li>
<li><p>应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id from t where num/2=100 </span><br></pre></td></tr></table></figure>

<p>应改为:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id from t where num=100*2 </span><br></pre></td></tr></table></figure>
</li>
<li><p>应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select id from t where substring(name,1,3)=&#x27;abc&#x27;--name以abc开头的id </span><br><span class="line">select id from t where datediff(day,createdate,&#x27;2005-11-30&#x27;)=0--&#x27;2005-11-30&#x27;生成的id </span><br></pre></td></tr></table></figure>

<p>应改为:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select id from t where name like &#x27;abc%&#x27; </span><br><span class="line">select id from t where createdate&gt;=&#x27;2005-11-30&#x27; and createdate&lt;&#x27;2005-12-1&#x27; </span><br></pre></td></tr></table></figure>
</li>
<li><p>不要在 where 子句中的“&#x3D;”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。</p>
</li>
<li><p>在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使用，并且应尽可能的让字段顺序与索引顺序相一致。</p>
</li>
<li><p>不要写一些没有意义的查询，如需要生成一个空表结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select col1,col2 into #t from t where 1=0 </span><br></pre></td></tr></table></figure>

<p>这类代码不会返回任何结果集，但是会消耗系统资源的，应改成这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create table #t(...) </span><br></pre></td></tr></table></figure>
</li>
<li><p>很多时候用 exists 代替 in 是一个好的选择：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select num from a where num in(select num from b) </span><br></pre></td></tr></table></figure>

<p>用下面的语句替换：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select num from a where exists(select 1 from b where num=a.num) </span><br></pre></td></tr></table></figure>
</li>
<li><p>并不是所有索引对查询都有效，SQL是根据表中数据来进行查询优化的，当索引列有大量数据重复时，SQL查询可能不会去利用索引，如一表中有字段sex，male、female几乎各一半，那么即使在sex上建了索引也对查询效率起不了作用。</p>
</li>
<li><p>索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有必要。</p>
</li>
<li><p>应尽可能的避免更新 clustered 索引数据列，因为 clustered 索引数据列的顺序就是表记录的物理存储顺序，一旦该列值改变将导致整个表记录的顺序的调整，会耗费相当大的资源。若应用系统需要频繁更新 clustered 索引数据列，那么需要考虑是否应将该索引建为 clustered 索引。</p>
</li>
<li><p>尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。这是因为引擎在处理查询和连接时会逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。</p>
</li>
<li><p>尽可能的使用 varchar&#x2F;nvarchar 代替 char&#x2F;nchar ，因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。</p>
</li>
<li><p>任何地方都不要使用 select * from t ，用具体的字段列表代替“*”，不要返回用不到的任何字段。</p>
</li>
<li><p>尽量使用表变量来代替临时表。如果表变量包含大量数据，请注意索引非常有限（只有主键索引）。</p>
</li>
<li><p>避免频繁创建和删除临时表，以减少系统表资源的消耗。</p>
</li>
<li><p>临时表并不是不可使用，适当地使用它们可以使某些例程更有效，例如，当需要重复引用大型表或常用表中的某个数据集时。但是，对于一次性事件，最好使用导出表。</p>
</li>
<li><p>在新建临时表时，如果一次性插入数据量很大，那么可以使用 select into 代替 create table，避免造成大量 log ，以提高速度；如果数据量不大，为了缓和系统表的资源，应先create table，然后insert。</p>
</li>
<li><p>如果使用到了临时表，在存储过程的最后务必将所有的临时表显式删除，先 truncate table ，然后 drop table ，这样可以避免系统表的较长时间锁定。</p>
</li>
<li><p>尽量避免使用游标，因为游标的效率较差，如果游标操作的数据超过1万行，那么就应该考虑改写。</p>
</li>
<li><p>使用基于游标的方法或临时表方法之前，应先寻找基于集的解决方案来解决问题，基于集的方法通常更有效。</p>
</li>
<li><p>与临时表一样，游标并不是不可使用。对小型数据集使用 FAST_FORWARD 游标通常要优于其他逐行处理方法，尤其是在必须引用几个表才能获得所需的数据时。在结果集中包括“合计”的例程通常要比使用游标执行的速度快。如果开发时间允许，基于游标的方法和基于集的方法都可以尝试一下，看哪一种方法的效果更好。</p>
</li>
<li><p>在所有的存储过程和触发器的开始处设置 SET NOCOUNT ON ，在结束时设置 SET NOCOUNT OFF 。无需在执行存储过程和触发器的每个语句后向客户端发送 DONE_IN_PROC 消息。</p>
</li>
<li><p>尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理。</p>
</li>
<li><p>尽量避免大事务操作，提高系统并发能力。</p>
</li>
</ol>
<h1 id="B-树添加和删除数据"><a href="#B-树添加和删除数据" class="headerlink" title="B+树添加和删除数据"></a>B+树添加和删除数据</h1><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/%E6%A0%91%E6%B7%BB%E5%8A%A0%E5%92%8C%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE%E5%9B%BE%E8%A7%A3.png" alt="B+树添加和删除数据图解"></p>
<h1 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h1><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/%E7%BA%A2%E9%BB%91%E6%A0%91%20(1).jpg" alt="红黑树"></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-数据库：mysql锁"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
	
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/08/05/%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%9Amysql%E9%94%81/"
    >mysql锁</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/08/05/%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%9Amysql%E9%94%81/" class="article-date">
  <time datetime="2022-08-05T07:55:12.000Z" itemprop="datePublished">2022-08-05</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a> / <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/">mysql</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="锁机制"><a href="#锁机制" class="headerlink" title="锁机制"></a>锁机制</h1><ul>
<li>事务与锁是不同的。事务具有ACID( 原子性、一致性、隔离性和持久性)，锁是用于<strong>解决隔离级别</strong>的一种机制。事务的隔离级别通过锁的机制来实现。</li>
<li>为了保证数据并发访问时的<strong>一致性和有效性</strong>，任何一个数据库都存在锁机制。锁机制的优劣直接影响到数据库的并发处理能力和系统性能，所以锁机制也就成为了各种数据库的核心技术之一。</li>
<li>锁机制是为了解决数据库的并发控制问题而产生的。如在同一时刻，客户端对同一个表做更新或查询操作，为了保证数据的一致性，必须对并发操作进行控制。同时，锁机制也为实现 MySQL 的各个隔离级别提供了保证。</li>
<li>可以将锁机制理解为使各种资源在被并发访问时变得有序所设计的一种规则。</li>
<li>如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。从这个角度来说，锁对数据库显得尤其重要，也更加复杂。</li>
</ul>
<h1 id="锁分类"><a href="#锁分类" class="headerlink" title="锁分类"></a>锁分类</h1><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/7d4abdeb78b66d9ba4110d54beec4855.png" alt="img"></p>
<ol>
<li>按照锁的粒度划分：<strong>行锁、表锁、页锁</strong></li>
<li>按照锁的使用方式划分：<strong>共享锁、排它锁</strong>（悲观锁的一种实现）</li>
<li>还有两种思想上的锁：<strong>悲观锁、乐观锁</strong>。</li>
<li>InnoDB中有几种行级锁类型：Record Lock、Gap Lock、Next-key Lock</li>
<li>按<strong>锁级别分类，可分为共享锁、排他锁和意向锁。</strong></li>
</ol>
<p>MySQL的锁机制最显著的特点是不同的存储引擎支持不同的锁机制。比如，MyISAM和MEMORY存储引擎采用的是表级锁，<strong>不支持行锁</strong>；BDB存储引擎采用的是页面锁，但也支持表级锁；InnoDB存储引擎既支持行级锁，也支持表级锁，但默认情况下是采用<strong>行级锁</strong>。不支持行锁意味着并发控制只能使用表锁，对于这种引擎的表，同 一张表上任何时刻只能有一个更新在执行，这就会影响到业务并发度。<strong>InnoDB是支持行锁的， 这也是MyISAM被InnoDB替代的重要原因之一。</strong></p>
<h1 id="行锁（row-level-locking）"><a href="#行锁（row-level-locking）" class="headerlink" title="行锁（row-level locking）"></a>行锁（row-level locking）</h1><ul>
<li>行级锁的锁定颗粒度在 MySQL 中是最小的，<strong>只针对操作的当前行进行加锁</strong>，所以<strong>行级锁发生锁定资源争用的概率也最小</strong>。</li>
<li>行级锁能够给予应用程序尽可能大的并发处理能力，从而提高需要高并发应用系统的整体性能。虽然行级锁在并发处理能力上面有较大的优势，但也因此带来了不少弊端。</li>
<li><strong>由于锁定资源的颗粒度很小，所以每次获取锁和释放锁需要做的事情也就更多，带来的消耗自然也就更大。</strong>此外，<strong>行级锁也最容易发生死锁</strong>。所以说<strong>行级锁最大程度地支持并发处理的同时，也带来了最大的锁开销</strong>。</li>
<li>行级锁主要应用于 <strong>InnoDB 存储引擎</strong>。</li>
<li><strong>随着锁定资源颗粒度的减小，锁定相同数据量的数据所需要消耗的内存数量也越来越多，实现算法也会越来越复杂。不过，随着锁定资源颗粒度的减小，应用程序的访问请求遇到锁等待的可能性也会随之降低，系统整体并发度也会随之提升。</strong></li>
<li><strong>行级锁按照使用方式分为共享锁和排他锁。</strong></li>
</ul>
<h1 id="表锁（table-level-locking）"><a href="#表锁（table-level-locking）" class="headerlink" title="表锁（table-level locking）"></a>表锁（table-level locking）</h1><ul>
<li>表级锁为表级别的锁定，会锁定整张表，<strong>可以很好的避免死锁</strong>，是 MySQL 中最大颗粒度的锁定机制。</li>
<li>一个用户在对表进行写操作(插入、删除、更新等)时，需要先获得写锁(也叫排斥锁)，这会阻塞其它用户对该表的所有读写操作。没有写锁时，其它读取的用户才能获得读锁，读锁之间是不相互阻塞的。</li>
<li>表级锁最大的特点就是<strong>实现逻辑非常简单，带来的系统负面影响最小</strong>。所以获取锁和释放锁的速度很快。当然，锁定颗粒度大带来最大的负面影响就是<strong>出现锁定资源争用的概率会很高</strong>，致使并发度大打折扣。</li>
<li>不过在某些特定的场景中，表级锁也可以有良好的性能。例如，READ LOCAL 表级锁支持某些类型的并发写操作。另外，写锁也比读锁有更高的优先级，因此一个写锁请求可能会被插入到读锁队列的前面(写锁可以插入到锁队列中读锁的前面，反之读锁则不能插入到写锁的前面)。</li>
<li>使用表级锁的主要是 MyISAM，MEMORY，CSV 等一些非事务性存储引擎。</li>
<li>尽管存储引擎可以管理自己的锁，MySQL 本身还是会使用各种有效的表级锁来实现不同的目的。例如，服务器会为诸如 ALTER TABLE 之类的语句使用表级锁，而忽略存储引擎的锁机制。</li>
</ul>
<h1 id="页锁（page-level-locking）"><a href="#页锁（page-level-locking）" class="headerlink" title="页锁（page-level locking）"></a>页锁（page-level locking）</h1><ul>
<li>页级锁是 MySQL 中比较独特的一种锁定级别，在其他数据库管理软件中并不常见。</li>
<li>页级锁的颗粒度<strong>介于行级锁与表级锁之间</strong>，所以获取锁定所需要的资源开销，以及所能提供的并发处理能力同样也是介于上面二者之间。另外，页级锁和行级锁一样，会发生死锁。</li>
<li>页级锁主要应用于 BDB 存储引擎。</li>
</ul>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/78c7b27c7fd257f074da21aef869b491.png" alt="img"></p>
<h1 id="共享锁（Shared-Lock）"><a href="#共享锁（Shared-Lock）" class="headerlink" title="共享锁（Shared Lock）"></a>共享锁（Shared Lock）</h1><ul>
<li><p>共享锁的代号是 <code>S</code>，是 <code>Share</code> 的缩写，也可称为<strong>读锁</strong>。是一种<strong>可以查看但无法修改和删除的数据锁</strong>。</p>
</li>
<li><p><strong>共享锁的锁粒度是行或者元组(多个行)<strong>。</strong>一个事务获取了共享锁之后，可以对锁定范围内的数据执行读操作。会阻止其它事务获得相同数据集的排他锁。</strong></p>
</li>
<li><p><strong>加锁方式</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 行级读锁</span><br><span class="line">select * from T where id=1 lock in share mode;</span><br><span class="line">-- 表级读锁</span><br><span class="line">lock table user_info read;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>释放方式</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">commit、rollback;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="排他锁（EXclusive-Lock）"><a href="#排他锁（EXclusive-Lock）" class="headerlink" title="排他锁（EXclusive Lock）"></a>排他锁（EXclusive Lock）</h1><ul>
<li><p>排他锁的代号是<code>X</code>，是 <code>eXclusive</code> 的缩写，也可称为<strong>写锁</strong>，是基本的锁类型。</p>
</li>
<li><p>排他锁的粒度与共享锁相同，也是行或者元组。<strong>一个事务获取了排他锁之后，可以对锁定范围内的数据执行写操作。允许获得排他锁的事务更新数据，阻止其它事务取得相同数据集的共享锁和排他锁。</strong></p>
</li>
<li><p>当有事务对数据加写锁后，其他事务不能再对锁定的数据加任何锁，又因为InnoDB对select语句默认不加锁，所以其他事务<strong>除了不能写操作外，照样是允许读的（尽管不允许加读锁）</strong>。</p>
</li>
<li><p><strong>主要为了在事务进行写操作时，不允许其他事务修改。</strong></p>
</li>
<li><p><strong>加锁方式</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 行级写锁</span><br><span class="line">自动：DML语句默认加写锁</span><br><span class="line">手动：select * from T where id=1 for update;</span><br><span class="line">-- 表级写锁</span><br><span class="line">lock table user_info write;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>释放方式</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">commit、rollback;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="意向锁（Intention-Lock）"><a href="#意向锁（Intention-Lock）" class="headerlink" title="意向锁（Intention Lock）"></a>意向锁（Intention Lock）</h1><ul>
<li><p>又称<strong>I锁</strong>。针对<strong>表锁</strong>。</p>
</li>
<li><p>为了允许行锁和表锁共存，实现多粒度锁机制，InnoDB 还有两种内部使用的意向锁。</p>
</li>
<li><p>意向锁是一种表锁，锁定的粒度是整张表，分为意向**共享锁(IS)和意向排他锁(IX)**两类。</p>
</li>
<li><p>意向共享锁表示一个事务有意对数据上共享锁或者排他锁。“有意”表示事务想执行操作但还没有真正执行。</p>
</li>
<li><p>当有事务给表的数据行加了共享锁或排他锁，同时会给表设置一个标识，代表已经有行锁了，其他事务要想对表加表锁时，就不必逐行判断有没有行锁可能跟表锁冲突了，直接读这个标识就可以确定自己该不该加表锁。特别是表中的记录很多时，逐行判断加表锁的方式效率很低。而<strong>这个标识就是意向锁</strong>。</p>
<ul>
<li>意向共享锁，IS锁，对整个表加共享锁之前，需要先获取到意向共享锁。</li>
<li>意向排他锁，IX锁，对整个表加排他锁之前，需要先获取到意向排他锁。</li>
<li>主要是为了提高加表锁的效率。</li>
</ul>
</li>
<li><p>加锁方式：</p>
<p>无法手动创建。</p>
</li>
</ul>
<p>锁和锁之间的关系，要么是相容的，要么是互斥的。</p>
<ul>
<li>锁 a 和锁 b 相容是指：操作同样一组数据时，如果事务 t1 获取了锁 a，另一个事务 t2 还可以获取锁 b；</li>
<li>锁 a 和锁 b 互斥是指：操作同样一组数据时，如果事务 t1 获取了锁 a，另一个事务 t2 在 t1 释放锁 a 之前无法释放锁 b</li>
</ul>
<p>其中<strong>共享锁</strong>、<strong>排他锁</strong>、<strong>意向共享锁、意向排他锁</strong>相互之间的兼容&#x2F;互斥关系如下表所示，其中 Y 表示相容，N 表示互斥。</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/24c690732b2a23eaaf35d230f986d830.png" alt="image-20220303132033771"></p>
<p><strong>如果一个事务请求的锁模式与当前的锁兼容，InnoDB 就将请求的锁授予该事务；反之，如果两者不兼容，该事务就要等待锁释放。</strong></p>
<p><strong>为了尽可能提高数据库的并发量，需每次锁定的数据范围越小越好，越小的锁其耗费的系统资源越多，系统性能下降。为在高并发响应和系统性能两方面进行平衡，这样就产生了“锁粒度”的概念。</strong></p>
<h1 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h1><ul>
<li><p>当程序中可能出现并发的情况时，就需要保证在并发情况下数据的准确性，以此确保当前用户和其他用户一起操作时，所得到的结果和他单独操作时的结果是一样的。这就叫做并发控制。并发控制的目的是保证一个用户的工作不会对另一个用户的工作产生不合理的影响。</p>
</li>
<li><p><strong>没有做好并发控制，就可能导致脏读、幻读和不可重复读等问题。</strong></p>
</li>
</ul>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/16b34e4c9b6784337b498623ea0dd849.png" alt="img"></p>
<p>常说的并发控制，一般都和数据库管理系统(DBMS)有关。在 DBMS 中并发控制的任务，是确保多个事务同时增删改查同一数据时，不破坏事务的隔离性、一致性和数据库的统一性。</p>
<p><code>实现并发控制的主要手段分为乐观并发控制和悲观并发控制两种。</code></p>
<p>无论是悲观锁还是乐观锁，都是人们定义出来的概念，<strong>可以认为是一种思想</strong>。其实不仅仅是关系型数据库系统中有乐观锁和悲观锁的概念，像 hibernate、tair、memcache 等都有类似的概念。所以，不应该拿乐观锁、悲观锁和其他的数据库锁等进行对比。<strong>乐观锁比较适用于读多写少的情况(多读场景)，悲观锁比较适用于写多读少的情况(多写场景)。</strong></p>
<h1 id="悲观锁（Pessimistic-Lock）"><a href="#悲观锁（Pessimistic-Lock）" class="headerlink" title="悲观锁（Pessimistic Lock）"></a>悲观锁（Pessimistic Lock）</h1><ul>
<li><p>在关系数据库管理系统里，悲观并发控制（又名“悲观锁”，Pessimistic Concurrency Control，缩写“PCC”）是一种并发控制的方法。它可以阻止一个事务以影响其他用户的方式来修改数据。<strong>如果一个事务执行的操作对某行数据应用了锁，那只有当这个事务把锁释放，其他事务才能够执行与该锁冲突的操作</strong>。悲观并发控制主要用于数据争用激烈的环境，以及发生并发冲突时使用锁保护数据的成本要低于回滚事务的成本的环境中。</p>
</li>
<li><p>悲观锁，具有强烈的独占和排他特性，正如其名，它指的是对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度(悲观)，因此，<strong>在整个数据处理过程中，将数据处于锁定状态</strong>。 <code>悲观锁的实现，往往依靠数据库提供的锁机制 （也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据）</code></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/e0a7bb67259e9c0de800ae7913bf0fd2.png" alt="img"></p>
</li>
<li><p>之所以叫做悲观锁，是因为这是一种对数据的修改持有悲观态度的并发控制方式。总是假设最坏的情况，每次读取数据的时候都默认其他线程会更改数据，因此需要进行加锁操作，当其他线程想要访问数据时，都需要阻塞挂起。</p>
</li>
<li><p>悲观锁的实现：</p>
<ol>
<li>传统的关系型数据库使用这种锁机制，比如行锁、表锁、读锁、写锁等，都是在操作之前先上锁。</li>
<li>Java 里面的同步<code>synchronized</code>关键字的实现。</li>
</ol>
</li>
<li><p>悲观锁主要分为<strong>共享锁和排他锁</strong></p>
</li>
<li><p>mysql中实现悲观锁的具体流程：</p>
<ol>
<li>在对任意记录进行修改前，先尝试为该记录加上排他锁（exclusive locking）</li>
<li>如果加锁失败，说明该记录正在被修改，那么当前查询可能要等待或者抛出异常。 具体响应方式由开发者根据实际需要决定。</li>
<li>如果成功加锁，那么就可以对记录做修改，事务完成后就会解锁了。</li>
<li>期间如果有其他对该记录做修改或加排他锁的操作，都会等待我们解锁或直接抛出异常。</li>
<li><strong>总而言之就是一句话：mysql中悲观锁的实现是通过排他锁来实现的</strong></li>
</ol>
</li>
</ul>
<p><strong>在mysql（InnoDB）中使用悲观锁：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.开始事务</span><br><span class="line">begin;/begin work;/start transaction; (三者选一就可以)</span><br><span class="line">2.查询出商品信息</span><br><span class="line">select ... for update;(这里是使用的行锁的排他锁)</span><br><span class="line">4.提交事务</span><br><span class="line">commit;/commit work;</span><br></pre></td></tr></table></figure>

<p>通过下面的例子来说明：</p>
<p><strong>1. 当你手动加上排它锁，但是并没有关闭mysql中的autocommit。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1.这里先给user表所有的行加上行锁的排他锁</span><br><span class="line">mysql&gt; select * from user for update;</span><br><span class="line">+----+------+--------+</span><br><span class="line">| id | name | psword |</span><br><span class="line">+----+------+--------+</span><br><span class="line">|  1 | a    | 1      |</span><br><span class="line">|  2 | b    | 2      |</span><br><span class="line">|  3 | c    | 3      |</span><br><span class="line">+----+------+--------+</span><br><span class="line">3 rows in set</span><br><span class="line"></span><br><span class="line">2.再对加了排他锁的行更改数据时，这里他会一直提示Unknown</span><br><span class="line">mysql&gt; update user set name=aa where id=1;</span><br><span class="line">1054 - Unknown column &#x27;aa&#x27; in &#x27;field list&#x27;</span><br><span class="line">mysql&gt; insert into user values(4,d,4);</span><br><span class="line">1054 - Unknown column &#x27;d&#x27; in &#x27;field list&#x27;</span><br></pre></td></tr></table></figure>

<p><strong>2. 关闭mysql中的autocommit后的正常流程</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">窗口1：</span><br><span class="line">mysql&gt; set autocommit=0;（先关闭mysql中的autocommit）</span><br><span class="line">Query OK, 0 rows affected</span><br><span class="line">我这里锁的是表中的所有行</span><br><span class="line">mysql&gt; select * from user for update;</span><br><span class="line">+----+-------+</span><br><span class="line">| id | price |</span><br><span class="line">+----+-------+</span><br><span class="line">|  1 |   500 |</span><br><span class="line">|  2 |   800 |</span><br><span class="line">+----+-------+</span><br><span class="line">2 rows in set</span><br><span class="line"></span><br><span class="line">窗口2：</span><br><span class="line">mysql&gt; update user set price=price-100 where id=1;</span><br><span class="line">执行上面操作的时候，会显示等待状态，一直到窗口1执行commit提交事务才会出现下面的显示结果</span><br><span class="line">Database changed</span><br><span class="line">Rows matched: 1  Changed: 1  Warnings: 0</span><br><span class="line"></span><br><span class="line">窗口1：执行commit手动提交事务</span><br><span class="line">mysql&gt; commit;</span><br><span class="line">Query OK, 0 rows affected</span><br><span class="line">再查询一下user表，发现已经执行了窗口2的更新操作</span><br><span class="line">mysql&gt; select * from user;</span><br><span class="line">+----+-------+</span><br><span class="line">| id | price |</span><br><span class="line">+----+-------+</span><br><span class="line">|  1 |   400 |</span><br><span class="line">|  2 |   800 |</span><br><span class="line">+----+-------+</span><br><span class="line">2 rows in set</span><br></pre></td></tr></table></figure>

<p>上面的例子展示了排它锁的原理：一个锁在某一时刻只能被一个线程占有，其它线程必须等待锁被释放之后才可能获取到锁或者进行数据的操作。</p>
<ul>
<li><p><strong>悲观锁的优点和不足</strong></p>
<p>悲观锁实际上是采取了“先取锁在访问”的策略，为数据的处理安全提供了保证，但是在效率方面，由于额外的加锁机制产生了额外的开销，并且<strong>增加了死锁的机会</strong>。并且降低了并发性；当一个事务加锁一行数据的时候，其他事务必须等待该事务提交之后，才能操作这行数据。</p>
</li>
</ul>
<h1 id="乐观锁（Optimistic-Locking）"><a href="#乐观锁（Optimistic-Locking）" class="headerlink" title="乐观锁（Optimistic Locking）"></a>乐观锁（Optimistic Locking）</h1><ul>
<li><p>在关系数据库管理系统里，乐观并发控制（又名“乐观锁”，Optimistic Concurrency Control，缩写“OCC”）是一种并发控制的方法。它假设多用户并发的事务在处理时不会彼此互相影响，各事务能够在不产生锁的情况下处理各自影响的那部分数据。在提交数据更新之前，每个事务会先检查在该事务读取数据后，有没有其他事务又修改了该数据。如果其他事务有更新的话，正在提交的事务会进行回滚。</p>
</li>
<li><p>乐观锁（ Optimistic Locking ） 相对悲观锁而言，乐观锁假设认为数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则让返回用户错误的信息，让用户决定如何去做。</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/569ff4e1a29633f4039ff83c0438346d.png" alt="img"></p>
</li>
<li><p>相对于悲观锁，在对数据库进行处理的时候，乐观锁并不会使用数据库提供的锁机制。</p>
</li>
<li><p>mysql实现乐观锁一般来说有3种方式：</p>
<ol>
<li>使用<strong>数据版本（Version）记录机制</strong>实现，这是乐观锁最常用的一种实现方式。一般是通过为数据库表增加一个数字类型的 “version” 字段，表示数据被修改的次数。当读取数据时，将version字段的值一同读出，数据每更新一次，对此version值加一。<br>当提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的version值进行比对，如果数据库表当前版本号与第一次取出来的version值相等，就进行更新操作，否则认为是过期数据，正在提交的事务会进行回滚。</li>
<li>第二种实现方式和第一种差不多，同样是在需要乐观锁控制的table中增加一个字段，名称无所谓，字段类型使用<strong>时间戳</strong>（timestamp）, 和上面的version类似，也是在更新提交的时候检查当前数据库中数据的时间戳和自己更新前取到的时间戳进行对比，如果一致就更新，否则就是版本冲突。</li>
<li>CAS 实现：Java 中java.util.concurrent.atomic包下面的原子变量使用了乐观锁的一种 CAS 实现方式</li>
</ol>
</li>
<li><p>乐观锁的优点和不足</p>
<p>乐观并发控制相信事务之间的数据竞争(data race)的概率是比较小的，因此尽可能直接做下去，直到提交的时候才去锁定，所以<strong>不会产生任何锁和死锁</strong>。但如果直接简单这么做，还是有可能会遇到不可预期的结果，例如两个事务都读取了数据库的某一行，经过修改以后写回数据库，这时就遇到了问题。</p>
</li>
<li><p>具体流程</p>
<ul>
<li>主要就是两个步骤：<strong>冲突检测和数据更新</strong>。比较典型的就是 CAS (Compare and Swap)。</li>
<li><strong>CAS 即比较并交换</strong>。是解决多线程并行情况下使用锁造成性能损耗的一种机制，CAS 操作包含三个操作数——<strong>内存位置(V)、预期原值(A)和新值(B)<strong>。如果内存位置的值(V)与预期原值(A)相匹配，那么处理器会自动将该位置值更新为新值(B)。否则，处理器不做任何操作。无论哪种情况，它都会在 CAS 指令之前返回该位置的值。CAS 有效地说明了“我认为位置(V)应该包含值(A)。如果包含该值，则将新值(B)放到这个位置；否则，不要更改该位置，只告诉我这个位置现在的值即可”。Java 中，</strong>sun.misc.Unsafe</strong> 类提供了硬件级别的原子操作来实现这个 CAS。<strong>java.util.concurrent</strong>包下大量的类都使用了这个 Unsafe.java 类的 CAS 操作。</li>
<li>当多个线程尝试使用 CAS 同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。比如前面的扣减库存问题，</li>
</ul>
</li>
<li><p>通过乐观锁可以实现如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">查出商品库存信息，quantity=3</span><br><span class="line">select quantity from items where id=1;</span><br><span class="line">修改商品库存为2</span><br><span class="line">update items set quantity=2 where id=1 and quantity = 3;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>在更新之前，先查询一下库存表中当前库存数(quantity)，然后在做 update 的时候，以库存数作为一个修改条件。当提交更新的时候，判断数据库表对应记录的当前库存数与第一次取出来的库存数进行比对，如果数据库表当前库存数与第一次取出来的库存数相等，则予以更新，否则认为是过期数据。</p>
</li>
<li><p>以上更新语句存在一个比较严重的问题，即<strong>ABA问题</strong>：</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/b67b363facf7760af75bfbad53b4e593.png" alt="img"></p>
<ol>
<li>比如说线程一从数据库中取出库存数 3，这时候线程二也从数据库中取出库存数 3，并且线程二进行了一些操作变成了 2。</li>
<li>然后线程二又将库存数变成 3，这时候线程一进行 CAS 操作发现数据库中仍然是 3，然后线程一操作成功。</li>
<li>尽管线程一的 CAS 操作成功，但是不代表这个过程就是没有问题的。</li>
</ol>
</li>
<li><p>一个比较好的解决办法，就是通过一个单独的可以顺序递增的 version 字段。优化如下：</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/d5de6b18dd097c35937d73caa0b6db1b.png" alt="img"></p>
<ul>
<li><p>乐观锁每次在执行数据修改操作时，都会带上一个版本号，一旦版本号和数据的版本号一致就可以执行修改操作并对版本号执行 +1 操作，否则就执行失败。因为每次操作的版本号都会随之增加，所以不会出现 ABA 问题。除了 version 以外，还可以使用时间戳，因为时间戳天然具有顺序递增性。</p>
</li>
<li><p>以上 SQL 其实还是有一定的问题的，就是一旦遇上高并发的时候，就只有一个线程可以修改成功，那么就会存在大量的失败。对于像淘宝这样的电商网站，高并发是常有的事，总让用户感知到失败显然是不合理的。所以，还是要想办法<strong>减少乐观锁的粒度</strong>。一个比较好的建议，就是<strong>减小乐观锁力度，最大程度的提升吞吐率，提高并发能力</strong>！如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">修改商品库存</span><br><span class="line">update item set quantity=quantity-1 where id=1 and quantity-1 &gt; 0;</span><br></pre></td></tr></table></figure>

<ul>
<li>以上 SQL 语句中，如果用户下单数为 1，则通过<code>quantity - 1 &gt; 0</code>的方式进行乐观锁控制。在执行过程中，会在一次原子操作中查询一遍 quantity 的值，并将其扣减掉 1。</li>
<li>高并发环境下锁粒度把控是一门重要的学问。选择一个好的锁，在保证数据安全的情况下，可以大大提升吞吐率，进而提升性能。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="理解-CAS-底层"><a href="#理解-CAS-底层" class="headerlink" title="理解 CAS 底层"></a>理解 CAS 底层</h1><p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/885eeb9d953fac34d4fdc53b31215b78.png" alt="img"></p>
<p>假如说有 3 个线程并发的要修改一个AtomicInteger的值，底层机制如下：</p>
<ol>
<li>首先，每个线程都会先获取当前的值，接着走一个原子的 CAS 操作。原子的意思就是这个 CAS 操作一定是自己完整执行完的，不会被别人打断。</li>
<li>然后 CAS 操作里，会比较一下，现在的值是不是刚才获取到的那个值。如果是，说明没人改过这个值，然后设置成累加 1 之后的一个值。</li>
<li>同理，如果有人在执行 CAS 的时候，发现之前获取的值跟当前的值不一样，会导致 CAS 失败。失败之后，进入一个无限循环，再次获取值，接着执行 CAS 操作。</li>
</ol>
<h1 id="CAS-典型应用"><a href="#CAS-典型应用" class="headerlink" title="CAS 典型应用"></a>CAS 典型应用</h1><p>java.util.concurrent.atomic包下的类大多是使用 CAS 操作来实现的，比如 AtomicInteger、AtomicBoolean、AtomicLong。一般在竞争不是特别激烈的时候，使用该包下的原子操作性能比使用 synchronized关键字的方式高效的多(查看 getAndSet()，可知如果资源竞争十分激烈的话，这个 for 循环可能会持续很久都不能成功跳出。不过这种情况可能需要考虑降低资源竞争才是)。</p>
<p>在较多的场景都可能会使用到这些原子类操作。一个典型应用就是计数了，在多线程的情况下需要考虑线程安全问题。</p>
<ol>
<li>支持计数功能 Demo 实现</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Increment</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在并发环境下对 count 进行自增运算是不安全的，为什么不安全以及如何解决这个问题呢？</p>
<ol start="2">
<li>为什么并发环境下的 count 自增操作不安全？因为 count++ 不是原子操作，而是三个原子操作的组合：<ol>
<li>读取内存中的 count 值赋值给局部变量 temp；</li>
<li>执行 temp+1 操作；</li>
<li>将 temp 赋值给 count。</li>
</ol>
</li>
</ol>
<p>所以如果两个线程同时执行 count++ 的话，不能保证线程一按顺序执行完上述三步后线程二才开始执行。</p>
<ol start="3">
<li>并发环境下 count++ 不安全问题的解决方案</li>
</ol>
<p>方案①：<strong>synchronized加锁</strong>。同一时间只有一个线程能加锁，其他线程需要等待锁，这样就不会出现 count 计数不准确的问题了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Increment</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是引入 synchronized 会造成多个线程排队的问题，相当于让各个线程串行化了，一个接一个的排队、加锁、处理数据、释放锁，下一个再进来。同一时间只有一个线程执行，这样的锁有点“重量级”了。这类似于悲观锁的实现，需要获取这个资源，就给它加锁，别的线程都无法访问该资源，直到操作完后释放对该资源的锁。虽然随着 Java 版本更新，也对 synchronized 做了很多优化，但是处理这种简单的累加操作，仍然显得“太重了”。</p>
<p>方案②：<strong>Atomic 原子类</strong>。对于 count++ 的操作，完全可以换一种做法，Java 并发包下面提供了一系列的 Atomic 原子类，比如说 AtomicInteger：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//import java.util.concurrent.atomic.AtomicInteger;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">AtomicInteger</span> <span class="variable">count</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">increase</span><span class="params">()</span> &#123;</span><br><span class="line">        count.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>多个线程可以并发的执行 AtomicInteger 的 incrementAndGet()，意思就是把 count 的值累加 1，接着返回累加后最新的值。实际上，Atomic 原子类底层用的不是传统意义的锁机制，而是无锁化的 CAS 机制，通过 CAS 机制保证多线程修改一个数值的安全性。</p>
<h1 id="CAS-性能优化"><a href="#CAS-性能优化" class="headerlink" title="CAS 性能优化"></a>CAS 性能优化</h1><p>从流程图可以看出来，大量的线程同时并发修改一个 AtomicInteger，可能有很多线程会不停的自旋，进入一个无限重复的循环中。这些线程不停地获取值，然后发起 CAS 操作，但是发现这个值被别人改过了，于是再次进入下一个循环，获取值，发起 CAS 操作又失败了，再次进入下一个循环。在大量线程高并发更新 AtomicInteger 的时候，这种问题可能会比较明显，导致大量线程空循环，自旋转，性能和效率都不是特别好。那么如何优化呢？</p>
<p>Java8 有一个新的类，LongAdder，它就是尝试使用分段 CAS 以及自动分段迁移的方式来大幅度提升多线程高并发执行 CAS 操作的性能，这个类具体是如何优化性能的呢？如图：</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/7abe51c80744d2eab1495895ec3fe11e.png" alt="img"></p>
<p><strong>LongAdder</strong></p>
<p>LongAdder 核心思想就是热点分离，这一点和 ConcurrentHashMap 的设计思想相似。就是将 value 值分离成一个数组，当多线程访问时，通过 hash 算法映射到其中的一个数字进行计数。而最终的结果，就是这些数组的求和累加。这样一来，就减小了锁的粒度。</p>
<p>LongAddr 的兄弟类如下：</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/60ca62457379f485d4482cc848269fb5.png" alt="img"></p>
<p>LongAdder兄弟类</p>
<h1 id="如何选择"><a href="#如何选择" class="headerlink" title="如何选择"></a>如何选择</h1><p>在乐观锁与悲观锁的选择上面，主要看下两者的区别以及适用场景就可以了。</p>
<ol>
<li><strong>响应效率</strong>：如果需要非常高的响应速度，建议采用乐观锁方案，成功就执行，不成功就失败，不需要等待其他并发去释放锁。乐观锁并未真正加锁，效率高。一旦锁的粒度掌握不好，更新失败的概率就会比较高，容易发生业务失败。</li>
<li><strong>冲突频率</strong>：如果冲突频率非常高，建议采用悲观锁，保证成功率。冲突频率大，选择乐观锁会需要多次重试才能成功，代价比较大。</li>
<li><strong>重试代价</strong>：如果重试代价大，建议采用悲观锁。悲观锁依赖数据库锁，效率低。更新失败的概率比较低。</li>
<li>乐观锁如果有人在你之前更新了，你的更新应当是被拒绝的，可以让用户从新操作。悲观锁则会等待前一个更新完成。这也是区别。</li>
</ol>
<p>随着互联网**三高架构(高并发、高性能、高可用)**的提出，悲观锁已经越来越少的被应用到生产环境中了，尤其是并发量比较大的业务场景。</p>
<h1 id="乐观锁和MVCC的区别？"><a href="#乐观锁和MVCC的区别？" class="headerlink" title="乐观锁和MVCC的区别？"></a>乐观锁和MVCC的区别？</h1><p>在数据库中，并发控制是指在多个用户&#x2F;进程&#x2F;线程同时对数据库进行操作时，如何保证事务的一致性和隔离性的，同时最大程度地并发。</p>
<p>当多个用户&#x2F;进程&#x2F;线程同时对数据库进行操作时，会出现3种冲突情形：</p>
<ol>
<li>读-读，不存在任何问题</li>
<li>读-写，有隔离性问题，可能遇到脏读（会读到未提交的数据） ，幻影读等。</li>
<li>写-写，可能丢失更新</li>
</ol>
<p><strong>要解决冲突，一种办法是是锁，即基于锁的并发控制，比如2PL两阶段锁协议，这种方式开销比较高，而且无法避免死锁。而基于无锁的并发控制有两种方式：就是MVCC多版本并发控制和OCC乐观并发控制，这两种方式分别解决上面的第2,3种情况。</strong></p>
<p><strong>多版本并发控制（MVCC）是一种用来解决读-写冲突的无锁并发控制</strong>，也就是为事务分配单向增长的时间戳，为每个修改保存一个版本，版本与事务时间戳关联，读操作只读该事务开始前的数据库的快照。 这样在读操作不用阻塞写操作，写操作不用阻塞读操作的同时，避免了脏读和不可重复读</p>
<p><strong>乐观并发控制（OCC）是一种用来解决写-写冲突的无锁并发控制</strong>，认为事务间争用没有那么多，所以先进行修改，在提交事务前，检查一下事务开始后，有没有新提交改变，如果没有就提交，如果有就放弃并重试。乐观并发控制类似自旋锁。乐观并发控制适用于低数据争用，写冲突比较少的环境。</p>
<p><strong>多版本并发控制可以结合基于锁的并发控制来解决写-写冲突</strong>，即MVCC+2PL，也可以结合乐观并发控制来解决写-写冲突。</p>
<h1 id="InnoDB锁的特性"><a href="#InnoDB锁的特性" class="headerlink" title="InnoDB锁的特性"></a>InnoDB锁的特性</h1><ol>
<li><p>在不通过索引条件查询的时候，InnoDB使用的确实是表锁（锁的是整张表）！</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">price属性并没有加索引，因此这时候虽然是用的行锁，锁的却是整张表</span><br><span class="line">窗口1：</span><br><span class="line">mysql&gt; select * from product where price=88 for update;</span><br><span class="line">+----+------+-------+-----+</span><br><span class="line">| id | name | price | num |</span><br><span class="line">+----+------+-------+-----+</span><br><span class="line">|  2 | 蒙牛 |    88 |   1 |</span><br><span class="line">+----+------+-------+-----+</span><br><span class="line"></span><br><span class="line">窗口2：</span><br><span class="line">mysql&gt; update product set price=price-100 where id=6;</span><br><span class="line">这里会等待，直到窗口1 commit后显示下面结果！</span><br><span class="line">Query OK, 1 row affected</span><br><span class="line">Rows matched: 1  Changed: 1  Warnings: 0</span><br></pre></td></tr></table></figure>
</li>
<li><p>由于 MySQL 的行锁是<strong>针对索引加的锁</strong>,不是针对记录加的锁,所以虽然是访问不同行的记录,但是如果是使用相同的索引键,是会出现锁冲突的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">这里的num属性 加上了普通索引，price属性并没有索引</span><br><span class="line">窗口1：</span><br><span class="line">mysql&gt; set autocommit=0;</span><br><span class="line">Query OK, 0 rows affected</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from product where num=1 and price=68 for update;</span><br><span class="line">+----+------+-------+-----+</span><br><span class="line">| id | name | price | num |</span><br><span class="line">+----+------+-------+-----+</span><br><span class="line">|  1 | 伊利 |    68 |   1 |</span><br><span class="line">+----+------+-------+-----+</span><br><span class="line"></span><br><span class="line">窗口2：</span><br><span class="line">mysql&gt; update product set price=price+100 where num=1 and price=88;</span><br><span class="line">这里会发生等待，直到窗口1 commit 显示下面结果</span><br><span class="line">Query OK, 1 row affected</span><br><span class="line">Rows matched: 1  Changed: 1  Warnings: 0</span><br><span class="line">mysql&gt; select * from product;</span><br><span class="line">+----+----------+-------+-----+</span><br><span class="line">| id | name     | price | num |</span><br><span class="line">+----+----------+-------+-----+</span><br><span class="line">|  1 | 伊利     |    68 |   1 |</span><br><span class="line">|  2 | 蒙牛     |   188 |   1 |</span><br><span class="line">+----+----------+-------+-----+</span><br></pre></td></tr></table></figure>
</li>
<li><p>当表有多个索引的时候,不同的事务可以使用不同的索引锁定不同的行,另外,不论是使用主键索引、唯一索引或普通索引,InnoDB都会使用行锁来对数据加锁。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">锁一行数据，DML操作其他行并没有影响</span><br><span class="line">窗口1：</span><br><span class="line">mysql&gt; select * from user where id=1 for update;</span><br><span class="line">+----+-------+</span><br><span class="line">| id | price |</span><br><span class="line">+----+-------+</span><br><span class="line">|  1 |   400 |</span><br><span class="line">+----+-------+</span><br><span class="line"></span><br><span class="line">窗口2：</span><br><span class="line">mysql&gt; update user set price=price+100 where id=2;</span><br><span class="line">无需等待窗口1 commit</span><br><span class="line">Database changed</span><br><span class="line">Rows matched: 1  Changed: 1  Warnings: 0</span><br></pre></td></tr></table></figure>
</li>
<li><p>即便在条件中使用了索引字段,但是否使用索引来检索数据是由 MySQL 通过判断不同 执行计划的代价来决定的,如果 MySQL 认为全表扫效率更高,比如对一些很小的表,它 就不会使用索引,这种情况下 InnoDB 将使用表锁,而不是行锁。因此,在分析锁冲突时, 别忘了检查SQL 的执行计划（explain查看）,以确认是否真正使用了索引。</p>
</li>
</ol>
<h1 id="死锁的原理及分析"><a href="#死锁的原理及分析" class="headerlink" title="死锁的原理及分析"></a>死锁的原理及分析</h1><h2 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h2><p>MySQL InnoDB存储引擎，实现的是基于多版本并发控制协议—MVCC(Multi-Version Concurrency Control) MVCC最大的好处，相信也是耳熟能详：<strong>读不加锁，读写不冲突</strong>。在读多写少的OLTP应用中，读写不冲突是非常重要的，极大的增加了系统的并发性能，这也是为什么现阶段，几乎所有的RDBMS，都支持了MVCC。</p>
<h2 id="PL：Two-Phase-Locking"><a href="#PL：Two-Phase-Locking" class="headerlink" title="PL：Two-Phase Locking"></a>PL：Two-Phase Locking</h2><p>传统RDBMS（关系数据库管理系统）加锁的一个原则，就是2PL (二阶段锁)：Two-Phase Locking。相对而言，2PL比较容易理解，说的是锁操作分为两个阶段：<strong>加锁阶段与解锁阶段</strong>，并且保证加锁阶段与解锁阶段不相交。下面，仍旧以MySQL为例，来简单看看2PL在MySQL中的实现。</p>
<table>
<thead>
<tr>
<th align="center">transaction</th>
<th align="center">mysql</th>
</tr>
</thead>
<tbody><tr>
<td align="center">begin;</td>
<td align="center">加锁阶段</td>
</tr>
<tr>
<td align="center">insert into</td>
<td align="center">加insert对应的锁</td>
</tr>
<tr>
<td align="center">update table</td>
<td align="center">加update对应的锁</td>
</tr>
<tr>
<td align="center">delete from</td>
<td align="center">加delete对应的锁</td>
</tr>
<tr>
<td align="center">commit</td>
<td align="center">解锁阶段</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">将insert、update、delete的锁全部解开</td>
</tr>
</tbody></table>
<p>上面的例子可以看出2PL就是将加锁、解锁分为两个阶段，并且互相不干扰。加锁阶段只加锁，解锁阶段只解锁。</p>
<h2 id="为什么会发生死锁"><a href="#为什么会发生死锁" class="headerlink" title="为什么会发生死锁"></a>为什么会发生死锁</h2><p>MyISAM中是不会产生死锁的，因为MyISAM总是一次性获得所需的全部锁，要么全部满足，要么全部等待。而在InnoDB中，锁是逐步获得的，就造成了死锁的可能。（不过现在一般都是InnoDB引擎，关于MyISAM不做考虑）</p>
<p>在InnoDB中，行级锁并不是直接锁记录，而是锁索引。索引分为主键索引和非主键索引两种，如果一条sql语句操作了主键索引，MySQL就会锁定这条主键索引；如果一条语句操作了非主键索引，MySQL会先锁定该非主键索引，再锁定相关的主键索引。</p>
<p>当两个事务同时执行，一个锁住了主键索引，在等待其他相关索引。另一个锁定了非主键索引，在等待主键索引。这样就会发生死锁。</p>
<p>通过两个SQL死锁的例子来说明</p>
<ol>
<li><strong>两个session的两条语句</strong></li>
</ol>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/20190406184514611.jpg" alt="img"></p>
<p>这种情况很好理解，首先session1获得 id&#x3D;1的锁 session2获得id&#x3D;5的锁，然后session想要获取id&#x3D;5的锁 等待，session2想要获取id&#x3D;1的锁 ，也等待！</p>
<ol start="2">
<li><strong>两个session的一条语句</strong></li>
</ol>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/20190406184524757.jpg" alt="img"></p>
<p>这种情况需要我们了解<strong>数据的索引的检索顺序</strong>原理简单说下：<strong>普通索引上面保存了主键索引，当我们使用普通索引检索数据时，如果所需的信息不够，那么会继续遍历主键索引。</strong></p>
<p>假设默认情况是RR隔离级别，针对session 1 从name索引出发，检索到的是（hdc,1）（hdc,6）不仅会加name索引上的记录X锁，而且会加聚簇索引上的记录X锁，加锁顺序为先[1,hdc,100]，后[6,hdc,10] 这个顺序是因为B+树结构的有序性。而Session 2，从pubtime索引出发，[10,6],[100,1]均满足过滤条件，同样也会加聚簇索引上的记录X锁，加锁顺序为[6,hdc,10]，后[1,hdc,100]。发现没有，跟Session 1的加锁顺序正好相反，如果两个Session恰好都持有了第一把锁，请求加第二把锁，死锁就发生了。</p>
<p><strong>避免死锁，这里只介绍常见的三种</strong></p>
<ol>
<li>如果不同程序会并发存取多个表，尽量约定以相同的顺序访问表，可以大大降低死锁机会。</li>
<li>在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁产生概率；</li>
<li>对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过表级锁定来减少死锁产生的概率；</li>
</ol>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-数据库：mysql基础"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
	
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/08/02/%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%9Amysql%E5%9F%BA%E7%A1%80/"
    >mysql基础</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/08/02/%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%9Amysql%E5%9F%BA%E7%A1%80/" class="article-date">
  <time datetime="2022-08-02T08:05:11.000Z" itemprop="datePublished">2022-08-02</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a> / <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/">mysql</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="1-mysql简介"><a href="#1-mysql简介" class="headerlink" title="1. mysql简介"></a>1. mysql简介</h1><ul>
<li><p>MySQL是一个<strong>关系型数据库管理系统</strong></p>
</li>
<li><p>由瑞典MySQL AB 公司开发，属于 <a target="_blank" rel="noopener" href="https://baike.baidu.com/item/Oracle">Oracle</a> 旗下产品</p>
</li>
<li><p>Mysql是一个<strong>开源免费的</strong>关系型数据库管理系统</p>
</li>
<li><p>mysql分为社区办和企业版</p>
</li>
<li><p>我们学习的是社区版</p>
</li>
</ul>
<hr>
<h1 id="2-关系型数据库"><a href="#2-关系型数据库" class="headerlink" title="2. 关系型数据库"></a>2. 关系型数据库</h1><p>建立在关系模型基础上的数据库,借助数学中的集合代数等一些数学概念和方法,处理关系型数据库中的数据</p>
<hr>
<h1 id="3-Mysql的安装"><a href="#3-Mysql的安装" class="headerlink" title="3. Mysql的安装"></a>3. Mysql的安装</h1><ul>
<li>windows的安装</li>
<li>Linux的安装</li>
</ul>
<hr>
<h1 id="4-Mysql默认的字符集的配置-了解"><a href="#4-Mysql默认的字符集的配置-了解" class="headerlink" title="4. Mysql默认的字符集的配置(了解)"></a>4. Mysql默认的字符集的配置(了解)</h1><p>以windows中的mysql的配置为例:</p>
<ul>
<li><p>找到mysql的存放配置文件的地方 <code>C:\ProgramData\MySQL\MySQL Server 5.6/my.ini</code></p>
</li>
<li><p>修改</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">character-set-server=utf8</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>但是: <strong>我们完全不建议这样修改</strong>,因为我们每个项目系统使用的数据库编码完全有可能不一样;</p>
</blockquote>
<hr>
<h1 id="5-启动和停止mysql的服务"><a href="#5-启动和停止mysql的服务" class="headerlink" title="5. 启动和停止mysql的服务"></a>5. 启动和停止mysql的服务</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net start mysql</span><br><span class="line">net stop mysql</span><br></pre></td></tr></table></figure>

<p>注意: 如果命令显式不可用代表操作系统的版本不支持(家庭版)</p>
<hr>
<h1 id="6-mysql的登录命令"><a href="#6-mysql的登录命令" class="headerlink" title="6. mysql的登录命令"></a>6. mysql的登录命令</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql <span class="operator">-</span>u用户名  <span class="operator">-</span>p密码 </span><br><span class="line">	<span class="operator">-</span>h: 默认为localhost</span><br><span class="line">	<span class="operator">-</span>P: 默认<span class="number">3306</span></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="7-mysql常用的系统命令"><a href="#7-mysql常用的系统命令" class="headerlink" title="7. mysql常用的系统命令"></a>7. mysql常用的系统命令</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看mysql的版本</span></span><br><span class="line">SELECT VERSION();</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看mysql当前登录的用户</span></span><br><span class="line">select user();</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看mysql的当前日期</span></span><br><span class="line">select now();</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看当前所在的数据库</span></span><br><span class="line">select database();</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="8-mysql的语句规范"><a href="#8-mysql的语句规范" class="headerlink" title="8. mysql的语句规范"></a>8. mysql的语句规范</h1><ul>
<li>关键字和函数名建议大写</li>
<li>数据库的名称,表的名称,字段的名称建议小写</li>
<li>数据库 表名 字段名建议加上&#96;&#96;</li>
<li>sql语句的<strong>定界符</strong>默认以; 结尾</li>
</ul>
<hr>
<h1 id="9-数据库的操作SQL类型-了解"><a href="#9-数据库的操作SQL类型-了解" class="headerlink" title="9. 数据库的操作SQL类型(了解)"></a>9. 数据库的操作SQL类型(了解)</h1><ul>
<li><p><strong>DDL</strong>(数据定义语言)(Data Defination Language)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE/VIEW/INDEX;</span><br><span class="line">DROP DATABASE;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>DML</strong>(数据操纵语言)(Data Manipulation Language)</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>) 插入：<span class="keyword">INSERT</span></span><br><span class="line"><span class="number">2</span>) 更新：<span class="keyword">UPDATE</span></span><br><span class="line"><span class="number">3</span>) 删除：<span class="keyword">DELETE</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>DQL</strong>(数据查询语言)(Data Query Language)</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DQL基本结构是由<span class="keyword">SELECT</span>子句，<span class="keyword">FROM</span>子句，<span class="keyword">WHERE</span></span><br><span class="line">子句组成的查询块：</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">&lt;</span>字段名表<span class="operator">&gt;</span></span><br><span class="line">	<span class="keyword">FROM</span> <span class="operator">&lt;</span>表或视图名<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="operator">&lt;</span>查询条件<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
</li>
<li><p><strong>DCL</strong>(数据控制语言)(Data Control Language) </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">用来定义安全级别和访问权限的</span><br><span class="line">常用的关键字：grant   revoke </span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="10-mysql中的概念"><a href="#10-mysql中的概念" class="headerlink" title="10. mysql中的概念"></a>10. mysql中的概念</h1><ul>
<li>数据库管理系统: 管理数据库的系统</li>
<li>数据库: 数组库是用来存放和组织<code>表</code>的</li>
<li>表:是存储数据的<strong>容器</strong>  </li>
<li>记录: 一行的数据</li>
<li>属性: 一列属性值</li>
</ul>
<hr>
<h1 id="11-数据库的操作-必会"><a href="#11-数据库的操作-必会" class="headerlink" title="11. 数据库的操作(必会)"></a>11. 数据库的操作(必会)</h1><ul>
<li>创建数据库</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE `db2`; #最简单的方式创建一个数据库</span><br></pre></td></tr></table></figure>

<p>注意: 数据库的名称可以加 &#96;&#96; ,也可以不加,默认mysql会给你自动加上</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE db2;  #可以省略``</span><br></pre></td></tr></table></figure>

<ul>
<li>带判断的创建数据库</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `db1`; #如果不存在db1这个数据库则创建db1数据库,如果存在则不会创建但是也不会报错</span><br></pre></td></tr></table></figure>

<ul>
<li>创建数据库并且指定字符集</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#mysql默认的字符集是latin1,latin1不支持中文</span><br><span class="line"><span class="keyword">CREATE</span> DATABASE IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `db3` <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>UTF8MB4;</span><br></pre></td></tr></table></figure>

<ul>
<li>删除数据库</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#删除数据库,如果数据库不存在则会报错</span><br><span class="line"><span class="keyword">DROP</span> DATABASE `db1`;</span><br><span class="line">#带判断的删除数据库</span><br><span class="line"><span class="keyword">DROP</span> DATABASE IF <span class="keyword">EXISTS</span> `db1`</span><br></pre></td></tr></table></figure>

<ul>
<li>查询数据库</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#查询数据库的创建信息</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> DATABASE `db3`;</span><br><span class="line">#查询当前RDBMS中有哪些数据库</span><br><span class="line"><span class="keyword">SHOW</span> DATABASES;</span><br><span class="line">#查询当前所在的数据库</span><br><span class="line"><span class="keyword">SELECT</span> DATABASE();</span><br></pre></td></tr></table></figure>

<ul>
<li>进入数据库</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">USE <span class="string">&#x27;db1&#x27;</span>;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="12-mysql中的数据类型"><a href="#12-mysql中的数据类型" class="headerlink" title="12. mysql中的数据类型"></a>12. mysql中的数据类型</h1><h2 id="12-1-整型"><a href="#12-1-整型" class="headerlink" title="12.1 整型"></a>12.1 整型</h2><table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">范围</th>
<th align="center">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>tinyint</strong></td>
<td align="center"><strong>1个字节 范围(-128<del>127)||0</del>255(无符号)</strong></td>
<td align="center"><strong>与java中的byte类型对应</strong></td>
</tr>
<tr>
<td align="center"><strong>smallint</strong></td>
<td align="center"><strong>2个字节 范围(-32768~32767|| 0 ~ 65535(无符号))</strong></td>
<td align="center"><strong>与java中的short对应</strong></td>
</tr>
<tr>
<td align="center">mediumint</td>
<td align="center">3 个字节, -8388608 to 8388607||0 to 16777215(无符号)</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><strong>int:Integer</strong></td>
<td align="center">4 个字节, -2147483648 to 2147483647||0 to 4294967295(无符号)</td>
<td align="center">与Java中的int类型对应</td>
</tr>
<tr>
<td align="center"><strong>bigint</strong></td>
<td align="center">8 个字节, -9223372036854775808 to 922337203685477580||0 to 18446744073709551615(无符号)</td>
<td align="center"><strong>与java中的long对应</strong></td>
</tr>
</tbody></table>
<hr>
<h2 id="12-2-浮点型"><a href="#12-2-浮点型" class="headerlink" title="12.2 浮点型"></a>12.2 浮点型</h2><table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">范围</th>
<th align="center">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="center">float(m,d)</td>
<td align="center">单精度浮点型  8位精度(4字节)   m总个数，d小数位</td>
<td align="center">与java的float对应</td>
</tr>
<tr>
<td align="center">double(m,d)</td>
<td align="center">双精度浮点型  16位精度(8字节)   m总个数，d小数位</td>
<td align="center">与java的double对应</td>
</tr>
</tbody></table>
<p>注意: 在实际开发过程中设计数据库时&#x3D;&#x3D;一定一定一定&#x3D;&#x3D;,<strong>涉及到小数的不要使用FLOAT和DOUBLE类型</strong></p>
<hr>
<h2 id="12-3-定点"><a href="#12-3-定点" class="headerlink" title="12.3 定点"></a>12.3 定点</h2><p>浮点型在数据库中存放的是近似值，而定点类型在数据库中存放的是精确值</p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">范围</th>
<th align="center">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>decimal(m,d)</strong></td>
<td align="center">参数m&lt;65 是总个数，d&lt;30且 d&lt;m 是小数位</td>
<td align="center">表示金额等精确值</td>
</tr>
</tbody></table>
<p>注意: Decimal这个类型如果Insert的数据比我们预设的d的长度大,也会进行四舍五入;  一般存储小数都会使用DECIMAL类型,<strong>不会丢失精度</strong></p>
<hr>
<h2 id="12-4-字符串"><a href="#12-4-字符串" class="headerlink" title="12.4 字符串"></a>12.4 字符串</h2><table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">范围</th>
<th align="center">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>char(n)</strong></td>
<td align="center"><strong>固定长度，最多255个</strong></td>
<td align="center">定长字符串,n 范围(0,255)， 如果不是定长的数据，n&lt;&#x3D;4 时才使用</td>
</tr>
<tr>
<td align="center"><strong>varchar(n)</strong></td>
<td align="center"><strong>变长字符串，最多65532个字符</strong></td>
<td align="center">变长字符串，65532&gt;n&gt;4, 注意，n 是字符数，而不是字节数</td>
</tr>
<tr>
<td align="center">tinytext</td>
<td align="center">存储 L+1 个字节，其中 L &lt; 2^8</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><strong>text</strong></td>
<td align="center">存储 L+2 个字节，其中 L &lt; 2^16</td>
<td align="center">存储文本的</td>
</tr>
<tr>
<td align="center">mediumtext</td>
<td align="center">存储 L+3 个字节，其中 L &lt; 2^24</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">longtext</td>
<td align="center">存储 L+4 个字节，其中 L &lt; 2^32</td>
<td align="center"></td>
</tr>
</tbody></table>
<h2 id="12-5-Blob二进制类型"><a href="#12-5-Blob二进制类型" class="headerlink" title="12.5 Blob二进制类型"></a>12.5 Blob二进制类型</h2><ul>
<li><p>BLOB和text存储方式不同，TEXT以文本方式存储，英文存储区分大小写，而Blob是以二进制方式存储，不分大小写。</p>
</li>
<li><p>BLOB存储的数据只能整体读出。 </p>
</li>
<li><p>TEXT可以指定字符集，BLOB不用指定字符集。</p>
</li>
</ul>
<hr>
<h2 id="12-6-日期时间类型"><a href="#12-6-日期时间类型" class="headerlink" title="12.6 日期时间类型"></a>12.6 日期时间类型</h2><table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="center">date</td>
<td align="center">日期 ‘2008-12-2’</td>
</tr>
<tr>
<td align="center">time</td>
<td align="center">时间 ‘12:25:36’</td>
</tr>
<tr>
<td align="center">datetime</td>
<td align="center">日期时间 ‘2008-12-2 22:06:44’</td>
</tr>
<tr>
<td align="center">timestamp</td>
<td align="center">自动存储记录修改时间</td>
</tr>
</tbody></table>
<hr>
<h1 id="13-mysql中数据类型属性-约束-CONSTRAINT"><a href="#13-mysql中数据类型属性-约束-CONSTRAINT" class="headerlink" title="13. mysql中数据类型属性(约束-CONSTRAINT)"></a>13. mysql中数据类型属性(约束-CONSTRAINT)</h1><table>
<thead>
<tr>
<th align="center">MySQL关键字</th>
<th align="center">含义</th>
<th align="center">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>NULL</strong></td>
<td align="center">数据列可包含NULL值</td>
<td align="center">mysql默认不指定约束,字段也不添加值,默认为NULL</td>
</tr>
<tr>
<td align="center"><strong>NOT NULL</strong></td>
<td align="center">数据列不允许包含NULL值</td>
<td align="center">非空约束</td>
</tr>
<tr>
<td align="center"><strong>DEFAULT</strong></td>
<td align="center">默认值</td>
<td align="center">默认值约束</td>
</tr>
<tr>
<td align="center"><strong>PRIMARY KEY</strong></td>
<td align="center">主键</td>
<td align="center">主键约束 &#x3D; 非空约束+唯一约束</td>
</tr>
<tr>
<td align="center"><strong>AUTO_INCREMENT</strong></td>
<td align="center">自动递增，适用于整数类型</td>
<td align="center">自增(一般和<strong>数值类型的主键</strong>联合使用)</td>
</tr>
<tr>
<td align="center"><strong>UNSIGNED</strong></td>
<td align="center">无符号</td>
<td align="center">保留正数部分</td>
</tr>
<tr>
<td align="center"><strong>UNIQUE</strong></td>
<td align="center">唯一约束</td>
<td align="center">此字段的值不能重复</td>
</tr>
</tbody></table>
<hr>
<ul>
<li><p>作用</p>
<ul>
<li>保证用户输入的数据存储到数据库中是正确的，准确的。</li>
<li>可以防止一些可能的输入错误。</li>
<li>如何使用<strong>完整性</strong>来保证存储到数据库中的数据是正确的准确的，需要在创建表的时候给表添加约束</li>
</ul>
</li>
<li><p>分类</p>
<ul>
<li>实体完整性</li>
<li>域完整性</li>
<li>引用完整性</li>
</ul>
</li>
</ul>
<h1 id="14-表的操作"><a href="#14-表的操作" class="headerlink" title="14. 表的操作"></a>14. 表的操作</h1><p>数据表是数据库的最重要的组成部分之一,是其他对象的基础;</p>
<h2 id="14-1-查看数据库中的所有的表"><a href="#14-1-查看数据库中的所有的表" class="headerlink" title="14.1 查看数据库中的所有的表"></a>14.1 查看数据库中的所有的表</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW TABLES;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="14-2-创建表"><a href="#14-2-创建表" class="headerlink" title="14.2 创建表"></a>14.2 创建表</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `<span class="keyword">user</span>`(id <span class="type">int</span>,name <span class="type">char</span>(<span class="number">32</span>),age tinyint);</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 带条件的创建表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `<span class="keyword">user</span>`(id <span class="type">int</span>,name <span class="type">char</span>(<span class="number">32</span>),age tinyint);</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建表时指定字符集,如果不指定默认使用的是数据库的字符集</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `<span class="keyword">user</span>`(id <span class="type">int</span>,name <span class="type">char</span>(<span class="number">32</span>),age tinyint) <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>UTF8;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看表结构</span></span><br><span class="line"><span class="keyword">DESCRIBE</span> `<span class="keyword">user</span>`;</span><br><span class="line"><span class="keyword">DESC</span> `<span class="keyword">user</span>`;  #简写</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="14-3-删除表"><a href="#14-3-删除表" class="headerlink" title="14.3 删除表"></a>14.3 删除表</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 删除表</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> `<span class="keyword">user</span>`;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 带判断的删除</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `<span class="keyword">user</span>`;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="14-4-修改表结构"><a href="#14-4-修改表结构" class="headerlink" title="14.4 修改表结构"></a>14.4 修改表结构</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 添加列</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> `<span class="keyword">member</span>` <span class="keyword">ADD</span> <span class="keyword">COLUMN</span> sex <span class="type">CHAR</span>(<span class="number">1</span>);</span><br><span class="line"><span class="comment">-- COLUMN关键字可以省略</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> `<span class="keyword">member</span>` <span class="keyword">ADD</span>  sex <span class="type">CHAR</span>(<span class="number">1</span>);  </span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 删除列	</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="keyword">member</span> <span class="keyword">DROP</span> <span class="keyword">COLUMN</span>  city;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="keyword">member</span> <span class="keyword">DROP</span>  city;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询列</span></span><br><span class="line"><span class="keyword">DESC</span> <span class="keyword">member</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- MODIFY只能修改列的属性 不能修改名字</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="keyword">member</span> MODIFY age <span class="type">SMALLINT</span>;</span><br><span class="line"><span class="comment">-- CHANGE 既能修改列的名称也能修改列的属性</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="keyword">member</span> CHANGE sex sex1 <span class="type">VARCHAR</span>(<span class="number">10</span>)</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="15-记录-数据-的操作"><a href="#15-记录-数据-的操作" class="headerlink" title="15. 记录(数据)的操作"></a>15. 记录(数据)的操作</h1><h2 id="15-1-添加数据"><a href="#15-1-添加数据" class="headerlink" title="15.1 添加数据"></a>15.1 添加数据</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 给表插入一条数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">member</span>(id,nick_name,age,sex) <span class="keyword">VALUES</span>(<span class="number">1</span>,<span class="string">&#x27;小明&#x27;</span>,<span class="number">12</span>,<span class="string">&#x27;男&#x27;</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 批量插入数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">member</span>(id,nick_name,age,sex) <span class="keyword">VALUES</span>(<span class="number">4</span>,&quot;小短腿&quot;,<span class="number">10</span>,<span class="string">&#x27;男&#x27;</span>),(<span class="number">5</span>,<span class="string">&#x27;大胖&#x27;</span>,<span class="number">30</span>,<span class="string">&#x27;男&#x27;</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 骚操作(不指定字段全量插入)----&gt;一般不建议使用全量插入数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">member</span> <span class="keyword">VALUES</span>(<span class="keyword">NULL</span>,<span class="string">&#x27;小明&#x27;</span>,<span class="number">20</span>);</span><br><span class="line">或者</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">member</span> <span class="keyword">VALUES</span>(<span class="keyword">DEFAULT</span>,<span class="string">&#x27;小明&#x27;</span>,<span class="number">20</span>);</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="15-2-查询数据-简单查询"><a href="#15-2-查询数据-简单查询" class="headerlink" title="15.2 查询数据(简单查询)"></a>15.2 查询数据(简单查询)</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 最简单的查询语句</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">member</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询指定的字段</span></span><br><span class="line"><span class="keyword">SELECT</span> nick_name <span class="keyword">FROM</span> <span class="keyword">member</span>;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="15-3-修改数据"><a href="#15-3-修改数据" class="headerlink" title="15.3 修改数据"></a>15.3 修改数据</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 修改数据</span></span><br><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">member</span> <span class="keyword">SET</span> nick_name<span class="operator">=</span><span class="string">&#x27;小胖子&#x27;</span> <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="15-4-删除数据"><a href="#15-4-删除数据" class="headerlink" title="15.4 删除数据"></a>15.4 删除数据</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 删除数据</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> <span class="keyword">member</span> <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">2</span>;                               </span><br></pre></td></tr></table></figure>

<hr>
<h1 id="16-表和表之间关系"><a href="#16-表和表之间关系" class="headerlink" title="16. 表和表之间关系"></a>16. 表和表之间关系</h1><h2 id="16-1-一对一的关系"><a href="#16-1-一对一的关系" class="headerlink" title="16.1 一对一的关系"></a>16.1 一对一的关系</h2><p>例如: 一个会员表中的一条记录只对应我们身份证表中的一条记录</p>
<ul>
<li><p>我们如果设计数据库时出现了一对一的表应该尽量避免;我们只需要给字段多的一方的表<strong>添加额外的字段即可</strong></p>
</li>
<li><p>如果我们设计的时候**无法避免(考虑的优化为题)**一对一的设计,我们需要让两个表的主键进行对应</p>
</li>
<li><p>如果一个表中的字段的个数超过16个,<strong>强烈建议</strong>使用一对一的表的设计</p>
</li>
</ul>
<hr>
<h2 id="16-2-一对多的关系"><a href="#16-2-一对多的关系" class="headerlink" title="16.2 一对多的关系"></a>16.2 一对多的关系</h2><p>例如: 一个会员对应多个订单,而一个订单只对应一个会员(会员表和订单表)</p>
<ul>
<li><p><strong>子表</strong>：订单表</p>
</li>
<li><p>在多的一方的表(订单表)加一个字段<strong>对应一的一方的表中的主键</strong>,数据类型要保持一致</p>
</li>
<li><p>而且我们根据墨菲定律,还可以为其加一个约束条件(<strong>外键(FOREIGN KEY)</strong>)</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 在表创建之后添加外键</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 在多的一方的表中添加了一个字段</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> orders <span class="keyword">ADD</span> <span class="keyword">COLUMN</span> m_id <span class="type">INT</span> ;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 添加外键约束</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> orders <span class="keyword">ADD</span> <span class="keyword">FOREIGN</span> KEY orders(m_id)  <span class="keyword">REFERENCES</span> <span class="keyword">member</span>(id);</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> orders <span class="keyword">ADD</span> <span class="keyword">FOREIGN</span> KEY(m_id)  <span class="keyword">REFERENCES</span> <span class="keyword">member</span>(id);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 可以指定外键的名称</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> orders <span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> ifbk_orders_mid_merber <span class="keyword">FOREIGN</span> KEY(m_id)  <span class="keyword">REFERENCES</span> <span class="keyword">member</span>(id);</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建表的时候直接添加外键</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> orders(</span><br><span class="line">	id <span class="type">INT</span>  AUTO_INCREMENT COMMENT <span class="string">&#x27;订单ID&#x27;</span>,</span><br><span class="line">	number <span class="type">VARCHAR</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;订单编号&#x27;</span>,</span><br><span class="line">	address <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;订单的发货地址&#x27;</span>,</span><br><span class="line">	m_id <span class="type">INT</span>,	</span><br><span class="line">	<span class="keyword">PRIMARY</span> KEY(id),</span><br><span class="line">	<span class="keyword">FOREIGN</span> KEY(m_id) <span class="keyword">REFERENCES</span> <span class="keyword">member</span>(id)</span><br><span class="line">) COMMENT <span class="string">&#x27;订单表&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>注意:</strong></p>
<ul>
<li>创建一对多的表的时候,首先要创建一方对应的那个表</li>
<li><code>REFERENCES</code>：<strong>指定外键依赖的表及对应的列</strong>，并且该列为该表的主键</li>
<li>我们为了数据的安全性,我们会把<strong>多方中的参照的字段设置为外键,而且类型要和一方中的主键保持一致</strong></li>
<li><strong>一般我们在商业项目中,尽量不要使用外键(等会解释)</strong></li>
</ul>
<hr>
<h2 id="16-3-多对多的关系"><a href="#16-3-多对多的关系" class="headerlink" title="16.3 多对多的关系"></a>16.3 多对多的关系</h2><blockquote>
<p>思想: 借助一个额外的表,实现多对多关系</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建商品表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> shop(</span><br><span class="line">	id <span class="type">INT</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;主键&#x27;</span>,</span><br><span class="line">	shop_name <span class="type">VARCHAR</span>(<span class="number">255</span>) COMMENT <span class="string">&#x27;商品名称&#x27;</span>,</span><br><span class="line">	stock <span class="type">INT</span> UNSIGNED COMMENT <span class="string">&#x27;商品库存&#x27;</span>,</span><br><span class="line">	<span class="keyword">PRIMARY</span> KEY(id)</span><br><span class="line">) COMMENT <span class="string">&#x27;商品表&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> member_shop;</span><br><span class="line"><span class="comment">-- 创建第三方的表(member_shop)</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>  member_shop(</span><br><span class="line">	m_id <span class="type">INT</span> COMMENT <span class="string">&#x27;参照member中的id&#x27;</span>,</span><br><span class="line">	s_id <span class="type">INT</span> COMMENT <span class="string">&#x27;参照shop中的id&#x27;</span>,</span><br><span class="line">	<span class="keyword">FOREIGN</span> KEY(m_id) <span class="keyword">REFERENCES</span> <span class="keyword">member</span>(id),</span><br><span class="line">	<span class="keyword">FOREIGN</span> KEY(s_id) <span class="keyword">REFERENCES</span> shop(id)</span><br><span class="line">) ENGINE<span class="operator">=</span>INNODB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 COMMENT <span class="string">&#x27;第三方的表&#x27;</span>;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="17-mysql的多字段查询"><a href="#17-mysql的多字段查询" class="headerlink" title="17. mysql的多字段查询"></a>17. mysql的多字段查询</h1><blockquote>
<p>select * 这种方式不建议使用,我们只查询需要的字段,select * 这种方式对性能有影响</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询多个字段</span></span><br><span class="line"><span class="keyword">SELECT</span> nick_name,age <span class="keyword">FROM</span> <span class="keyword">member</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询字段并且指定字段的别名</span></span><br><span class="line"><span class="keyword">SELECT</span> nick_name <span class="keyword">AS</span> nname,age <span class="keyword">FROM</span> <span class="keyword">member</span>;</span><br><span class="line"><span class="keyword">SELECT</span> nick_name  nname,age <span class="keyword">FROM</span> <span class="keyword">member</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 这才是一条完整的sql语句,我们在实际的开发中不会写这个多的东西,会省略一些东西(库名,字段的别名,表的别名...),sql的执行引擎会帮我们进行词法和语法的补全</span></span><br><span class="line"><span class="keyword">SELECT</span> db3.member.nick_name <span class="keyword">AS</span> nick_name,db3.member.age <span class="keyword">AS</span> age <span class="keyword">FROM</span> db3.member <span class="keyword">AS</span> <span class="keyword">member</span>;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="18-mysql中的排序"><a href="#18-mysql中的排序" class="headerlink" title="18. mysql中的排序"></a>18. mysql中的排序</h1><blockquote>
<p>ORDER BY col_name ASC|DESC</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 不指定任何的排序字段的情况下,默认是按主键的升序排列的</span></span><br><span class="line"><span class="keyword">SELECT</span> id,nick_name,age <span class="keyword">FROM</span> <span class="keyword">member</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 指定按age来排序(默认是升序)</span></span><br><span class="line"><span class="keyword">SELECT</span> id,nick_name,age <span class="keyword">FROM</span> <span class="keyword">member</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> age ;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 指定按age的降序进行排序</span></span><br><span class="line"><span class="keyword">SELECT</span> id,nick_name,age <span class="keyword">FROM</span> <span class="keyword">member</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> age <span class="keyword">DESC</span> ;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="19-mysql中的分组查询"><a href="#19-mysql中的分组查询" class="headerlink" title="19. mysql中的分组查询"></a>19. mysql中的分组查询</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建学生表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> student(</span><br><span class="line">    id <span class="type">INT</span> AUTO_INCREMENT,</span><br><span class="line">    sname <span class="type">VARCHAR</span>(<span class="number">64</span>),</span><br><span class="line">    age TINYINT UNSIGNED,</span><br><span class="line">    grade <span class="type">VARCHAR</span>(<span class="number">32</span>),</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY(id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询grade字段不为NULL的总记录数</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(grade) <span class="keyword">FROM</span> student ;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询每个班级及其班级的总人数</span></span><br><span class="line"><span class="keyword">SELECT</span> grade, <span class="built_in">COUNT</span>(grade) <span class="keyword">FROM</span> student <span class="keyword">GROUP</span> <span class="keyword">BY</span>(grade);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- HAVING 是对分组后的数据进行条件过滤</span></span><br><span class="line"><span class="keyword">SELECT</span> grade, <span class="built_in">COUNT</span>(grade) <span class="keyword">FROM</span> student <span class="keyword">GROUP</span> <span class="keyword">BY</span>(grade) <span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(grade)<span class="operator">&gt;</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询年龄age&gt;25的,班级及其班级里面的人数  WHERE 是对分组之前的数据进行筛选</span></span><br><span class="line"><span class="keyword">SELECT</span> grade,<span class="built_in">COUNT</span>(grade) <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age<span class="operator">&gt;</span><span class="number">25</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span>(grade) ;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询年龄age&gt;25的,班级人数&gt;1的,班级及其班级里面的人数</span></span><br><span class="line"><span class="keyword">SELECT</span> grade,<span class="built_in">COUNT</span>(grade) <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age<span class="operator">&gt;</span><span class="number">25</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span>(grade) <span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(grade)<span class="operator">&gt;</span><span class="number">1</span> ;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="20-mysql中的分页查询"><a href="#20-mysql中的分页查询" class="headerlink" title="20. mysql中的分页查询"></a>20. mysql中的分页查询</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">limit</span><br><span class="line"><span class="comment">-- 用来限定查询结果的起始行和总行数的。</span></span><br><span class="line"><span class="comment">-- 用来实现分页查询</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">ORDER</span> <span class="keyword">BY</span> id LIMIT <span class="number">0</span>,<span class="number">3</span>;</span><br><span class="line"><span class="comment">-- 0表示从第一条数据开始，3表示查询3条数据</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">ORDER</span> <span class="keyword">BY</span> id LIMIT <span class="number">3</span>,<span class="number">3</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">ORDER</span> <span class="keyword">BY</span> id LIMIT <span class="number">6</span>,<span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<h1 id="21-查询小结"><a href="#21-查询小结" class="headerlink" title="21. 查询小结"></a>21. 查询小结</h1><p><strong>基本查询语句的书写顺序和执行顺序</strong></p>
<ul>
<li><p>书写顺序：</p>
<p><code>select-from-where-group by-having-order by-limit;</code></p>
</li>
<li><p>执行顺序：</p>
<p><code>from-where-group by-having-select-order by-limit;</code></p>
</li>
</ul>
<h1 id="22-AND和OR"><a href="#22-AND和OR" class="headerlink" title="22. AND和OR"></a>22. AND和OR</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- and代表两个添加都成立</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">member</span> <span class="keyword">WHERE</span>  age<span class="operator">&gt;</span><span class="number">25</span> <span class="keyword">AND</span> sex<span class="operator">=</span><span class="string">&#x27;女&#x27;</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- or其中只要有一个成立则查出来</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">member</span> <span class="keyword">WHERE</span>  age<span class="operator">&gt;</span><span class="number">25</span> <span class="keyword">OR</span> sex<span class="operator">=</span><span class="string">&#x27;女&#x27;</span> </span><br></pre></td></tr></table></figure>

<hr>
<h1 id="23-IN和NOT-IN"><a href="#23-IN和NOT-IN" class="headerlink" title="23. IN和NOT IN"></a>23. IN和NOT IN</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 多个OR连接并不是很方便</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">member</span> <span class="keyword">WHERE</span> age <span class="operator">=</span> <span class="number">30</span> <span class="keyword">OR</span> age<span class="operator">=</span><span class="number">40</span> <span class="keyword">OR</span> age<span class="operator">=</span><span class="number">50</span> <span class="keyword">OR</span> age<span class="operator">=</span><span class="number">45</span> ;</span><br><span class="line"><span class="comment">-- 使用IN进行匹配,达到上面OR的效果</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">member</span> <span class="keyword">WHERE</span> age <span class="keyword">IN</span>(<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>,<span class="number">45</span>) ;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 多个AND连接不方便</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">member</span> <span class="keyword">WHERE</span> age <span class="operator">!=</span> <span class="number">30</span> <span class="keyword">AND</span> age<span class="operator">!=</span><span class="number">40</span> <span class="keyword">AND</span> age<span class="operator">!=</span><span class="number">50</span> <span class="keyword">AND</span> age<span class="operator">!=</span><span class="number">45</span> ;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">member</span> <span class="keyword">WHERE</span> age <span class="keyword">NOT</span> <span class="keyword">IN</span>(<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>,<span class="number">45</span>) ;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="24-BETWEEN…AND"><a href="#24-BETWEEN…AND" class="headerlink" title="24. BETWEEN…AND"></a>24. BETWEEN…AND</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询指定区域内的数据</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">member</span> <span class="keyword">WHERE</span> age<span class="operator">&gt;=</span><span class="number">30</span> <span class="keyword">AND</span> age<span class="operator">&lt;=</span><span class="number">40</span></span><br><span class="line"><span class="comment">-- 也可以使用BETWEEN...and来代替</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">member</span> <span class="keyword">WHERE</span> age <span class="keyword">BETWEEN</span> <span class="number">30</span> <span class="keyword">AND</span> <span class="number">40</span>;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="23-NOT-BETWEEN…AND"><a href="#23-NOT-BETWEEN…AND" class="headerlink" title="23. NOT BETWEEN…AND"></a>23. NOT BETWEEN…AND</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">member</span> <span class="keyword">WHERE</span> age<span class="operator">&lt;</span><span class="number">30</span> <span class="keyword">OR</span> age<span class="operator">&gt;</span><span class="number">40</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">member</span> <span class="keyword">WHERE</span> age <span class="keyword">NOT</span> <span class="keyword">BETWEEN</span> <span class="number">30</span> <span class="keyword">AND</span> <span class="number">40</span>;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="26-mysql的子查询"><a href="#26-mysql的子查询" class="headerlink" title="26. mysql的子查询"></a>26. mysql的子查询</h1><p>把一个查询的结果当成另一个查询的条件进行使用</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询小花购买过的全部的商品</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">  <span class="operator">*</span> </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">  member_shop </span><br><span class="line"><span class="keyword">WHERE</span> m_id <span class="operator">=</span> </span><br><span class="line">  (<span class="keyword">SELECT</span> </span><br><span class="line">    id</span><br><span class="line">  <span class="keyword">FROM</span></span><br><span class="line">    <span class="keyword">member</span> </span><br><span class="line">  <span class="keyword">WHERE</span> nick_name <span class="operator">=</span> <span class="string">&#x27;小花&#x27;</span>)</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="27-多表查询"><a href="#27-多表查询" class="headerlink" title="27. 多表查询"></a>27. 多表查询</h1><h2 id="合并结果集"><a href="#合并结果集" class="headerlink" title="合并结果集"></a>合并结果集</h2><ul>
<li><p><strong>去重：union</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> aa(</span><br><span class="line">	id <span class="type">INT</span>,</span><br><span class="line">	NAME <span class="type">VARCHAR</span>(<span class="number">10</span>)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> aa <span class="keyword">VALUES</span>(<span class="number">1</span>,<span class="string">&#x27;aaa&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> aa <span class="keyword">VALUES</span>(<span class="number">2</span>,<span class="string">&#x27;bbb&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> aa <span class="keyword">VALUES</span>(<span class="number">3</span>,<span class="string">&#x27;ccc&#x27;</span>);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> bb(</span><br><span class="line">	id <span class="type">INT</span>,</span><br><span class="line">	NAME <span class="type">VARCHAR</span>(<span class="number">10</span>)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> bb <span class="keyword">VALUES</span>(<span class="number">1</span>,<span class="string">&#x27;aaa&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> bb <span class="keyword">VALUES</span>(<span class="number">2</span>,<span class="string">&#x27;bbb&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> bb <span class="keyword">VALUES</span>(<span class="number">4</span>,<span class="string">&#x27;ddd&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> aa <span class="keyword">UNION</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> bb;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>不去重：union all</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> aa <span class="keyword">UNION</span> <span class="keyword">ALL</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> bb;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="多表连接查询"><a href="#多表连接查询" class="headerlink" title="多表连接查询"></a>多表连接查询</h2><p><strong>使用关联关系可以去除无用笛卡尔积</strong></p>
<ul>
<li><p><strong>内连接(显式内连接)</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询小花下过的订单(使用多表连接进行查询)  笛卡尔积</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">  member.id m_id,</span><br><span class="line">  member.nick_name,</span><br><span class="line">  orders.`address`,</span><br><span class="line">  orders.`create_time` </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">  <span class="keyword">member</span> <span class="keyword">INNER</span> <span class="keyword">JOIN</span> orders </span><br><span class="line"><span class="keyword">ON</span> member.id <span class="operator">=</span> orders.m_id </span><br><span class="line"><span class="keyword">WHERE</span> member.nick_name <span class="operator">=</span> <span class="string">&#x27;小花&#x27;</span> ;</span><br></pre></td></tr></table></figure>

<p>注意:我们使用内连接的时候可以省略<code>INNER JOIN</code>,使<code>逗号</code>在多个表之间进行连接(隐式连接),连接条件也要使用<code>WHERE</code>关键系代替<code>ON</code>关键字</p>
<p>隐式连接的<strong>语法不太友好</strong>,简单的多个表之间的查询可以使用,但是复杂的sql就不建议使用<code>隐式连接</code></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询小花下过的订单(使用多表连接进行查询)  笛卡尔积</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">  m.id  m_id,</span><br><span class="line">  m.nick_name,</span><br><span class="line">  o.`address`,</span><br><span class="line">  o.`create_time`</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">  <span class="keyword">member</span> m,</span><br><span class="line">  orders o</span><br><span class="line"><span class="keyword">WHERE</span> m.id <span class="operator">=</span> o.m_id </span><br><span class="line">  <span class="keyword">AND</span> m.nick_name <span class="operator">=</span> <span class="string">&#x27;小花&#x27;</span> ;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>外链接 outer join on</strong></p>
<ul>
<li><p><strong>左外连接 left outer join</strong></p>
<p>特点：<strong>查询的结果存在不满足条件等式的可能性</strong>。</p>
<p>以<strong>左边的表为主表</strong>，先查询左表中的所有内容，然后在查询右表，<strong>右表满足条件的显示，不满足条件的显示为null</strong>。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">  member.id m_id,</span><br><span class="line">  member.nick_name,</span><br><span class="line">  orders.`address`,</span><br><span class="line">  orders.`create_time` </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line"><span class="keyword">member</span> <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> orders </span><br><span class="line"><span class="keyword">ON</span> member.id <span class="operator">=</span> orders.m_id </span><br><span class="line"><span class="keyword">AND</span> member.nick_name <span class="operator">=</span> <span class="string">&#x27;小花&#x27;</span> ;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>右外连接 right outer join</strong>(不建议使用,因为可以直接转换为左外链接)</p>
</li>
</ul>
</li>
<li><p><strong>自然链接   natural join</strong></p>
<ul>
<li><p>链接查询会产生笛卡尔积，可以使用主外键关系等式去除笛卡尔积。自然链接，我们不需要自己给出主外键关系等式，它会自己找到。自动拿2个表中名字和类型一样的列作为条件。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">NATURAL</span> <span class="keyword">JOIN</span> dept;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">NATURAL</span> <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> dept;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">NATURAL</span> <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> dept;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<hr>
<h1 id="28-多表的连接的商业项目使用建议"><a href="#28-多表的连接的商业项目使用建议" class="headerlink" title="28. 多表的连接的商业项目使用建议"></a>28. 多表的连接的商业项目使用建议</h1><ul>
<li>多表连接时尽量使用<strong>显式连接</strong>,因为显式连接的sql的语义明确</li>
<li>生产环境建议表的联查个数不要超过3张表(可以是3张)</li>
<li>如果3张表的联查还不能解决你的问题,那么你就需要在<strong>业务层面解决</strong>或者是<strong>数据库设计缺陷</strong></li>
<li><strong>在项目中不建议使用外键</strong>,我们完全可以在业务层保证数据的安全性;<ul>
<li>数据库本质的作用是用来存储数据,而不是进行数据约束的;因为外键会造成我们数据源库迁移的灾难;</li>
</ul>
</li>
</ul>
<hr>
<h1 id="29-级联删除与级联更新"><a href="#29-级联删除与级联更新" class="headerlink" title="29. 级联删除与级联更新"></a>29. 级联删除与级联更新</h1><p>外键的级联删除：如果父表中的记录被删除，则子表中对应的记录自动被删除</p>
<p>父表——被外键引用的表</p>
<p>子表——引用父表中的主键作为外键的表</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- ON DELETE CASCADE  级联删除</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> orders <span class="keyword">ADD</span> <span class="keyword">FOREIGN</span> KEY(`m_id`) <span class="keyword">REFERENCES</span> <span class="keyword">member</span>(`id`) <span class="keyword">ON</span> <span class="keyword">DELETE</span> CASCADE ;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- ON UPDATE CASCADE  级联更新</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> orders <span class="keyword">ADD</span> <span class="keyword">FOREIGN</span> KEY(`m_id`) <span class="keyword">REFERENCES</span> <span class="keyword">member</span>(`id`)  <span class="keyword">ON</span> <span class="keyword">UPDATE</span> CASCADE;</span><br></pre></td></tr></table></figure>

<p>当然级联更新和级联删除时可以同时设置的</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> orders <span class="keyword">ADD</span> <span class="keyword">FOREIGN</span> KEY (`m_id`) <span class="keyword">REFERENCES</span> <span class="keyword">member</span> (`id`) </span><br><span class="line"><span class="keyword">ON</span> <span class="keyword">DELETE</span> CASCADE  <span class="keyword">ON</span> <span class="keyword">UPDATE</span> CASCADE;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>也可以借助可视化工具进行修改级联删除和级联更新</p>
</blockquote>
<hr>
<h1 id="30-mysql中的分隔符-定界符"><a href="#30-mysql中的分隔符-定界符" class="headerlink" title="30. mysql中的分隔符(定界符)"></a>30. mysql中的分隔符(定界符)</h1><p>mysql中默认的分割符是 <code>;</code>  也就是说遇到 <code>;</code> 就会立即执行sql</p>
<p>在<strong>函数存储过程</strong>这些特性中需要写多个sql组成一个整体,当成整体来执行,而这些特性中,一条一条的语句之间语法规定必须用<code>;</code>来分开</p>
<p>所以我们要创建函数 存储过程 必须先要把默认的分隔符 <code>;</code>替换成其他的符号;</p>
<p><strong>在会话中替换默认的分隔符,使用下面语句</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER $$  </span><br></pre></td></tr></table></figure>

<hr>
<h1 id="31-mysql中的函数"><a href="#31-mysql中的函数" class="headerlink" title="31. mysql中的函数"></a>31. mysql中的函数</h1><p>函数:在编程中函数其实就是一段业务的封装</p>
<p>mysql中的函数: 对多个sql业务的封装,<strong>避免反复的进行词法和语法分析</strong></p>
<h2 id="31-1-系统函数"><a href="#31-1-系统函数" class="headerlink" title="31.1 系统函数"></a>31.1 系统函数</h2><p>mysql系统帮我们定义的函数</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询mysql系统当前时间</span></span><br><span class="line"><span class="keyword">SELECT</span> NOW();</span><br><span class="line"><span class="comment">-- 查询当前mysql的版本</span></span><br><span class="line"><span class="keyword">SELECT</span> VERSION();</span><br><span class="line"><span class="comment">-- 查询当前所在的数据库</span></span><br><span class="line"><span class="keyword">SELECT</span> DATABASE();</span><br><span class="line"><span class="comment">-- 查询当前登录mysql的用户和主机</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">USER</span>();</span><br><span class="line"><span class="comment">-- 获取一个字符串对应的md5值</span></span><br><span class="line"><span class="keyword">SELECT</span> MD5(&quot;HELLO&quot;);</span><br><span class="line"><span class="comment">-- 查询去重</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> university <span class="keyword">from</span> user_profile;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="31-2-聚合函数"><a href="#31-2-聚合函数" class="headerlink" title="31.2 聚合函数"></a>31.2 聚合函数</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 统计某个字段的记录数</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(`age`) <span class="keyword">FROM</span> student;</span><br><span class="line"><span class="comment">-- 查询某个字段的最大值</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MAX</span>(age) <span class="keyword">FROM</span> student;</span><br><span class="line"><span class="comment">-- 查询某个字段的最小值</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MIN</span>(age) <span class="keyword">FROM</span> student;</span><br><span class="line"><span class="comment">-- 查询某个字段的平均值</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">AVG</span>(age) <span class="keyword">FROM</span> student;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="31-3-数学函数"><a href="#31-3-数学函数" class="headerlink" title="31.3 数学函数"></a>31.3 数学函数</h2><p>数学函数主要用于处理数字，包括整型、浮点数等。</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/873abdbc9f3e48afb773d6f1a43cc9b2.png" alt="img"></p>
<h2 id="31-4-字符串函数"><a href="#31-4-字符串函数" class="headerlink" title="31.4 字符串函数"></a>31.4 字符串函数</h2><p>字符串函数是MySQL中最常用的一类函数，字符串函数主要用于处理表中的字符串。</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/b9ae4e4455ab4bdfb6376f9340079471.png" alt="img"></p>
<h2 id="31-5-日期时间函数"><a href="#31-5-日期时间函数" class="headerlink" title="31.5 日期时间函数"></a>31.5 日期时间函数</h2><p>MySQL的日期和时间函数主要用于处理日期时间。</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/1cd4478fee414b94adeb284222be5dc7.png" alt="img"></p>
<h2 id="31-6-条件判断函数"><a href="#31-6-条件判断函数" class="headerlink" title="31.6 条件判断函数"></a>31.6 条件判断函数</h2><p>条件判断函数用来在SQL语句中进行条件判断。根据是否满足判断条件，SQL语句执行不同的分支。例如,从员工表中查询员工的业绩。如果业绩高于指定值n,则输出good;否则，输出bad。下面是各种条件判断函数的表达式、作用和使用方法。</p>
<ul>
<li><p><strong>IF(expr,v1,v2)函数</strong></p>
<p>IF(expr,vl,v2)函数中，如果表达式expr成立，返回结果v1;否则，返回结果v2。</p>
</li>
<li><p><strong>IFNULL(v1,v2)函数</strong></p>
<p>IFNULL(v1,v2)函数中，如果v1的值不为空，就显示v1的值;否则就显示v2的值。</p>
</li>
<li><p><strong>CASE函数</strong></p>
<ul>
<li><p><strong>CASE WHEN expr1 THEN v1 [WHEN expr2 THEN v2…] [ELSE vn] END</strong></p>
<p>CASE WHEN exprl THEN v1 [WHEN expr2 THEN v2…] [ELSE vn] END函数中，CASE表示函数开始，END表示函数结束。如果表达式expr1成立时，返回v1的值。如果表达式expr2成立时，返回v2的值。依次类推，最后遇到ELSE时，返回vn 的值。</p>
</li>
<li><p><strong>CASE expr WHEN e1 THEN v1 [WHEN e2 THEN v2…] [ELSE vn] END</strong></p>
<p>CASE expr WHEN e1 THEN v1 [WHEN e2 THEN v2…] [ELSE vn] END 函数中，如果表达式expr取值等于e1时,返回v1的值。如果表达式expr取值等于e2时，返回v2的值。依次类推，最后遇到ELSE时，返回vn的值。CASE表示函数开始，END表示函数结束。</p>
</li>
</ul>
</li>
</ul>
<h2 id="31-7-自定义函数-了解"><a href="#31-7-自定义函数-了解" class="headerlink" title="31.7 自定义函数(了解)"></a>31.7 自定义函数(了解)</h2><p>我们自己编写的函数</p>
<ul>
<li>函数的参数</li>
<li>返回值</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- 函数的可以返回任意类型的值,也可以接受任意类型的值为参数</span><br><span class="line">- 函数的返回值和参数没有必然联系的</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> 函数名称(参数名称 参数类型) <span class="keyword">RETURNS</span> 返回值类型</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	函数语句 #函数语句只有一条时,可以省略<span class="keyword">BEGIN</span>和<span class="keyword">END</span></span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 首先创建函数之前一定要先修改其定界符,要不然遇到函数中的第一个;就会执行报错</span></span><br><span class="line">DELIMITER $$</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> MYADD (a <span class="type">INT</span>,b <span class="type">INT</span>) <span class="keyword">RETURNS</span> <span class="type">INT</span> </span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">  <span class="keyword">DECLARE</span> i <span class="type">INT</span> ; <span class="comment">-- 变量的定义</span></span><br><span class="line">  <span class="keyword">SET</span> i <span class="operator">=</span> a<span class="operator">+</span>b ; <span class="comment">-- 给变量设置值</span></span><br><span class="line">  <span class="keyword">RETURN</span> i ;  <span class="comment">-- 返回数据</span></span><br><span class="line"><span class="keyword">END</span> $$</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> MYADD(<span class="number">12</span>,<span class="number">22</span>); <span class="comment">-- 函数的调用</span></span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建自定义函数</span></span><br><span class="line">DELIMITER $$</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> STUAGEGTCOUNT (a <span class="type">INT</span>) <span class="keyword">RETURNS</span> <span class="type">BIGINT</span> </span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">   <span class="keyword">DECLARE</span> c <span class="type">BIGINT</span>;</span><br><span class="line">   <span class="keyword">SET</span> c<span class="operator">=</span>(<span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age<span class="operator">&gt;</span>a);</span><br><span class="line">   <span class="keyword">RETURN</span> c;</span><br><span class="line"><span class="keyword">END</span> $$</span><br><span class="line"><span class="comment">-- 调用自定义函数</span></span><br><span class="line"><span class="keyword">SELECT</span> STUAGEGTCOUNT(<span class="number">30</span>);</span><br></pre></td></tr></table></figure>

<p><strong>函数的调用</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 函数名称(实参列表);</span><br></pre></td></tr></table></figure>

<p><strong>删除函数</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">FUNCTION</span> [IF <span class="keyword">EXISTS</span>]  `MYADD`</span><br></pre></td></tr></table></figure>

<p><strong>自定义函数可能出现错误:</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">错误代码： <span class="number">1418</span></span><br><span class="line">This <span class="keyword">function</span> has <span class="keyword">none</span> <span class="keyword">of</span> <span class="keyword">DETERMINISTIC</span>, <span class="keyword">NO</span> <span class="keyword">SQL</span>, <span class="keyword">or</span> <span class="keyword">READS</span> <span class="keyword">SQL</span> DATA <span class="keyword">in</span> its declaration <span class="keyword">and</span> <span class="type">binary</span> logging <span class="keyword">is</span> enabled (you <span class="operator">*</span>might<span class="operator">*</span> want <span class="keyword">to</span> use the less safe log_bin_trust_function_creators variable)</span><br></pre></td></tr></table></figure>

<p><strong>原因</strong>：mysql在新版本中添加<strong>函数保护器</strong>,默认如果不进行配置,则无法创建自定义函数,我们需要在当前会话中把函数保护器关掉,尽量不要在全局(系统的配置文件)关闭函数保护器;</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看函数保护器的状态</span></span><br><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> &quot;%log_bin_trust_function_creators%&quot;</span><br><span class="line">	<span class="comment">-- OFF:不能创建自定义函数(保护器处于开启状态)</span></span><br><span class="line">	<span class="comment">-- ON:能创建自定义函数(保护器关闭)</span></span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 允许创建自定义函数</span></span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> log_bin_trust_function_creators<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>经过上面的设置我们就可以正常的创建自定义函数了;</p>
<hr>
<h1 id="32-mysql存储过程-了解"><a href="#32-mysql存储过程-了解" class="headerlink" title="32. mysql存储过程(了解)"></a>32. mysql存储过程(了解)</h1><h2 id="32-1-sql语句的执行流程"><a href="#32-1-sql语句的执行流程" class="headerlink" title="32.1 sql语句的执行流程"></a>32.1 sql语句的执行流程</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sql</span>语句<span class="comment">---&gt;sql执行优化器(编译)---&gt;词法分析,语法分析---&gt;sql优化---&gt;运行sql(读取数据)--&gt;结果</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="32-2-什么是存储过程"><a href="#32-2-什么是存储过程" class="headerlink" title="32.2 什么是存储过程?"></a>32.2 什么是存储过程?</h2><p>sql语句的编译的集合,以名称来存储,合并为一个单元处理;</p>
<p>如果在实现用户的某些需求时，需要编写一组复杂的SQL语句才能实现的时候，那么我们就可以将这组复杂的SQL语句集提前编写在数据库中，由JDBC调用来执行这组SQL语句。</p>
<p>把编写在数据库中的SQL语句集称为存储过程。</p>
<p>存储过程就类似于Java中的方法，需要先定义，使用时需要调用。存储过程可以定义参数，参数分为<code>IN、OUT、INOUT</code>类型三种类型。</p>
<ol>
<li>IN类型的参数表示接受调用者传入的数据；</li>
<li>OUT类型的参数表示向调用者返回数据；</li>
<li>INOUT类型的参数即可以接受调用者传入的参数，也可以向调用者返回数据。</li>
</ol>
<hr>
<h2 id="32-3-存储过程的特点"><a href="#32-3-存储过程的特点" class="headerlink" title="32.3 存储过程的特点"></a>32.3 存储过程的特点</h2><p><strong>优点</strong></p>
<ul>
<li>实现较快的执行速度(避免重复的编译,词法分析,语法分析等操作)</li>
<li>减少网络流量，<strong>减少应用程序和数据库服务器之间的流量</strong>。</li>
<li>存储的程序是<strong>安全的</strong>。数据库管理员是可以向访问数据库中存储过程的应用程序授予适当的权限，而不是向基础数据库表提供任何权限。</li>
<li><strong>简化对变动的管理</strong>。如果表名、列名、或业务逻辑有了变化。只需要更改存储过程的代码。使用它的人不用更改自己的代码。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>如果使用大量的存储过程，那么使用这些存储过程的每个连接的内存使用量将大大增加。此外，如果在存储过程中过度使用大量的逻辑操作，那么CPU的使用率也在增加，因为MySQL数据库最初的设计就侧重于高效的查询，而不是逻辑运算。</li>
<li>存储过程的构造使得开发具有了复杂的业务逻辑的存储过程变得困难。</li>
<li>很难调试存储过程。只有少数数据库管理系统允许调试存储过程。不幸的是，MySQL不提供调试存储过程的功能。</li>
<li>开发和维护存储过程都不容易。开发和维护存储过程通常需要一个不是所有应用程序开发人员拥有的专业技能。这可能导致应用程序开发和维护阶段的问题。</li>
<li><strong>对数据库依赖程度较高，移值性差</strong>。</li>
</ul>
<hr>
<h2 id="32-4-存储过程的语法"><a href="#32-4-存储过程的语法" class="headerlink" title="32.4 存储过程的语法"></a>32.4 存储过程的语法</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建存储过程</span></span><br><span class="line">DELIMITER $$</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> proc2 (a <span class="type">INT</span>) </span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">  <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age<span class="operator">&gt;</span>a;</span><br><span class="line">  <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">member</span>;</span><br><span class="line"><span class="keyword">END</span> $$</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 调用存储过程</span></span><br><span class="line"><span class="keyword">CALL</span> proc2(<span class="number">20</span>)</span><br></pre></td></tr></table></figure>

<h2 id="32-5-删除存储过程"><a href="#32-5-删除存储过程" class="headerlink" title="32.5 删除存储过程"></a>32.5 删除存储过程</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span> proc1;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="33-mysql函数和存储过程对比"><a href="#33-mysql函数和存储过程对比" class="headerlink" title="33. mysql函数和存储过程对比"></a>33. mysql函数和存储过程对比</h1><ul>
<li><p>存储过程和函数都是为了提高<strong>程序的运行效率</strong>和<strong>减少网络带宽</strong>而存在的</p>
</li>
<li><p>存储过程可以实现相对复杂的功能,而函数针对性比较强</p>
</li>
<li><p>存储过程可以返回多个值(无需<code>return</code>关键字),函数只能有一个返回值</p>
</li>
<li><p><strong>在实际商业项目中尽量不要使用存储过程和自定义函数</strong></p>
</li>
</ul>
<hr>
<h1 id="34-mysql中的视图-了解"><a href="#34-mysql中的视图-了解" class="headerlink" title="34. mysql中的视图(了解)"></a>34. mysql中的视图(了解)</h1><p>视图其实就是一个虚拟表,这虚拟表可以存储我们查询的结果,方便我们进行二次查询,提升查询效率;查询的时候就可以像使用表一样用视图;</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建视图(View)</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> myStudentView <span class="keyword">AS</span> (<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age<span class="operator">&gt;</span><span class="number">20</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询视图的数据(可以把视图当成表来使用)</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> myStudentView;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 删除视图</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">VIEW</span> myStudentView;</span><br></pre></td></tr></table></figure>

<p><strong>注意: 视图是依赖表而存在的,如果表被删除了,视图就无效了;</strong></p>
<hr>
<h1 id="35-mysql中的触发器-了解"><a href="#35-mysql中的触发器-了解" class="headerlink" title="35. mysql中的触发器(了解)"></a>35. mysql中的触发器(了解)</h1><p>触发器(trigger)：监听事件,并触发某操作</p>
<p>触发器的四要素:</p>
<ul>
<li>监视地点(table)</li>
<li>监视事件(insert&#x2F;update&#x2F;delete)</li>
<li>触发时机(after&#x2F;before)</li>
<li>触发事件(insert&#x2F;update&#x2F;delete)</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建班级表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> grade (</span><br><span class="line">  id <span class="type">INT</span> AUTO_INCREMENT,</span><br><span class="line">  gname <span class="type">VARCHAR</span> (<span class="number">64</span>),</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY(id)</span><br><span class="line">);</span><br><span class="line"><span class="comment">-- 创建学生表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> student (</span><br><span class="line">  id <span class="type">INT</span> AUTO_INCREMENT,</span><br><span class="line">  nickname <span class="type">VARCHAR</span> (<span class="number">64</span>),</span><br><span class="line">  age TINYINT UNSIGNED,</span><br><span class="line">  g_id TINYINT UNSIGNED,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY(id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>需求: 我们删除班级,实现自动删除班级对应的学生 </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建触发器</span></span><br><span class="line">DELIMITER $$</span><br><span class="line"><span class="comment">-- 触发地点:grade  监听事件: delete  触发时机: before  触发事件:delete</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> `tigger1` BEFORE <span class="keyword">DELETE</span> <span class="keyword">ON</span> `grade` </span><br><span class="line">    <span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span> </span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"> <span class="keyword">DELETE</span> <span class="keyword">FROM</span> student; </span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line">$$</span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="36-mysql中的存储引擎"><a href="#36-mysql中的存储引擎" class="headerlink" title="36. mysql中的存储引擎"></a>36. mysql中的存储引擎</h1><p>mysql可以将数据以不同的技术存储在文件或者(内存)中,这种技术叫存储引擎;</p>
<p>每种存储引擎都有不同的<strong>存储机制,索引技术,表锁定技术</strong>,最终应用的场景各不相同,但是现在最主流的mysql的存储引擎用的对多的还是<code>INNODB</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 查询数据库支持哪些存储引擎</span><br><span class="line">show enginess \G;</span><br><span class="line">-- 查询数据库默认的存储引擎</span><br><span class="line">show variables like &#x27;%storage_engine%&#x27;;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">存储引擎</th>
<th align="center">MYISAM</th>
<th align="center">INNODB</th>
<th align="center">MEMORY</th>
</tr>
</thead>
<tbody><tr>
<td align="center">存储限制</td>
<td align="center">256TB</td>
<td align="center">64TB</td>
<td align="center">有限制</td>
</tr>
<tr>
<td align="center"><strong>事务安全性</strong></td>
<td align="center">NO</td>
<td align="center"><strong>YES</strong></td>
<td align="center">NO</td>
</tr>
<tr>
<td align="center"><strong>支持索引</strong></td>
<td align="center">YES</td>
<td align="center"><strong>YES</strong></td>
<td align="center">YES</td>
</tr>
<tr>
<td align="center">数据压缩</td>
<td align="center">YES</td>
<td align="center">NO</td>
<td align="center">NO</td>
</tr>
<tr>
<td align="center"><strong>是否支持外键</strong></td>
<td align="center">NO</td>
<td align="center"><strong>YES</strong></td>
<td align="center">NO</td>
</tr>
</tbody></table>
<blockquote>
<p>如果没有特殊要求,在互联网项目中,INNODB存储引擎是我们首选;</p>
</blockquote>
<hr>
<h1 id="37-执行mysql的脚本"><a href="#37-执行mysql的脚本" class="headerlink" title="37.  执行mysql的脚本"></a>37.  执行mysql的脚本</h1><ul>
<li><p>登录mysql之后执行sql脚本</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source sqlpath</span><br></pre></td></tr></table></figure>
</li>
<li><p>登录mysql时候直接执行sql脚本</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot -p &lt;sqlpath</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用可视化工具备份和还原(推荐做法)</strong></p>
</li>
</ul>
<hr>
<h1 id="38-Mysql管理工具"><a href="#38-Mysql管理工具" class="headerlink" title="38. Mysql管理工具"></a>38. Mysql管理工具</h1><ul>
<li>Workbench(mysql官方推荐使用的)  免费的 跨平台的 </li>
<li>Sequel Pro 只在mac端有</li>
<li>HeidiSQL(免费  开源)</li>
<li>phpMyAdmin(web应用)</li>
<li>mysqlfont(免费  轻量级) 只有windows端有,对高分辨率屏支持不好</li>
<li><strong>Navicat(商业 收费) 跨平台  功能最强大  UI最漂亮</strong>  </li>
<li><strong>SQLyog(收费  不跨平台)</strong> 对高分辨率屏支持不好</li>
</ul>
<hr>
<h1 id="39-mysql的版本升级"><a href="#39-mysql的版本升级" class="headerlink" title="39. mysql的版本升级"></a>39. mysql的版本升级</h1><p>升级数据库版本之前一定要先备份数据,再执行升级;</p>
<ul>
<li>备份数据</li>
<li>卸载老版本的mysql<ul>
<li>停止系统的mysql服务</li>
<li>检查系统服务是否存在如果存在先删除 <code>sc delete mysql</code>,这个命令必须使用管理员用户权限</li>
<li>删除数据目录</li>
</ul>
</li>
<li>安装新版本的<code>mysql-8.0.22.0</code></li>
<li>恢复数据(执行前面备份的sql脚本)</li>
</ul>
<hr>
<h1 id="40-mysql中的模糊查询"><a href="#40-mysql中的模糊查询" class="headerlink" title="40. mysql中的模糊查询"></a>40. mysql中的模糊查询</h1><p><code>%</code>: 匹配0个或者多个任意字符</p>
<p><code>_</code>: 匹配任意一个字符</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询昵称中以 &#x27;小&#x27; 开头的数据</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">member</span> <span class="keyword">WHERE</span> nickname <span class="keyword">LIKE</span> <span class="string">&#x27;小%&#x27;</span>;</span><br><span class="line"><span class="comment">-- 查询昵称中包含 &#x27;小&#x27; 的数据</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">member</span> <span class="keyword">WHERE</span> nickname <span class="keyword">LIKE</span> <span class="string">&#x27;%小%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>模糊查询的前缀查询效率<code>极低</code>(要进行全表扫描),要慎重使用;</li>
<li>一般生产环境会直接禁用<strong>like</strong>模糊查询功能;</li>
<li><strong>左模糊查询(“%abc”)不会使用索引</strong></li>
<li><strong>右模糊查询(“abc%”)会使用索引abc</strong></li>
</ul>
<hr>
<h1 id="41-mysql中的事务"><a href="#41-mysql中的事务" class="headerlink" title="41. mysql中的事务"></a>41. mysql中的事务</h1><h2 id="41-1-mysql事务介绍"><a href="#41-1-mysql事务介绍" class="headerlink" title="41.1 mysql事务介绍"></a>41.1 mysql事务介绍</h2><p>事务是一个最小的不可在分的工作单元，把做完一个业务分成好多单元,整个过程每个单元<strong>全部</strong>处理成功,才算整个的业务处理成功,只要有任何一个单元处理失败,则认为业务处理失败;</p>
<p><strong>作用: 保证了数据的完整性</strong></p>
<p>属性：传播行为、隔离级别、只读和事务超时</p>
<hr>
<h2 id="41-2-事务控制"><a href="#41-2-事务控制" class="headerlink" title="41.2 事务控制"></a>41.2 事务控制</h2><p>整个过程的每一个单元全部处理成功那么事务才会<strong>提交(commit)<strong>，只要其中任何一个单元出现异常,我们则让事务</strong>回滚(rollback)</strong></p>
<hr>
<h2 id="41-3-事务的特性"><a href="#41-3-事务的特性" class="headerlink" title="41.3 事务的特性"></a>41.3 事务的特性</h2><p><strong>ACID</strong></p>
<p><strong>atomicity(原子性)</strong>: 事务中所有的操作要么全部成功,要么全部失败;</p>
<p><strong>consistency(一致性)</strong>: 事务执行前后的状态(数据)保持一致</p>
<p><strong>isolation(隔离性)</strong>: 多个事务在执行过程中互相不受影响</p>
<p><strong>durability(持久性)</strong>: 事务一旦被提交,那么对数据库中的数据的改变时永久性的,即使在数据库系统遇到故障的时候,排除故障之后这些数据也不会丢失;</p>
<p>注意: 只有当前三条性质都满足了，才能保证事务的一致性；事务这个特性其实我们一直在使用,只是我们没有特别的在意这个事,因为mysql默认的事务的提交方式是自动提交的</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> &quot;%autocommit%&quot;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="41-4-手动控制事务的提交与回滚"><a href="#41-4-手动控制事务的提交与回滚" class="headerlink" title="41.4 手动控制事务的提交与回滚"></a>41.4 手动控制事务的提交与回滚</h2><p>mysql默认事务的提交方式是自动提交的,但是我们一般使用到事务的时候都会进行手动的控制,也就是要关闭mysql的事务自动提交;</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 开启事务(临时关闭mysql的&quot;事务自动提交&quot;)</span></span><br><span class="line"><span class="keyword">START</span> TRANSACTION;<span class="comment">-- 或者使用 BEGIN;</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">member</span>(nickname,sex,age)<span class="keyword">VALUES</span>(&quot;小胖1&quot;,<span class="string">&#x27;男&#x27;</span>,<span class="number">30</span>);</span><br><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">member</span> <span class="keyword">SET</span> age<span class="operator">=</span><span class="number">10</span> <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">3</span>;</span><br><span class="line"><span class="comment">-- 提交事务</span></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 开启事务(临时关闭mysql的&quot;事务自动提交&quot;)</span></span><br><span class="line"><span class="keyword">START</span> TRANSACTION;  <span class="comment">-- 或者使用BEGIN;</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">member</span>(nickname,sex,age)<span class="keyword">VALUES</span>(&quot;小胖1&quot;,<span class="string">&#x27;男&#x27;</span>,<span class="number">30</span>);</span><br><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">member</span> <span class="keyword">SET</span> age<span class="operator">=</span><span class="number">10</span> <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">3</span>;</span><br><span class="line"><span class="comment">-- 回滚事务</span></span><br><span class="line"><span class="keyword">ROLLBACK</span>;</span><br></pre></td></tr></table></figure>

<h2 id="41-5-事务的隔离性"><a href="#41-5-事务的隔离性" class="headerlink" title="41.5 事务的隔离性"></a>41.5 事务的隔离性</h2><p>隔离性保证了,多个事务在执行过程中互相不受影响;</p>
<p>mysql中的事务隔离级别有以下几种:</p>
<ul>
<li><strong>Read UNCOMMITTED(读未提交)</strong></li>
<li><strong>READ COMMITTED(读已提交)</strong> —-&gt;oracle中事务默认的隔离级别</li>
<li><strong>REPEATABLE READ(重复读)</strong> —&gt;<strong>mysql中的事务的隔离级别</strong></li>
<li><strong>SERIALIZABLE(串行化)</strong></li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询默认的事务隔离级别</span></span><br><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@tx</span>_isolation;  <span class="comment">--老版本中的查询方式</span></span><br><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@transaction</span>_isolation; <span class="comment">-- 新版本中查询方式</span></span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 更改当前会话的隔离级别</span></span><br><span class="line"><span class="keyword">set</span> session transaction isolation level read uncommitted; <span class="comment">-- 设置当前会话隔离级别为读未提交</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="41-6-事务隔离级别引发的问题"><a href="#41-6-事务隔离级别引发的问题" class="headerlink" title="41.6 事务隔离级别引发的问题"></a>41.6 事务隔离级别引发的问题</h2><blockquote>
<p>脏读问题</p>
</blockquote>
<ul>
<li><p>脏读:  设置事务的隔离级别为 <code>READ UNCOMMITTED</code>,会读到其他事务没有提交的数据;</p>
</li>
<li><p>例如：事务A读取到了事务已经修改但未提交的数据，这种数据就叫脏数据，是不正确的</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/0e5ac64c906c4d13b6dbdecda01b5910.png" alt="img"></p>
</li>
<li><p>解决脏读: 设置事务的隔离级别为 <code>READ COMMITTED</code>,既可以解决数据脏读问题</p>
</li>
</ul>
<blockquote>
<p>不可重复读问题</p>
</blockquote>
<ul>
<li><p>不可重复读: 在一个事务中,前后两次读到的数据不一致</p>
</li>
<li><p>例如：对于事务A多次读取同一个数据时，由于其他是事务也在访问这个数据，进行修改且提交，对于事务A，读取同一个数据时，有可能导致数据不一致，叫不可重复读。</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/2b755a18343a4122a434c5d955804492.png" alt="img"></p>
</li>
<li><p>解决不可重复读: 使用的<code>REPEATABLE READ</code>隔离级别可以解决;</p>
</li>
</ul>
<blockquote>
<p>虚读|幻读问题</p>
</blockquote>
<ul>
<li><p>虚读: 设置为<code>READ UNCOMMITTED ,READ COMMITTED,REPEATABLE READ</code>的事务,有时候可以读取到其他事务新插入的行,这种情况就称为虚读;</p>
</li>
<li><p>解决虚读: 把事务的隔离级别设置成 <code>SERIALIZABLE</code>之后就可以解决虚读问题;</p>
</li>
</ul>
<blockquote>
<p>解决方案: 我们在实际开发过程中一般不会使用两个极端的隔离级别(读未提交,  串行化),我们会使用中间的两个;</p>
</blockquote>
<hr>
<h2 id="41-7-事务的传播特性"><a href="#41-7-事务的传播特性" class="headerlink" title="41.7 事务的传播特性"></a>41.7 事务的传播特性</h2><p><strong>PROPAGATION_REQUIRED</strong>–支持当前事务，如果当前没有事务，就新建一个事务。这是最常见的选择。 </p>
<p><strong>PROPAGATION_SUPPORTS</strong>–支持当前事务，如果当前没有事务，就以非事务方式执行。 </p>
<p><strong>PROPAGATION_MANDATORY</strong>–支持当前事务，如果当前没有事务，就抛出异常。 </p>
<p><strong>PROPAGATION_REQUIRES_NEW</strong>–新建事务，如果当前存在事务，把当前事务挂起。 </p>
<p><strong>PROPAGATION_NOT_SUPPORTED</strong>–以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。 </p>
<p><strong>PROPAGATION_NEVER</strong>–以非事务方式执行，如果当前存在事务，则抛出异常。</p>
<h1 id="42-innodb锁机制"><a href="#42-innodb锁机制" class="headerlink" title="42. innodb锁机制"></a>42. innodb锁机制</h1><h2 id="42-1-innodb锁机制介绍"><a href="#42-1-innodb锁机制介绍" class="headerlink" title="42.1 innodb锁机制介绍"></a>42.1 innodb锁机制介绍</h2><p>从锁的颗粒来说锁分为行锁和表锁;</p>
<p>在innodb中提供了两种锁机制:</p>
<ul>
<li><p>乐观锁:  并不是硬编码的实现,而是通过version版本号来进行实现&#x3D;&#x3D;(innodb中并没有实现乐观锁)&#x3D;&#x3D;</p>
</li>
<li><p>悲观锁: 这是innodb存储引擎默认实现的锁机制,这种锁是<strong>表锁</strong>,而悲观锁的实现又分为两种实现:</p>
<ul>
<li><p>共享锁(S锁),读锁</p>
<ul>
<li><p>在读取的行设置一个共享模式的锁,这个共享锁允许其他的会话读取数据,但是不允许修改,如果其他的会话也需要修改数据,则</p>
<p>要等待持有共享锁的会话结束锁的释放,才能修改数据;</p>
</li>
<li><p>可以在多个会话中加多个共享锁</p>
</li>
</ul>
</li>
<li><p><strong>添加多个共享锁容易出现互相等待释放的情况,造成死锁问题,所以使用多个共享锁一定要慎重;</strong></p>
</li>
<li><p>排它锁(X锁),写锁</p>
<ul>
<li>排它锁是不允许重复添加的</li>
<li>排它锁没有死锁问题</li>
</ul>
</li>
</ul>
<hr>
</li>
</ul>
<h2 id="42-2-显式加锁"><a href="#42-2-显式加锁" class="headerlink" title="42.2 显式加锁"></a>42.2 显式加锁</h2><ul>
<li>共享锁的添加: <code>lock in share mode</code></li>
<li>排它锁的添加: <code>for update</code></li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from account lock in share mode;</span><br><span class="line">select * from account for update;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="42-3-mvcc并发系统快照读与当前读"><a href="#42-3-mvcc并发系统快照读与当前读" class="headerlink" title="42.3 mvcc并发系统快照读与当前读"></a>42.3 mvcc并发系统快照读与当前读</h2><p><strong>快照读:</strong> 不加锁的select操作就属于快照读</p>
<p>当前读: 加锁的操作属于当前读</p>
<p>当前读读到的是最新的数据,而且在读取的过程中是&#x3D;&#x3D;不允许&#x3D;&#x3D;其他的事务修改数据;</p>
<hr>
<h1 id="43-mysql中的执行计划"><a href="#43-mysql中的执行计划" class="headerlink" title="43. mysql中的执行计划"></a>43. mysql中的执行计划</h1><p>mysql执行流程:</p>
<p>客户端(sql语句)—&gt;mysql-rdbms–&gt;innodb存储引擎–&gt;sql查询优化器(sql语句的优化)—&gt;….</p>
<p>sql查询优化器会把优化的东西形成一个产物,这个产物就是执行计划; 简单来说就是SQL在数据库中执行时的表现情况。</p>
<p>我们在实际的开发过程中,一般涉及到mysql的优化都会先查看其执行计划;</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> shop;</span><br></pre></td></tr></table></figure>

<ul>
<li>执行计划看的时候先看执行计划的id,<strong>id越大的先执行</strong>;</li>
<li>如果id相同从上往下看</li>
</ul>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/mysql%E6%9E%B6%E6%9E%84.jpg" alt="mysql架构"></p>
<hr>
<h1 id="44-mysql中的索引技术-非常重要"><a href="#44-mysql中的索引技术-非常重要" class="headerlink" title="44. mysql中的索引技术(非常重要)"></a>44. mysql中的索引技术(非常重要)</h1><h2 id="44-1-索引技术的介绍"><a href="#44-1-索引技术的介绍" class="headerlink" title="44.1 索引技术的介绍"></a>44.1 索引技术的介绍</h2><ul>
<li>mysql中的索引技术可以帮助我们快速检索数据</li>
<li>innodb底层索引技术就是通过B+tree实现的</li>
<li>索引其实就是我们平常用到的 ‘<code>目录</code>‘</li>
<li>索引在mysql启动时就会加到内存中,形成B+Tree,在mysql停止的时候会持久化到硬盘;</li>
</ul>
<hr>
<h2 id="44-2-索引的分类"><a href="#44-2-索引的分类" class="headerlink" title="44.2 索引的分类"></a>44.2 索引的分类</h2><ul>
<li>普通索引</li>
<li>主键索引</li>
<li>唯一索引</li>
<li>全文索引</li>
</ul>
<hr>
<h2 id="44-3-普通索引"><a href="#44-3-普通索引" class="headerlink" title="44.3 普通索引"></a>44.3 普通索引</h2><p>普通索引如果不指定名称,则索引的名称和字段的名称相同;</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建索引的第一种方式</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_nickname <span class="keyword">ON</span> account(nickname); </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建索引的第二种方式(不常用)</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> account <span class="keyword">ADD</span> INDEX idx_nickname1(nickname);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建索引的第三种方式</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> u1(nickname <span class="type">VARCHAR</span>(<span class="number">64</span>),age TINYINT UNSIGNED,KEY idx_nickname(nickname));</span><br></pre></td></tr></table></figure>

<ul>
<li>建立普通索引的列的数据是可以重复的</li>
</ul>
<hr>
<h2 id="44-4-主键索引"><a href="#44-4-主键索引" class="headerlink" title="44.4 主键索引"></a>44.4 主键索引</h2><p>主键索引如果不指定索引的名称,则主键索引的名称为 <code>PRIMARY</code></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 声明为主键的列就是自动添加主键索引</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> u1(id <span class="type">INT</span> ,nickname <span class="type">VARCHAR</span>(<span class="number">64</span>),age TINYINT UNSIGNED,<span class="keyword">PRIMARY</span> KEY(id));</span><br></pre></td></tr></table></figure>

<ul>
<li><p>主键索引的列的数据非空,唯一的</p>
</li>
<li><p>一个表中建议只有一个主键列</p>
</li>
</ul>
<hr>
<h2 id="44-5-唯一索引"><a href="#44-5-唯一索引" class="headerlink" title="44.5 唯一索引"></a>44.5 唯一索引</h2><p>唯一索引如果不指定名称,则索引的名称和字段的名称相同;</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建索引的第一种方式</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> INDEX uk_nickname <span class="keyword">ON</span> u1(nickname); </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建表时创建唯一索引</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> u1 (</span><br><span class="line">  id <span class="type">INT</span>,</span><br><span class="line">  nickname <span class="type">VARCHAR</span> (<span class="number">64</span>) ,</span><br><span class="line">  age TINYINT UNSIGNED,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (id),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY uk_nickname(nickname) </span><br><span class="line">) ;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果一列被约束为<code>UNIQUE</code>,则在这一列默认添加唯一索引</li>
<li>添加唯一索引的列可以为<code>NULL</code>值,这也是和主键索引,不同的地方</li>
</ul>
<hr>
<h2 id="44-6-全文索引"><a href="#44-6-全文索引" class="headerlink" title="44.6 全文索引"></a>44.6 全文索引</h2><blockquote>
<p>全文索引,通过建立<code>倒排索引</code>,可以提高数据的检索效率,解决判断字段中 <code>是否包含</code> 的问题;</p>
</blockquote>
<p>我们如果使用like关键字会出现很多问题:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 我们已经给nickname字段添加了普通索引</span></span><br><span class="line"><span class="comment">-- 会使用索引</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> account <span class="keyword">WHERE</span> nickname<span class="operator">=</span><span class="string">&#x27;小明&#x27;</span>;</span><br><span class="line"><span class="comment">-- 会使用索引</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> account <span class="keyword">WHERE</span> nickname <span class="keyword">LIKE</span> <span class="string">&#x27;小明%&#x27;</span>;</span><br><span class="line"><span class="comment">-- 不会使用索引</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> account <span class="keyword">WHERE</span> nickname <span class="keyword">LIKE</span> <span class="string">&#x27;%小明%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>不使用到索引我们如果进行大规模数据检索时,效率会大大的降低,所以前面我们说过 <code>我们只在简单业务或者数据量小的时候才考虑使用like关键字</code>;</p>
<blockquote>
<p>全文索引注意的地方:</p>
</blockquote>
<ul>
<li><p>mysql5.6以前,只有<code>MYISAM</code>存储引擎支持全文索引</p>
</li>
<li><p>在5.6中<code>INNODB</code>存储引擎加入了对全文索引的支持,<strong>但是只支持英文的全文索引,不支持中文的全文索引</strong></p>
</li>
<li><p>&#x3D;&#x3D;<strong>在5.7.6中,mysql内置了<code>ngram</code>分词器,用来支持中文;</strong>&#x3D;&#x3D;</p>
</li>
</ul>
<blockquote>
<p>配置ngram分词的最小长度:      </p>
</blockquote>
<p>默认长度为2,当然我们也可以设置成1,但是设置成1的话就会浪费大量的空间,不是很好,<code>mysql建议我们配置为2</code>;</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">ngram分词器对分词最小长度(也就是说分词器,分词的时候最小也是两个词一分)</span></span><br><span class="line">[mysqld]</span><br><span class="line">ft_min_word_len=2</span><br></pre></td></tr></table></figure>

<blockquote>
<p>创建全文索引</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建索引的第一种方式</span></span><br><span class="line"><span class="keyword">CREATE</span> FULLTEXT INDEX ft_nickname <span class="keyword">ON</span> account(nickname) <span class="keyword">WITH</span> PARSER ngram ; </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建索引的第二种方式(不常用)</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> account <span class="keyword">ADD</span> FULLTEXT INDEX ft_nickname(nickname) <span class="keyword">WITH</span> PARSER ngram;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建索引的第三种方式</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> u1(nickname <span class="type">VARCHAR</span>(<span class="number">64</span>),age TINYINT UNSIGNED,FULLTEXT KEY ft_nickname(nickname) <span class="keyword">WITH</span> PARSER ngram );</span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用全文索引</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> account <span class="keyword">WHERE</span> <span class="keyword">MATCH</span>(nickname) AGAINST(&quot;你觉得华为笔记本合小米手机哪个好&quot;);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>match</code>中的字段和创建全文建索引时的字段<strong>必须一致</strong>;</li>
</ul>
<blockquote>
<p>全文索引的检索流程</p>
</blockquote>
<p>用户输入词—&gt;sql执行引擎—&gt;<code>ngram</code>分词器对用户输入的词进行分词(配置了最小的分词个数)—&gt;把分词器分的词依次的去倒排索引中去查找,找出相应的记录返回;</p>
<hr>
<h2 id="44-7-组合索引"><a href="#44-7-组合索引" class="headerlink" title="44.7 组合索引"></a>44.7 组合索引</h2><p><strong>包含多个字段的索引</strong>称为组合索引;</p>
<blockquote>
<p>组合索引包含</p>
</blockquote>
<ul>
<li>组合普通索引</li>
<li>组合主键索引</li>
<li>组合唯一索引</li>
<li>组合全文索引</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建复合索引时必须指定索引的名称,不能省略</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX mu_title_content <span class="keyword">ON</span> article(title,content,publish_time);</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> article <span class="keyword">WHERE</span> title <span class="keyword">LIKE</span> <span class="string">&#x27;小米%&#x27;</span>; <span class="comment">-- 使用到索引</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> article <span class="keyword">WHERE</span> title <span class="keyword">LIKE</span> <span class="string">&#x27;小米%&#x27;</span> <span class="keyword">AND</span> content <span class="keyword">LIKE</span> <span class="string">&#x27;小米%&#x27;</span>; <span class="comment">-- 使用了索引</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> article <span class="keyword">WHERE</span>  content <span class="keyword">LIKE</span> <span class="string">&#x27;小米%&#x27;</span>; <span class="comment">-- 没有索引</span></span><br></pre></td></tr></table></figure>

<p><strong>建议多列索引的列不要超过2个列</strong></p>
<ul>
<li><p>以上这个复合索引相当于建立了这3个索引</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(title),(title,content),(title,content,publish_time)</span><br></pre></td></tr></table></figure>
</li>
<li><p>多列索引遵循<strong>最左前缀</strong>的原则</p>
</li>
<li><p>多列索引在创建的时候,如果其中有字段时<code>TEXT</code>或<code>BLOB</code>类型,就必须指定索引的长度;</p>
</li>
</ul>
<hr>
<h2 id="44-8-使用索引的优点"><a href="#44-8-使用索引的优点" class="headerlink" title="44.8 使用索引的优点"></a>44.8 使用索引的优点</h2><ul>
<li>使用主键索引或者唯一索引,可以保证数据库中的表的数据是唯一</li>
<li><strong>通过建立索引可以大大的提高数据检索的效率,减少表扫描的行数(避免进行全表扫描)</strong></li>
<li>我们在进行多表连接的时候,可以使用索引加速表之间的连接</li>
</ul>
<hr>
<h2 id="44-9-使用索引的缺点"><a href="#44-9-使用索引的缺点" class="headerlink" title="44.9 使用索引的缺点"></a>44.9 使用索引的缺点</h2><ul>
<li>在创建索引和维护索引时都需要耗费时间;</li>
<li>索引文件会占用物理存储空间,除了表的数据占用一部分空间,索引文件也会占用一部分空间;</li>
<li><strong>设置为<code>text</code>和<code>blob</code>类型的字段强烈不建议添加索引;</strong></li>
</ul>
<hr>
<h1 id="45-mysql中的记录截取"><a href="#45-mysql中的记录截取" class="headerlink" title="45. mysql中的记录截取"></a>45. mysql中的记录截取</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> account LIMIT <span class="keyword">start</span>,count;</span><br><span class="line"><span class="keyword">start</span>:开始位置,从<span class="number">0</span>开始</span><br><span class="line">count:截取的记录数量</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="46-mysql数据库设计-了解"><a href="#46-mysql数据库设计-了解" class="headerlink" title="46. mysql数据库设计(了解)"></a>46. mysql数据库设计(了解)</h1><ul>
<li><p><strong>第一设计范式 ：表中的每一列都不能再分(不要出现二维表)</strong></p>
</li>
<li><p>第二设计范式：满足第一设计范式，除主键外每一列都必须依靠主键</p>
</li>
<li><p>第三设计范式：满足第二设计范式，除主键列外，每一列都不能相互依靠</p>
</li>
</ul>
<p>数据库范式的提出是很早以前的事了,在很早以前硬盘是非常昂贵的,一般都会遵循1,2,3范式,但是随着互联网的发展,硬盘非常便宜,所以我们在现在的商业项目中一般不会遵循2,3范式(用时间换空间),<strong>第一范式会遵循</strong>;</p>
<hr>
<h1 id="47-国内大厂的数据库开发规范-参照阿里的开发规范"><a href="#47-国内大厂的数据库开发规范-参照阿里的开发规范" class="headerlink" title="47. 国内大厂的数据库开发规范(参照阿里的开发规范)"></a>47. 国内大厂的数据库开发规范(参照阿里的开发规范)</h1><ol>
<li><p>库名与应用名称尽量一致</p>
</li>
<li><p>表名、字段名必须使用小写字母或数字，禁止出现数字开头,如果一个单词不能表达那就使用下划线分隔;</p>
</li>
<li><p>表名不使用复数名词;</p>
</li>
<li><p>表的命名最好是加上“业务名称_表的作用”。如，edu_teacher </p>
</li>
<li><p>表必备三字段：id, gmt_create, gmt_modified<br>说明：其中 id 必为主键，类型为 bigint unsigned、单表时自增、步长为 1。（如果使用分库分表集群部署，则id类型为varchar，非自增，业务中使用分布式id生成器）<br>gmt_create, gmt_modified 的类型均为 datetime 类型，前者现在时表示主动创建，后者过去分词表示被动更新。</p>
</li>
<li><p>单表行数超过 500 万行或者单表容量超过 2GB，才推荐进行分库分表。 说明：如果预计三年后的数据量根本达不到这个级别，请不要在创建表时就分库分表。</p>
</li>
<li><p>表达是与否概念的字段，必须使用 is_xxx 的方式命名，数据类型是 unsigned tinyint （1 表示是，0 表示否）。<br>说明：任何字段如果为非负数，必须是 unsigned。<br>注意：POJO 类中的任何布尔类型的变量，都不要加 is 前缀。数据库表示是与否的值，使用 tinyint 类型，坚持 is_xxx 的 命名方式是为了明确其取值含义与取值范围。<br>正例：表达逻辑删除的字段名 is_deleted，1 表示删除，0 表示未删除。</p>
</li>
<li><p>小数类型为 decimal，禁止使用 float 和 double。 说明：float 和 double 在存储的时候，存在精度损失的问题，很可能在值的比较时，得到不 正确的结果。如果存储的数据范围超过 decimal 的范围，建议将数据拆成整数和小数分开存储。</p>
</li>
<li><p>如果存储的字符串长度几乎相等，使用 char 定长字符串类型。</p>
</li>
<li><p>varchar 是可变长字符串，不预先分配存储空间，长度不要超过 5000，如果存储长度大于此值，定义字段类型为 text，独立出来一张表，用主键来对应，避免影响其它字段索 引效率。</p>
</li>
<li><p>唯一索引名为 uk_字段名；普通索引名则为 idx_字段名。<br>说明：uk_ 即 unique key；idx_ 即 index 的简称</p>
</li>
<li><p><strong>不得使用外键与级联，一切外键概念必须在应用层解决</strong>。外键与级联更新适用于单机低并发，不适合分布式、高并发集群；级联更新是强阻塞，存在数据库更新风暴的风险；外键影响数据库的插入速度</p>
</li>
<li><p>慎重使用<code>like</code>进行模糊查询, 通配符如果在前面则不会使用到索引,影响检索效率;</p>
</li>
<li><p>如果是简单的搜索业务建议使用mysql5.7中新增的全文索引,不建议直接上solor,elasticsearch这样的检索系统,因为会使得维护成本增加;</p>
</li>
</ol>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-JUC：线程与进程"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
	
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/08/02/JUC%EF%BC%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B/"
    >线程与进程</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/08/02/JUC%EF%BC%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B/" class="article-date">
  <time datetime="2022-08-02T06:55:01.000Z" itemprop="datePublished">2022-08-02</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/JUC/">JUC</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/0-00000005.png" alt="img"></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-JVM：再谈类的加载器"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
	
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/08/01/JVM%EF%BC%9A%E5%86%8D%E8%B0%88%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8/"
    >再谈类的加载器</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/08/01/JVM%EF%BC%9A%E5%86%8D%E8%B0%88%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8/" class="article-date">
  <time datetime="2022-08-01T08:33:26.000Z" itemprop="datePublished">2022-08-01</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/JVM/">JVM</a> / <a class="article-category-link" href="/categories/JVM/2-%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E7%AF%87/">2.字节码与类的加载篇</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>类加载器是JVM执行类加载机制的前提。</p>
<p><strong>ClassLoader的作用：</strong></p>
<p>ClassLoader是Java的核心组件，所有的Class都是由ClassLoader进行加载的，ClassLoader负责通过各种方式将Class信息的二进制数据流读入JVM内部，<strong>转换为一个与目标类对应的java.lang.Class对象实例</strong>。然后交给Java虚拟机进行链接、初始化等操作。因此，ClassLoader在整个装载阶段，<strong>只能影响到类的加载</strong>，而无法通过ClassLoader去改变类的链接和初始化行为。至于它是否可以运行，则由Execution Engine决定。</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220801165131938.png" alt="image-20220801165131938"></p>
<p><strong>大厂面试题</strong></p>
<p><strong>蚂蚁金服：</strong> </p>
<p>深入分析ClassLoader，双亲委派机制 </p>
<p>类加载器的双亲委派模型是什么？一面：双亲委派机制及使用原因 </p>
<p><strong>百度：</strong> </p>
<p>都有哪些类加载器，这些类加载器都加载哪些文件？ </p>
<p>手写一个类加载器Demo </p>
<p>Class的forName（“java.lang.String”）和Class的getClassLoader（）的Loadclass（“java.lang.String”）有什么区别？ </p>
<p><strong>腾讯：</strong> </p>
<p>什么是双亲委派模型？ </p>
<p>类加载器有哪些？ </p>
<p><strong>小米：</strong> </p>
<p>双亲委派模型介绍一下 </p>
<p><strong>滴滴：</strong> </p>
<p>简单说说你了解的类加载器一面：讲一下双亲委派模型，以及其优点 </p>
<p><strong>字节跳动：</strong> </p>
<p>什么是类加载器，类加载器有哪些？</p>
<p><strong>京东：</strong></p>
<p>类加载器的双亲委派模型是什么？</p>
<p>双亲委派机制可以打破吗？为什么</p>
<h2 id="类加载的分类"><a href="#类加载的分类" class="headerlink" title="类加载的分类"></a>类加载的分类</h2><p>类的加载分类：<strong>显式加载 vs 隐式加载</strong></p>
<p>class文件的显式加载与隐式加载的方式是指<strong>JVM加载class文件到内存的方式</strong>。</p>
<ul>
<li>显式加载指的是在代码中通过调用ClassLoader加载class对象，如直接使用Class.forName(name)或this.getClass().getClassLoader().loadClass()加载class对象。</li>
<li>隐式加载则是不直接在代码中调用ClassLoader的方法加载class对象，而是通过虚拟机自动加载到内存中，如在加载某个类的class文件时，该类的class文件中引用了另外一个类的对象，此时额外引用的类将通过JVM自动加载到内存中。</li>
</ul>
<p>在日常开发以上两种方式一般会混合使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//隐式加载</span></span><br><span class="line">User user=<span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line"><span class="comment">//显式加载，并初始化</span></span><br><span class="line">Class clazz=Class.forName(<span class="string">&quot;com.test.java.User&quot;</span>);</span><br><span class="line"><span class="comment">//显式加载，但不初始化</span></span><br><span class="line">ClassLoader.getSystemClassLoader().loadClass(<span class="string">&quot;com.test.java.Parent&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="类加载器的必要性"><a href="#类加载器的必要性" class="headerlink" title="类加载器的必要性"></a>类加载器的必要性</h2><p>一般情况下，Java开发人员并不需要在程序中显式地使用类加载器，但是了解类加载器的加载机制却显得至关重要。从以下几个方面说：</p>
<ul>
<li>避免在开发中遇到java.lang.ClassNotFoundException异常或java.lang.NoClassDefFoundError异常时，手足无措。只有了解类加载器的 加载机制才能够在出现异常的时候快速地根据错误异常日志定位问题和解决问题</li>
<li>需要支持类的动态加载或需要对编译后的字节码文件进行加解密操作时，就需要与类加载器打交道了。</li>
<li>开发人员可以在程序中编写自定义类加载器来重新定义类的加载规则，以便实现一些自定义的处理逻辑。</li>
</ul>
<h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><p><strong>何为类的唯一性？</strong></p>
<ul>
<li><strong>对于任意一个类，都需要由加载它的类加载器和这个类本身一同确认其在Java虚拟机中的唯一性。</strong></li>
<li>每一个类加载器，都拥有一个独立的类名称空间：<strong>比较两个类是否相等，只有在这两个类是由同一个类加载器加载的前提下才有意义</strong>。否则，即使这两个类源自同一个Class文件，被同一个虚拟机加载，只要加载他们的类加载器不同，那这两个类就必定不相等。</li>
</ul>
<p><strong>命名空间</strong></p>
<ul>
<li>每个类加载器都有自己的命名空间，命名空间由该加载器及所有的父加载器所加载的类组成 </li>
<li>在同一命名空间中，不会出现类的完整名字（包括类的包名）相同的两个类 </li>
<li>在不同的命名空间中，有可能会出现类的完整名字（包括类的包名）相同的两个类</li>
</ul>
<p>在大型应用中，我们往往借助这一特性，来运行同一个类的不同版本。</p>
<h2 id="类加载机制的基本特征"><a href="#类加载机制的基本特征" class="headerlink" title="类加载机制的基本特征"></a>类加载机制的基本特征</h2><ul>
<li><strong>双亲委派模型</strong>。但不是所有类加载都遵守这个模型，有的时候，启动类加载器所加载的类型，是可能要加载用户代码的，比如JDK内部的ServiceProvider&#x2F;ServiceLoader机制，用户可以在标准API框架上，提供自己的实现，JDK也需要提供些默认的参考实现。例如，Java中JNDI、JDBC、文件系统、Cipher等很多方面，都是利用的这种机制，这种情况就不会用双亲委派模型去加载，而是利用所谓的上下文加载器。</li>
<li><strong>可见性</strong>，子类加载器可以访问父加载器加载的类型，但是反过来是不允许的。不然，因为缺少必要的隔离，我们就没有办法利用类加载器去实现容器的逻辑。</li>
<li><strong>单一性</strong>，由于父加载器的类型对于子加载器是可见的，所以父加载器中加载过的类型，就不会在子加载器中重复加载。但是注意，类加载器“邻居”间，同一类型仍然可以被加载多次，因为互相并不可见。</li>
</ul>
<h2 id="类加载器之间的关系"><a href="#类加载器之间的关系" class="headerlink" title="类加载器之间的关系"></a>类加载器之间的关系</h2><p>Launcher类核心代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Launcher.ExtClassLoader var1;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    var1 = Launcher.ExtClassLoader.getExtClassLoader();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException var10) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InternalError</span>(<span class="string">&quot;Could not create extension class loader&quot;</span>, var10);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.loader = Launcher.AppClassLoader.getAppClassLoader(var1);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException var9) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InternalError</span>(<span class="string">&quot;Could not create application class loader&quot;</span>, var9);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Thread.currentThread().setContextClassLoader(<span class="built_in">this</span>.loader);</span><br></pre></td></tr></table></figure>

<ul>
<li>ExtClassLoader的Parent类是null</li>
<li>AppClassLoader的Parent类是ExtClassLoader</li>
<li>当前线程的ClassLoader是AppClassLoader</li>
</ul>
<p><strong>注意，这里的Parent类并不是Java语言意义上的继承关系，而是一种包含关系</strong></p>
<h1 id="类的加载器分类"><a href="#类的加载器分类" class="headerlink" title="类的加载器分类"></a>类的加载器分类</h1><ul>
<li>JVM支持两种类型的类加载器，分别为<strong>引导类加载器（Bootstrap ClassLoader）和自定义类加载器（User-Defined ClassLoader）</strong>。</li>
<li>从概念上来讲，自定义类加载器一般指的是程序中由开发人员自定义的一类类加载器，但是Java虚拟机规范却没有这么定义，而是将所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器。无论类加载器的类型如何划分，在程序中我们最常见的类加载器结构主要是如下情况：</li>
</ul>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220801170741523.png" alt="image-20220801170741523"></p>
<ul>
<li>除了顶层的启动类加载器外，其余的类加载器都应当有自己的“父类”加载器。</li>
<li>不同类加载器看似是继承（Inheritance）关系，实际上是<strong>包含关系</strong>。在下层加载器中，包含着上层加载器的引用。</li>
</ul>
<p>父类加载器和子类加载器的关系：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ClassLoader</span>&#123;</span><br><span class="line">    ClassLoader parent;<span class="comment">//父类加载器</span></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">ClassLoader</span><span class="params">(ClassLoader parent)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.parent = parent;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ParentClassLoader</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ParentClassLoader</span><span class="params">(ClassLoader parent)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(parent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ChildClassLoader</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ChildClassLoader</span><span class="params">(ClassLoader parent)</span>&#123; <span class="comment">//parent = new ParentClassLoader();</span></span><br><span class="line">        <span class="built_in">super</span>(parent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正是由于子类加载器中包含着父类加载器的引用，所以可以通过子类加载器的方法获取对应的父类加载器</p>
<p><strong>注意：</strong></p>
<p>启动类加载器通过C&#x2F;C++语言编写，而自定义类加载器都是由Java语言编写的，虽然扩展类加载器和应用程序类加载器是被jdk开发人员使用java语言来编写的，但是也是由java语言编写的，所以也被称为自定义类加载器</p>
<h2 id="引导类加载器"><a href="#引导类加载器" class="headerlink" title="引导类加载器"></a>引导类加载器</h2><p><strong><code>启动类加载器（引导类加载器，Bootstrap ClassLoader）</code></strong></p>
<ul>
<li>这个类加载使用C&#x2F;C++语言实现的，嵌套在JVM内部。 </li>
<li>它用来加载Java的核心库（JAVAHOME&#x2F;jre&#x2F;lib&#x2F;rt.jar或sun.boot.class.path路径下的内容）。用于提供JVM自身需要的类。 </li>
<li>并不继承自java.lang.ClassLoader，没有父加载器。 </li>
<li>出于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类 </li>
<li>加载扩展类和应用程序类加载器，并指定为他们的父类加载器。</li>
</ul>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220801171139803.png" alt="image-20220801171139803"></p>
<p>​				使用-XX:+TraceClassLoading参数得到。 </p>
<p>启动类加载器使用C++编写的？Yes！</p>
<ul>
<li>C&#x2F;C++：指针函数&amp;函数指针、C++支持多继承、更加高效</li>
<li>Java：由C演变而来，（C）–版，单继承</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;＊＊＊＊＊＊＊＊＊＊启动类加载器＊＊＊＊＊＊＊＊＊＊&quot;</span>);</span><br><span class="line"><span class="comment">// 获取BootstrapclassLoader能够加载的api的路径</span></span><br><span class="line">URL[] urLs = sun.misc.Launcher.getBootstrapcLassPath().getURLs();</span><br><span class="line"><span class="keyword">for</span> (URL element : urLs) &#123;</span><br><span class="line">    System.out.println(element.toExternalForm());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 从上面的路径中随意选择一个类，来看看他的类加载器是什么：引导类加载器</span></span><br><span class="line"><span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> java.security.Provider.class.getClassLoader();</span><br><span class="line">System.out.println(classLoader);</span><br></pre></td></tr></table></figure>

<p><strong>执行结果</strong></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220801171535415.png" alt="image-20220801171535415"></p>
<h2 id="扩展类加载器"><a href="#扩展类加载器" class="headerlink" title="扩展类加载器"></a>扩展类加载器</h2><p><strong><code>扩展类加载器（Extension ClassLoader）</code></strong></p>
<ul>
<li>Java语言编写，由sun.misc.Launcher$ExtClassLoader实现。 </li>
<li>继承于ClassLoader类 </li>
<li>父类加载器为启动类加载器 </li>
<li>从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的jre&#x2F;lib&#x2F;ext子目录下加载类库。如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;＊＊＊＊＊＊＊＊＊＊＊扩展类加载器＊＊＊＊＊＊＊＊＊＊＊&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">extDirs</span> <span class="operator">=</span>System.getProperty(<span class="string">&quot;java.ext.dirs&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (String path :extDirs.split( regex:<span class="string">&quot;;&quot;</span>))&#123;</span><br><span class="line">    System.out.println(path);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从上面的路径中随意选择一个类，来看看他的类加载器是什么：扩展类加载器</span></span><br><span class="line"><span class="type">lassLoader</span> <span class="variable">classLoader1</span> <span class="operator">=</span> sun.security.ec.CurveDB.class.getClassLoader();</span><br><span class="line">System.out.print1n(classLoader1); <span class="comment">//sun.misc. Launcher$ExtCLassLoader@1540e19d</span></span><br></pre></td></tr></table></figure>

<p><strong>执行结果</strong></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220801182018580.png" alt="image-20220801182018580"></p>
<h2 id="系统类加载器"><a href="#系统类加载器" class="headerlink" title="系统类加载器"></a>系统类加载器</h2><p><strong><code>应用程序类加载器（系统类加载器，AppClassLoader）</code></strong></p>
<ul>
<li>java语言编写，由sun.misc.Launcher$AppClassLoader实现</li>
<li>继承于ClassLoader类</li>
<li>父类加载器为扩展类加载器</li>
<li>它负责加载环境变量classpath或系统属性java.class.path 指定路径下的类库</li>
<li>应用程序中的类加载器默认是系统类加载器。</li>
<li>它是<strong>用户自定义类加载器的默认父加载器</strong></li>
<li>通过ClassLoader的getSystemClassLoader()方法可以获取到该类加载器</li>
</ul>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220801191221763.png" alt="image-20220801191221763"></p>
<h2 id="用户自定义类加载器"><a href="#用户自定义类加载器" class="headerlink" title="用户自定义类加载器"></a>用户自定义类加载器</h2><p><strong>用户自定义类加载器</strong> </p>
<ul>
<li>在Java的日常应用程序开发中，类的加载几乎是由上述3种类加载器相互配合执行的。在必要时，我们还可以自定义类加载器，来定制类的加载方式。</li>
<li>体现Java语言强大生命力和巨大魅力的关键因素之一便是，Java开发者可以自定义类加载器来实现类库的动态加载，加载源可以是本地的JAR包，也可以是网络上的远程资源。</li>
<li><strong>通过类加载器可以实现非常绝妙的插件机制</strong>，这方面的实际应用案例举不胜举。例如，著名的OSGI组件框架，再如Eclipse的插件机制。类加载器为应用程序提供了一种动态增加新功能的机制，这种机制无须重新打包发布应用程序就能实现。</li>
<li>同时，<strong>自定义加载器能够实现应用隔离</strong>，例如Tomcat，Spring等中间件和组件框架都在内部实现了自定义的加载器，并通过自定义加载器隔离不同的组件模块。这种机制比C&#x2F;C程序要好太多，想不修改C&#x2F;C程序就能为其新增功能，几乎是不可能的，仅仅一个兼容性便能阻挡住所有美好的设想。</li>
<li>自定义类加载器通常需要继承于ClassLoader。</li>
</ul>
<h1 id="测试不同的类的加载器"><a href="#测试不同的类的加载器" class="headerlink" title="测试不同的类的加载器"></a>测试不同的类的加载器</h1><p>每个Class对象都会包含一个定义它的ClassLoader的一个引用。</p>
<p><strong>获取ClassLoader的途径</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获得当前类的ClassLoader</span></span><br><span class="line">clazz.getClassLoader()</span><br><span class="line"><span class="comment">// 获得当前线程上下文的ClassLoader</span></span><br><span class="line">Thread.currentThread().getContextClassLoader()</span><br><span class="line"><span class="comment">// 获得系统的ClassLoader</span></span><br><span class="line">ClassLoader.getSystemClassLoader()</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong></p>
<ul>
<li>站在程序的角度看，引导类加载器与另外两种类加载器（系统类加载器和扩展类加载器）并不是同一个层次意义上的加 载器，引导类加载器是使用C++语言编写而成的，而另外两种类加载器则是使用Java语言编写而成的。由于引导类加载 器压根儿就不是一个Java类，因此在Java程序中只能打印出空值。</li>
<li>数组类的Class对象，不是由类加载器去创建的，而是在Java运行期JVM根据需要自动创建的。对于数组类的类加载器 来说，是通过Class.getClassLoader()返回的，与数组当中元素类型的类加载器是一样的；如果数组当中的元素类型 是基本数据类型，数组类是没有类加载器的。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 运行结果：null</span></span><br><span class="line">String[] strArr = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">6</span>];</span><br><span class="line">System.out.println(strArr.getClass().getClassLoader());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果：sun．misc．Launcher＄AppCLassLoader＠18b4aac2</span></span><br><span class="line">ClassLoaderTest[] test=<span class="keyword">new</span> <span class="title class_">ClassLoaderTest</span>[<span class="number">1</span>];</span><br><span class="line">System.out.println(test.getClass().getClassLoader());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果：null</span></span><br><span class="line"><span class="type">int</span>[]ints =<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">System.out.println(ints.getClass().getClassLoader());</span><br></pre></td></tr></table></figure>

<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassLoaderTest1</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//获取系统该类加载器</span></span><br><span class="line">        ClassLoader systemClassLoader=ClassLoader.getSystemCLassLoader();</span><br><span class="line">        System.out.print1n(systemClassLoader);<span class="comment">//sun.misc.Launcher$AppCLassLoader@18b4aac2</span></span><br><span class="line">        <span class="comment">//获取扩展类加载器</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">extClassLoader</span> <span class="operator">=</span>systemClassLoader.getParent();</span><br><span class="line">        System.out.println(extClassLoader);<span class="comment">//sun.misc. Launcher$ExtCLassLoader@1540e19d</span></span><br><span class="line">        <span class="comment">//试图获取引导类加载器：失败</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">bootstrapClassLoader</span> <span class="operator">=</span>extClassLoader.getParent();</span><br><span class="line">        System.out.print1n(bootstrapClassLoader);<span class="comment">//null</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//##################################</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span>Class.forName(<span class="string">&quot;java.lang.String&quot;</span>).getClassLoader();</span><br><span class="line">            System.out.println(classLoader);</span><br><span class="line">            <span class="comment">//自定义的类默认使用系统类加载器</span></span><br><span class="line">            ClassLoader classLoader1=Class.forName(<span class="string">&quot;com.atguigu.java.ClassLoaderTest1&quot;</span>).getClassLoader();</span><br><span class="line">            System.out.println(classLoader1);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//关于数组类型的加载：使用的类的加载器与数组元素的类的加载器相同</span></span><br><span class="line">            String[] arrstr = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">10</span>];</span><br><span class="line">            System.out.println(arrstr.getClass().getClassLoader());<span class="comment">//null：表示使用的是引导类加载器</span></span><br><span class="line">                </span><br><span class="line">            ClassLoaderTest1[] arr1 =<span class="keyword">new</span> <span class="title class_">ClassLoaderTest1</span>[<span class="number">10</span>];</span><br><span class="line">            System.out.println(arr1.getClass().getClassLoader());<span class="comment">//sun.misc. Launcher$AppcLassLoader@18b4aac2</span></span><br><span class="line">            </span><br><span class="line">            <span class="type">int</span>[] arr2 = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">            System.out.println(arr2.getClass().getClassLoader());<span class="comment">//null:不需要类的加载器</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="ClassLoader源码解析"><a href="#ClassLoader源码解析" class="headerlink" title="ClassLoader源码解析"></a>ClassLoader源码解析</h1><p><strong>ClassLoader与现有类的关系：</strong></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220801192113919.png" alt="image-20220801192113919"></p>
<p>除了以上虚拟机自带的加载器外，用户还可以定制自己的类加载器。Java提供了抽象类java.lang.ClassLoader，所有用户自定义的类加载器都应该继承ClassLoader类。</p>
<h2 id="ClassLoader的主要方法"><a href="#ClassLoader的主要方法" class="headerlink" title="ClassLoader的主要方法"></a>ClassLoader的主要方法</h2><p>抽象类ClassLoader的主要方法：（内部没有抽象方法）</p>
<ol>
<li>返回该类加载器的超类加载器</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> ClassLoader <span class="title function_">getParent</span><span class="params">()</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>加载名称为name的类，返回结果为java.lang.Class类的实例。如果找不到类，则返回 ClassNotFoundException异常。该方法中的逻辑就是<strong>双亲委派模式的实现</strong>。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试代码：</span></span><br><span class="line">ClassLoader.getSyatemClassLoader().loadClass(<span class="string">&quot;com.ysy.User&quot;</span>) ;</span><br><span class="line"></span><br><span class="line"><span class="comment">//涉及到对如下方法的调用</span></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="type">boolean</span> resolve)<span class="comment">//resolve: true-加载class的同时进行解析操作</span></span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;<span class="comment">//同步操作，保证只能加载一次</span></span><br><span class="line">        <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">        <span class="comment">//首先，在缓存中查找是否已经加载同名的类</span></span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">t0</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//获取当前类加载器的父类加载器</span></span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//如果存在父类加载器，则调用父类加载器进行类的加载</span></span><br><span class="line">                    c = parent.loadClass(name, <span class="literal">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//parent==null：父类加载器是引导类加载器</span></span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">            &#125;</span><br><span class="line">加载器</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;<span class="comment">//当前类的加载器的父类未加载此类 or 当前类的加载器未加载此类</span></span><br><span class="line">                <span class="comment">// If still not found, then invoke findClass in order to find the class.</span></span><br><span class="line">                <span class="comment">// 调用当前ClassLoader的findClass()</span></span><br><span class="line">                <span class="type">long</span> <span class="variable">t1</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">                c = findClass(name);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;<span class="comment">//是否进行解析操作</span></span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>查找二进制名称为name的类，返回结果为java.lang.Class类的实例。<strong>这是一个受保护的方法</strong>，JVM鼓励我们重写此方法，需要自定义加载器遵循双亲委托机制，该方法会在检查完父类加载器之后被loadClass()方法调用。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException</span><br></pre></td></tr></table></figure>

<ul>
<li>在JDK1.2之前，在自定义类加载时，总会去继承ClassLoader类并重写loadClass方法，从而实现自定义的类加载类。但是在JDK1.2之后已不再建议用户去覆盖loadClass()方法，而是建议把自定义的类加载逻辑写在findClass()方法中，从前面的分析可知，findClass()方法是在loadClass()方法中被调用的，当loadClass()方法中父加载器加载失败后，则会调用自己的findClass()方法来完成类加载，这样就可以保证自定义的类加载器也符合双亲委托模式。</li>
<li>需要注意的是ClassLoader类中并没有实现findClass()方法的具体代码逻辑，取而代之的是抛出ClassNotFoundException异常，同时应该知道的是findClass方法通常是和defineClass方法一起使用的。<strong>一般情况下，在自定义类加载器时，会直接覆盖ClassLoader的findClass()方法并编写加载规则，取得要加载类的字节码后转换成流，然后调用defineClass()方法生成类的Class对象。</strong></li>
</ul>
<ol start="4">
<li>根据给定的字节数组b转换为Class的实例，off和len参数表示实际Class信息在byte数组中的位置和长度，其中byte数组b是ClassLoader从外部获取的。这是受保护的方法，只有在自定义ClassLoader子类中可以使用。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Class&lt;?&gt; defineClass(String name, <span class="type">byte</span>[] b,<span class="type">int</span> off,<span class="type">int</span> len)</span><br></pre></td></tr></table></figure>

<ul>
<li>defineClass()方法是用来将byte字节流解析成JVM能够识别的Class对象（ClassLoader中已实现该方法逻辑），通过这个方法不仅能够通过class文件实例化class对象，也可以通过其他方式实例化class对象，如通过网络接收一个类的字节码，然后转换为byte字节流创建对应的Class对象。</li>
<li><strong>defineClass()方法通常与findClass()方法一起使用，一般情况下，在自定义类加载器时，会直接覆盖ClassLoader的findClass()方法并编写加载规则，取得要加载类的字节码后转换成流，然后调用defineClass()方法生成类的Class对象</strong></li>
</ul>
<p><strong>简单举例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="comment">// 获取类的字节数组</span></span><br><span class="line">    <span class="type">byte</span>[] classData =getClassData(name);</span><br><span class="line">    <span class="keyword">if</span> (classData == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassNotFoundException</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//使用defineClass生成class对象</span></span><br><span class="line">        <span class="keyword">return</span> defineClass(name,classData,θ,classData.length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>链接指定的一个Java类。使用该方法可以使用类的Class对象创建完成的同时也被解析。前面我们说链接阶段主要是对字节码进行验证，为类变量分配内存并设置初始值同时将字节码文件中的符号引用转换为直接引用。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">resolveClass</span><span class="params">(Class&lt;?&gt; c)</span></span><br></pre></td></tr></table></figure>

<ol start="6">
<li>查找名称为name的已经被加载过的类，返回结果为java.lang.Class类的实例。这个方法是final方法，无法被修改。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Class&lt;?&gt; findLoadedClass(String name)</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>它也是一个ClassLoader的实例，这个字段所表示的ClassLoader也称为这个ClassLoader的双亲。在类加载的过程中，ClassLoader可能会将某些请求交予自己的双亲处理。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ClassLoader parent;</span><br></pre></td></tr></table></figure>

<h2 id="SecureClassLoader与URLClassLoader"><a href="#SecureClassLoader与URLClassLoader" class="headerlink" title="SecureClassLoader与URLClassLoader"></a>SecureClassLoader与URLClassLoader</h2><ul>
<li>接着SecureClassLoader扩展了ClassLoader，新增了几个与使用相关的代码源（对代码源的位置及其证书的验证）和权限定义类验证（主要指对class源码的访问权限）的方法，一般我们不会直接跟这个类打交道，更多是与它的子类URLClassLoader有所关联。</li>
<li>前面说过，ClassLoader是一个抽象类，很多方法是空的没有实现，比如findClass()、findResource()等。而URLClassLoader这个实现类为这些方法提供了具体的实现。并新增了URLClassPath类协助取得Class字节码流等功能。<strong>在编写自定义类加载器时，如果没有太过于复杂的需求，可以直接继承URLClassLoader类</strong>，这样就可以避免自己去编写findClass()方法及其获取字节码流的方式，使自定义类加载器编写更加简洁。</li>
</ul>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220801195807846.png" alt="image-20220801195807846"></p>
<h2 id="ExtClassLoader与AppClassLoader"><a href="#ExtClassLoader与AppClassLoader" class="headerlink" title="ExtClassLoader与AppClassLoader"></a>ExtClassLoader与AppClassLoader</h2><ul>
<li><p>了解完URLClassLoader后接着看看剩余的两个类加载器，即拓展类加载器ExtClassLoader和系统类加载器AppClassLoader，这两个类都继承自URLClassLoader，是sun.misc.Launcher的静态内部类。</p>
</li>
<li><p>sun.misc.Launcher主要被系统用于启动主应用程序，ExtClassLoader和AppClassLoader都是由sun.misc.Launcher创建的，其类主要类结构如下：</p>
</li>
</ul>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220801200002661.png" alt="image-20220801200002661"></p>
<ul>
<li>我们发现ExtClassLoader并没有重写loadClass()方法，这足矣说明其<strong>遵循双亲委派模式</strong>，而AppClassLoader重载了loadClass()方法，但最终调用的还是父类loadClass()方法，因此依然遵守双亲委派模式。</li>
</ul>
<h2 id="Class-forName-与ClassLoader-loadClass"><a href="#Class-forName-与ClassLoader-loadClass" class="headerlink" title="Class.forName()与ClassLoader.loadClass()"></a>Class.forName()与ClassLoader.loadClass()</h2><p><strong>Class.forName()</strong></p>
<ul>
<li><p>Class.forName()：是一个<strong>静态方法</strong>，最常用的是Class.forName(String className); </p>
</li>
<li><p>根据传入的类的全限定名返回一个Class对象。<strong>该方法在将Class文件加载到内存的同时，会执行类的初始化</strong>。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class.forName(<span class="string">&quot;com.atguigu.java.Helloworld&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>ClassLoader.loadClass()</strong></p>
<ul>
<li><p>ClassLoader.loadClass()：这是一个实例方法，需要一个ClassLoader对象来调用该方法。 </p>
</li>
<li><p><strong>该方法将Class文件加载到内存时，并不会执行类的初始化，直到这个类第一次使用时才进行初始化</strong>。该方法因为需要得到一个ClassLoader对象，所以可以根据需要指定使用哪个类加载器。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Classloader</span> <span class="variable">cl</span> <span class="operator">=</span> ......; cl.loadClass(<span class="string">&quot;com.atguigu.java.Helloworld&quot;</span>);</span><br></pre></td></tr></table></figure>

<h1 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h1><h2 id="定义与本质"><a href="#定义与本质" class="headerlink" title="定义与本质"></a>定义与本质</h2><p>类加载器用来把类加载到Java虚拟机中。从JDK1.2版本开始，类的加载过程采用双亲委派机制，这种机制能更好地保证Java平台的安全。</p>
<p><strong>定义</strong></p>
<p>如果一个类加载器在接到加载类的请求时，它首先不会自己尝试去加载这个类，而是把这个请求任务委托给父类加载器去完成，依次递归，如果父类加载器可以完成类加载任务，就成功返回。只有父类加载器无法完成此加载任务时，才自己去加载。</p>
<p><strong>本质</strong></p>
<p>规定了类加载的顺序是：<strong>引导类加载器先加载，若加载不到，由扩展类加载器加载，若还加载不到，才会由系统类加载器或自定义的类加载器进行加载。</strong></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220801200314590.png" alt="image-20220801200314590"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220801200333015.png" alt="image-20220801200333015"></p>
<h2 id="优势与劣势"><a href="#优势与劣势" class="headerlink" title="优势与劣势"></a>优势与劣势</h2><p><strong>双亲委派机制优势</strong> </p>
<ul>
<li>避免类的重复加载，确保一个类的全局唯一性 ，<strong>Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关系可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。</strong></li>
<li>保护程序安全，防止核心API被随意篡改</li>
</ul>
<p><strong>代码支持</strong></p>
<p>双亲委派机制在java.lang.ClassLoader.loadClass(String，boolean)接口中体现。该接口的逻辑如下：</p>
<ol>
<li>先在当前加载器的缓存中查找有无目标类，如果有，直接返回。</li>
<li>判断当前加载器的父加载器是否为空，如果不为空，则调用parent.loadClass(name，false)接口进行加载。</li>
<li>反之，如果当前加载器的父类加载器为空，则调用findBootstrapClassorNull(name)接口，让引导类加载器进行加载。</li>
<li>如果通过以上3条路径都没能成功加载，则调用findClass(name)接口进行加载。该接口最终会调用java.lang.ClassLoader接口的defineClass系列的native接口加载目标Java类。</li>
</ol>
<p>双亲委派的模型就隐藏在这第2和第3步中。</p>
<p><strong>举例</strong></p>
<p>假设当前加载的是java.lang.Object这个类，很显然，该类属于JDK中核心得不能再核心的一个类，因此一定只能由引导类加载器进行加载。当]VM准备加载javaJang.Object时，JVM默认会使用系统类加载器去加载，按照上面4步加载的逻辑，在第1步从系统类的缓存中肯定查找不到该类，于是进入第2步。由于从系统类加载器的父加载器是扩展类加载器，于是扩展类加载器继续从第1步开始重复。由于扩展类加载器的缓存中也一定查找不到该类，因此进入第2步。扩展类的父加载器是null，因此系统调用findClass（String），最终通过引导类加载器进行加载。</p>
<p><strong>思考</strong></p>
<p>如果在自定义的类加载器中重写java.lang.ClassLoader.loadClass(String)或java.lang.ClassLoader.loadclass(String，boolean)方法，抹去其中的双亲委派机制，仅保留上面这4步中的第l步与第4步，那么是不是就能够加载核心类库了呢？</p>
<p>这也不行！因为<strong>JDK还为核心类库提供了一层保护机制</strong>。不管是自定义的类加载器，还是系统类加载器抑或扩展类加载器，最终都<strong>必须调用 java.lang.ClassLoader.defineclass(String，byte[]，int，int，ProtectionDomain)方法</strong>，而<strong>该方法会执行preDefineClass()接口，该接口中提供了对JDK核心类库的保护。</strong></p>
<p><strong>弊端</strong></p>
<p>检查类是否加载的委托过程是单向的，这个方式虽然从结构上说比较清晰，使各个ClassLoader的职责非常明确，但是同时会带来一个问题，即<strong>顶层的ClassLoader无法访问底层的ClassLoader所加载的类。</strong></p>
<p>通常情况下，启动类加载器中的类为系统核心类，包括一些重要的系统接口，而在应用类加载器中，为应用类。按照这种模式，<strong>应用类访问系统类自然是没有问题，但是系统类访问应用类就会出现问题</strong>。比如在系统类中提供了一个接口，该接口需要在应用类中得以实现，该接口还绑定一个工厂方法，用于创建该接口的实例，而接口和工厂方法都在启动类加载器中。这时，就会出现该工厂方法无法创建由应用类加载器加载的应用实例的问题。</p>
<p><strong>结论</strong></p>
<p><strong>由于Java虚拟机规范并没有明确要求类加载器的加载机制一定要使用双亲委派模型，只是建议采用这种方式而已。</strong>比如在Tomcat中，类加载器所采用的加载机制就和传统的双亲委派模型有一定区别，当缺省的类加载器接收到一个类的加载任务时，首先会由它自行加载，当它加载失败时，才会将类的加载任务委派给它的超类加载器去执行，这同时也是Serylet规范推荐的一种做法。</p>
<h2 id="破坏双亲委派机制"><a href="#破坏双亲委派机制" class="headerlink" title="破坏双亲委派机制"></a>破坏双亲委派机制</h2><p>双亲委派模型并不是一个具有强制性约束的模型，而是Java设计者推荐给开发者们的类加载器实现方式。 </p>
<p>在Java的世界中大部分的类加载器都遵循这个模型，但也有例外的情况，直到Java模块化出现为止，双亲委派模型主要出现过3次较大规模“被破坏”的情况。 </p>
<p><strong>第一次破坏双亲委派机制</strong> </p>
<p>双亲委派模型的第一次“被破坏”其实发生在双亲委派模型出现之前一—即JDK1.2面世以前的“远古”时代。 由于双亲委派模型在JDK 1.2之后才被引入，但是类加载器的概念和抽象类java.lang.ClassLoader则在Java的第一个版本中就已经存在，面对经存在的用户自定义类加载器的代码，Java设计者们引入双亲委派模型时不得不做出一些妥协，<strong>为了兼容这些已有代码，无法再以技术手段避免loadClass()被子类覆盖的可能性</strong>，只能在JDK1.2之后的java.lang.ClassLoader中添加一个新的protected方法findClass()，并引导用户编写的类加载逻辑时尽可能去重写这个方法，而不是在loadClass()中编写代码。上节我们已经分析过loadClass()方法，双亲委派的具体逻辑就实现在这里面，按照loadClass()方法的逻辑，如果父类加载失败，会自动调用自己的findClass()方法来完成加载，这样既不影响用户按照自己的意愿去加载类，又可以保证新写出来的类加载器是符合双亲委派规则的。</p>
<p><strong>第二次破坏双亲委派机制：线程上下文类加载器</strong></p>
<p>双亲委派模型的第二次“被破坏”是由这个模型自身的缺陷导致的，双亲委派很好地解决了各个类加载器协作时基础类型的一致性问题（<strong>越基础的类由越上层的加载器进行加载</strong>），基础类型之所以被称为“基础”，是因为它们总是作为被用户代码继承、调用的API存在，但程序设计往往没有绝对不变的完美规则，<strong>如果有基础类型又要调用回用户的代码，那该怎么办呢？</strong></p>
<p>这并非是不可能出现的事情，一个典型的例子便是JNDI服务，JNDI现在已经是Java的标准服务，它的代码由启动类加载器来完成加载（在JDK 1.3时加入到rt.jar的），肯定属于Java中很基础的类型了。但JNDI存在的目的就是对资源进行查找和集中管理，它需要调用由其他厂商实现并部署在应用程序的ClassPath下的JNDI服务提供者接口（Service Provider Interface，SPI）的代码，现在问题来了，<strong>启动类加载器是绝不可能认识、加载这些代码的，那该怎么办？</strong>（SPI：在Java平台中，通常把核心类rt.jar中提供外部服务、可由应用层自行实现的接口称为SPI） </p>
<p>为了解决这个困境，Java的设计团队只好引入了一个不太优雅的设计：<strong>线程上下文类加载器（Thread Context ClassLoader）</strong>。这个类加载器可以通过java.lang.Thread类的setContextClassLoader()方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过的话，那这个类加载器默认就是应用程序类加载器。 </p>
<p>有了线程上下文类加载器，程序就可以做一些“舞弊”的事情了。JNDI服务使用这个线程上下文类加载器去加载所需的SPI服务代码，<strong>这是一种父类加载器去请求子类加载器完成类加载的行为，这种行为实际上是打通了双亲委派模型的层次结构来逆向使用类加载器，已经违背了双亲委派模型的一般性原则</strong>，但也是无可奈何的事情。 例如JNDI、JDBC、JCE、JAXB和JBI等。不过，当SPI的服务提供者多于一个的时候，代码就只能根据具体提供者的类型来硬编码判断，为了消除这种极不优雅的实现方式，在JDK6时，JDK提供了java.util.ServiceLoader类，以META-INF&#x2F;services中的配置信息，辅以责任链模式，这才算是给SPI的加载提供了一种相对合理的解决方案。</p>
<p> <img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220801201949469.png" alt="image-20220801201949469"></p>
<p>默认上下文加载器就是应用类加载器，这样以上下文加载器为中介，使得启动类加载器中的代码也可以访问应用类加载器中的类。</p>
<p><strong>第三次破坏双亲委派机制</strong></p>
<p>双亲委派模型的第三次“被破坏”是由于用户对程序动态性的追求而导致的。如：**代码热替换(Hot Swap)、模块热部署(Hot Deployment)**等</p>
<p>IBM公司主导的JSR-291(即OSGiR4.2)实现模块化热部署的关键是它自定义的类加载器机制的实现，每一个程序模块(osGi中称为Bundle)都有一个自己的类加载器，当需要更换一个Bundle时，就把Bund1e连同类加载器一起换掉以实现代码的热替换。在oSGi环境下，类加载器不再双亲委派模型推荐的树状结构，而是进一步发展为更加复杂的<strong>网状结构</strong>。</p>
<p>当收到类加载请求时，OSGi将按照下面的顺序进行类搜索：</p>
<ol>
<li>*<em>将以java.<em>开头的类，委派给父类加载器加载。</em></em></li>
<li><strong>否则，将委派列表名单内的类，委派给父类加载器加载。</strong></li>
<li>否则，将Import列表中的类，委派给Export这个类的Bundle的类加载器加载。</li>
<li>否则，查找当前Bundle的ClassPath，使用自己的类加载器加载。</li>
<li>否则，查找类是否在自己的Fragment Bundle中，如果在，则委派给Fragment Bundle的类加载器加载。</li>
<li>否则，查找Dynamic Import列表的Bundle，委派给对应Bund1e的类加载器加载。</li>
<li>否则，类查找失败。</li>
</ol>
<p>说明：只有开头两点仍然符合双亲委派模型的原则，其余的类查找都是在平级的类加载器中进行的</p>
<p>小结：这里，我们使用了“被破坏”这个词来形容上述不符合双亲委派模型原则的行为，但这里“被破坏”并不一定是带有贬义的。只要有明确的目的和充分的理由，突破旧有原则无疑是一种创新。</p>
<p>正如：OSGi中的类加载器的设计不符合传统的双亲委派的类加载器架构，且业界对其为了实现热部署而带来的额外的高复杂度还存在不少争议，但对这方面有了解的技术人员基本还是能达成一个共识，认为<strong>OSGi中对类加载器的运用是值得学习的，完全弄懂了OSGi的实现，就算是掌握了类加载器的精粹。</strong></p>
<h2 id="热替换的实现"><a href="#热替换的实现" class="headerlink" title="热替换的实现"></a>热替换的实现</h2><p>热替换是指在程序的运行过程中，不停止服务，只通过替换程序文件来修改程序的行为。<strong>热替换的关键需求在于服务不能中断，修改必须立即表现正在运行的系统之中。</strong>基本上大部分脚本语言都是天生支持热替换的，比如：PHP，只要替换了PHP源文件，这种改动就会立即生效，而无需重启Web服务器。</p>
<p>但对Java来说，热替换并非天生就支持，如果一个类已经加载到系统中，通过修改类文件，并无法让系统再来加载并重定义这个类。因此，在Java中实现这一功能的一个可行的方法就是灵活运用ClassLoader。</p>
<p>注意：由不同ClassLoader加载的同名类属于不同的类型，不能相互转换和兼容。即两个不同的ClassLoader加载同一个类，在虚拟机内部，会认为这2个类是完全不同的。</p>
<p>根据这个特点，可以用来模拟热替换的实现，基本思路如下图所示：</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220801202415612.png" alt="image-20220801202415612"></p>
<h1 id="沙箱安全机制"><a href="#沙箱安全机制" class="headerlink" title="沙箱安全机制"></a>沙箱安全机制</h1><p>沙箱安全机制 </p>
<ul>
<li>保证程序安全</li>
<li>保护Java原生的JDK代码</li>
</ul>
<p><strong>Java安全模型的核心就是Java沙箱（sandbox）</strong>。什么是沙箱？沙箱是一个限制程序运行的环境。 </p>
<p>沙箱机制就是<strong>将Java代码限定在虚拟机（JVM）特定的运行范围中，并且严格限制代码对本地系统资源访问。</strong>通过这样的措施来保证对代码的有限隔离，防止对本地系统造成破坏。 </p>
<p><strong>沙箱主要限制系统资源访问</strong>，那系统资源包括什么？CPU、内存、文件系统、网络。不同级别的沙箱对这些资源访问的限制也可以不一样。 </p>
<p>所有的Java程序运行都可以指定沙箱，可以定制安全策略。</p>
<h2 id="JDK1-0时期"><a href="#JDK1-0时期" class="headerlink" title="JDK1.0时期"></a>JDK1.0时期</h2><p>在Java中将执行程序分成本地代码和远程代码两种，本地代码默认视为可信任的，而远程代码则被看作是不受信的。对于授信的本地代码，可以访问一切本地资源。而对于非授信的远程代码在早期的Java实现中，安全依赖于<strong>沙箱（Sandbox）机制</strong>。如下图所示JDK1.0安全模型</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220801202834014.png" alt="image-20220801202834014"></p>
<h2 id="JDK1-1时期"><a href="#JDK1-1时期" class="headerlink" title="JDK1.1时期"></a>JDK1.1时期</h2><p>JDK1.0中如此严格的安全机制也给程序的功能扩展带来障碍，比如当用户希望远程代码访问本地系统的文件时候，就无法实现。</p>
<p>因此在后续的Java1.1版本中，针 对安全机制做了改进，增加了<strong>安全策略</strong>。允许用户指定代码对本地资源的访问权限。</p>
<p>如下图所示JDK1.1安全模型</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220801202852367.png" alt="image-20220801202852367"></p>
<h2 id="JDK1-2时期"><a href="#JDK1-2时期" class="headerlink" title="JDK1.2时期"></a>JDK1.2时期</h2><p>在Java1.2版本中，再次改进了安全机制，增加了<strong>代码签名</strong>。不论本地代码或是远程代码，都会按照用户的安全策略设定，由类加载器加载到虚拟机中权限不同的运行空间，来实现差异化的代码执行权限控制。如下图所示JDK1.2安全模型：</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220801202951518.png" alt="image-20220801202951518"></p>
<h2 id="JDK1-6时期"><a href="#JDK1-6时期" class="headerlink" title="JDK1.6时期"></a>JDK1.6时期</h2><p>当前最新的安全机制实现，则引入了<strong>域</strong>（Domain）的概念。</p>
<p> 虚拟机会把所有代码加载到不同的系统域和应用域。<strong>系统域部分专门负责与关键资源进行交互，</strong>而各个应用域部分则通过系统域的部分代理来对各种需要的资源进行访问。虚拟机中不同的受保护域（Protected Domain），对应不一样的权限（Permission）。存在于不同域中的类文件就具有了当前域的全部权限，如下图所示，最新的安全模型（jdk1.6）</p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220801203023638.png" alt="image-20220801203023638"></p>
<h1 id="自定义类的加载器"><a href="#自定义类的加载器" class="headerlink" title="自定义类的加载器"></a>自定义类的加载器</h1><h2 id="为什么要自定义类加载器？"><a href="#为什么要自定义类加载器？" class="headerlink" title="为什么要自定义类加载器？"></a>为什么要自定义类加载器？</h2><ul>
<li><p>隔离加载类</p>
<p>在某些框架内进行中间件与应用的模块隔离，把类加载到不同的环境。比如:阿里内某容器框架通过自定义类加载器确保应用中依赖的jar包不会影响到中间件运行时使用的jar包。再比如:Tomcat这类Web应用服务器，内部自定义了好几种类加载器，用于隔离同一个Web应用服务器上的不同应用程序。（类的仲裁–&gt;类冲突）</p>
</li>
<li><p>修改类加载的方式</p>
<p>类的加载模型并非强制，除Bootstrap外，其他的加载并非一定要引入，或者根据实际情况在某个时间点进行按需进行动态加载  </p>
</li>
<li><p>扩展加载源 </p>
<p>比如从数据库、网络、甚至是电视机机顶盒进行加载 </p>
</li>
<li><p>防止源码泄漏</p>
<p>Java代码容易被编译和篡改，可以进行编译加密。那么类加载也需要自定义，还原加密的字节码。</p>
</li>
</ul>
<h2 id="常见的场景"><a href="#常见的场景" class="headerlink" title="常见的场景"></a>常见的场景</h2><ul>
<li><p>实现类似进程内隔离，类加载器实际上用作不同的命名空间，以提供类似容器、模块化的效果。例如，两个模块依赖于某个类库的不同版本，如果分别被不同的容器加载，就可以互不干扰。这个方面的集大成者是JavaEE和OSGI、JPMS等框架。</p>
</li>
<li><p>应用需要从不同的数据源获取类定义信息，例如网络数据源，而不是本地文件系统。或者是需要自己操纵字节码，动态修改或者生成类型。</p>
</li>
</ul>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>在一般情况下，使用不同的类加载器去加载不同的功能模块，会提高应用程序的安全性。但是，如果涉及Java类型转换，则加载器反而容易产生不美好的事情。在做Java类型转换时，只有两个类型都是由同一个加载器所加载，才能进行类型转换，否则转换时会发生异常。</p>
<h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><p>Java提供了抽象类java.lang.ClassLoader，所有用户自定义的类加载器都应该继承ClassLoader类。</p>
<p>在自定义ClassLoader的子类时候，我们常见的会有两种做法:</p>
<ul>
<li>方式一:重写loadClass()方法</li>
<li>方式二:重写findclass()方法</li>
</ul>
<p><strong>对比</strong></p>
<p>这两种方法本质上差不多，毕竟loadClass()也会调用findClass()，但是从逻辑上讲我们最好不要直接修改loadClass()的内部逻辑。建议的做法是只在findClass()里重写自定义类的加载方法，根据参数指定类的名字，返回对应的Class对象的引用。</p>
<ul>
<li><p>loadclass()这个方法是实现双亲委派模型逻辑的地方，擅自修改这个方法会导致模型被破坏，容易造成问题。<strong>因此我们最好是在双亲委派模型框架内进行小范围的改动，不破坏原有的稳定结构。</strong>同时，也避免了自己重写loadClass()方法的过程中必须写双亲委托的重复代码，从代码的复用性来看，不直接修改这个方法始终是比较好的选择。</p>
</li>
<li><p>当编写好自定义类加载器后，便可以在程序中调用loadClass()方法来实现类加载操作。</p>
</li>
</ul>
<p><strong>说明</strong></p>
<ul>
<li>其父类加载器是系统类加载器</li>
<li>JVM中的所有类加载都会使用java.lang.ClassLoader.loadClass(String)接口(自定义类加载器并重写java.lang.ClassLoader.loadClass(String)接口的除外)，连JDK的核心类库也不能例外。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClassLoader</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String byteCodePath;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyClassLoader</span><span class="params">(String byteCodePath)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.byteCodePath = byteCodePath;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyClassLoader</span><span class="params">(ClassLoader parent, String byteCodePath)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(parent);</span><br><span class="line">        <span class="built_in">this</span>.byteCodePath = byteCodePath;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String className) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//获取字节码的完整路径</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> byteCodePath + className + <span class="string">&quot;.class&quot;</span>;</span><br><span class="line">            <span class="comment">//获取一个输入流</span></span><br><span class="line">            bis = <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(fileName));</span><br><span class="line">            <span class="comment">//获取一个输出流</span></span><br><span class="line">            baos = <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//具体读入数据并写出的过程</span></span><br><span class="line">            <span class="type">int</span> len;</span><br><span class="line">            <span class="type">byte</span>[] data = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">while</span> ((len = bis.read(data)) != -<span class="number">1</span>)&#123;</span><br><span class="line">                baos.write(data, <span class="number">0</span>, len);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//获取内存中的完整的字节数组的数据</span></span><br><span class="line">            <span class="type">byte</span>[] byteCodes = baos.toByteArray();</span><br><span class="line">            <span class="comment">//调用defineClass方法，将字节数组的数据转换为Class的实例</span></span><br><span class="line">            Class&lt;?&gt; clazz = defineClass(<span class="literal">null</span>, byteCodes, <span class="number">0</span>, byteCodes.length);</span><br><span class="line">            <span class="keyword">return</span> clazz;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(baos != <span class="literal">null</span>)</span><br><span class="line">                    baos.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(bis != <span class="literal">null</span>)</span><br><span class="line">                    bis.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClassLoaderTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyClassLoader</span> <span class="variable">myClassLoader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClassLoader</span>(<span class="string">&quot;d:/&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class&lt;?&gt; clazz = myClassLoader.loadClass(<span class="string">&quot;Demo1&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;加载此类的类的加载器为：&quot;</span> + clazz.getClassLoader().getClass().getName());<span class="comment">//com.ysy.MyClassLoader</span></span><br><span class="line">            System.out.println(<span class="string">&quot;加载当前类的父类加载器为：&quot;</span> + clazz.getClassLoader().getParent().getClass().getName());<span class="comment">//sun.misc.Launcher$AppClassLoader</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Java9新特性"><a href="#Java9新特性" class="headerlink" title="Java9新特性"></a>Java9新特性</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassLoaderTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(ClassLoaderTest.class.getClassLoader());</span><br><span class="line">        System.out.println(ClassLoaderTest.class.getClassLoader().getParent());</span><br><span class="line">        System.out.println(ClassLoaderTest.class.getClassLoader().getParent().getParent());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取系统类加载器</span></span><br><span class="line">        System.out.println(ClassLoader.getSystemClassLoader());</span><br><span class="line">        <span class="comment">//获取平台类加载器</span></span><br><span class="line">        System.out.println(ClassLoader.getPlatformClassLoader());</span><br><span class="line">        <span class="comment">//获取类的加载器的名称</span></span><br><span class="line">        System.out.println(ClassLoaderTest.class.getClassLoader().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了保证兼容性，JDK9没有从根本上改变三层类加载器架构和双亲委派模型，但为了模块化系统的顺利运行，仍然发生了一些值得被注意的变动。</p>
<ol>
<li>扩展机制被移除，扩展类加载器由于向后兼容性的原因被保留，不过被**重命名为平台类加载器(platform class loader)**。可以通过classLoader的新方法getPlatformClassLoader()来获取。<br>JDK9时基于模块化进行构建(原来的rt.jar和tools.jar被拆分成数十个JMOD文件)，其中的Java类库就已天然地满足了可扩展的需求，那自然无须再保留<JAVA_HOME>\lib\ext目录，此前使用这个目录或者java.ext.dirs系统变量来扩展JDK功能的机制已经没有继续存在的价值了。 </li>
<li>平台类加载器和应用程序类加载器都不再继承自java.net.URLClassLoader。<br>现在启动类加载器、平台类加载器、应用程序类加载器全都继承于jdk.internal.loader.BuiltinClassLoader。</li>
</ol>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220801211150773.png" alt="image-20220801211150773"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220801210659674.png" alt="image-20220801210659674"></p>
<p>如果有程序直接依赖了这种继承关系，或者依赖了URLClassLoader类的特定方法，那代码很可能会在JDK9及更高版本的JDK中崩溃。</p>
<ol>
<li>在Java9中，类加载器有了名称。该名称在构造方法中指定，可以通过getName()方法来获取。平台类加载器的名称是platform，应用类加载器的名称是app。<strong>类加载器的名称在调试与类加载器相关的问题时会非常有用</strong>。</li>
<li>启动类加载器现在是在jvm内部和java类库共同协作实现的类加载器（以前是C++实现），但为了与之前代码兼容，在获取启动类加载器的场景中仍然会返回null，而不会得到BootClassLoader实例。</li>
<li>类加载的委派关系也发生了变动。当平台及应用程序类加载器收到类加载请求，在委派给父加载器加载前，要先判断该类是否能够归属到某一个系统模块中，如果可以找到这样的归属关系，就要优先委派给负责那个模块的加载器完成加载。</li>
</ol>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220801211004879.png" alt="image-20220801211004879"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220801210941474.png" alt="image-20220801210941474"></p>
<p><img src="https://ysy-java.oss-cn-hangzhou.aliyuncs.com/image-20220801211059364.png" alt="image-20220801211059364"></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
  </article>
  

  
  <nav class="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2022
        <i class="ri-heart-fill heart_icon"></i> Shiyu Yang
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="Healer"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>